////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <wrangle-glx.h>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char * _glew_glx_glXQueryExtensionsString (Display * dpy, int  screen)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  const char * result = ((const char *)0);
  // GLX_VERSION_1_1 - glXQueryExtensionsString
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_1] && glxConfig.m_glXQueryExtensionsString)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryExtensionsString (dpy, screen);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char * _glew_glx_glXQueryServerString (Display * dpy, int  screen, int  name)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  const char * result = ((const char *)0);
  // GLX_VERSION_1_1 - glXQueryServerString
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_1] && glxConfig.m_glXQueryServerString)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryServerString (dpy, screen, name);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char * _glew_glx_glXGetClientString (Display * dpy, int  name)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  const char * result = ((const char *)0);
  // GLX_VERSION_1_1 - glXGetClientString
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_1] && glxConfig.m_glXGetClientString)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetClientString (dpy, name);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Display * _glew_glx_glXGetCurrentDisplay ()
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Display * result = ((Display *)0);
  // GLX_VERSION_1_2 - glXGetCurrentDisplay
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_2] && glxConfig.m_glXGetCurrentDisplay)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetCurrentDisplay ();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXFBConfig * _glew_glx_glXGetFBConfigs (Display * dpy, int  screen, int * nelements)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXFBConfig * result = ((GLXFBConfig *)0);
  // GLX_VERSION_1_3 - glXGetFBConfigs
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXGetFBConfigs)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetFBConfigs (dpy, screen, nelements);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXFBConfig * _glew_glx_glXChooseFBConfig (Display * dpy, int  screen, const int * attrib_list, int * nelements)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXFBConfig * result = ((GLXFBConfig *)0);
  // GLX_VERSION_1_3 - glXChooseFBConfig
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXChooseFBConfig)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXChooseFBConfig (dpy, screen, attrib_list, nelements);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXGetFBConfigAttrib (Display * dpy, GLXFBConfig config, int  attribute, int * value)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_VERSION_1_3 - glXGetFBConfigAttrib
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXGetFBConfigAttrib)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetFBConfigAttrib (dpy, config, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

XVisualInfo * _glew_glx_glXGetVisualFromFBConfig (Display * dpy, GLXFBConfig config)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  XVisualInfo * result = ((XVisualInfo *)0);
  // GLX_VERSION_1_3 - glXGetVisualFromFBConfig
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXGetVisualFromFBConfig)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetVisualFromFBConfig (dpy, config);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXWindow _glew_glx_glXCreateWindow (Display * dpy, GLXFBConfig config, Window win, const int * attrib_list)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXWindow result = ((GLXWindow)0);
  // GLX_VERSION_1_3 - glXCreateWindow
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXCreateWindow)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreateWindow (dpy, config, win, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXDestroyWindow (Display * dpy, GLXWindow win)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_VERSION_1_3 - glXDestroyWindow
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXDestroyWindow)
  {
    prototypeCalled = true;
    glxConfig.m_glXDestroyWindow (dpy, win);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXPixmap _glew_glx_glXCreatePixmap (Display * dpy, GLXFBConfig config, Pixmap pixmap, const int * attrib_list)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXPixmap result = ((GLXPixmap)0);
  // GLX_VERSION_1_3 - glXCreatePixmap
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXCreatePixmap)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreatePixmap (dpy, config, pixmap, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXDestroyPixmap (Display * dpy, GLXPixmap pixmap)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_VERSION_1_3 - glXDestroyPixmap
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXDestroyPixmap)
  {
    prototypeCalled = true;
    glxConfig.m_glXDestroyPixmap (dpy, pixmap);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXPbuffer _glew_glx_glXCreatePbuffer (Display * dpy, GLXFBConfig config, const int * attrib_list)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXPbuffer result = ((GLXPbuffer)0);
  // GLX_VERSION_1_3 - glXCreatePbuffer
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXCreatePbuffer)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreatePbuffer (dpy, config, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXDestroyPbuffer (Display * dpy, GLXPbuffer pbuf)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_VERSION_1_3 - glXDestroyPbuffer
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXDestroyPbuffer)
  {
    prototypeCalled = true;
    glxConfig.m_glXDestroyPbuffer (dpy, pbuf);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXQueryDrawable (Display * dpy, GLXDrawable draw, int  attribute, unsigned int * value)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_VERSION_1_3 - glXQueryDrawable
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXQueryDrawable)
  {
    prototypeCalled = true;
    glxConfig.m_glXQueryDrawable (dpy, draw, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXContext _glew_glx_glXCreateNewContext (Display * dpy, GLXFBConfig config, int  render_type, GLXContext share_list, Bool direct)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXContext result = ((GLXContext)0);
  // GLX_VERSION_1_3 - glXCreateNewContext
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXCreateNewContext)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreateNewContext (dpy, config, render_type, share_list, direct);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXMakeContextCurrent (Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_VERSION_1_3 - glXMakeContextCurrent
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXMakeContextCurrent)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXMakeContextCurrent (dpy, draw, read, ctx);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXDrawable _glew_glx_glXGetCurrentReadDrawable ()
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXDrawable result = ((GLXDrawable)0);
  // GLX_VERSION_1_3 - glXGetCurrentReadDrawable
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXGetCurrentReadDrawable)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetCurrentReadDrawable ();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXQueryContext (Display * dpy, GLXContext ctx, int  attribute, int * value)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_VERSION_1_3 - glXQueryContext
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXQueryContext)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryContext (dpy, ctx, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXSelectEvent (Display * dpy, GLXDrawable draw, unsigned long  event_mask)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_VERSION_1_3 - glXSelectEvent
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXSelectEvent)
  {
    prototypeCalled = true;
    glxConfig.m_glXSelectEvent (dpy, draw, event_mask);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXGetSelectedEvent (Display * dpy, GLXDrawable draw, unsigned long * event_mask)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_VERSION_1_3 - glXGetSelectedEvent
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_3] && glxConfig.m_glXGetSelectedEvent)
  {
    prototypeCalled = true;
    glxConfig.m_glXGetSelectedEvent (dpy, draw, event_mask);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

__GLXextFuncPtr _glew_glx_glXGetProcAddress (const GLubyte * procName)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  __GLXextFuncPtr result = ((__GLXextFuncPtr)0);
  // GLX_VERSION_1_4 - glXGetProcAddress
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_VERSION_1_4] && glxConfig.m_glXGetProcAddress)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetProcAddress (procName);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

unsigned int _glew_glx_glXGetGPUIDsAMD (unsigned int  maxCount, unsigned int * ids)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  unsigned int result = ((unsigned int)0);
  // GLX_AMD_gpu_association - glXGetGPUIDsAMD
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_AMD_gpu_association] && glxConfig.m_glXGetGPUIDsAMD)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetGPUIDsAMD (maxCount, ids);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXGetGPUInfoAMD (unsigned int  id, int  property, GLenum dataType, unsigned int  size, void * data)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_AMD_gpu_association - glXGetGPUInfoAMD
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_AMD_gpu_association] && glxConfig.m_glXGetGPUInfoAMD)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetGPUInfoAMD (id, property, dataType, size, data);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

unsigned int _glew_glx_glXGetContextGPUIDAMD (GLXContext ctx)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  unsigned int result = ((unsigned int)0);
  // GLX_AMD_gpu_association - glXGetContextGPUIDAMD
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_AMD_gpu_association] && glxConfig.m_glXGetContextGPUIDAMD)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetContextGPUIDAMD (ctx);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXContext _glew_glx_glXCreateAssociatedContextAMD (unsigned int  id, GLXContext share_list)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXContext result = ((GLXContext)0);
  // GLX_AMD_gpu_association - glXCreateAssociatedContextAMD
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_AMD_gpu_association] && glxConfig.m_glXCreateAssociatedContextAMD)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreateAssociatedContextAMD (id, share_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXContext _glew_glx_glXCreateAssociatedContextAttribsAMD (unsigned int  id, GLXContext share_context, const int * attribList)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXContext result = ((GLXContext)0);
  // GLX_AMD_gpu_association - glXCreateAssociatedContextAttribsAMD
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_AMD_gpu_association] && glxConfig.m_glXCreateAssociatedContextAttribsAMD)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreateAssociatedContextAttribsAMD (id, share_context, attribList);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXDeleteAssociatedContextAMD (GLXContext ctx)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_AMD_gpu_association - glXDeleteAssociatedContextAMD
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_AMD_gpu_association] && glxConfig.m_glXDeleteAssociatedContextAMD)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXDeleteAssociatedContextAMD (ctx);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXMakeAssociatedContextCurrentAMD (GLXContext ctx)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_AMD_gpu_association - glXMakeAssociatedContextCurrentAMD
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_AMD_gpu_association] && glxConfig.m_glXMakeAssociatedContextCurrentAMD)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXMakeAssociatedContextCurrentAMD (ctx);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXContext _glew_glx_glXGetCurrentAssociatedContextAMD ()
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXContext result = ((GLXContext)0);
  // GLX_AMD_gpu_association - glXGetCurrentAssociatedContextAMD
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_AMD_gpu_association] && glxConfig.m_glXGetCurrentAssociatedContextAMD)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetCurrentAssociatedContextAMD ();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXBlitContextFramebufferAMD (GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_AMD_gpu_association - glXBlitContextFramebufferAMD
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_AMD_gpu_association] && glxConfig.m_glXBlitContextFramebufferAMD)
  {
    prototypeCalled = true;
    glxConfig.m_glXBlitContextFramebufferAMD (dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXContext _glew_glx_glXCreateContextAttribsARB (Display * dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int * attrib_list)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXContext result = ((GLXContext)0);
  // GLX_ARB_create_context - glXCreateContextAttribsARB
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_ARB_create_context] && glxConfig.m_glXCreateContextAttribsARB)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreateContextAttribsARB (dpy, config, share_context, direct, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

__GLXextFuncPtr _glew_glx_glXGetProcAddressARB (const GLubyte * procName)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  __GLXextFuncPtr result = ((__GLXextFuncPtr)0);
  // GLX_ARB_get_proc_address - glXGetProcAddressARB
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_ARB_get_proc_address] && glxConfig.m_glXGetProcAddressARB)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetProcAddressARB (procName);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Display * _glew_glx_glXGetCurrentDisplayEXT ()
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Display * result = ((Display *)0);
  // GLX_EXT_import_context - glXGetCurrentDisplayEXT
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_EXT_import_context] && glxConfig.m_glXGetCurrentDisplayEXT)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetCurrentDisplayEXT ();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXQueryContextInfoEXT (Display * dpy, GLXContext context, int  attribute, int * value)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_EXT_import_context - glXQueryContextInfoEXT
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_EXT_import_context] && glxConfig.m_glXQueryContextInfoEXT)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryContextInfoEXT (dpy, context, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXContextID _glew_glx_glXGetContextIDEXT (const GLXContext context)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXContextID result = ((GLXContextID)0);
  // GLX_EXT_import_context - glXGetContextIDEXT
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_EXT_import_context] && glxConfig.m_glXGetContextIDEXT)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetContextIDEXT (context);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXContext _glew_glx_glXImportContextEXT (Display * dpy, GLXContextID contextID)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXContext result = ((GLXContext)0);
  // GLX_EXT_import_context - glXImportContextEXT
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_EXT_import_context] && glxConfig.m_glXImportContextEXT)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXImportContextEXT (dpy, contextID);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXFreeContextEXT (Display * dpy, GLXContext context)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_EXT_import_context - glXFreeContextEXT
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_EXT_import_context] && glxConfig.m_glXFreeContextEXT)
  {
    prototypeCalled = true;
    glxConfig.m_glXFreeContextEXT (dpy, context);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXSwapIntervalEXT (Display * dpy, GLXDrawable drawable, int  interval)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_EXT_swap_control - glXSwapIntervalEXT
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_EXT_swap_control] && glxConfig.m_glXSwapIntervalEXT)
  {
    prototypeCalled = true;
    glxConfig.m_glXSwapIntervalEXT (dpy, drawable, interval);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXBindTexImageEXT (Display * dpy, GLXDrawable drawable, int  buffer, const int * attrib_list)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_EXT_texture_from_pixmap - glXBindTexImageEXT
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_EXT_texture_from_pixmap] && glxConfig.m_glXBindTexImageEXT)
  {
    prototypeCalled = true;
    glxConfig.m_glXBindTexImageEXT (dpy, drawable, buffer, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXReleaseTexImageEXT (Display * dpy, GLXDrawable drawable, int  buffer)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_EXT_texture_from_pixmap - glXReleaseTexImageEXT
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_EXT_texture_from_pixmap] && glxConfig.m_glXReleaseTexImageEXT)
  {
    prototypeCalled = true;
    glxConfig.m_glXReleaseTexImageEXT (dpy, drawable, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

unsigned int _glew_glx_glXGetAGPOffsetMESA (const void * pointer)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  unsigned int result = ((unsigned int)0);
  // GLX_MESA_agp_offset - glXGetAGPOffsetMESA
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_MESA_agp_offset] && glxConfig.m_glXGetAGPOffsetMESA)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetAGPOffsetMESA (pointer);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXCopySubBufferMESA (Display * dpy, GLXDrawable drawable, int  x, int  y, int  width, int  height)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_MESA_copy_sub_buffer - glXCopySubBufferMESA
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_MESA_copy_sub_buffer] && glxConfig.m_glXCopySubBufferMESA)
  {
    prototypeCalled = true;
    glxConfig.m_glXCopySubBufferMESA (dpy, drawable, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXPixmap _glew_glx_glXCreateGLXPixmapMESA (Display * dpy, XVisualInfo * visual, Pixmap pixmap, Colormap cmap)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXPixmap result = ((GLXPixmap)0);
  // GLX_MESA_pixmap_colormap - glXCreateGLXPixmapMESA
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_MESA_pixmap_colormap] && glxConfig.m_glXCreateGLXPixmapMESA)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreateGLXPixmapMESA (dpy, visual, pixmap, cmap);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXQueryCurrentRendererIntegerMESA (int  attribute, unsigned int * value)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_MESA_query_renderer - glXQueryCurrentRendererIntegerMESA
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_MESA_query_renderer] && glxConfig.m_glXQueryCurrentRendererIntegerMESA)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryCurrentRendererIntegerMESA (attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char * _glew_glx_glXQueryCurrentRendererStringMESA (int  attribute)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  const char * result = ((const char *)0);
  // GLX_MESA_query_renderer - glXQueryCurrentRendererStringMESA
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_MESA_query_renderer] && glxConfig.m_glXQueryCurrentRendererStringMESA)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryCurrentRendererStringMESA (attribute);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXQueryRendererIntegerMESA (Display * dpy, int  screen, int  renderer, int  attribute, unsigned int * value)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_MESA_query_renderer - glXQueryRendererIntegerMESA
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_MESA_query_renderer] && glxConfig.m_glXQueryRendererIntegerMESA)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryRendererIntegerMESA (dpy, screen, renderer, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char * _glew_glx_glXQueryRendererStringMESA (Display * dpy, int  screen, int  renderer, int  attribute)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  const char * result = ((const char *)0);
  // GLX_MESA_query_renderer - glXQueryRendererStringMESA
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_MESA_query_renderer] && glxConfig.m_glXQueryRendererStringMESA)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryRendererStringMESA (dpy, screen, renderer, attribute);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXReleaseBuffersMESA (Display * dpy, GLXDrawable drawable)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_MESA_release_buffers - glXReleaseBuffersMESA
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_MESA_release_buffers] && glxConfig.m_glXReleaseBuffersMESA)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXReleaseBuffersMESA (dpy, drawable);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_glx_glXSet3DfxModeMESA (GLint mode)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLboolean result = ((GLboolean)0);
  // GLX_MESA_set_3dfx_mode - glXSet3DfxModeMESA
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_MESA_set_3dfx_mode] && glxConfig.m_glXSet3DfxModeMESA)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXSet3DfxModeMESA (mode);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXGetSwapIntervalMESA ()
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_MESA_swap_control - glXGetSwapIntervalMESA
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_MESA_swap_control] && glxConfig.m_glXGetSwapIntervalMESA)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetSwapIntervalMESA ();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXSwapIntervalMESA (unsigned int  interval)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_MESA_swap_control - glXSwapIntervalMESA
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_MESA_swap_control] && glxConfig.m_glXSwapIntervalMESA)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXSwapIntervalMESA (interval);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXCopyBufferSubDataNV (Display * dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_NV_copy_buffer - glXCopyBufferSubDataNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_copy_buffer] && glxConfig.m_glXCopyBufferSubDataNV)
  {
    prototypeCalled = true;
    glxConfig.m_glXCopyBufferSubDataNV (dpy, readCtx, writeCtx, readTarget, writeTarget, readOffset, writeOffset, size);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXNamedCopyBufferSubDataNV (Display * dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_NV_copy_buffer - glXNamedCopyBufferSubDataNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_copy_buffer] && glxConfig.m_glXNamedCopyBufferSubDataNV)
  {
    prototypeCalled = true;
    glxConfig.m_glXNamedCopyBufferSubDataNV (dpy, readCtx, writeCtx, readBuffer, writeBuffer, readOffset, writeOffset, size);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXCopyImageSubDataNV (Display * dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_NV_copy_image - glXCopyImageSubDataNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_copy_image] && glxConfig.m_glXCopyImageSubDataNV)
  {
    prototypeCalled = true;
    glxConfig.m_glXCopyImageSubDataNV (dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXDelayBeforeSwapNV (Display * dpy, GLXDrawable drawable, GLfloat seconds)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_NV_delay_before_swap - glXDelayBeforeSwapNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_delay_before_swap] && glxConfig.m_glXDelayBeforeSwapNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXDelayBeforeSwapNV (dpy, drawable, seconds);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

unsigned int * _glew_glx_glXEnumerateVideoDevicesNV (Display * dpy, int  screen, int * nelements)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  unsigned int * result = ((unsigned int *)0);
  // GLX_NV_present_video - glXEnumerateVideoDevicesNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_present_video] && glxConfig.m_glXEnumerateVideoDevicesNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXEnumerateVideoDevicesNV (dpy, screen, nelements);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXBindVideoDeviceNV (Display * dpy, unsigned int  video_slot, unsigned int  video_device, const int * attrib_list)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_NV_present_video - glXBindVideoDeviceNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_present_video] && glxConfig.m_glXBindVideoDeviceNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXBindVideoDeviceNV (dpy, video_slot, video_device, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXJoinSwapGroupNV (Display * dpy, GLXDrawable drawable, GLuint group)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_NV_swap_group - glXJoinSwapGroupNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_swap_group] && glxConfig.m_glXJoinSwapGroupNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXJoinSwapGroupNV (dpy, drawable, group);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXBindSwapBarrierNV (Display * dpy, GLuint group, GLuint barrier)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_NV_swap_group - glXBindSwapBarrierNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_swap_group] && glxConfig.m_glXBindSwapBarrierNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXBindSwapBarrierNV (dpy, group, barrier);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXQuerySwapGroupNV (Display * dpy, GLXDrawable drawable, GLuint * group, GLuint * barrier)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_NV_swap_group - glXQuerySwapGroupNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_swap_group] && glxConfig.m_glXQuerySwapGroupNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQuerySwapGroupNV (dpy, drawable, group, barrier);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXQueryMaxSwapGroupsNV (Display * dpy, int  screen, GLuint * maxGroups, GLuint * maxBarriers)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_NV_swap_group - glXQueryMaxSwapGroupsNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_swap_group] && glxConfig.m_glXQueryMaxSwapGroupsNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryMaxSwapGroupsNV (dpy, screen, maxGroups, maxBarriers);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXQueryFrameCountNV (Display * dpy, int  screen, GLuint * count)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_NV_swap_group - glXQueryFrameCountNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_swap_group] && glxConfig.m_glXQueryFrameCountNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryFrameCountNV (dpy, screen, count);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXResetFrameCountNV (Display * dpy, int  screen)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_NV_swap_group - glXResetFrameCountNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_swap_group] && glxConfig.m_glXResetFrameCountNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXResetFrameCountNV (dpy, screen);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXBindVideoCaptureDeviceNV (Display * dpy, unsigned int  video_capture_slot, GLXVideoCaptureDeviceNV device)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_NV_video_capture - glXBindVideoCaptureDeviceNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_video_capture] && glxConfig.m_glXBindVideoCaptureDeviceNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXBindVideoCaptureDeviceNV (dpy, video_capture_slot, device);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXVideoCaptureDeviceNV * _glew_glx_glXEnumerateVideoCaptureDevicesNV (Display * dpy, int  screen, int * nelements)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXVideoCaptureDeviceNV * result = ((GLXVideoCaptureDeviceNV *)0);
  // GLX_NV_video_capture - glXEnumerateVideoCaptureDevicesNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_video_capture] && glxConfig.m_glXEnumerateVideoCaptureDevicesNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXEnumerateVideoCaptureDevicesNV (dpy, screen, nelements);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXLockVideoCaptureDeviceNV (Display * dpy, GLXVideoCaptureDeviceNV device)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_NV_video_capture - glXLockVideoCaptureDeviceNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_video_capture] && glxConfig.m_glXLockVideoCaptureDeviceNV)
  {
    prototypeCalled = true;
    glxConfig.m_glXLockVideoCaptureDeviceNV (dpy, device);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXQueryVideoCaptureDeviceNV (Display * dpy, GLXVideoCaptureDeviceNV device, int  attribute, int * value)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_NV_video_capture - glXQueryVideoCaptureDeviceNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_video_capture] && glxConfig.m_glXQueryVideoCaptureDeviceNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryVideoCaptureDeviceNV (dpy, device, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXReleaseVideoCaptureDeviceNV (Display * dpy, GLXVideoCaptureDeviceNV device)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_NV_video_capture - glXReleaseVideoCaptureDeviceNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_video_capture] && glxConfig.m_glXReleaseVideoCaptureDeviceNV)
  {
    prototypeCalled = true;
    glxConfig.m_glXReleaseVideoCaptureDeviceNV (dpy, device);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXGetVideoDeviceNV (Display * dpy, int  screen, int  numVideoDevices, GLXVideoDeviceNV * pVideoDevice)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_NV_video_out - glXGetVideoDeviceNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_video_out] && glxConfig.m_glXGetVideoDeviceNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetVideoDeviceNV (dpy, screen, numVideoDevices, pVideoDevice);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXReleaseVideoDeviceNV (Display * dpy, int  screen, GLXVideoDeviceNV VideoDevice)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_NV_video_out - glXReleaseVideoDeviceNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_video_out] && glxConfig.m_glXReleaseVideoDeviceNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXReleaseVideoDeviceNV (dpy, screen, VideoDevice);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXBindVideoImageNV (Display * dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int  iVideoBuffer)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_NV_video_out - glXBindVideoImageNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_video_out] && glxConfig.m_glXBindVideoImageNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXBindVideoImageNV (dpy, VideoDevice, pbuf, iVideoBuffer);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXReleaseVideoImageNV (Display * dpy, GLXPbuffer pbuf)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_NV_video_out - glXReleaseVideoImageNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_video_out] && glxConfig.m_glXReleaseVideoImageNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXReleaseVideoImageNV (dpy, pbuf);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXSendPbufferToVideoNV (Display * dpy, GLXPbuffer pbuf, int  iBufferType, unsigned long * pulCounterPbuffer, GLboolean bBlock)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_NV_video_out - glXSendPbufferToVideoNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_video_out] && glxConfig.m_glXSendPbufferToVideoNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXSendPbufferToVideoNV (dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXGetVideoInfoNV (Display * dpy, int  screen, GLXVideoDeviceNV VideoDevice, unsigned long * pulCounterOutputPbuffer, unsigned long * pulCounterOutputVideo)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_NV_video_out - glXGetVideoInfoNV
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_NV_video_out] && glxConfig.m_glXGetVideoInfoNV)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetVideoInfoNV (dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXGetSyncValuesOML (Display * dpy, GLXDrawable drawable, int64_t * ust, int64_t * msc, int64_t * sbc)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_OML_sync_control - glXGetSyncValuesOML
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_OML_sync_control] && glxConfig.m_glXGetSyncValuesOML)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetSyncValuesOML (dpy, drawable, ust, msc, sbc);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXGetMscRateOML (Display * dpy, GLXDrawable drawable, int32_t * numerator, int32_t * denominator)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_OML_sync_control - glXGetMscRateOML
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_OML_sync_control] && glxConfig.m_glXGetMscRateOML)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetMscRateOML (dpy, drawable, numerator, denominator);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int64_t _glew_glx_glXSwapBuffersMscOML (Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int64_t result = ((int64_t)0);
  // GLX_OML_sync_control - glXSwapBuffersMscOML
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_OML_sync_control] && glxConfig.m_glXSwapBuffersMscOML)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXSwapBuffersMscOML (dpy, drawable, target_msc, divisor, remainder);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXWaitForMscOML (Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t * ust, int64_t * msc, int64_t * sbc)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_OML_sync_control - glXWaitForMscOML
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_OML_sync_control] && glxConfig.m_glXWaitForMscOML)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXWaitForMscOML (dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXWaitForSbcOML (Display * dpy, GLXDrawable drawable, int64_t target_sbc, int64_t * ust, int64_t * msc, int64_t * sbc)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_OML_sync_control - glXWaitForSbcOML
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_OML_sync_control] && glxConfig.m_glXWaitForSbcOML)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXWaitForSbcOML (dpy, drawable, target_sbc, ust, msc, sbc);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXCushionSGI (Display * dpy, Window window, float  cushion)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_SGI_cushion - glXCushionSGI
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGI_cushion] && glxConfig.m_glXCushionSGI)
  {
    prototypeCalled = true;
    glxConfig.m_glXCushionSGI (dpy, window, cushion);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXMakeCurrentReadSGI (Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_SGI_make_current_read - glXMakeCurrentReadSGI
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGI_make_current_read] && glxConfig.m_glXMakeCurrentReadSGI)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXMakeCurrentReadSGI (dpy, draw, read, ctx);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXDrawable _glew_glx_glXGetCurrentReadDrawableSGI ()
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXDrawable result = ((GLXDrawable)0);
  // GLX_SGI_make_current_read - glXGetCurrentReadDrawableSGI
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGI_make_current_read] && glxConfig.m_glXGetCurrentReadDrawableSGI)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetCurrentReadDrawableSGI ();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXSwapIntervalSGI (int  interval)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGI_swap_control - glXSwapIntervalSGI
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGI_swap_control] && glxConfig.m_glXSwapIntervalSGI)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXSwapIntervalSGI (interval);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXGetVideoSyncSGI (unsigned int * count)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGI_video_sync - glXGetVideoSyncSGI
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGI_video_sync] && glxConfig.m_glXGetVideoSyncSGI)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetVideoSyncSGI (count);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXWaitVideoSyncSGI (int  divisor, int  remainder, unsigned int * count)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGI_video_sync - glXWaitVideoSyncSGI
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGI_video_sync] && glxConfig.m_glXWaitVideoSyncSGI)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXWaitVideoSyncSGI (divisor, remainder, count);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXAssociateDMPbufferSGIX (Display * dpy, GLXPbufferSGIX pbuffer, DMparams * params, DMbuffer dmbuffer)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_SGIX_dmbuffer - glXAssociateDMPbufferSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_dmbuffer] && glxConfig.m_glXAssociateDMPbufferSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXAssociateDMPbufferSGIX (dpy, pbuffer, params, dmbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXGetFBConfigAttribSGIX (Display * dpy, GLXFBConfigSGIX config, int  attribute, int * value)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_fbconfig - glXGetFBConfigAttribSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_fbconfig] && glxConfig.m_glXGetFBConfigAttribSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetFBConfigAttribSGIX (dpy, config, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXFBConfigSGIX * _glew_glx_glXChooseFBConfigSGIX (Display * dpy, int  screen, int * attrib_list, int * nelements)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXFBConfigSGIX * result = ((GLXFBConfigSGIX *)0);
  // GLX_SGIX_fbconfig - glXChooseFBConfigSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_fbconfig] && glxConfig.m_glXChooseFBConfigSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXChooseFBConfigSGIX (dpy, screen, attrib_list, nelements);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXPixmap _glew_glx_glXCreateGLXPixmapWithConfigSGIX (Display * dpy, GLXFBConfigSGIX config, Pixmap pixmap)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXPixmap result = ((GLXPixmap)0);
  // GLX_SGIX_fbconfig - glXCreateGLXPixmapWithConfigSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_fbconfig] && glxConfig.m_glXCreateGLXPixmapWithConfigSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreateGLXPixmapWithConfigSGIX (dpy, config, pixmap);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXContext _glew_glx_glXCreateContextWithConfigSGIX (Display * dpy, GLXFBConfigSGIX config, int  render_type, GLXContext share_list, Bool direct)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXContext result = ((GLXContext)0);
  // GLX_SGIX_fbconfig - glXCreateContextWithConfigSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_fbconfig] && glxConfig.m_glXCreateContextWithConfigSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreateContextWithConfigSGIX (dpy, config, render_type, share_list, direct);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

XVisualInfo * _glew_glx_glXGetVisualFromFBConfigSGIX (Display * dpy, GLXFBConfigSGIX config)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  XVisualInfo * result = ((XVisualInfo *)0);
  // GLX_SGIX_fbconfig - glXGetVisualFromFBConfigSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_fbconfig] && glxConfig.m_glXGetVisualFromFBConfigSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetVisualFromFBConfigSGIX (dpy, config);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXFBConfigSGIX _glew_glx_glXGetFBConfigFromVisualSGIX (Display * dpy, XVisualInfo * vis)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXFBConfigSGIX result = ((GLXFBConfigSGIX)0);
  // GLX_SGIX_fbconfig - glXGetFBConfigFromVisualSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_fbconfig] && glxConfig.m_glXGetFBConfigFromVisualSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetFBConfigFromVisualSGIX (dpy, vis);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXHyperpipeNetworkSGIX * _glew_glx_glXQueryHyperpipeNetworkSGIX (Display * dpy, int * npipes)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXHyperpipeNetworkSGIX * result = ((GLXHyperpipeNetworkSGIX *)0);
  // GLX_SGIX_hyperpipe - glXQueryHyperpipeNetworkSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_hyperpipe] && glxConfig.m_glXQueryHyperpipeNetworkSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryHyperpipeNetworkSGIX (dpy, npipes);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXHyperpipeConfigSGIX (Display * dpy, int  networkId, int  npipes, GLXHyperpipeConfigSGIX * cfg, int * hpId)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_hyperpipe - glXHyperpipeConfigSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_hyperpipe] && glxConfig.m_glXHyperpipeConfigSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXHyperpipeConfigSGIX (dpy, networkId, npipes, cfg, hpId);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXHyperpipeConfigSGIX * _glew_glx_glXQueryHyperpipeConfigSGIX (Display * dpy, int  hpId, int * npipes)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXHyperpipeConfigSGIX * result = ((GLXHyperpipeConfigSGIX *)0);
  // GLX_SGIX_hyperpipe - glXQueryHyperpipeConfigSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_hyperpipe] && glxConfig.m_glXQueryHyperpipeConfigSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryHyperpipeConfigSGIX (dpy, hpId, npipes);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXDestroyHyperpipeConfigSGIX (Display * dpy, int  hpId)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_hyperpipe - glXDestroyHyperpipeConfigSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_hyperpipe] && glxConfig.m_glXDestroyHyperpipeConfigSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXDestroyHyperpipeConfigSGIX (dpy, hpId);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXBindHyperpipeSGIX (Display * dpy, int  hpId)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_hyperpipe - glXBindHyperpipeSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_hyperpipe] && glxConfig.m_glXBindHyperpipeSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXBindHyperpipeSGIX (dpy, hpId);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXQueryHyperpipeBestAttribSGIX (Display * dpy, int  timeSlice, int  attrib, int  size, void * attribList, void * returnAttribList)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_hyperpipe - glXQueryHyperpipeBestAttribSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_hyperpipe] && glxConfig.m_glXQueryHyperpipeBestAttribSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryHyperpipeBestAttribSGIX (dpy, timeSlice, attrib, size, attribList, returnAttribList);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXHyperpipeAttribSGIX (Display * dpy, int  timeSlice, int  attrib, int  size, void * attribList)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_hyperpipe - glXHyperpipeAttribSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_hyperpipe] && glxConfig.m_glXHyperpipeAttribSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXHyperpipeAttribSGIX (dpy, timeSlice, attrib, size, attribList);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXQueryHyperpipeAttribSGIX (Display * dpy, int  timeSlice, int  attrib, int  size, void * returnAttribList)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_hyperpipe - glXQueryHyperpipeAttribSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_hyperpipe] && glxConfig.m_glXQueryHyperpipeAttribSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryHyperpipeAttribSGIX (dpy, timeSlice, attrib, size, returnAttribList);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXPbufferSGIX _glew_glx_glXCreateGLXPbufferSGIX (Display * dpy, GLXFBConfigSGIX config, unsigned int  width, unsigned int  height, int * attrib_list)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXPbufferSGIX result = ((GLXPbufferSGIX)0);
  // GLX_SGIX_pbuffer - glXCreateGLXPbufferSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_pbuffer] && glxConfig.m_glXCreateGLXPbufferSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreateGLXPbufferSGIX (dpy, config, width, height, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXDestroyGLXPbufferSGIX (Display * dpy, GLXPbufferSGIX pbuf)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_SGIX_pbuffer - glXDestroyGLXPbufferSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_pbuffer] && glxConfig.m_glXDestroyGLXPbufferSGIX)
  {
    prototypeCalled = true;
    glxConfig.m_glXDestroyGLXPbufferSGIX (dpy, pbuf);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXQueryGLXPbufferSGIX (Display * dpy, GLXPbufferSGIX pbuf, int  attribute, unsigned int * value)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_SGIX_pbuffer - glXQueryGLXPbufferSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_pbuffer] && glxConfig.m_glXQueryGLXPbufferSGIX)
  {
    prototypeCalled = true;
    glxConfig.m_glXQueryGLXPbufferSGIX (dpy, pbuf, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXSelectEventSGIX (Display * dpy, GLXDrawable drawable, unsigned long  mask)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_SGIX_pbuffer - glXSelectEventSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_pbuffer] && glxConfig.m_glXSelectEventSGIX)
  {
    prototypeCalled = true;
    glxConfig.m_glXSelectEventSGIX (dpy, drawable, mask);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXGetSelectedEventSGIX (Display * dpy, GLXDrawable drawable, unsigned long * mask)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_SGIX_pbuffer - glXGetSelectedEventSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_pbuffer] && glxConfig.m_glXGetSelectedEventSGIX)
  {
    prototypeCalled = true;
    glxConfig.m_glXGetSelectedEventSGIX (dpy, drawable, mask);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXBindSwapBarrierSGIX (Display * dpy, GLXDrawable drawable, int  barrier)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_SGIX_swap_barrier - glXBindSwapBarrierSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_swap_barrier] && glxConfig.m_glXBindSwapBarrierSGIX)
  {
    prototypeCalled = true;
    glxConfig.m_glXBindSwapBarrierSGIX (dpy, drawable, barrier);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Bool _glew_glx_glXQueryMaxSwapBarriersSGIX (Display * dpy, int  screen, int * max)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Bool result = ((Bool)0);
  // GLX_SGIX_swap_barrier - glXQueryMaxSwapBarriersSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_swap_barrier] && glxConfig.m_glXQueryMaxSwapBarriersSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryMaxSwapBarriersSGIX (dpy, screen, max);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXJoinSwapGroupSGIX (Display * dpy, GLXDrawable drawable, GLXDrawable member)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_SGIX_swap_group - glXJoinSwapGroupSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_swap_group] && glxConfig.m_glXJoinSwapGroupSGIX)
  {
    prototypeCalled = true;
    glxConfig.m_glXJoinSwapGroupSGIX (dpy, drawable, member);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXBindChannelToWindowSGIX (Display * display, int  screen, int  channel, Window window)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_video_resize - glXBindChannelToWindowSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_video_resize] && glxConfig.m_glXBindChannelToWindowSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXBindChannelToWindowSGIX (display, screen, channel, window);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXChannelRectSGIX (Display * display, int  screen, int  channel, int  x, int  y, int  w, int  h)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_video_resize - glXChannelRectSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_video_resize] && glxConfig.m_glXChannelRectSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXChannelRectSGIX (display, screen, channel, x, y, w, h);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXQueryChannelRectSGIX (Display * display, int  screen, int  channel, int * dx, int * dy, int * dw, int * dh)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_video_resize - glXQueryChannelRectSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_video_resize] && glxConfig.m_glXQueryChannelRectSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryChannelRectSGIX (display, screen, channel, dx, dy, dw, dh);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXQueryChannelDeltasSGIX (Display * display, int  screen, int  channel, int * x, int * y, int * w, int * h)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_video_resize - glXQueryChannelDeltasSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_video_resize] && glxConfig.m_glXQueryChannelDeltasSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXQueryChannelDeltasSGIX (display, screen, channel, x, y, w, h);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int _glew_glx_glXChannelRectSyncSGIX (Display * display, int  screen, int  channel, GLenum synctype)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  int result = ((int)0);
  // GLX_SGIX_video_resize - glXChannelRectSyncSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_video_resize] && glxConfig.m_glXChannelRectSyncSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXChannelRectSyncSGIX (display, screen, channel, synctype);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLXVideoSourceSGIX _glew_glx_glXCreateGLXVideoSourceSGIX (Display * display, int  screen, VLServer server, VLPath path, int  nodeClass, VLNode drainNode)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  GLXVideoSourceSGIX result = ((GLXVideoSourceSGIX)0);
  // GLX_SGIX_video_source - glXCreateGLXVideoSourceSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_video_source] && glxConfig.m_glXCreateGLXVideoSourceSGIX)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXCreateGLXVideoSourceSGIX (display, screen, server, path, nodeClass, drainNode);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_glx_glXDestroyGLXVideoSourceSGIX (Display * dpy, GLXVideoSourceSGIX glxvideosource)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  // GLX_SGIX_video_source - glXDestroyGLXVideoSourceSGIX
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SGIX_video_source] && glxConfig.m_glXDestroyGLXVideoSourceSGIX)
  {
    prototypeCalled = true;
    glxConfig.m_glXDestroyGLXVideoSourceSGIX (dpy, glxvideosource);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Status _glew_glx_glXGetTransparentIndexSUN (Display * dpy, Window overlay, Window underlay, unsigned long * pTransparentIndex)
{
  bool prototypeCalled = false;
  const glew::glx::DeviceConfig &glxConfig = glew::glx::GetConfig ();
  Status result = ((Status)0);
  // GLX_SUN_get_transparent_index - glXGetTransparentIndexSUN
  if (!prototypeCalled && glxConfig.m_featureSupported [GLEW_GLX_SUN_get_transparent_index] && glxConfig.m_glXGetTransparentIndexSUN)
  {
    prototypeCalled = true;
    result = glxConfig.m_glXGetTransparentIndexSUN (dpy, overlay, underlay, pTransparentIndex);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool glew::IsSupported (GLEW_GLX_FeatureSet feature)
{
  return glew::glx::IsSupported (feature);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
