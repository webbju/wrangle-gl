////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <wrangle-egl.h>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglBindTexImage) {
    prototypeCalled = true;
    result = eglContext->m_eglBindTexImage(dpy, surface, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglReleaseTexImage) {
    prototypeCalled = true;
    result = eglContext->m_eglReleaseTexImage(dpy, surface, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglSurfaceAttrib) {
    prototypeCalled = true;
    result = eglContext->m_eglSurfaceAttrib(dpy, surface, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglSwapInterval(EGLDisplay dpy, EGLint interval) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglSwapInterval) {
    prototypeCalled = true;
    result = eglContext->m_eglSwapInterval(dpy, interval);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglBindAPI(EGLenum api) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglBindAPI) {
    prototypeCalled = true;
    result = eglContext->m_eglBindAPI(api);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLenum _glew_egl_eglQueryAPI() {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLenum result = ((EGLenum)0);
  if (!prototypeCalled && eglContext->m_eglQueryAPI) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryAPI();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSurface _glew_egl_eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSurface result = ((EGLSurface)0);
  if (!prototypeCalled && eglContext->m_eglCreatePbufferFromClientBuffer) {
    prototypeCalled = true;
    result = eglContext->m_eglCreatePbufferFromClientBuffer(dpy, buftype, buffer, config, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglReleaseThread() {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglReleaseThread) {
    prototypeCalled = true;
    result = eglContext->m_eglReleaseThread();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglWaitClient() {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglWaitClient) {
    prototypeCalled = true;
    result = eglContext->m_eglWaitClient();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLContext _glew_egl_eglGetCurrentContext() {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLContext result = ((EGLContext)0);
  if (!prototypeCalled && eglContext->m_eglGetCurrentContext) {
    prototypeCalled = true;
    result = eglContext->m_eglGetCurrentContext();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSync _glew_egl_eglCreateSync(EGLDisplay dpy, EGLenum type, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSync result = ((EGLSync)0);
  if (!prototypeCalled && eglContext->m_eglCreateSync) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateSync(dpy, type, attrib_list);
  }
  if (!prototypeCalled && eglContext->m_eglCreateSync64KHR) {
    prototypeCalled = true;
    result = (EGLSync) eglContext->m_eglCreateSync64KHR(dpy, type, (const EGLAttribKHR *) attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglDestroySync(EGLDisplay dpy, EGLSync sync) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglDestroySync) {
    prototypeCalled = true;
    result = eglContext->m_eglDestroySync(dpy, sync);
  }
  if (!prototypeCalled && eglContext->m_eglDestroySyncKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglDestroySyncKHR(dpy, (EGLSyncKHR) sync);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLint _glew_egl_eglClientWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags, EGLTime timeout) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLint result = ((EGLint)0);
  if (!prototypeCalled && eglContext->m_eglClientWaitSync) {
    prototypeCalled = true;
    result = eglContext->m_eglClientWaitSync(dpy, sync, flags, timeout);
  }
  if (!prototypeCalled && eglContext->m_eglClientWaitSyncKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglClientWaitSyncKHR(dpy, (EGLSyncKHR) sync, flags, (EGLTimeKHR) timeout);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglGetSyncAttrib(EGLDisplay dpy, EGLSync sync, EGLint attribute, EGLAttrib * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglGetSyncAttrib) {
    prototypeCalled = true;
    result = eglContext->m_eglGetSyncAttrib(dpy, sync, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLImage _glew_egl_eglCreateImage(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLImage result = ((EGLImage)0);
  if (!prototypeCalled && eglContext->m_eglCreateImage) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateImage(dpy, ctx, target, buffer, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglDestroyImage(EGLDisplay dpy, EGLImage image) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglDestroyImage) {
    prototypeCalled = true;
    result = eglContext->m_eglDestroyImage(dpy, image);
  }
  if (!prototypeCalled && eglContext->m_eglDestroyImageKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglDestroyImageKHR(dpy, (EGLImageKHR) image);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLDisplay _glew_egl_eglGetPlatformDisplay(EGLenum platform, void * native_display, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLDisplay result = ((EGLDisplay)0);
  if (!prototypeCalled && eglContext->m_eglGetPlatformDisplay) {
    prototypeCalled = true;
    result = eglContext->m_eglGetPlatformDisplay(platform, native_display, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSurface _glew_egl_eglCreatePlatformWindowSurface(EGLDisplay dpy, EGLConfig config, void * native_window, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSurface result = ((EGLSurface)0);
  if (!prototypeCalled && eglContext->m_eglCreatePlatformWindowSurface) {
    prototypeCalled = true;
    result = eglContext->m_eglCreatePlatformWindowSurface(dpy, config, native_window, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSurface _glew_egl_eglCreatePlatformPixmapSurface(EGLDisplay dpy, EGLConfig config, void * native_pixmap, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSurface result = ((EGLSurface)0);
  if (!prototypeCalled && eglContext->m_eglCreatePlatformPixmapSurface) {
    prototypeCalled = true;
    result = eglContext->m_eglCreatePlatformPixmapSurface(dpy, config, native_pixmap, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglWaitSync(EGLDisplay dpy, EGLSync sync, EGLint flags) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglWaitSync) {
    prototypeCalled = true;
    result = eglContext->m_eglWaitSync(dpy, sync, flags);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_egl_eglSetBlobCacheFuncsANDROID(EGLDisplay dpy, EGLSetBlobFuncANDROID set, EGLGetBlobFuncANDROID get) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  if (!prototypeCalled && eglContext->m_eglSetBlobCacheFuncsANDROID) {
    prototypeCalled = true;
    eglContext->m_eglSetBlobCacheFuncsANDROID(dpy, set, get);
  }
  GLEW_ASSERT (prototypeCalled);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLClientBuffer _glew_egl_eglCreateNativeClientBufferANDROID(const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLClientBuffer result = ((EGLClientBuffer)0);
  if (!prototypeCalled && eglContext->m_eglCreateNativeClientBufferANDROID) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateNativeClientBufferANDROID(attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLClientBuffer _glew_egl_eglGetNativeClientBufferANDROID(const struct AHardwareBuffer * buffer) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLClientBuffer result = ((EGLClientBuffer)0);
  if (!prototypeCalled && eglContext->m_eglGetNativeClientBufferANDROID) {
    prototypeCalled = true;
    result = eglContext->m_eglGetNativeClientBufferANDROID(buffer);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLint _glew_egl_eglDupNativeFenceFDANDROID(EGLDisplay dpy, EGLSyncKHR sync) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLint result = ((EGLint)0);
  if (!prototypeCalled && eglContext->m_eglDupNativeFenceFDANDROID) {
    prototypeCalled = true;
    result = eglContext->m_eglDupNativeFenceFDANDROID(dpy, sync);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglPresentationTimeANDROID(EGLDisplay dpy, EGLSurface surface, EGLnsecsANDROID time) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglPresentationTimeANDROID) {
    prototypeCalled = true;
    result = eglContext->m_eglPresentationTimeANDROID(dpy, surface, time);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglGetCompositorTimingSupportedANDROID(EGLDisplay dpy, EGLSurface surface, EGLint name) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglGetCompositorTimingSupportedANDROID) {
    prototypeCalled = true;
    result = eglContext->m_eglGetCompositorTimingSupportedANDROID(dpy, surface, name);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglGetCompositorTimingANDROID(EGLDisplay dpy, EGLSurface surface, EGLint numTimestamps, const EGLint * names, EGLnsecsANDROID * values) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglGetCompositorTimingANDROID) {
    prototypeCalled = true;
    result = eglContext->m_eglGetCompositorTimingANDROID(dpy, surface, numTimestamps, names, values);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglGetNextFrameIdANDROID(EGLDisplay dpy, EGLSurface surface, EGLuint64KHR * frameId) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglGetNextFrameIdANDROID) {
    prototypeCalled = true;
    result = eglContext->m_eglGetNextFrameIdANDROID(dpy, surface, frameId);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglGetFrameTimestampSupportedANDROID(EGLDisplay dpy, EGLSurface surface, EGLint timestamp) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglGetFrameTimestampSupportedANDROID) {
    prototypeCalled = true;
    result = eglContext->m_eglGetFrameTimestampSupportedANDROID(dpy, surface, timestamp);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglGetFrameTimestampsANDROID(EGLDisplay dpy, EGLSurface surface, EGLuint64KHR frameId, EGLint numTimestamps, const EGLint * timestamps, EGLnsecsANDROID * values) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglGetFrameTimestampsANDROID) {
    prototypeCalled = true;
    result = eglContext->m_eglGetFrameTimestampsANDROID(dpy, surface, frameId, numTimestamps, timestamps, values);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, void ** value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQuerySurfacePointerANGLE) {
    prototypeCalled = true;
    result = eglContext->m_eglQuerySurfacePointerANGLE(dpy, surface, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglGetMscRateANGLE(EGLDisplay dpy, EGLSurface surface, EGLint * numerator, EGLint * denominator) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglGetMscRateANGLE) {
    prototypeCalled = true;
    result = eglContext->m_eglGetMscRateANGLE(dpy, surface, numerator, denominator);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglClientSignalSyncEXT(EGLDisplay dpy, EGLSync sync, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglClientSignalSyncEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglClientSignalSyncEXT(dpy, sync, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryDeviceAttribEXT(EGLDeviceEXT device, EGLint attribute, EGLAttrib * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryDeviceAttribEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryDeviceAttribEXT(device, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char * _glew_egl_eglQueryDeviceStringEXT(EGLDeviceEXT device, EGLint name) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  const char * result = ((const char *)0);
  if (!prototypeCalled && eglContext->m_eglQueryDeviceStringEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryDeviceStringEXT(device, name);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryDevicesEXT(EGLint max_devices, EGLDeviceEXT * devices, EGLint * num_devices) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryDevicesEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryDevicesEXT(max_devices, devices, num_devices);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryDisplayAttribEXT(EGLDisplay dpy, EGLint attribute, EGLAttrib * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryDisplayAttribEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryDisplayAttribEXT(dpy, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryDmaBufFormatsEXT(EGLDisplay dpy, EGLint max_formats, EGLint * formats, EGLint * num_formats) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryDmaBufFormatsEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryDmaBufFormatsEXT(dpy, max_formats, formats, num_formats);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryDmaBufModifiersEXT(EGLDisplay dpy, EGLint format, EGLint max_modifiers, EGLuint64KHR * modifiers, EGLBoolean * external_only, EGLint * num_modifiers) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryDmaBufModifiersEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryDmaBufModifiersEXT(dpy, format, max_modifiers, modifiers, external_only, num_modifiers);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglGetOutputLayersEXT(EGLDisplay dpy, const EGLAttrib * attrib_list, EGLOutputLayerEXT * layers, EGLint max_layers, EGLint * num_layers) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglGetOutputLayersEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglGetOutputLayersEXT(dpy, attrib_list, layers, max_layers, num_layers);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglGetOutputPortsEXT(EGLDisplay dpy, const EGLAttrib * attrib_list, EGLOutputPortEXT * ports, EGLint max_ports, EGLint * num_ports) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglGetOutputPortsEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglGetOutputPortsEXT(dpy, attrib_list, ports, max_ports, num_ports);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglOutputLayerAttribEXT(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint attribute, EGLAttrib value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglOutputLayerAttribEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglOutputLayerAttribEXT(dpy, layer, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryOutputLayerAttribEXT(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint attribute, EGLAttrib * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryOutputLayerAttribEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryOutputLayerAttribEXT(dpy, layer, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char * _glew_egl_eglQueryOutputLayerStringEXT(EGLDisplay dpy, EGLOutputLayerEXT layer, EGLint name) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  const char * result = ((const char *)0);
  if (!prototypeCalled && eglContext->m_eglQueryOutputLayerStringEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryOutputLayerStringEXT(dpy, layer, name);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglOutputPortAttribEXT(EGLDisplay dpy, EGLOutputPortEXT port, EGLint attribute, EGLAttrib value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglOutputPortAttribEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglOutputPortAttribEXT(dpy, port, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryOutputPortAttribEXT(EGLDisplay dpy, EGLOutputPortEXT port, EGLint attribute, EGLAttrib * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryOutputPortAttribEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryOutputPortAttribEXT(dpy, port, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char * _glew_egl_eglQueryOutputPortStringEXT(EGLDisplay dpy, EGLOutputPortEXT port, EGLint name) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  const char * result = ((const char *)0);
  if (!prototypeCalled && eglContext->m_eglQueryOutputPortStringEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryOutputPortStringEXT(dpy, port, name);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLDisplay _glew_egl_eglGetPlatformDisplayEXT(EGLenum platform, void * native_display, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLDisplay result = ((EGLDisplay)0);
  if (!prototypeCalled && eglContext->m_eglGetPlatformDisplayEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglGetPlatformDisplayEXT(platform, native_display, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSurface _glew_egl_eglCreatePlatformWindowSurfaceEXT(EGLDisplay dpy, EGLConfig config, void * native_window, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSurface result = ((EGLSurface)0);
  if (!prototypeCalled && eglContext->m_eglCreatePlatformWindowSurfaceEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglCreatePlatformWindowSurfaceEXT(dpy, config, native_window, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSurface _glew_egl_eglCreatePlatformPixmapSurfaceEXT(EGLDisplay dpy, EGLConfig config, void * native_pixmap, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSurface result = ((EGLSurface)0);
  if (!prototypeCalled && eglContext->m_eglCreatePlatformPixmapSurfaceEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglCreatePlatformPixmapSurfaceEXT(dpy, config, native_pixmap, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamConsumerOutputEXT(EGLDisplay dpy, EGLStreamKHR stream, EGLOutputLayerEXT layer) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamConsumerOutputEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamConsumerOutputEXT(dpy, stream, layer);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglSwapBuffersWithDamageEXT(EGLDisplay dpy, EGLSurface surface, const EGLint * rects, EGLint n_rects) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglSwapBuffersWithDamageEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglSwapBuffersWithDamageEXT(dpy, surface, rects, n_rects);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglUnsignalSyncEXT(EGLDisplay dpy, EGLSync sync, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglUnsignalSyncEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglUnsignalSyncEXT(dpy, sync, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSurface _glew_egl_eglCreatePixmapSurfaceHI(EGLDisplay dpy, EGLConfig config, struct EGLClientPixmapHI * pixmap) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSurface result = ((EGLSurface)0);
  if (!prototypeCalled && eglContext->m_eglCreatePixmapSurfaceHI) {
    prototypeCalled = true;
    result = eglContext->m_eglCreatePixmapSurfaceHI(dpy, config, pixmap);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSyncKHR _glew_egl_eglCreateSync64KHR(EGLDisplay dpy, EGLenum type, const EGLAttribKHR * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSyncKHR result = ((EGLSyncKHR)0);
  if (!prototypeCalled && eglContext->m_eglCreateSync64KHR) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateSync64KHR(dpy, type, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLint _glew_egl_eglDebugMessageControlKHR(EGLDEBUGPROCKHR callback, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLint result = ((EGLint)0);
  if (!prototypeCalled && eglContext->m_eglDebugMessageControlKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglDebugMessageControlKHR(callback, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryDebugKHR(EGLint attribute, EGLAttrib * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryDebugKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryDebugKHR(attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLint _glew_egl_eglLabelObjectKHR(EGLDisplay display, EGLenum objectType, EGLObjectKHR object, EGLLabelKHR label) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLint result = ((EGLint)0);
  if (!prototypeCalled && eglContext->m_eglLabelObjectKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglLabelObjectKHR(display, objectType, object, label);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryDisplayAttribKHR(EGLDisplay dpy, EGLint name, EGLAttrib * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryDisplayAttribKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryDisplayAttribKHR(dpy, name, value);
  }
  if (!prototypeCalled && eglContext->m_eglQueryDisplayAttribEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryDisplayAttribEXT(dpy, name, value);
  }
  if (!prototypeCalled && eglContext->m_eglQueryDisplayAttribNV) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryDisplayAttribNV(dpy, name, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSyncKHR _glew_egl_eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSyncKHR result = ((EGLSyncKHR)0);
  if (!prototypeCalled && eglContext->m_eglCreateSyncKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateSyncKHR(dpy, type, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglDestroySyncKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglDestroySyncKHR(dpy, sync);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLint _glew_egl_eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLint result = ((EGLint)0);
  if (!prototypeCalled && eglContext->m_eglClientWaitSyncKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglClientWaitSyncKHR(dpy, sync, flags, timeout);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglGetSyncAttribKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglGetSyncAttribKHR(dpy, sync, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLImageKHR _glew_egl_eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLImageKHR result = ((EGLImageKHR)0);
  if (!prototypeCalled && eglContext->m_eglCreateImageKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateImageKHR(dpy, ctx, target, buffer, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglDestroyImageKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglDestroyImageKHR(dpy, image);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglLockSurfaceKHR(EGLDisplay dpy, EGLSurface surface, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglLockSurfaceKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglLockSurfaceKHR(dpy, surface, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglUnlockSurfaceKHR(EGLDisplay dpy, EGLSurface surface) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglUnlockSurfaceKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglUnlockSurfaceKHR(dpy, surface);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQuerySurface64KHR(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLAttribKHR * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQuerySurface64KHR) {
    prototypeCalled = true;
    result = eglContext->m_eglQuerySurface64KHR(dpy, surface, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface, EGLint * rects, EGLint n_rects) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglSetDamageRegionKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglSetDamageRegionKHR(dpy, surface, rects, n_rects);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglSignalSyncKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglSignalSyncKHR(dpy, sync, mode);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLStreamKHR _glew_egl_eglCreateStreamKHR(EGLDisplay dpy, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLStreamKHR result = ((EGLStreamKHR)0);
  if (!prototypeCalled && eglContext->m_eglCreateStreamKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateStreamKHR(dpy, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglDestroyStreamKHR(EGLDisplay dpy, EGLStreamKHR stream) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglDestroyStreamKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglDestroyStreamKHR(dpy, stream);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamAttribKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamAttribKHR(dpy, stream, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryStreamKHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryStreamKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryStreamKHR(dpy, stream, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryStreamu64KHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLuint64KHR * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryStreamu64KHR) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryStreamu64KHR(dpy, stream, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLStreamKHR _glew_egl_eglCreateStreamAttribKHR(EGLDisplay dpy, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLStreamKHR result = ((EGLStreamKHR)0);
  if (!prototypeCalled && eglContext->m_eglCreateStreamAttribKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateStreamAttribKHR(dpy, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglSetStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLAttrib value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglSetStreamAttribKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglSetStreamAttribKHR(dpy, stream, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLAttrib * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryStreamAttribKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryStreamAttribKHR(dpy, stream, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamConsumerAcquireAttribKHR(EGLDisplay dpy, EGLStreamKHR stream, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamConsumerAcquireAttribKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamConsumerAcquireAttribKHR(dpy, stream, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamConsumerReleaseAttribKHR(EGLDisplay dpy, EGLStreamKHR stream, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamConsumerReleaseAttribKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamConsumerReleaseAttribKHR(dpy, stream, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy, EGLStreamKHR stream) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamConsumerGLTextureExternalKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamConsumerGLTextureExternalKHR(dpy, stream);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamConsumerAcquireKHR(EGLDisplay dpy, EGLStreamKHR stream) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamConsumerAcquireKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamConsumerAcquireKHR(dpy, stream);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamConsumerReleaseKHR(EGLDisplay dpy, EGLStreamKHR stream) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamConsumerReleaseKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamConsumerReleaseKHR(dpy, stream);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLNativeFileDescriptorKHR _glew_egl_eglGetStreamFileDescriptorKHR(EGLDisplay dpy, EGLStreamKHR stream) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLNativeFileDescriptorKHR result = ((EGLNativeFileDescriptorKHR)0);
  if (!prototypeCalled && eglContext->m_eglGetStreamFileDescriptorKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglGetStreamFileDescriptorKHR(dpy, stream);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLStreamKHR _glew_egl_eglCreateStreamFromFileDescriptorKHR(EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLStreamKHR result = ((EGLStreamKHR)0);
  if (!prototypeCalled && eglContext->m_eglCreateStreamFromFileDescriptorKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateStreamFromFileDescriptorKHR(dpy, file_descriptor);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryStreamTimeKHR(EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLTimeKHR * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryStreamTimeKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryStreamTimeKHR(dpy, stream, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSurface _glew_egl_eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config, EGLStreamKHR stream, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSurface result = ((EGLSurface)0);
  if (!prototypeCalled && eglContext->m_eglCreateStreamProducerSurfaceKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateStreamProducerSurfaceKHR(dpy, config, stream, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface surface, const EGLint * rects, EGLint n_rects) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglSwapBuffersWithDamageKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglSwapBuffersWithDamageKHR(dpy, surface, rects, n_rects);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLint _glew_egl_eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLint result = ((EGLint)0);
  if (!prototypeCalled && eglContext->m_eglWaitSyncKHR) {
    prototypeCalled = true;
    result = eglContext->m_eglWaitSyncKHR(dpy, sync, flags);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLImageKHR _glew_egl_eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLImageKHR result = ((EGLImageKHR)0);
  if (!prototypeCalled && eglContext->m_eglCreateDRMImageMESA) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateDRMImageMESA(dpy, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint * name, EGLint * handle, EGLint * stride) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglExportDRMImageMESA) {
    prototypeCalled = true;
    result = eglContext->m_eglExportDRMImageMESA(dpy, image, name, handle, stride);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglExportDMABUFImageQueryMESA(EGLDisplay dpy, EGLImageKHR image, int * fourcc, int * num_planes, EGLuint64KHR * modifiers) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglExportDMABUFImageQueryMESA) {
    prototypeCalled = true;
    result = eglContext->m_eglExportDMABUFImageQueryMESA(dpy, image, fourcc, num_planes, modifiers);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglExportDMABUFImageMESA(EGLDisplay dpy, EGLImageKHR image, int * fds, EGLint * strides, EGLint * offsets) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglExportDMABUFImageMESA) {
    prototypeCalled = true;
    result = eglContext->m_eglExportDMABUFImageMESA(dpy, image, fds, strides, offsets);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

char * _glew_egl_eglGetDisplayDriverConfig(EGLDisplay dpy) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  char * result = ((char *)0);
  if (!prototypeCalled && eglContext->m_eglGetDisplayDriverConfig) {
    prototypeCalled = true;
    result = eglContext->m_eglGetDisplayDriverConfig(dpy);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char * _glew_egl_eglGetDisplayDriverName(EGLDisplay dpy) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  const char * result = ((const char *)0);
  if (!prototypeCalled && eglContext->m_eglGetDisplayDriverName) {
    prototypeCalled = true;
    result = eglContext->m_eglGetDisplayDriverName(dpy);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglSwapBuffersRegionNOK(EGLDisplay dpy, EGLSurface surface, EGLint numRects, const EGLint * rects) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglSwapBuffersRegionNOK) {
    prototypeCalled = true;
    result = eglContext->m_eglSwapBuffersRegionNOK(dpy, surface, numRects, rects);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglSwapBuffersRegion2NOK(EGLDisplay dpy, EGLSurface surface, EGLint numRects, const EGLint * rects) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglSwapBuffersRegion2NOK) {
    prototypeCalled = true;
    result = eglContext->m_eglSwapBuffersRegion2NOK(dpy, surface, numRects, rects);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryNativeDisplayNV(EGLDisplay dpy, EGLNativeDisplayType * display_id) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryNativeDisplayNV) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryNativeDisplayNV(dpy, display_id);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryNativeWindowNV(EGLDisplay dpy, EGLSurface surf, EGLNativeWindowType * window) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryNativeWindowNV) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryNativeWindowNV(dpy, surf, window);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryNativePixmapNV(EGLDisplay dpy, EGLSurface surf, EGLNativePixmapType * pixmap) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryNativePixmapNV) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryNativePixmapNV(dpy, surf, pixmap);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglPostSubBufferNV) {
    prototypeCalled = true;
    result = eglContext->m_eglPostSubBufferNV(dpy, surface, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamConsumerGLTextureExternalAttribsNV(EGLDisplay dpy, EGLStreamKHR stream, const EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamConsumerGLTextureExternalAttribsNV) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamConsumerGLTextureExternalAttribsNV(dpy, stream, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamImageConsumerConnectNV(EGLDisplay dpy, EGLStreamKHR stream, EGLint num_modifiers, EGLuint64KHR * modifiers, EGLAttrib * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamImageConsumerConnectNV) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamImageConsumerConnectNV(dpy, stream, num_modifiers, modifiers, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLint _glew_egl_eglQueryStreamConsumerEventNV(EGLDisplay dpy, EGLStreamKHR stream, EGLTime timeout, EGLenum * event, EGLAttrib * aux) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLint result = ((EGLint)0);
  if (!prototypeCalled && eglContext->m_eglQueryStreamConsumerEventNV) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryStreamConsumerEventNV(dpy, stream, timeout, event, aux);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamAcquireImageNV(EGLDisplay dpy, EGLStreamKHR stream, EGLImage * pImage, EGLSync sync) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamAcquireImageNV) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamAcquireImageNV(dpy, stream, pImage, sync);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamReleaseImageNV(EGLDisplay dpy, EGLStreamKHR stream, EGLImage image, EGLSync sync) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamReleaseImageNV) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamReleaseImageNV(dpy, stream, image, sync);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglStreamFlushNV(EGLDisplay dpy, EGLStreamKHR stream) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglStreamFlushNV) {
    prototypeCalled = true;
    result = eglContext->m_eglStreamFlushNV(dpy, stream);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryDisplayAttribNV(EGLDisplay dpy, EGLint attribute, EGLAttrib * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryDisplayAttribNV) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryDisplayAttribNV(dpy, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglSetStreamMetadataNV(EGLDisplay dpy, EGLStreamKHR stream, EGLint n, EGLint offset, EGLint size, const void * data) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglSetStreamMetadataNV) {
    prototypeCalled = true;
    result = eglContext->m_eglSetStreamMetadataNV(dpy, stream, n, offset, size, data);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryStreamMetadataNV(EGLDisplay dpy, EGLStreamKHR stream, EGLenum name, EGLint n, EGLint offset, EGLint size, void * data) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryStreamMetadataNV) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryStreamMetadataNV(dpy, stream, name, n, offset, size, data);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglResetStreamNV(EGLDisplay dpy, EGLStreamKHR stream) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglResetStreamNV) {
    prototypeCalled = true;
    result = eglContext->m_eglResetStreamNV(dpy, stream);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSyncKHR _glew_egl_eglCreateStreamSyncNV(EGLDisplay dpy, EGLStreamKHR stream, EGLenum type, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSyncKHR result = ((EGLSyncKHR)0);
  if (!prototypeCalled && eglContext->m_eglCreateStreamSyncNV) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateStreamSyncNV(dpy, stream, type, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLSyncNV _glew_egl_eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint * attrib_list) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLSyncNV result = ((EGLSyncNV)0);
  if (!prototypeCalled && eglContext->m_eglCreateFenceSyncNV) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateFenceSyncNV(dpy, condition, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglDestroySyncNV(EGLSyncNV sync) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglDestroySyncNV) {
    prototypeCalled = true;
    result = eglContext->m_eglDestroySyncNV(sync);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglFenceNV(EGLSyncNV sync) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglFenceNV) {
    prototypeCalled = true;
    result = eglContext->m_eglFenceNV(sync);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLint _glew_egl_eglClientWaitSyncNV(EGLSyncNV sync, EGLint flags, EGLTimeNV timeout) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLint result = ((EGLint)0);
  if (!prototypeCalled && eglContext->m_eglClientWaitSyncNV) {
    prototypeCalled = true;
    result = eglContext->m_eglClientWaitSyncNV(sync, flags, timeout);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglSignalSyncNV(EGLSyncNV sync, EGLenum mode) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglSignalSyncNV) {
    prototypeCalled = true;
    result = eglContext->m_eglSignalSyncNV(sync, mode);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglGetSyncAttribNV(EGLSyncNV sync, EGLint attribute, EGLint * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglGetSyncAttribNV) {
    prototypeCalled = true;
    result = eglContext->m_eglGetSyncAttribNV(sync, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLuint64NV _glew_egl_eglGetSystemTimeFrequencyNV() {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLuint64NV result = ((EGLuint64NV)0);
  if (!prototypeCalled && eglContext->m_eglGetSystemTimeFrequencyNV) {
    prototypeCalled = true;
    result = eglContext->m_eglGetSystemTimeFrequencyNV();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLuint64NV _glew_egl_eglGetSystemTimeNV() {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLuint64NV result = ((EGLuint64NV)0);
  if (!prototypeCalled && eglContext->m_eglGetSystemTimeNV) {
    prototypeCalled = true;
    result = eglContext->m_eglGetSystemTimeNV();
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglCompositorSetContextListEXT(const EGLint * external_ref_ids, EGLint num_entries) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglCompositorSetContextListEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglCompositorSetContextListEXT(external_ref_ids, num_entries);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglCompositorSetContextAttributesEXT(EGLint external_ref_id, const EGLint * context_attributes, EGLint num_entries) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglCompositorSetContextAttributesEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglCompositorSetContextAttributesEXT(external_ref_id, context_attributes, num_entries);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglCompositorSetWindowListEXT(EGLint external_ref_id, const EGLint * external_win_ids, EGLint num_entries) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglCompositorSetWindowListEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglCompositorSetWindowListEXT(external_ref_id, external_win_ids, num_entries);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglCompositorSetWindowAttributesEXT(EGLint external_win_id, const EGLint * window_attributes, EGLint num_entries) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglCompositorSetWindowAttributesEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglCompositorSetWindowAttributesEXT(external_win_id, window_attributes, num_entries);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglCompositorBindTexWindowEXT(EGLint external_win_id) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglCompositorBindTexWindowEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglCompositorBindTexWindowEXT(external_win_id);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglCompositorSetSizeEXT(EGLint external_win_id, EGLint width, EGLint height) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglCompositorSetSizeEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglCompositorSetSizeEXT(external_win_id, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglCompositorSwapPolicyEXT(EGLint external_win_id, EGLint policy) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglCompositorSwapPolicyEXT) {
    prototypeCalled = true;
    result = eglContext->m_eglCompositorSwapPolicyEXT(external_win_id, policy);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglBindWaylandDisplayWL(EGLDisplay dpy, struct wl_display * display) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglBindWaylandDisplayWL) {
    prototypeCalled = true;
    result = eglContext->m_eglBindWaylandDisplayWL(dpy, display);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglUnbindWaylandDisplayWL(EGLDisplay dpy, struct wl_display * display) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglUnbindWaylandDisplayWL) {
    prototypeCalled = true;
    result = eglContext->m_eglUnbindWaylandDisplayWL(dpy, display);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

EGLBoolean _glew_egl_eglQueryWaylandBufferWL(EGLDisplay dpy, struct wl_resource * buffer, EGLint attribute, EGLint * value) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  EGLBoolean result = ((EGLBoolean)0);
  if (!prototypeCalled && eglContext->m_eglQueryWaylandBufferWL) {
    prototypeCalled = true;
    result = eglContext->m_eglQueryWaylandBufferWL(dpy, buffer, attribute, value);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct wl_buffer * _glew_egl_eglCreateWaylandBufferFromImageWL(EGLDisplay dpy, EGLImageKHR image) {
  bool prototypeCalled = false;
  const glew::egl::Context *eglContext = glew::egl::s_eglContext;
  struct wl_buffer * result = ((struct wl_buffer *)0);
  if (!prototypeCalled && eglContext->m_eglCreateWaylandBufferFromImageWL) {
    prototypeCalled = true;
    result = eglContext->m_eglCreateWaylandBufferFromImageWL(dpy, image);
  }
  GLEW_ASSERT (prototypeCalled);
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
