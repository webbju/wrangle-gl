////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <cstring>
#include <string>
#include <unordered_set>

#include <wrangle-gl.h>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawArrays (GLenum mode, GLint first, GLsizei count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glDrawArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glDrawArrays)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArrays (mode, first, count);
  }
  // GL_ES_VERSION_2_0 - glDrawArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glDrawArrays)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArrays (mode, first, count);
  }
  // GL_EXT_vertex_array - glDrawArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glDrawArraysEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysEXT (mode, first, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElements (GLenum mode, GLsizei count, GLenum type, const void * indices)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glDrawElements
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glDrawElements)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElements (mode, count, type, indices);
  }
  // GL_ES_VERSION_2_0 - glDrawElements
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glDrawElements)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElements (mode, count, type, indices);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPointerv (GLenum pname, void ** params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glGetPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glGetPointerv)
  {
    prototypeCalled = true;
    glConfig.m_glGetPointerv (pname, params);
  }
  // GL_VERSION_4_3 - glGetPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetPointerv)
  {
    prototypeCalled = true;
    glConfig.m_glGetPointerv (pname, params);
  }
  // GL_ES_VERSION_3_2 - glGetPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetPointerv)
  {
    prototypeCalled = true;
    glConfig.m_glGetPointerv (pname, params);
  }
  // GL_KHR_debug - glGetPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetPointerv)
  {
    prototypeCalled = true;
    glConfig.m_glGetPointerv (pname, params);
  }
  // GL_EXT_vertex_array - glGetPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glGetPointervEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetPointervEXT (pname, params);
  }
  // GL_KHR_debug - glGetPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetPointervKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetPointervKHR (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPolygonOffset (GLfloat factor, GLfloat units)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glPolygonOffset
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glPolygonOffset)
  {
    prototypeCalled = true;
    glConfig.m_glPolygonOffset (factor, units);
  }
  // GL_ES_VERSION_2_0 - glPolygonOffset
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glPolygonOffset)
  {
    prototypeCalled = true;
    glConfig.m_glPolygonOffset (factor, units);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTexImage1D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glCopyTexImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glCopyTexImage1D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexImage1D (target, level, internalformat, x, y, width, border);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glCopyTexImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glCopyTexImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexImage2D (target, level, internalformat, x, y, width, height, border);
  }
  // GL_ES_VERSION_2_0 - glCopyTexImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glCopyTexImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexImage2D (target, level, internalformat, x, y, width, height, border);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glCopyTexSubImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glCopyTexSubImage1D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexSubImage1D (target, level, xoffset, x, y, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glCopyTexSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glCopyTexSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexSubImage2D (target, level, xoffset, yoffset, x, y, width, height);
  }
  // GL_ES_VERSION_2_0 - glCopyTexSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glCopyTexSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexSubImage2D (target, level, xoffset, yoffset, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glTexSubImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glTexSubImage1D)
  {
    prototypeCalled = true;
    glConfig.m_glTexSubImage1D (target, level, xoffset, width, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glTexSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glTexSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glTexSubImage2D (target, level, xoffset, yoffset, width, height, format, type, pixels);
  }
  // GL_ES_VERSION_2_0 - glTexSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glTexSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glTexSubImage2D (target, level, xoffset, yoffset, width, height, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindTexture (GLenum target, GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glBindTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glBindTexture)
  {
    prototypeCalled = true;
    glConfig.m_glBindTexture (target, texture);
  }
  // GL_ES_VERSION_2_0 - glBindTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glBindTexture)
  {
    prototypeCalled = true;
    glConfig.m_glBindTexture (target, texture);
  }
  // GL_EXT_texture_object - glBindTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_object] && glConfig.m_glBindTextureEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindTextureEXT (target, texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteTextures (GLsizei n, const GLuint * textures)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glDeleteTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glDeleteTextures)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteTextures (n, textures);
  }
  // GL_ES_VERSION_2_0 - glDeleteTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glDeleteTextures)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteTextures (n, textures);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenTextures (GLsizei n, GLuint * textures)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glGenTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glGenTextures)
  {
    prototypeCalled = true;
    glConfig.m_glGenTextures (n, textures);
  }
  // GL_ES_VERSION_2_0 - glGenTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGenTextures)
  {
    prototypeCalled = true;
    glConfig.m_glGenTextures (n, textures);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsTexture (GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glIsTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glIsTexture)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsTexture (texture);
  }
  // GL_ES_VERSION_2_0 - glIsTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glIsTexture)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsTexture (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glArrayElement (GLint i)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glArrayElement
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glArrayElement)
  {
    prototypeCalled = true;
    glConfig.m_glArrayElement (i);
  }
  // GL_EXT_vertex_array - glArrayElement
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glArrayElementEXT)
  {
    prototypeCalled = true;
    glConfig.m_glArrayElementEXT (i);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorPointer (GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glColorPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glColorPointer)
  {
    prototypeCalled = true;
    glConfig.m_glColorPointer (size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableClientState (GLenum array)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glDisableClientState
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glDisableClientState)
  {
    prototypeCalled = true;
    glConfig.m_glDisableClientState (array);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEdgeFlagPointer (GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glEdgeFlagPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glEdgeFlagPointer)
  {
    prototypeCalled = true;
    glConfig.m_glEdgeFlagPointer (stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableClientState (GLenum array)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glEnableClientState
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glEnableClientState)
  {
    prototypeCalled = true;
    glConfig.m_glEnableClientState (array);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glIndexPointer (GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glIndexPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glIndexPointer)
  {
    prototypeCalled = true;
    glConfig.m_glIndexPointer (type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInterleavedArrays (GLenum format, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glInterleavedArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glInterleavedArrays)
  {
    prototypeCalled = true;
    glConfig.m_glInterleavedArrays (format, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalPointer (GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glNormalPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glNormalPointer)
  {
    prototypeCalled = true;
    glConfig.m_glNormalPointer (type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glTexCoordPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glTexCoordPointer)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordPointer (size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexPointer (GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glVertexPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glVertexPointer)
  {
    prototypeCalled = true;
    glConfig.m_glVertexPointer (size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glAreTexturesResident (GLsizei n, const GLuint * textures, GLboolean * residences)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glAreTexturesResident
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glAreTexturesResident)
  {
    prototypeCalled = true;
    result = glConfig.m_glAreTexturesResident (n, textures, residences);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPrioritizeTextures (GLsizei n, const GLuint * textures, const GLfloat * priorities)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glPrioritizeTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glPrioritizeTextures)
  {
    prototypeCalled = true;
    glConfig.m_glPrioritizeTextures (n, textures, priorities);
  }
  // GL_EXT_texture_object - glPrioritizeTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_object] && glConfig.m_glPrioritizeTexturesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPrioritizeTexturesEXT (n, textures, (const GLclampf *) priorities);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glIndexub (GLubyte c)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glIndexub
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glIndexub)
  {
    prototypeCalled = true;
    glConfig.m_glIndexub (c);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glIndexubv (const GLubyte * c)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glIndexubv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glIndexubv)
  {
    prototypeCalled = true;
    glConfig.m_glIndexubv (c);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPopClientAttrib ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glPopClientAttrib
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glPopClientAttrib)
  {
    prototypeCalled = true;
    glConfig.m_glPopClientAttrib ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPushClientAttrib (GLbitfield mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_1 - glPushClientAttrib
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_1] && glConfig.m_glPushClientAttrib)
  {
    prototypeCalled = true;
    glConfig.m_glPushClientAttrib (mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_2 - glDrawRangeElements
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_2] && glConfig.m_glDrawRangeElements)
  {
    prototypeCalled = true;
    glConfig.m_glDrawRangeElements (mode, start, end, count, type, indices);
  }
  // GL_ES_VERSION_3_0 - glDrawRangeElements
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glDrawRangeElements)
  {
    prototypeCalled = true;
    glConfig.m_glDrawRangeElements (mode, start, end, count, type, indices);
  }
  // GL_EXT_draw_range_elements - glDrawRangeElements
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_range_elements] && glConfig.m_glDrawRangeElementsEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawRangeElementsEXT (mode, start, end, count, type, indices);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexImage3D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_2 - glTexImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_2] && glConfig.m_glTexImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage3D (target, level, internalformat, width, height, depth, border, format, type, pixels);
  }
  // GL_ES_VERSION_3_0 - glTexImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glTexImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage3D (target, level, internalformat, width, height, depth, border, format, type, pixels);
  }
  // GL_EXT_texture3D - glTexImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture3D] && glConfig.m_glTexImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage3DEXT (target, level, (GLenum) internalformat, width, height, depth, border, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_2 - glTexSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_2] && glConfig.m_glTexSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glTexSubImage3D (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }
  // GL_ES_VERSION_3_0 - glTexSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glTexSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glTexSubImage3D (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }
  // GL_EXT_texture3D - glTexSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture3D] && glConfig.m_glTexSubImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexSubImage3DEXT (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_2 - glCopyTexSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_2] && glConfig.m_glCopyTexSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexSubImage3D (target, level, xoffset, yoffset, zoffset, x, y, width, height);
  }
  // GL_ES_VERSION_3_0 - glCopyTexSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glCopyTexSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexSubImage3D (target, level, xoffset, yoffset, zoffset, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glActiveTexture (GLenum texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glActiveTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glActiveTexture)
  {
    prototypeCalled = true;
    glConfig.m_glActiveTexture (texture);
  }
  // GL_ES_VERSION_2_0 - glActiveTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glActiveTexture)
  {
    prototypeCalled = true;
    glConfig.m_glActiveTexture (texture);
  }
  // GL_ARB_multitexture - glActiveTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glActiveTextureARB)
  {
    prototypeCalled = true;
    glConfig.m_glActiveTextureARB (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSampleCoverage (GLfloat value, GLboolean invert)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glSampleCoverage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glSampleCoverage)
  {
    prototypeCalled = true;
    glConfig.m_glSampleCoverage (value, invert);
  }
  // GL_ES_VERSION_2_0 - glSampleCoverage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glSampleCoverage)
  {
    prototypeCalled = true;
    glConfig.m_glSampleCoverage (value, invert);
  }
  // GL_ARB_multisample - glSampleCoverage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multisample] && glConfig.m_glSampleCoverageARB)
  {
    prototypeCalled = true;
    glConfig.m_glSampleCoverageARB (value, invert);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glCompressedTexImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glCompressedTexImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage3D (target, level, internalformat, width, height, depth, border, imageSize, data);
  }
  // GL_ES_VERSION_3_0 - glCompressedTexImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glCompressedTexImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage3D (target, level, internalformat, width, height, depth, border, imageSize, data);
  }
  // GL_ARB_texture_compression - glCompressedTexImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexImage3DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage3DARB (target, level, internalformat, width, height, depth, border, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glCompressedTexImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glCompressedTexImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage2D (target, level, internalformat, width, height, border, imageSize, data);
  }
  // GL_ES_VERSION_2_0 - glCompressedTexImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glCompressedTexImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage2D (target, level, internalformat, width, height, border, imageSize, data);
  }
  // GL_ARB_texture_compression - glCompressedTexImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexImage2DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage2DARB (target, level, internalformat, width, height, border, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexImage1D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glCompressedTexImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glCompressedTexImage1D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage1D (target, level, internalformat, width, border, imageSize, data);
  }
  // GL_ARB_texture_compression - glCompressedTexImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexImage1DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage1DARB (target, level, internalformat, width, border, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glCompressedTexSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glCompressedTexSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage3D (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
  }
  // GL_ES_VERSION_3_0 - glCompressedTexSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glCompressedTexSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage3D (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
  }
  // GL_ARB_texture_compression - glCompressedTexSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexSubImage3DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage3DARB (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glCompressedTexSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glCompressedTexSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage2D (target, level, xoffset, yoffset, width, height, format, imageSize, data);
  }
  // GL_ES_VERSION_2_0 - glCompressedTexSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glCompressedTexSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage2D (target, level, xoffset, yoffset, width, height, format, imageSize, data);
  }
  // GL_ARB_texture_compression - glCompressedTexSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexSubImage2DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage2DARB (target, level, xoffset, yoffset, width, height, format, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glCompressedTexSubImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glCompressedTexSubImage1D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage1D (target, level, xoffset, width, format, imageSize, data);
  }
  // GL_ARB_texture_compression - glCompressedTexSubImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexSubImage1DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage1DARB (target, level, xoffset, width, format, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCompressedTexImage (GLenum target, GLint level, void * img)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glGetCompressedTexImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glGetCompressedTexImage)
  {
    prototypeCalled = true;
    glConfig.m_glGetCompressedTexImage (target, level, img);
  }
  // GL_ARB_texture_compression - glGetCompressedTexImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glGetCompressedTexImageARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetCompressedTexImageARB (target, level, img);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClientActiveTexture (GLenum texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glClientActiveTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glClientActiveTexture)
  {
    prototypeCalled = true;
    glConfig.m_glClientActiveTexture (texture);
  }
  // GL_ARB_multitexture - glClientActiveTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glClientActiveTextureARB)
  {
    prototypeCalled = true;
    glConfig.m_glClientActiveTextureARB (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1d (GLenum target, GLdouble s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord1d)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1d (target, s);
  }
  // GL_ARB_multitexture - glMultiTexCoord1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1dARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1dARB (target, s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1dv (GLenum target, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord1dv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1dv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1dvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1f (GLenum target, GLfloat s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord1f)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1f (target, s);
  }
  // GL_ARB_multitexture - glMultiTexCoord1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1fARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1fARB (target, s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1fv (GLenum target, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord1fv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1fv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1fvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1i (GLenum target, GLint s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord1i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord1i)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1i (target, s);
  }
  // GL_ARB_multitexture - glMultiTexCoord1i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1iARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1iARB (target, s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1iv (GLenum target, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord1iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord1iv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1iv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord1iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1ivARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1s (GLenum target, GLshort s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord1s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord1s)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1s (target, s);
  }
  // GL_ARB_multitexture - glMultiTexCoord1s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1sARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1sARB (target, s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1sv (GLenum target, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord1sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord1sv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1sv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord1sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1svARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1svARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2d (GLenum target, GLdouble s, GLdouble t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord2d)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2d (target, s, t);
  }
  // GL_ARB_multitexture - glMultiTexCoord2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2dARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2dARB (target, s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2dv (GLenum target, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord2dv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2dv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2dvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2f (GLenum target, GLfloat s, GLfloat t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord2f)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2f (target, s, t);
  }
  // GL_ARB_multitexture - glMultiTexCoord2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2fARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2fARB (target, s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2fv (GLenum target, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord2fv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2fv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2fvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2i (GLenum target, GLint s, GLint t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord2i)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2i (target, s, t);
  }
  // GL_ARB_multitexture - glMultiTexCoord2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2iARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2iARB (target, s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2iv (GLenum target, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord2iv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2iv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2ivARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2s (GLenum target, GLshort s, GLshort t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord2s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord2s)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2s (target, s, t);
  }
  // GL_ARB_multitexture - glMultiTexCoord2s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2sARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2sARB (target, s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2sv (GLenum target, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord2sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord2sv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2sv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord2sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2svARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2svARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3d (GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord3d)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3d (target, s, t, r);
  }
  // GL_ARB_multitexture - glMultiTexCoord3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3dARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3dARB (target, s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3dv (GLenum target, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord3dv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3dv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3dvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3f (GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord3f)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3f (target, s, t, r);
  }
  // GL_ARB_multitexture - glMultiTexCoord3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3fARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3fARB (target, s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3fv (GLenum target, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord3fv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3fv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3fvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3i (GLenum target, GLint s, GLint t, GLint r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord3i)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3i (target, s, t, r);
  }
  // GL_ARB_multitexture - glMultiTexCoord3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3iARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3iARB (target, s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3iv (GLenum target, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord3iv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3iv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3ivARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3s (GLenum target, GLshort s, GLshort t, GLshort r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord3s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord3s)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3s (target, s, t, r);
  }
  // GL_ARB_multitexture - glMultiTexCoord3s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3sARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3sARB (target, s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3sv (GLenum target, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord3sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord3sv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3sv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord3sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3svARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3svARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4d (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord4d)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4d (target, s, t, r, q);
  }
  // GL_ARB_multitexture - glMultiTexCoord4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4dARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4dARB (target, s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4dv (GLenum target, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord4dv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4dv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4dvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord4f)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4f (target, s, t, r, q);
  }
  // GL_ARB_multitexture - glMultiTexCoord4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4fARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4fARB (target, s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4fv (GLenum target, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord4fv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4fv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4fvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4i (GLenum target, GLint s, GLint t, GLint r, GLint q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord4i)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4i (target, s, t, r, q);
  }
  // GL_ARB_multitexture - glMultiTexCoord4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4iARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4iARB (target, s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4iv (GLenum target, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord4iv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4iv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4ivARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4s (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord4s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord4s)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4s (target, s, t, r, q);
  }
  // GL_ARB_multitexture - glMultiTexCoord4s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4sARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4sARB (target, s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4sv (GLenum target, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultiTexCoord4sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultiTexCoord4sv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4sv (target, v);
  }
  // GL_ARB_multitexture - glMultiTexCoord4sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4svARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4svARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLoadTransposeMatrixf (const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glLoadTransposeMatrixf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glLoadTransposeMatrixf)
  {
    prototypeCalled = true;
    glConfig.m_glLoadTransposeMatrixf (m);
  }
  // GL_ARB_transpose_matrix - glLoadTransposeMatrixf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transpose_matrix] && glConfig.m_glLoadTransposeMatrixfARB)
  {
    prototypeCalled = true;
    glConfig.m_glLoadTransposeMatrixfARB (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLoadTransposeMatrixd (const GLdouble * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glLoadTransposeMatrixd
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glLoadTransposeMatrixd)
  {
    prototypeCalled = true;
    glConfig.m_glLoadTransposeMatrixd (m);
  }
  // GL_ARB_transpose_matrix - glLoadTransposeMatrixd
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transpose_matrix] && glConfig.m_glLoadTransposeMatrixdARB)
  {
    prototypeCalled = true;
    glConfig.m_glLoadTransposeMatrixdARB (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultTransposeMatrixf (const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultTransposeMatrixf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultTransposeMatrixf)
  {
    prototypeCalled = true;
    glConfig.m_glMultTransposeMatrixf (m);
  }
  // GL_ARB_transpose_matrix - glMultTransposeMatrixf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transpose_matrix] && glConfig.m_glMultTransposeMatrixfARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultTransposeMatrixfARB (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultTransposeMatrixd (const GLdouble * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_3 - glMultTransposeMatrixd
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_3] && glConfig.m_glMultTransposeMatrixd)
  {
    prototypeCalled = true;
    glConfig.m_glMultTransposeMatrixd (m);
  }
  // GL_ARB_transpose_matrix - glMultTransposeMatrixd
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transpose_matrix] && glConfig.m_glMultTransposeMatrixdARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultTransposeMatrixdARB (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFuncSeparate (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glBlendFuncSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glBlendFuncSeparate)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparate (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
  }
  // GL_ES_VERSION_2_0 - glBlendFuncSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glBlendFuncSeparate)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparate (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
  }
  // GL_EXT_blend_func_separate - glBlendFuncSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_func_separate] && glConfig.m_glBlendFuncSeparateEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparateEXT (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawArrays (GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glMultiDrawArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glMultiDrawArrays)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawArrays (mode, first, count, drawcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElements (GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glMultiDrawElements
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glMultiDrawElements)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElements (mode, count, type, indices, drawcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameterf (GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glPointParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glPointParameterf)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterf (pname, param);
  }
  // GL_ARB_point_parameters - glPointParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_point_parameters] && glConfig.m_glPointParameterfARB)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfARB (pname, param);
  }
  // GL_EXT_point_parameters - glPointParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_point_parameters] && glConfig.m_glPointParameterfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfEXT (pname, param);
  }
  // GL_SGIS_point_parameters - glPointParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_point_parameters] && glConfig.m_glPointParameterfSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfSGIS (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameterfv (GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glPointParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glPointParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfv (pname, params);
  }
  // GL_ARB_point_parameters - glPointParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_point_parameters] && glConfig.m_glPointParameterfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfvARB (pname, params);
  }
  // GL_EXT_point_parameters - glPointParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_point_parameters] && glConfig.m_glPointParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfvEXT (pname, params);
  }
  // GL_SGIS_point_parameters - glPointParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_point_parameters] && glConfig.m_glPointParameterfvSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfvSGIS (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameteri (GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glPointParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glPointParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameteri (pname, param);
  }
  // GL_NV_point_sprite - glPointParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_point_sprite] && glConfig.m_glPointParameteriNV)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameteriNV (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameteriv (GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glPointParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glPointParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameteriv (pname, params);
  }
  // GL_NV_point_sprite - glPointParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_point_sprite] && glConfig.m_glPointParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterivNV (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoordf (GLfloat coord)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glFogCoordf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glFogCoordf)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordf (coord);
  }
  // GL_EXT_fog_coord - glFogCoordf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fog_coord] && glConfig.m_glFogCoordfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordfEXT (coord);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoordfv (const GLfloat * coord)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glFogCoordfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glFogCoordfv)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordfv (coord);
  }
  // GL_EXT_fog_coord - glFogCoordfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fog_coord] && glConfig.m_glFogCoordfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordfvEXT (coord);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoordd (GLdouble coord)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glFogCoordd
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glFogCoordd)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordd (coord);
  }
  // GL_EXT_fog_coord - glFogCoordd
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fog_coord] && glConfig.m_glFogCoorddEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoorddEXT (coord);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoorddv (const GLdouble * coord)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glFogCoorddv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glFogCoorddv)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoorddv (coord);
  }
  // GL_EXT_fog_coord - glFogCoorddv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fog_coord] && glConfig.m_glFogCoorddvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoorddvEXT (coord);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoordPointer (GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glFogCoordPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glFogCoordPointer)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordPointer (type, stride, pointer);
  }
  // GL_EXT_fog_coord - glFogCoordPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fog_coord] && glConfig.m_glFogCoordPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordPointerEXT (type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3b (GLbyte red, GLbyte green, GLbyte blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3b
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3b)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3b (red, green, blue);
  }
  // GL_EXT_secondary_color - glSecondaryColor3b
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3bEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3bEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3bv (const GLbyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3bv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3bv)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3bv (v);
  }
  // GL_EXT_secondary_color - glSecondaryColor3bv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3bvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3bvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3d (GLdouble red, GLdouble green, GLdouble blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3d)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3d (red, green, blue);
  }
  // GL_EXT_secondary_color - glSecondaryColor3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3dEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3dv (const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3dv)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3dv (v);
  }
  // GL_EXT_secondary_color - glSecondaryColor3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3dvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3f (GLfloat red, GLfloat green, GLfloat blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3f)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3f (red, green, blue);
  }
  // GL_EXT_secondary_color - glSecondaryColor3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3fEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3fv (const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3fv)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3fv (v);
  }
  // GL_EXT_secondary_color - glSecondaryColor3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3fvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3i (GLint red, GLint green, GLint blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3i)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3i (red, green, blue);
  }
  // GL_EXT_secondary_color - glSecondaryColor3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3iEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3iv (const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3iv)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3iv (v);
  }
  // GL_EXT_secondary_color - glSecondaryColor3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3ivEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3s (GLshort red, GLshort green, GLshort blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3s)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3s (red, green, blue);
  }
  // GL_EXT_secondary_color - glSecondaryColor3s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3sEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3sEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3sv (const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3sv)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3sv (v);
  }
  // GL_EXT_secondary_color - glSecondaryColor3sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3svEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3svEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3ub (GLubyte red, GLubyte green, GLubyte blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3ub
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3ub)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3ub (red, green, blue);
  }
  // GL_EXT_secondary_color - glSecondaryColor3ub
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3ubEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3ubEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3ubv (const GLubyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3ubv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3ubv)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3ubv (v);
  }
  // GL_EXT_secondary_color - glSecondaryColor3ubv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3ubvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3ubvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3ui (GLuint red, GLuint green, GLuint blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3ui)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3ui (red, green, blue);
  }
  // GL_EXT_secondary_color - glSecondaryColor3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3uiEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3uiv (const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3uiv (v);
  }
  // GL_EXT_secondary_color - glSecondaryColor3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3uivEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3us (GLushort red, GLushort green, GLushort blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3us
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3us)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3us (red, green, blue);
  }
  // GL_EXT_secondary_color - glSecondaryColor3us
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3usEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3usEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3usv (const GLushort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColor3usv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColor3usv)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3usv (v);
  }
  // GL_EXT_secondary_color - glSecondaryColor3usv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3usvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3usvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColorPointer (GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glSecondaryColorPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glSecondaryColorPointer)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColorPointer (size, type, stride, pointer);
  }
  // GL_EXT_secondary_color - glSecondaryColorPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColorPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColorPointerEXT (size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2d (GLdouble x, GLdouble y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos2d)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2d (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2dv (const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos2dv)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2dv (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2f (GLfloat x, GLfloat y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos2f)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2f (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2fv (const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos2fv)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2fv (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2i (GLint x, GLint y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos2i)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2i (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2iv (const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos2iv)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2iv (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2s (GLshort x, GLshort y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos2s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos2s)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2s (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2sv (const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos2sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos2sv)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2sv (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3d (GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos3d)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3d (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3dv (const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos3dv)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3dv (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3f (GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos3f)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3f (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3fv (const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos3fv)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3fv (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3i (GLint x, GLint y, GLint z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos3i)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3i (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3iv (const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos3iv)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3iv (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3s (GLshort x, GLshort y, GLshort z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos3s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos3s)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3s (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3sv (const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glWindowPos3sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glWindowPos3sv)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3sv (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendColor (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glBlendColor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glBlendColor)
  {
    prototypeCalled = true;
    glConfig.m_glBlendColor (red, green, blue, alpha);
  }
  // GL_ES_VERSION_2_0 - glBlendColor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glBlendColor)
  {
    prototypeCalled = true;
    glConfig.m_glBlendColor (red, green, blue, alpha);
  }
  // GL_ARB_imaging - glBlendColor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glBlendColor)
  {
    prototypeCalled = true;
    glConfig.m_glBlendColor (red, green, blue, alpha);
  }
  // GL_EXT_blend_color - glBlendColor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_color] && glConfig.m_glBlendColorEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendColorEXT (red, green, blue, alpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquation (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_4 - glBlendEquation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_4] && glConfig.m_glBlendEquation)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquation (mode);
  }
  // GL_ES_VERSION_2_0 - glBlendEquation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glBlendEquation)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquation (mode);
  }
  // GL_ARB_imaging - glBlendEquation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glBlendEquation)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquation (mode);
  }
  // GL_EXT_blend_minmax - glBlendEquation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_minmax] && glConfig.m_glBlendEquationEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationEXT (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenQueries (GLsizei n, GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glGenQueries
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glGenQueries)
  {
    prototypeCalled = true;
    glConfig.m_glGenQueries (n, ids);
  }
  // GL_ES_VERSION_3_0 - glGenQueries
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGenQueries)
  {
    prototypeCalled = true;
    glConfig.m_glGenQueries (n, ids);
  }
  // GL_ARB_occlusion_query - glGenQueries
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glGenQueriesARB)
  {
    prototypeCalled = true;
    glConfig.m_glGenQueriesARB (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteQueries (GLsizei n, const GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glDeleteQueries
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glDeleteQueries)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteQueries (n, ids);
  }
  // GL_ES_VERSION_3_0 - glDeleteQueries
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glDeleteQueries)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteQueries (n, ids);
  }
  // GL_ARB_occlusion_query - glDeleteQueries
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glDeleteQueriesARB)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteQueriesARB (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsQuery (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glIsQuery
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glIsQuery)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsQuery (id);
  }
  // GL_ES_VERSION_3_0 - glIsQuery
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glIsQuery)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsQuery (id);
  }
  // GL_ARB_occlusion_query - glIsQuery
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glIsQueryARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsQueryARB (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginQuery (GLenum target, GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glBeginQuery
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glBeginQuery)
  {
    prototypeCalled = true;
    glConfig.m_glBeginQuery (target, id);
  }
  // GL_ES_VERSION_3_0 - glBeginQuery
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glBeginQuery)
  {
    prototypeCalled = true;
    glConfig.m_glBeginQuery (target, id);
  }
  // GL_ARB_occlusion_query - glBeginQuery
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glBeginQueryARB)
  {
    prototypeCalled = true;
    glConfig.m_glBeginQueryARB (target, id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndQuery (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glEndQuery
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glEndQuery)
  {
    prototypeCalled = true;
    glConfig.m_glEndQuery (target);
  }
  // GL_ES_VERSION_3_0 - glEndQuery
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glEndQuery)
  {
    prototypeCalled = true;
    glConfig.m_glEndQuery (target);
  }
  // GL_ARB_occlusion_query - glEndQuery
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glEndQueryARB)
  {
    prototypeCalled = true;
    glConfig.m_glEndQueryARB (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryiv (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glGetQueryiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glGetQueryiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryiv (target, pname, params);
  }
  // GL_ES_VERSION_3_0 - glGetQueryiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetQueryiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryiv (target, pname, params);
  }
  // GL_ARB_occlusion_query - glGetQueryiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glGetQueryivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryivARB (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryObjectiv (GLuint id, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glGetQueryObjectiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glGetQueryObjectiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectiv (id, pname, params);
  }
  // GL_ARB_occlusion_query - glGetQueryObjectiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glGetQueryObjectivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectivARB (id, pname, params);
  }
  // GL_EXT_disjoint_timer_query - glGetQueryObjectiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glGetQueryObjectivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectivEXT (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryObjectuiv (GLuint id, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glGetQueryObjectuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glGetQueryObjectuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectuiv (id, pname, params);
  }
  // GL_ES_VERSION_3_0 - glGetQueryObjectuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetQueryObjectuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectuiv (id, pname, params);
  }
  // GL_ARB_occlusion_query - glGetQueryObjectuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glGetQueryObjectuivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectuivARB (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBuffer (GLenum target, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glBindBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glBindBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBindBuffer (target, buffer);
  }
  // GL_ES_VERSION_2_0 - glBindBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glBindBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBindBuffer (target, buffer);
  }
  // GL_ARB_vertex_buffer_object - glBindBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glBindBufferARB)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferARB (target, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteBuffers (GLsizei n, const GLuint * buffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glDeleteBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glDeleteBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteBuffers (n, buffers);
  }
  // GL_ES_VERSION_2_0 - glDeleteBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glDeleteBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteBuffers (n, buffers);
  }
  // GL_ARB_vertex_buffer_object - glDeleteBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glDeleteBuffersARB)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteBuffersARB (n, buffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenBuffers (GLsizei n, GLuint * buffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glGenBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glGenBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glGenBuffers (n, buffers);
  }
  // GL_ES_VERSION_2_0 - glGenBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGenBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glGenBuffers (n, buffers);
  }
  // GL_ARB_vertex_buffer_object - glGenBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glGenBuffersARB)
  {
    prototypeCalled = true;
    glConfig.m_glGenBuffersARB (n, buffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsBuffer (GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glIsBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glIsBuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsBuffer (buffer);
  }
  // GL_ES_VERSION_2_0 - glIsBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glIsBuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsBuffer (buffer);
  }
  // GL_ARB_vertex_buffer_object - glIsBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glIsBufferARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsBufferARB (buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferData (GLenum target, GLsizeiptr size, const void * data, GLenum usage)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glBufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glBufferData)
  {
    prototypeCalled = true;
    glConfig.m_glBufferData (target, size, data, usage);
  }
  // GL_ES_VERSION_2_0 - glBufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glBufferData)
  {
    prototypeCalled = true;
    glConfig.m_glBufferData (target, size, data, usage);
  }
  // GL_ARB_vertex_buffer_object - glBufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glBufferDataARB)
  {
    prototypeCalled = true;
    glConfig.m_glBufferDataARB (target, (GLsizeiptrARB) size, data, usage);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glBufferSubData (target, offset, size, data);
  }
  // GL_ES_VERSION_2_0 - glBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glBufferSubData (target, offset, size, data);
  }
  // GL_ARB_vertex_buffer_object - glBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glBufferSubDataARB)
  {
    prototypeCalled = true;
    glConfig.m_glBufferSubDataARB (target, (GLintptrARB) offset, (GLsizeiptrARB) size, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glGetBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glGetBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferSubData (target, offset, size, data);
  }
  // GL_ARB_vertex_buffer_object - glGetBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glGetBufferSubDataARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferSubDataARB (target, (GLintptrARB) offset, (GLsizeiptrARB) size, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void * _glew_gl_glMapBuffer (GLenum target, GLenum access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  void * result = ((void *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glMapBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glMapBuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapBuffer (target, access);
  }
  // GL_ARB_vertex_buffer_object - glMapBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glMapBufferARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapBufferARB (target, access);
  }
  // GL_OES_mapbuffer - glMapBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_mapbuffer] && glConfig.m_glMapBufferOES)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapBufferOES (target, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glUnmapBuffer (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glUnmapBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glUnmapBuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glUnmapBuffer (target);
  }
  // GL_ES_VERSION_3_0 - glUnmapBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUnmapBuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glUnmapBuffer (target);
  }
  // GL_ARB_vertex_buffer_object - glUnmapBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glUnmapBufferARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glUnmapBufferARB (target);
  }
  // GL_OES_mapbuffer - glUnmapBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_mapbuffer] && glConfig.m_glUnmapBufferOES)
  {
    prototypeCalled = true;
    result = glConfig.m_glUnmapBufferOES (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetBufferParameteriv (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glGetBufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glGetBufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferParameteriv (target, pname, params);
  }
  // GL_ES_VERSION_2_0 - glGetBufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetBufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferParameteriv (target, pname, params);
  }
  // GL_ARB_vertex_buffer_object - glGetBufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glGetBufferParameterivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferParameterivARB (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetBufferPointerv (GLenum target, GLenum pname, void ** params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_1_5 - glGetBufferPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_1_5] && glConfig.m_glGetBufferPointerv)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferPointerv (target, pname, params);
  }
  // GL_ES_VERSION_3_0 - glGetBufferPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetBufferPointerv)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferPointerv (target, pname, params);
  }
  // GL_ARB_vertex_buffer_object - glGetBufferPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glGetBufferPointervARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferPointervARB (target, pname, params);
  }
  // GL_OES_mapbuffer - glGetBufferPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_mapbuffer] && glConfig.m_glGetBufferPointervOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferPointervOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glBlendEquationSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glBlendEquationSeparate)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparate (modeRGB, modeAlpha);
  }
  // GL_ES_VERSION_2_0 - glBlendEquationSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glBlendEquationSeparate)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparate (modeRGB, modeAlpha);
  }
  // GL_EXT_blend_equation_separate - glBlendEquationSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_equation_separate] && glConfig.m_glBlendEquationSeparateEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparateEXT (modeRGB, modeAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawBuffers (GLsizei n, const GLenum * bufs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glDrawBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glDrawBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glDrawBuffers (n, bufs);
  }
  // GL_ES_VERSION_3_0 - glDrawBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glDrawBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glDrawBuffers (n, bufs);
  }
  // GL_ARB_draw_buffers - glDrawBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_buffers] && glConfig.m_glDrawBuffersARB)
  {
    prototypeCalled = true;
    glConfig.m_glDrawBuffersARB (n, bufs);
  }
  // GL_ATI_draw_buffers - glDrawBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_draw_buffers] && glConfig.m_glDrawBuffersATI)
  {
    prototypeCalled = true;
    glConfig.m_glDrawBuffersATI (n, bufs);
  }
  // GL_EXT_draw_buffers - glDrawBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers] && glConfig.m_glDrawBuffersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawBuffersEXT (n, bufs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilOpSeparate (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glStencilOpSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glStencilOpSeparate)
  {
    prototypeCalled = true;
    glConfig.m_glStencilOpSeparate (face, sfail, dpfail, dppass);
  }
  // GL_ES_VERSION_2_0 - glStencilOpSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glStencilOpSeparate)
  {
    prototypeCalled = true;
    glConfig.m_glStencilOpSeparate (face, sfail, dpfail, dppass);
  }
  // GL_ATI_separate_stencil - glStencilOpSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_separate_stencil] && glConfig.m_glStencilOpSeparateATI)
  {
    prototypeCalled = true;
    glConfig.m_glStencilOpSeparateATI (face, sfail, dpfail, dppass);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilFuncSeparate (GLenum face, GLenum func, GLint ref, GLuint mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glStencilFuncSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glStencilFuncSeparate)
  {
    prototypeCalled = true;
    glConfig.m_glStencilFuncSeparate (face, func, ref, mask);
  }
  // GL_ES_VERSION_2_0 - glStencilFuncSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glStencilFuncSeparate)
  {
    prototypeCalled = true;
    glConfig.m_glStencilFuncSeparate (face, func, ref, mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilMaskSeparate (GLenum face, GLuint mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glStencilMaskSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glStencilMaskSeparate)
  {
    prototypeCalled = true;
    glConfig.m_glStencilMaskSeparate (face, mask);
  }
  // GL_ES_VERSION_2_0 - glStencilMaskSeparate
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glStencilMaskSeparate)
  {
    prototypeCalled = true;
    glConfig.m_glStencilMaskSeparate (face, mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glAttachShader (GLuint program, GLuint shader)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glAttachShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glAttachShader)
  {
    prototypeCalled = true;
    glConfig.m_glAttachShader (program, shader);
  }
  // GL_ES_VERSION_2_0 - glAttachShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glAttachShader)
  {
    prototypeCalled = true;
    glConfig.m_glAttachShader (program, shader);
  }
  // GL_ARB_shader_objects - glAttachShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glAttachObjectARB)
  {
    prototypeCalled = true;
    glConfig.m_glAttachObjectARB ((GLhandleARB) program, (GLhandleARB) shader);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindAttribLocation (GLuint program, GLuint index, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glBindAttribLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glBindAttribLocation)
  {
    prototypeCalled = true;
    glConfig.m_glBindAttribLocation (program, index, name);
  }
  // GL_ES_VERSION_2_0 - glBindAttribLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glBindAttribLocation)
  {
    prototypeCalled = true;
    glConfig.m_glBindAttribLocation (program, index, name);
  }
  // GL_ARB_vertex_shader - glBindAttribLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glBindAttribLocationARB)
  {
    prototypeCalled = true;
    glConfig.m_glBindAttribLocationARB ((GLhandleARB) program, index, (const GLcharARB *) name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompileShader (GLuint shader)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glCompileShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glCompileShader)
  {
    prototypeCalled = true;
    glConfig.m_glCompileShader (shader);
  }
  // GL_ES_VERSION_2_0 - glCompileShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glCompileShader)
  {
    prototypeCalled = true;
    glConfig.m_glCompileShader (shader);
  }
  // GL_ARB_shader_objects - glCompileShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glCompileShaderARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompileShaderARB ((GLhandleARB) shader);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glCreateProgram ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glCreateProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glCreateProgram)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateProgram ();
  }
  // GL_ES_VERSION_2_0 - glCreateProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glCreateProgram)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateProgram ();
  }
  // GL_ARB_shader_objects - glCreateProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glCreateProgramObjectARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateProgramObjectARB ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glCreateShader (GLenum type)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glCreateShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glCreateShader)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateShader (type);
  }
  // GL_ES_VERSION_2_0 - glCreateShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glCreateShader)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateShader (type);
  }
  // GL_ARB_shader_objects - glCreateShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glCreateShaderObjectARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateShaderObjectARB (type);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteProgram (GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glDeleteProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glDeleteProgram)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteProgram (program);
  }
  // GL_ES_VERSION_2_0 - glDeleteProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glDeleteProgram)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteProgram (program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteShader (GLuint shader)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glDeleteShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glDeleteShader)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteShader (shader);
  }
  // GL_ES_VERSION_2_0 - glDeleteShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glDeleteShader)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteShader (shader);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDetachShader (GLuint program, GLuint shader)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glDetachShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glDetachShader)
  {
    prototypeCalled = true;
    glConfig.m_glDetachShader (program, shader);
  }
  // GL_ES_VERSION_2_0 - glDetachShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glDetachShader)
  {
    prototypeCalled = true;
    glConfig.m_glDetachShader (program, shader);
  }
  // GL_ARB_shader_objects - glDetachShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glDetachObjectARB)
  {
    prototypeCalled = true;
    glConfig.m_glDetachObjectARB ((GLhandleARB) program, (GLhandleARB) shader);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableVertexAttribArray (GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glDisableVertexAttribArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glDisableVertexAttribArray)
  {
    prototypeCalled = true;
    glConfig.m_glDisableVertexAttribArray (index);
  }
  // GL_ES_VERSION_2_0 - glDisableVertexAttribArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glDisableVertexAttribArray)
  {
    prototypeCalled = true;
    glConfig.m_glDisableVertexAttribArray (index);
  }
  // GL_ARB_vertex_program - glDisableVertexAttribArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glDisableVertexAttribArrayARB)
  {
    prototypeCalled = true;
    glConfig.m_glDisableVertexAttribArrayARB (index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableVertexAttribArray (GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glEnableVertexAttribArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glEnableVertexAttribArray)
  {
    prototypeCalled = true;
    glConfig.m_glEnableVertexAttribArray (index);
  }
  // GL_ES_VERSION_2_0 - glEnableVertexAttribArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glEnableVertexAttribArray)
  {
    prototypeCalled = true;
    glConfig.m_glEnableVertexAttribArray (index);
  }
  // GL_ARB_vertex_program - glEnableVertexAttribArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glEnableVertexAttribArrayARB)
  {
    prototypeCalled = true;
    glConfig.m_glEnableVertexAttribArrayARB (index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetActiveAttrib
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetActiveAttrib)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveAttrib (program, index, bufSize, length, size, type, name);
  }
  // GL_ES_VERSION_2_0 - glGetActiveAttrib
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetActiveAttrib)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveAttrib (program, index, bufSize, length, size, type, name);
  }
  // GL_ARB_vertex_shader - glGetActiveAttrib
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glGetActiveAttribARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveAttribARB ((GLhandleARB) program, index, bufSize, length, size, type, (GLcharARB *) name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveUniform (GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetActiveUniform
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetActiveUniform)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniform (program, index, bufSize, length, size, type, name);
  }
  // GL_ES_VERSION_2_0 - glGetActiveUniform
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetActiveUniform)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniform (program, index, bufSize, length, size, type, name);
  }
  // GL_ARB_shader_objects - glGetActiveUniform
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetActiveUniformARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformARB ((GLhandleARB) program, index, bufSize, length, size, type, (GLcharARB *) name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetAttachedShaders (GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetAttachedShaders
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetAttachedShaders)
  {
    prototypeCalled = true;
    glConfig.m_glGetAttachedShaders (program, maxCount, count, shaders);
  }
  // GL_ES_VERSION_2_0 - glGetAttachedShaders
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetAttachedShaders)
  {
    prototypeCalled = true;
    glConfig.m_glGetAttachedShaders (program, maxCount, count, shaders);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetAttribLocation (GLuint program, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetAttribLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetAttribLocation)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetAttribLocation (program, name);
  }
  // GL_ES_VERSION_2_0 - glGetAttribLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetAttribLocation)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetAttribLocation (program, name);
  }
  // GL_ARB_vertex_shader - glGetAttribLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glGetAttribLocationARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetAttribLocationARB ((GLhandleARB) program, (const GLcharARB *) name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramiv (GLuint program, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetProgramiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetProgramiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramiv (program, pname, params);
  }
  // GL_ES_VERSION_2_0 - glGetProgramiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetProgramiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramiv (program, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramInfoLog (GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetProgramInfoLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetProgramInfoLog)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramInfoLog (program, bufSize, length, infoLog);
  }
  // GL_ES_VERSION_2_0 - glGetProgramInfoLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetProgramInfoLog)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramInfoLog (program, bufSize, length, infoLog);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetShaderiv (GLuint shader, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetShaderiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetShaderiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetShaderiv (shader, pname, params);
  }
  // GL_ES_VERSION_2_0 - glGetShaderiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetShaderiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetShaderiv (shader, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetShaderInfoLog (GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetShaderInfoLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetShaderInfoLog)
  {
    prototypeCalled = true;
    glConfig.m_glGetShaderInfoLog (shader, bufSize, length, infoLog);
  }
  // GL_ES_VERSION_2_0 - glGetShaderInfoLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetShaderInfoLog)
  {
    prototypeCalled = true;
    glConfig.m_glGetShaderInfoLog (shader, bufSize, length, infoLog);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetShaderSource (GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetShaderSource
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetShaderSource)
  {
    prototypeCalled = true;
    glConfig.m_glGetShaderSource (shader, bufSize, length, source);
  }
  // GL_ES_VERSION_2_0 - glGetShaderSource
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetShaderSource)
  {
    prototypeCalled = true;
    glConfig.m_glGetShaderSource (shader, bufSize, length, source);
  }
  // GL_ARB_shader_objects - glGetShaderSource
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetShaderSourceARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetShaderSourceARB ((GLhandleARB) shader, bufSize, length, (GLcharARB *) source);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetUniformLocation (GLuint program, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetUniformLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetUniformLocation)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetUniformLocation (program, name);
  }
  // GL_ES_VERSION_2_0 - glGetUniformLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetUniformLocation)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetUniformLocation (program, name);
  }
  // GL_ARB_shader_objects - glGetUniformLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetUniformLocationARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetUniformLocationARB ((GLhandleARB) program, (const GLcharARB *) name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformfv (GLuint program, GLint location, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetUniformfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetUniformfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformfv (program, location, params);
  }
  // GL_ES_VERSION_2_0 - glGetUniformfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetUniformfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformfv (program, location, params);
  }
  // GL_ARB_shader_objects - glGetUniformfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetUniformfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformfvARB ((GLhandleARB) program, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformiv (GLuint program, GLint location, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetUniformiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetUniformiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformiv (program, location, params);
  }
  // GL_ES_VERSION_2_0 - glGetUniformiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetUniformiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformiv (program, location, params);
  }
  // GL_ARB_shader_objects - glGetUniformiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetUniformivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformivARB ((GLhandleARB) program, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribdv (GLuint index, GLenum pname, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetVertexAttribdv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetVertexAttribdv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribdv (index, pname, params);
  }
  // GL_ARB_vertex_program - glGetVertexAttribdv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetVertexAttribdvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribdvARB (index, pname, params);
  }
  // GL_NV_vertex_program - glGetVertexAttribdv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetVertexAttribdvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribdvNV (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetVertexAttribfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetVertexAttribfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribfv (index, pname, params);
  }
  // GL_ES_VERSION_2_0 - glGetVertexAttribfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetVertexAttribfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribfv (index, pname, params);
  }
  // GL_ARB_vertex_program - glGetVertexAttribfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetVertexAttribfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribfvARB (index, pname, params);
  }
  // GL_NV_vertex_program - glGetVertexAttribfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetVertexAttribfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribfvNV (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribiv (GLuint index, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetVertexAttribiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetVertexAttribiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribiv (index, pname, params);
  }
  // GL_ES_VERSION_2_0 - glGetVertexAttribiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetVertexAttribiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribiv (index, pname, params);
  }
  // GL_ARB_vertex_program - glGetVertexAttribiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetVertexAttribivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribivARB (index, pname, params);
  }
  // GL_NV_vertex_program - glGetVertexAttribiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetVertexAttribivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribivNV (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribPointerv (GLuint index, GLenum pname, void ** pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glGetVertexAttribPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glGetVertexAttribPointerv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribPointerv (index, pname, pointer);
  }
  // GL_ES_VERSION_2_0 - glGetVertexAttribPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetVertexAttribPointerv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribPointerv (index, pname, pointer);
  }
  // GL_ARB_vertex_program - glGetVertexAttribPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetVertexAttribPointervARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribPointervARB (index, pname, pointer);
  }
  // GL_NV_vertex_program - glGetVertexAttribPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetVertexAttribPointervNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribPointervNV (index, pname, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsProgram (GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glIsProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glIsProgram)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsProgram (program);
  }
  // GL_ES_VERSION_2_0 - glIsProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glIsProgram)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsProgram (program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsShader (GLuint shader)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glIsShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glIsShader)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsShader (shader);
  }
  // GL_ES_VERSION_2_0 - glIsShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glIsShader)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsShader (shader);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLinkProgram (GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glLinkProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glLinkProgram)
  {
    prototypeCalled = true;
    glConfig.m_glLinkProgram (program);
  }
  // GL_ES_VERSION_2_0 - glLinkProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glLinkProgram)
  {
    prototypeCalled = true;
    glConfig.m_glLinkProgram (program);
  }
  // GL_ARB_shader_objects - glLinkProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glLinkProgramARB)
  {
    prototypeCalled = true;
    glConfig.m_glLinkProgramARB ((GLhandleARB) program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShaderSource (GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glShaderSource
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glShaderSource)
  {
    prototypeCalled = true;
    glConfig.m_glShaderSource (shader, count, string, length);
  }
  // GL_ES_VERSION_2_0 - glShaderSource
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glShaderSource)
  {
    prototypeCalled = true;
    glConfig.m_glShaderSource (shader, count, string, length);
  }
  // GL_ARB_shader_objects - glShaderSource
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glShaderSourceARB)
  {
    prototypeCalled = true;
    glConfig.m_glShaderSourceARB ((GLhandleARB) shader, count, (const GLcharARB **) string, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUseProgram (GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUseProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUseProgram)
  {
    prototypeCalled = true;
    glConfig.m_glUseProgram (program);
  }
  // GL_ES_VERSION_2_0 - glUseProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUseProgram)
  {
    prototypeCalled = true;
    glConfig.m_glUseProgram (program);
  }
  // GL_ARB_shader_objects - glUseProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUseProgramObjectARB)
  {
    prototypeCalled = true;
    glConfig.m_glUseProgramObjectARB ((GLhandleARB) program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1f (GLint location, GLfloat v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform1f)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1f (location, v0);
  }
  // GL_ES_VERSION_2_0 - glUniform1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform1f)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1f (location, v0);
  }
  // GL_ARB_shader_objects - glUniform1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform1fARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1fARB (location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2f (GLint location, GLfloat v0, GLfloat v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform2f)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2f (location, v0, v1);
  }
  // GL_ES_VERSION_2_0 - glUniform2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform2f)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2f (location, v0, v1);
  }
  // GL_ARB_shader_objects - glUniform2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform2fARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2fARB (location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform3f)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3f (location, v0, v1, v2);
  }
  // GL_ES_VERSION_2_0 - glUniform3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform3f)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3f (location, v0, v1, v2);
  }
  // GL_ARB_shader_objects - glUniform3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform3fARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3fARB (location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform4f)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4f (location, v0, v1, v2, v3);
  }
  // GL_ES_VERSION_2_0 - glUniform4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform4f)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4f (location, v0, v1, v2, v3);
  }
  // GL_ARB_shader_objects - glUniform4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform4fARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4fARB (location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1i (GLint location, GLint v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform1i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform1i)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1i (location, v0);
  }
  // GL_ES_VERSION_2_0 - glUniform1i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform1i)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1i (location, v0);
  }
  // GL_ARB_shader_objects - glUniform1i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform1iARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1iARB (location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2i (GLint location, GLint v0, GLint v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform2i)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2i (location, v0, v1);
  }
  // GL_ES_VERSION_2_0 - glUniform2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform2i)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2i (location, v0, v1);
  }
  // GL_ARB_shader_objects - glUniform2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform2iARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2iARB (location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3i (GLint location, GLint v0, GLint v1, GLint v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform3i)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3i (location, v0, v1, v2);
  }
  // GL_ES_VERSION_2_0 - glUniform3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform3i)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3i (location, v0, v1, v2);
  }
  // GL_ARB_shader_objects - glUniform3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform3iARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3iARB (location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4i (GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform4i)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4i (location, v0, v1, v2, v3);
  }
  // GL_ES_VERSION_2_0 - glUniform4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform4i)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4i (location, v0, v1, v2, v3);
  }
  // GL_ARB_shader_objects - glUniform4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform4iARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4iARB (location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1fv (GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform1fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1fv (location, count, value);
  }
  // GL_ES_VERSION_2_0 - glUniform1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform1fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1fv (location, count, value);
  }
  // GL_ARB_shader_objects - glUniform1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform1fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1fvARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2fv (GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform2fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2fv (location, count, value);
  }
  // GL_ES_VERSION_2_0 - glUniform2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform2fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2fv (location, count, value);
  }
  // GL_ARB_shader_objects - glUniform2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform2fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2fvARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3fv (GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform3fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3fv (location, count, value);
  }
  // GL_ES_VERSION_2_0 - glUniform3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform3fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3fv (location, count, value);
  }
  // GL_ARB_shader_objects - glUniform3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform3fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3fvARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4fv (GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform4fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4fv (location, count, value);
  }
  // GL_ES_VERSION_2_0 - glUniform4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform4fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4fv (location, count, value);
  }
  // GL_ARB_shader_objects - glUniform4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4fvARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1iv (GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform1iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform1iv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1iv (location, count, value);
  }
  // GL_ES_VERSION_2_0 - glUniform1iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform1iv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1iv (location, count, value);
  }
  // GL_ARB_shader_objects - glUniform1iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform1ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1ivARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2iv (GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform2iv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2iv (location, count, value);
  }
  // GL_ES_VERSION_2_0 - glUniform2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform2iv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2iv (location, count, value);
  }
  // GL_ARB_shader_objects - glUniform2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform2ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2ivARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3iv (GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform3iv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3iv (location, count, value);
  }
  // GL_ES_VERSION_2_0 - glUniform3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform3iv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3iv (location, count, value);
  }
  // GL_ARB_shader_objects - glUniform3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform3ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3ivARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4iv (GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniform4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniform4iv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4iv (location, count, value);
  }
  // GL_ES_VERSION_2_0 - glUniform4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniform4iv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4iv (location, count, value);
  }
  // GL_ARB_shader_objects - glUniform4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform4ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4ivARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniformMatrix2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniformMatrix2fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2fv (location, count, transpose, value);
  }
  // GL_ES_VERSION_2_0 - glUniformMatrix2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniformMatrix2fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2fv (location, count, transpose, value);
  }
  // GL_ARB_shader_objects - glUniformMatrix2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniformMatrix2fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2fvARB (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniformMatrix3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniformMatrix3fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3fv (location, count, transpose, value);
  }
  // GL_ES_VERSION_2_0 - glUniformMatrix3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniformMatrix3fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3fv (location, count, transpose, value);
  }
  // GL_ARB_shader_objects - glUniformMatrix3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniformMatrix3fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3fvARB (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glUniformMatrix4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glUniformMatrix4fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4fv (location, count, transpose, value);
  }
  // GL_ES_VERSION_2_0 - glUniformMatrix4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glUniformMatrix4fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4fv (location, count, transpose, value);
  }
  // GL_ARB_shader_objects - glUniformMatrix4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniformMatrix4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4fvARB (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glValidateProgram (GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glValidateProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glValidateProgram)
  {
    prototypeCalled = true;
    glConfig.m_glValidateProgram (program);
  }
  // GL_ES_VERSION_2_0 - glValidateProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glValidateProgram)
  {
    prototypeCalled = true;
    glConfig.m_glValidateProgram (program);
  }
  // GL_ARB_shader_objects - glValidateProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glValidateProgramARB)
  {
    prototypeCalled = true;
    glConfig.m_glValidateProgramARB ((GLhandleARB) program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1d (GLuint index, GLdouble x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib1d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1d (index, x);
  }
  // GL_ARB_vertex_program - glVertexAttrib1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1dARB (index, x);
  }
  // GL_NV_vertex_program - glVertexAttrib1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1dNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1dNV (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1dv (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib1dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1dv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1dvARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1dvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1f (GLuint index, GLfloat x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib1f)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1f (index, x);
  }
  // GL_ES_VERSION_2_0 - glVertexAttrib1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glVertexAttrib1f)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1f (index, x);
  }
  // GL_ARB_vertex_program - glVertexAttrib1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fARB (index, x);
  }
  // GL_NV_vertex_program - glVertexAttrib1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1fNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fNV (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1fv (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib1fv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fv (index, v);
  }
  // GL_ES_VERSION_2_0 - glVertexAttrib1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glVertexAttrib1fv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fvARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1s (GLuint index, GLshort x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib1s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib1s)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1s (index, x);
  }
  // GL_ARB_vertex_program - glVertexAttrib1s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1sARB (index, x);
  }
  // GL_NV_vertex_program - glVertexAttrib1s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1sNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1sNV (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1sv (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib1sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib1sv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1sv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib1sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1svARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib1sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1svNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2d (GLuint index, GLdouble x, GLdouble y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib2d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2d (index, x, y);
  }
  // GL_ARB_vertex_program - glVertexAttrib2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2dARB (index, x, y);
  }
  // GL_NV_vertex_program - glVertexAttrib2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2dNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2dNV (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2dv (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib2dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2dv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2dvARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2dvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2f (GLuint index, GLfloat x, GLfloat y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib2f)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2f (index, x, y);
  }
  // GL_ES_VERSION_2_0 - glVertexAttrib2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glVertexAttrib2f)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2f (index, x, y);
  }
  // GL_ARB_vertex_program - glVertexAttrib2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fARB (index, x, y);
  }
  // GL_NV_vertex_program - glVertexAttrib2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2fNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fNV (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2fv (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib2fv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fv (index, v);
  }
  // GL_ES_VERSION_2_0 - glVertexAttrib2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glVertexAttrib2fv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fvARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2s (GLuint index, GLshort x, GLshort y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib2s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib2s)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2s (index, x, y);
  }
  // GL_ARB_vertex_program - glVertexAttrib2s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2sARB (index, x, y);
  }
  // GL_NV_vertex_program - glVertexAttrib2s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2sNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2sNV (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2sv (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib2sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib2sv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2sv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib2sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2svARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib2sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2svNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3d (GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib3d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3d (index, x, y, z);
  }
  // GL_ARB_vertex_program - glVertexAttrib3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3dARB (index, x, y, z);
  }
  // GL_NV_vertex_program - glVertexAttrib3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3dNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3dNV (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3dv (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib3dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3dv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3dvARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3dvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3f (GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib3f)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3f (index, x, y, z);
  }
  // GL_ES_VERSION_2_0 - glVertexAttrib3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glVertexAttrib3f)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3f (index, x, y, z);
  }
  // GL_ARB_vertex_program - glVertexAttrib3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fARB (index, x, y, z);
  }
  // GL_NV_vertex_program - glVertexAttrib3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3fNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fNV (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3fv (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib3fv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fv (index, v);
  }
  // GL_ES_VERSION_2_0 - glVertexAttrib3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glVertexAttrib3fv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fvARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3s (GLuint index, GLshort x, GLshort y, GLshort z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib3s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib3s)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3s (index, x, y, z);
  }
  // GL_ARB_vertex_program - glVertexAttrib3s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3sARB (index, x, y, z);
  }
  // GL_NV_vertex_program - glVertexAttrib3s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3sNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3sNV (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3sv (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib3sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib3sv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3sv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib3sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3svARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib3sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3svNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4Nbv (GLuint index, const GLbyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4Nbv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4Nbv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4Nbv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4Nbv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NbvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NbvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4Niv (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4Niv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4Niv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4Niv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4Niv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NivARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4Nsv (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4Nsv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4Nsv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4Nsv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4Nsv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NsvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NsvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4Nub (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4Nub
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4Nub)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4Nub (index, x, y, z, w);
  }
  // GL_ARB_vertex_program - glVertexAttrib4Nub
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NubARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NubARB (index, x, y, z, w);
  }
  // GL_NV_vertex_program - glVertexAttrib4Nub
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4ubNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4ubNV (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4Nubv (GLuint index, const GLubyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4Nubv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4Nubv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4Nubv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4Nubv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NubvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NubvARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib4Nubv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4ubvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4ubvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4Nuiv (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4Nuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4Nuiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4Nuiv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4Nuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NuivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NuivARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4Nusv (GLuint index, const GLushort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4Nusv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4Nusv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4Nusv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4Nusv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NusvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NusvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4bv (GLuint index, const GLbyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4bv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4bv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4bv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4bv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4bvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4bvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4d (index, x, y, z, w);
  }
  // GL_ARB_vertex_program - glVertexAttrib4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4dARB (index, x, y, z, w);
  }
  // GL_NV_vertex_program - glVertexAttrib4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4dNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4dNV (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4dv (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4dv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4dvARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4dvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4f (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4f)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4f (index, x, y, z, w);
  }
  // GL_ES_VERSION_2_0 - glVertexAttrib4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glVertexAttrib4f)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4f (index, x, y, z, w);
  }
  // GL_ARB_vertex_program - glVertexAttrib4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fARB (index, x, y, z, w);
  }
  // GL_NV_vertex_program - glVertexAttrib4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4fNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fNV (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4fv (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4fv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fv (index, v);
  }
  // GL_ES_VERSION_2_0 - glVertexAttrib4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glVertexAttrib4fv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fvARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4iv (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4iv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4iv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4ivARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4s (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4s)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4s (index, x, y, z, w);
  }
  // GL_ARB_vertex_program - glVertexAttrib4s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4sARB (index, x, y, z, w);
  }
  // GL_NV_vertex_program - glVertexAttrib4s
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4sNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4sNV (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4sv (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4sv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4sv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4svARB (index, v);
  }
  // GL_NV_vertex_program - glVertexAttrib4sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4svNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4ubv (GLuint index, const GLubyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4ubv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4ubv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4ubv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4ubv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4ubvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4ubvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4uiv (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4uiv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4uivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4uivARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4usv (GLuint index, const GLushort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttrib4usv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttrib4usv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4usv (index, v);
  }
  // GL_ARB_vertex_program - glVertexAttrib4usv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4usvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4usvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_0 - glVertexAttribPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_0] && glConfig.m_glVertexAttribPointer)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribPointer (index, size, type, normalized, stride, pointer);
  }
  // GL_ES_VERSION_2_0 - glVertexAttribPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glVertexAttribPointer)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribPointer (index, size, type, normalized, stride, pointer);
  }
  // GL_ARB_vertex_program - glVertexAttribPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttribPointerARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribPointerARB (index, size, type, normalized, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix2x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_1 - glUniformMatrix2x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_1] && glConfig.m_glUniformMatrix2x3fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x3fv (location, count, transpose, value);
  }
  // GL_ES_VERSION_3_0 - glUniformMatrix2x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniformMatrix2x3fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x3fv (location, count, transpose, value);
  }
  // GL_NV_non_square_matrices - glUniformMatrix2x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix2x3fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x3fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix3x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_1 - glUniformMatrix3x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_1] && glConfig.m_glUniformMatrix3x2fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x2fv (location, count, transpose, value);
  }
  // GL_ES_VERSION_3_0 - glUniformMatrix3x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniformMatrix3x2fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x2fv (location, count, transpose, value);
  }
  // GL_NV_non_square_matrices - glUniformMatrix3x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix3x2fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x2fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix2x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_1 - glUniformMatrix2x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_1] && glConfig.m_glUniformMatrix2x4fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x4fv (location, count, transpose, value);
  }
  // GL_ES_VERSION_3_0 - glUniformMatrix2x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniformMatrix2x4fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x4fv (location, count, transpose, value);
  }
  // GL_NV_non_square_matrices - glUniformMatrix2x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix2x4fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x4fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix4x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_1 - glUniformMatrix4x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_1] && glConfig.m_glUniformMatrix4x2fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x2fv (location, count, transpose, value);
  }
  // GL_ES_VERSION_3_0 - glUniformMatrix4x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniformMatrix4x2fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x2fv (location, count, transpose, value);
  }
  // GL_NV_non_square_matrices - glUniformMatrix4x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix4x2fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x2fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix3x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_1 - glUniformMatrix3x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_1] && glConfig.m_glUniformMatrix3x4fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x4fv (location, count, transpose, value);
  }
  // GL_ES_VERSION_3_0 - glUniformMatrix3x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniformMatrix3x4fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x4fv (location, count, transpose, value);
  }
  // GL_NV_non_square_matrices - glUniformMatrix3x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix3x4fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x4fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix4x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_2_1 - glUniformMatrix4x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_2_1] && glConfig.m_glUniformMatrix4x3fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x3fv (location, count, transpose, value);
  }
  // GL_ES_VERSION_3_0 - glUniformMatrix4x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniformMatrix4x3fv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x3fv (location, count, transpose, value);
  }
  // GL_NV_non_square_matrices - glUniformMatrix4x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix4x3fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x3fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorMaski (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glColorMaski
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glColorMaski)
  {
    prototypeCalled = true;
    glConfig.m_glColorMaski (index, r, g, b, a);
  }
  // GL_ES_VERSION_3_2 - glColorMaski
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glColorMaski)
  {
    prototypeCalled = true;
    glConfig.m_glColorMaski (index, r, g, b, a);
  }
  // GL_EXT_draw_buffers_indexed - glColorMaski
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glColorMaskiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glColorMaskiEXT (index, r, g, b, a);
  }
  // GL_OES_draw_buffers_indexed - glColorMaski
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glColorMaskiOES)
  {
    prototypeCalled = true;
    glConfig.m_glColorMaskiOES (index, r, g, b, a);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetBooleani_v (GLenum target, GLuint index, GLboolean * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetBooleani_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetBooleani_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetBooleani_v (target, index, data);
  }
  // GL_ES_VERSION_3_1 - glGetBooleani_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glGetBooleani_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetBooleani_v (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetIntegeri_v (GLenum target, GLuint index, GLint * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetIntegeri_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetIntegeri_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetIntegeri_v (target, index, data);
  }
  // GL_VERSION_3_1 - glGetIntegeri_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glGetIntegeri_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetIntegeri_v (target, index, data);
  }
  // GL_ES_VERSION_3_0 - glGetIntegeri_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetIntegeri_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetIntegeri_v (target, index, data);
  }
  // GL_ARB_uniform_buffer_object - glGetIntegeri_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object] && glConfig.m_glGetIntegeri_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetIntegeri_v (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnablei (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glEnablei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glEnablei)
  {
    prototypeCalled = true;
    glConfig.m_glEnablei (target, index);
  }
  // GL_ES_VERSION_3_2 - glEnablei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glEnablei)
  {
    prototypeCalled = true;
    glConfig.m_glEnablei (target, index);
  }
  // GL_EXT_draw_buffers_indexed - glEnablei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glEnableiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEnableiEXT (target, index);
  }
  // GL_NV_viewport_array - glEnablei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glEnableiNV)
  {
    prototypeCalled = true;
    glConfig.m_glEnableiNV (target, index);
  }
  // GL_OES_draw_buffers_indexed - glEnablei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glEnableiOES)
  {
    prototypeCalled = true;
    glConfig.m_glEnableiOES (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisablei (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glDisablei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glDisablei)
  {
    prototypeCalled = true;
    glConfig.m_glDisablei (target, index);
  }
  // GL_ES_VERSION_3_2 - glDisablei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glDisablei)
  {
    prototypeCalled = true;
    glConfig.m_glDisablei (target, index);
  }
  // GL_EXT_draw_buffers_indexed - glDisablei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glDisableiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDisableiEXT (target, index);
  }
  // GL_NV_viewport_array - glDisablei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glDisableiNV)
  {
    prototypeCalled = true;
    glConfig.m_glDisableiNV (target, index);
  }
  // GL_OES_draw_buffers_indexed - glDisablei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glDisableiOES)
  {
    prototypeCalled = true;
    glConfig.m_glDisableiOES (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsEnabledi (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glIsEnabledi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glIsEnabledi)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsEnabledi (target, index);
  }
  // GL_ES_VERSION_3_2 - glIsEnabledi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glIsEnabledi)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsEnabledi (target, index);
  }
  // GL_EXT_draw_buffers_indexed - glIsEnabledi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glIsEnablediEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsEnablediEXT (target, index);
  }
  // GL_NV_viewport_array - glIsEnabledi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glIsEnablediNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsEnablediNV (target, index);
  }
  // GL_OES_draw_buffers_indexed - glIsEnabledi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glIsEnablediOES)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsEnablediOES (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginTransformFeedback (GLenum primitiveMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glBeginTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glBeginTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glBeginTransformFeedback (primitiveMode);
  }
  // GL_ES_VERSION_3_0 - glBeginTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glBeginTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glBeginTransformFeedback (primitiveMode);
  }
  // GL_EXT_transform_feedback - glBeginTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glBeginTransformFeedbackEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBeginTransformFeedbackEXT (primitiveMode);
  }
  // GL_NV_transform_feedback - glBeginTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glBeginTransformFeedbackNV)
  {
    prototypeCalled = true;
    glConfig.m_glBeginTransformFeedbackNV (primitiveMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndTransformFeedback ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glEndTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glEndTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glEndTransformFeedback ();
  }
  // GL_ES_VERSION_3_0 - glEndTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glEndTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glEndTransformFeedback ();
  }
  // GL_EXT_transform_feedback - glEndTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glEndTransformFeedbackEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEndTransformFeedbackEXT ();
  }
  // GL_NV_transform_feedback - glEndTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glEndTransformFeedbackNV)
  {
    prototypeCalled = true;
    glConfig.m_glEndTransformFeedbackNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBufferRange (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glBindBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glBindBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferRange (target, index, buffer, offset, size);
  }
  // GL_VERSION_3_1 - glBindBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glBindBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferRange (target, index, buffer, offset, size);
  }
  // GL_ES_VERSION_3_0 - glBindBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glBindBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferRange (target, index, buffer, offset, size);
  }
  // GL_ARB_uniform_buffer_object - glBindBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object] && glConfig.m_glBindBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferRange (target, index, buffer, offset, size);
  }
  // GL_EXT_transform_feedback - glBindBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glBindBufferRangeEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferRangeEXT (target, index, buffer, offset, size);
  }
  // GL_NV_transform_feedback - glBindBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glBindBufferRangeNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferRangeNV (target, index, buffer, offset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBufferBase (GLenum target, GLuint index, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glBindBufferBase
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glBindBufferBase)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferBase (target, index, buffer);
  }
  // GL_VERSION_3_1 - glBindBufferBase
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glBindBufferBase)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferBase (target, index, buffer);
  }
  // GL_ES_VERSION_3_0 - glBindBufferBase
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glBindBufferBase)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferBase (target, index, buffer);
  }
  // GL_ARB_uniform_buffer_object - glBindBufferBase
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object] && glConfig.m_glBindBufferBase)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferBase (target, index, buffer);
  }
  // GL_EXT_transform_feedback - glBindBufferBase
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glBindBufferBaseEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferBaseEXT (target, index, buffer);
  }
  // GL_NV_transform_feedback - glBindBufferBase
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glBindBufferBaseNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferBaseNV (target, index, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTransformFeedbackVaryings (GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glTransformFeedbackVaryings
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glTransformFeedbackVaryings)
  {
    prototypeCalled = true;
    glConfig.m_glTransformFeedbackVaryings (program, count, varyings, bufferMode);
  }
  // GL_ES_VERSION_3_0 - glTransformFeedbackVaryings
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glTransformFeedbackVaryings)
  {
    prototypeCalled = true;
    glConfig.m_glTransformFeedbackVaryings (program, count, varyings, bufferMode);
  }
  // GL_EXT_transform_feedback - glTransformFeedbackVaryings
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glTransformFeedbackVaryingsEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTransformFeedbackVaryingsEXT (program, count, varyings, bufferMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTransformFeedbackVarying (GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetTransformFeedbackVarying
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetTransformFeedbackVarying)
  {
    prototypeCalled = true;
    glConfig.m_glGetTransformFeedbackVarying (program, index, bufSize, length, size, type, name);
  }
  // GL_ES_VERSION_3_0 - glGetTransformFeedbackVarying
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetTransformFeedbackVarying)
  {
    prototypeCalled = true;
    glConfig.m_glGetTransformFeedbackVarying (program, index, bufSize, length, size, type, name);
  }
  // GL_EXT_transform_feedback - glGetTransformFeedbackVarying
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glGetTransformFeedbackVaryingEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTransformFeedbackVaryingEXT (program, index, bufSize, length, size, type, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClampColor (GLenum target, GLenum clamp)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glClampColor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glClampColor)
  {
    prototypeCalled = true;
    glConfig.m_glClampColor (target, clamp);
  }
  // GL_ARB_color_buffer_float - glClampColor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_color_buffer_float] && glConfig.m_glClampColorARB)
  {
    prototypeCalled = true;
    glConfig.m_glClampColorARB (target, clamp);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginConditionalRender (GLuint id, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glBeginConditionalRender
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glBeginConditionalRender)
  {
    prototypeCalled = true;
    glConfig.m_glBeginConditionalRender (id, mode);
  }
  // GL_NV_conditional_render - glBeginConditionalRender
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_conditional_render] && glConfig.m_glBeginConditionalRenderNV)
  {
    prototypeCalled = true;
    glConfig.m_glBeginConditionalRenderNV (id, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndConditionalRender ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glEndConditionalRender
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glEndConditionalRender)
  {
    prototypeCalled = true;
    glConfig.m_glEndConditionalRender ();
  }
  // GL_NV_conditional_render - glEndConditionalRender
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_conditional_render] && glConfig.m_glEndConditionalRenderNV)
  {
    prototypeCalled = true;
    glConfig.m_glEndConditionalRenderNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribIPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribIPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribIPointer)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribIPointer (index, size, type, stride, pointer);
  }
  // GL_ES_VERSION_3_0 - glVertexAttribIPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glVertexAttribIPointer)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribIPointer (index, size, type, stride, pointer);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribIPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribIPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribIPointerEXT (index, size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribIiv (GLuint index, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetVertexAttribIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetVertexAttribIiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribIiv (index, pname, params);
  }
  // GL_ES_VERSION_3_0 - glGetVertexAttribIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetVertexAttribIiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribIiv (index, pname, params);
  }
  // GL_EXT_gpu_shader4 - glGetVertexAttribIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glGetVertexAttribIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribIivEXT (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribIuiv (GLuint index, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetVertexAttribIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetVertexAttribIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribIuiv (index, pname, params);
  }
  // GL_ES_VERSION_3_0 - glGetVertexAttribIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetVertexAttribIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribIuiv (index, pname, params);
  }
  // GL_EXT_gpu_shader4 - glGetVertexAttribIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glGetVertexAttribIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribIuivEXT (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI1i (GLuint index, GLint x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI1i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI1i)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1i (index, x);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI1i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI1iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1iEXT (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI2i (GLuint index, GLint x, GLint y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI2i)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2i (index, x, y);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI2iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2iEXT (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI3i (GLuint index, GLint x, GLint y, GLint z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI3i)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3i (index, x, y, z);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI3iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3iEXT (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4i (GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI4i)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4i (index, x, y, z, w);
  }
  // GL_ES_VERSION_3_0 - glVertexAttribI4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glVertexAttribI4i)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4i (index, x, y, z, w);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4iEXT (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI1ui (GLuint index, GLuint x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI1ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1ui (index, x);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI1uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1uiEXT (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI2ui (GLuint index, GLuint x, GLuint y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI2ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2ui (index, x, y);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI2uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2uiEXT (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI3ui (GLuint index, GLuint x, GLuint y, GLuint z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI3ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3ui (index, x, y, z);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI3uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3uiEXT (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4ui (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI4ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4ui (index, x, y, z, w);
  }
  // GL_ES_VERSION_3_0 - glVertexAttribI4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glVertexAttribI4ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4ui (index, x, y, z, w);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4uiEXT (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI1iv (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI1iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI1iv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1iv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI1iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI1ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1ivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI2iv (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI2iv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2iv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI2ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2ivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI3iv (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI3iv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3iv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI3ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3ivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4iv (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI4iv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4iv (index, v);
  }
  // GL_ES_VERSION_3_0 - glVertexAttribI4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glVertexAttribI4iv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4iv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4ivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI1uiv (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1uiv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI1uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1uivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI2uiv (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2uiv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI2uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2uivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI3uiv (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3uiv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI3uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3uivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4uiv (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4uiv (index, v);
  }
  // GL_ES_VERSION_3_0 - glVertexAttribI4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glVertexAttribI4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4uiv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4uivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4bv (GLuint index, const GLbyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI4bv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI4bv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4bv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI4bv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4bvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4bvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4sv (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI4sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI4sv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4sv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI4sv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4svEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4svEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4ubv (GLuint index, const GLubyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI4ubv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI4ubv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4ubv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI4ubv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4ubvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4ubvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4usv (GLuint index, const GLushort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glVertexAttribI4usv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glVertexAttribI4usv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4usv (index, v);
  }
  // GL_EXT_gpu_shader4 - glVertexAttribI4usv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4usvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4usvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformuiv (GLuint program, GLint location, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetUniformuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetUniformuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformuiv (program, location, params);
  }
  // GL_ES_VERSION_3_0 - glGetUniformuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetUniformuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformuiv (program, location, params);
  }
  // GL_EXT_gpu_shader4 - glGetUniformuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glGetUniformuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformuivEXT (program, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindFragDataLocation (GLuint program, GLuint color, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glBindFragDataLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glBindFragDataLocation)
  {
    prototypeCalled = true;
    glConfig.m_glBindFragDataLocation (program, color, name);
  }
  // GL_EXT_blend_func_extended - glBindFragDataLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_func_extended] && glConfig.m_glBindFragDataLocationEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindFragDataLocationEXT (program, color, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetFragDataLocation (GLuint program, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetFragDataLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetFragDataLocation)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetFragDataLocation (program, name);
  }
  // GL_ES_VERSION_3_0 - glGetFragDataLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetFragDataLocation)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetFragDataLocation (program, name);
  }
  // GL_EXT_gpu_shader4 - glGetFragDataLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glGetFragDataLocationEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetFragDataLocationEXT (program, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1ui (GLint location, GLuint v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glUniform1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glUniform1ui)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1ui (location, v0);
  }
  // GL_ES_VERSION_3_0 - glUniform1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniform1ui)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1ui (location, v0);
  }
  // GL_EXT_gpu_shader4 - glUniform1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform1uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1uiEXT (location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2ui (GLint location, GLuint v0, GLuint v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glUniform2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glUniform2ui)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2ui (location, v0, v1);
  }
  // GL_ES_VERSION_3_0 - glUniform2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniform2ui)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2ui (location, v0, v1);
  }
  // GL_EXT_gpu_shader4 - glUniform2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform2uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2uiEXT (location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3ui (GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glUniform3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glUniform3ui)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3ui (location, v0, v1, v2);
  }
  // GL_ES_VERSION_3_0 - glUniform3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniform3ui)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3ui (location, v0, v1, v2);
  }
  // GL_EXT_gpu_shader4 - glUniform3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform3uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3uiEXT (location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4ui (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glUniform4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glUniform4ui)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4ui (location, v0, v1, v2, v3);
  }
  // GL_ES_VERSION_3_0 - glUniform4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniform4ui)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4ui (location, v0, v1, v2, v3);
  }
  // GL_EXT_gpu_shader4 - glUniform4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform4uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4uiEXT (location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1uiv (GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glUniform1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glUniform1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1uiv (location, count, value);
  }
  // GL_ES_VERSION_3_0 - glUniform1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniform1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1uiv (location, count, value);
  }
  // GL_EXT_gpu_shader4 - glUniform1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform1uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1uivEXT (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2uiv (GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glUniform2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glUniform2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2uiv (location, count, value);
  }
  // GL_ES_VERSION_3_0 - glUniform2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniform2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2uiv (location, count, value);
  }
  // GL_EXT_gpu_shader4 - glUniform2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform2uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2uivEXT (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3uiv (GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glUniform3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glUniform3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3uiv (location, count, value);
  }
  // GL_ES_VERSION_3_0 - glUniform3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniform3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3uiv (location, count, value);
  }
  // GL_EXT_gpu_shader4 - glUniform3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform3uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3uivEXT (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4uiv (GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glUniform4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glUniform4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4uiv (location, count, value);
  }
  // GL_ES_VERSION_3_0 - glUniform4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniform4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4uiv (location, count, value);
  }
  // GL_EXT_gpu_shader4 - glUniform4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform4uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4uivEXT (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexParameterIiv (GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glTexParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glTexParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIiv (target, pname, params);
  }
  // GL_ES_VERSION_3_2 - glTexParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glTexParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIiv (target, pname, params);
  }
  // GL_EXT_texture_border_clamp - glTexParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glTexParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIivEXT (target, pname, params);
  }
  // GL_OES_texture_border_clamp - glTexParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glTexParameterIivOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIivOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexParameterIuiv (GLenum target, GLenum pname, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glTexParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glTexParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIuiv (target, pname, params);
  }
  // GL_ES_VERSION_3_2 - glTexParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glTexParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIuiv (target, pname, params);
  }
  // GL_EXT_texture_border_clamp - glTexParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glTexParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIuivEXT (target, pname, params);
  }
  // GL_OES_texture_border_clamp - glTexParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glTexParameterIuivOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIuivOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexParameterIiv (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetTexParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetTexParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIiv (target, pname, params);
  }
  // GL_ES_VERSION_3_2 - glGetTexParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetTexParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIiv (target, pname, params);
  }
  // GL_EXT_texture_border_clamp - glGetTexParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glGetTexParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIivEXT (target, pname, params);
  }
  // GL_OES_texture_border_clamp - glGetTexParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glGetTexParameterIivOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIivOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexParameterIuiv (GLenum target, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetTexParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetTexParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIuiv (target, pname, params);
  }
  // GL_ES_VERSION_3_2 - glGetTexParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetTexParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIuiv (target, pname, params);
  }
  // GL_EXT_texture_border_clamp - glGetTexParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glGetTexParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIuivEXT (target, pname, params);
  }
  // GL_OES_texture_border_clamp - glGetTexParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glGetTexParameterIuivOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIuivOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearBufferiv (GLenum buffer, GLint drawbuffer, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glClearBufferiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glClearBufferiv)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferiv (buffer, drawbuffer, value);
  }
  // GL_ES_VERSION_3_0 - glClearBufferiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glClearBufferiv)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferiv (buffer, drawbuffer, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearBufferuiv (GLenum buffer, GLint drawbuffer, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glClearBufferuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glClearBufferuiv)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferuiv (buffer, drawbuffer, value);
  }
  // GL_ES_VERSION_3_0 - glClearBufferuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glClearBufferuiv)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferuiv (buffer, drawbuffer, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearBufferfv (GLenum buffer, GLint drawbuffer, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glClearBufferfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glClearBufferfv)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferfv (buffer, drawbuffer, value);
  }
  // GL_ES_VERSION_3_0 - glClearBufferfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glClearBufferfv)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferfv (buffer, drawbuffer, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearBufferfi (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glClearBufferfi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glClearBufferfi)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferfi (buffer, drawbuffer, depth, stencil);
  }
  // GL_ES_VERSION_3_0 - glClearBufferfi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glClearBufferfi)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferfi (buffer, drawbuffer, depth, stencil);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const GLubyte * _glew_gl_glGetStringi (GLenum name, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  const GLubyte * result = ((const GLubyte *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetStringi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetStringi)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetStringi (name, index);
  }
  // GL_ES_VERSION_3_0 - glGetStringi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetStringi)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetStringi (name, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsRenderbuffer (GLuint renderbuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glIsRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glIsRenderbuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsRenderbuffer (renderbuffer);
  }
  // GL_ES_VERSION_2_0 - glIsRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glIsRenderbuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsRenderbuffer (renderbuffer);
  }
  // GL_ARB_framebuffer_object - glIsRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glIsRenderbuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsRenderbuffer (renderbuffer);
  }
  // GL_EXT_framebuffer_object - glIsRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glIsRenderbufferEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsRenderbufferEXT (renderbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindRenderbuffer (GLenum target, GLuint renderbuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glBindRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glBindRenderbuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBindRenderbuffer (target, renderbuffer);
  }
  // GL_ES_VERSION_2_0 - glBindRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glBindRenderbuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBindRenderbuffer (target, renderbuffer);
  }
  // GL_ARB_framebuffer_object - glBindRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glBindRenderbuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBindRenderbuffer (target, renderbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteRenderbuffers (GLsizei n, const GLuint * renderbuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glDeleteRenderbuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glDeleteRenderbuffers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteRenderbuffers (n, renderbuffers);
  }
  // GL_ES_VERSION_2_0 - glDeleteRenderbuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glDeleteRenderbuffers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteRenderbuffers (n, renderbuffers);
  }
  // GL_ARB_framebuffer_object - glDeleteRenderbuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glDeleteRenderbuffers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteRenderbuffers (n, renderbuffers);
  }
  // GL_EXT_framebuffer_object - glDeleteRenderbuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glDeleteRenderbuffersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteRenderbuffersEXT (n, renderbuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenRenderbuffers (GLsizei n, GLuint * renderbuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGenRenderbuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGenRenderbuffers)
  {
    prototypeCalled = true;
    glConfig.m_glGenRenderbuffers (n, renderbuffers);
  }
  // GL_ES_VERSION_2_0 - glGenRenderbuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGenRenderbuffers)
  {
    prototypeCalled = true;
    glConfig.m_glGenRenderbuffers (n, renderbuffers);
  }
  // GL_ARB_framebuffer_object - glGenRenderbuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glGenRenderbuffers)
  {
    prototypeCalled = true;
    glConfig.m_glGenRenderbuffers (n, renderbuffers);
  }
  // GL_EXT_framebuffer_object - glGenRenderbuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glGenRenderbuffersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenRenderbuffersEXT (n, renderbuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glRenderbufferStorage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glRenderbufferStorage)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorage (target, internalformat, width, height);
  }
  // GL_ES_VERSION_2_0 - glRenderbufferStorage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glRenderbufferStorage)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorage (target, internalformat, width, height);
  }
  // GL_ARB_framebuffer_object - glRenderbufferStorage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glRenderbufferStorage)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorage (target, internalformat, width, height);
  }
  // GL_EXT_framebuffer_object - glRenderbufferStorage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glRenderbufferStorageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageEXT (target, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetRenderbufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetRenderbufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetRenderbufferParameteriv (target, pname, params);
  }
  // GL_ES_VERSION_2_0 - glGetRenderbufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetRenderbufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetRenderbufferParameteriv (target, pname, params);
  }
  // GL_ARB_framebuffer_object - glGetRenderbufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glGetRenderbufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetRenderbufferParameteriv (target, pname, params);
  }
  // GL_EXT_framebuffer_object - glGetRenderbufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glGetRenderbufferParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetRenderbufferParameterivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsFramebuffer (GLuint framebuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glIsFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glIsFramebuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsFramebuffer (framebuffer);
  }
  // GL_ES_VERSION_2_0 - glIsFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glIsFramebuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsFramebuffer (framebuffer);
  }
  // GL_ARB_framebuffer_object - glIsFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glIsFramebuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsFramebuffer (framebuffer);
  }
  // GL_EXT_framebuffer_object - glIsFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glIsFramebufferEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsFramebufferEXT (framebuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindFramebuffer (GLenum target, GLuint framebuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glBindFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glBindFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBindFramebuffer (target, framebuffer);
  }
  // GL_ES_VERSION_2_0 - glBindFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glBindFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBindFramebuffer (target, framebuffer);
  }
  // GL_ARB_framebuffer_object - glBindFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glBindFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBindFramebuffer (target, framebuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteFramebuffers (GLsizei n, const GLuint * framebuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glDeleteFramebuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glDeleteFramebuffers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteFramebuffers (n, framebuffers);
  }
  // GL_ES_VERSION_2_0 - glDeleteFramebuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glDeleteFramebuffers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteFramebuffers (n, framebuffers);
  }
  // GL_ARB_framebuffer_object - glDeleteFramebuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glDeleteFramebuffers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteFramebuffers (n, framebuffers);
  }
  // GL_EXT_framebuffer_object - glDeleteFramebuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glDeleteFramebuffersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteFramebuffersEXT (n, framebuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenFramebuffers (GLsizei n, GLuint * framebuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGenFramebuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGenFramebuffers)
  {
    prototypeCalled = true;
    glConfig.m_glGenFramebuffers (n, framebuffers);
  }
  // GL_ES_VERSION_2_0 - glGenFramebuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGenFramebuffers)
  {
    prototypeCalled = true;
    glConfig.m_glGenFramebuffers (n, framebuffers);
  }
  // GL_ARB_framebuffer_object - glGenFramebuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glGenFramebuffers)
  {
    prototypeCalled = true;
    glConfig.m_glGenFramebuffers (n, framebuffers);
  }
  // GL_EXT_framebuffer_object - glGenFramebuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glGenFramebuffersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenFramebuffersEXT (n, framebuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glCheckFramebufferStatus (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glCheckFramebufferStatus
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glCheckFramebufferStatus)
  {
    prototypeCalled = true;
    result = glConfig.m_glCheckFramebufferStatus (target);
  }
  // GL_ES_VERSION_2_0 - glCheckFramebufferStatus
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glCheckFramebufferStatus)
  {
    prototypeCalled = true;
    result = glConfig.m_glCheckFramebufferStatus (target);
  }
  // GL_ARB_framebuffer_object - glCheckFramebufferStatus
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glCheckFramebufferStatus)
  {
    prototypeCalled = true;
    result = glConfig.m_glCheckFramebufferStatus (target);
  }
  // GL_EXT_framebuffer_object - glCheckFramebufferStatus
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glCheckFramebufferStatusEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glCheckFramebufferStatusEXT (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTexture1D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glFramebufferTexture1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glFramebufferTexture1D)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture1D (target, attachment, textarget, texture, level);
  }
  // GL_ARB_framebuffer_object - glFramebufferTexture1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glFramebufferTexture1D)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture1D (target, attachment, textarget, texture, level);
  }
  // GL_EXT_framebuffer_object - glFramebufferTexture1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glFramebufferTexture1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture1DEXT (target, attachment, textarget, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glFramebufferTexture2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glFramebufferTexture2D)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture2D (target, attachment, textarget, texture, level);
  }
  // GL_ES_VERSION_2_0 - glFramebufferTexture2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glFramebufferTexture2D)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture2D (target, attachment, textarget, texture, level);
  }
  // GL_ARB_framebuffer_object - glFramebufferTexture2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glFramebufferTexture2D)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture2D (target, attachment, textarget, texture, level);
  }
  // GL_EXT_framebuffer_object - glFramebufferTexture2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glFramebufferTexture2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture2DEXT (target, attachment, textarget, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTexture3D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glFramebufferTexture3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glFramebufferTexture3D)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture3D (target, attachment, textarget, texture, level, zoffset);
  }
  // GL_ARB_framebuffer_object - glFramebufferTexture3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glFramebufferTexture3D)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture3D (target, attachment, textarget, texture, level, zoffset);
  }
  // GL_EXT_framebuffer_object - glFramebufferTexture3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glFramebufferTexture3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture3DEXT (target, attachment, textarget, texture, level, zoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glFramebufferRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glFramebufferRenderbuffer)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferRenderbuffer (target, attachment, renderbuffertarget, renderbuffer);
  }
  // GL_ES_VERSION_2_0 - glFramebufferRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glFramebufferRenderbuffer)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferRenderbuffer (target, attachment, renderbuffertarget, renderbuffer);
  }
  // GL_ARB_framebuffer_object - glFramebufferRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glFramebufferRenderbuffer)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferRenderbuffer (target, attachment, renderbuffertarget, renderbuffer);
  }
  // GL_EXT_framebuffer_object - glFramebufferRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glFramebufferRenderbufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferRenderbufferEXT (target, attachment, renderbuffertarget, renderbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGetFramebufferAttachmentParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGetFramebufferAttachmentParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetFramebufferAttachmentParameteriv (target, attachment, pname, params);
  }
  // GL_ES_VERSION_2_0 - glGetFramebufferAttachmentParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetFramebufferAttachmentParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetFramebufferAttachmentParameteriv (target, attachment, pname, params);
  }
  // GL_ARB_framebuffer_object - glGetFramebufferAttachmentParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glGetFramebufferAttachmentParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetFramebufferAttachmentParameteriv (target, attachment, pname, params);
  }
  // GL_EXT_framebuffer_object - glGetFramebufferAttachmentParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glGetFramebufferAttachmentParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetFramebufferAttachmentParameterivEXT (target, attachment, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenerateMipmap (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGenerateMipmap
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGenerateMipmap)
  {
    prototypeCalled = true;
    glConfig.m_glGenerateMipmap (target);
  }
  // GL_ES_VERSION_2_0 - glGenerateMipmap
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGenerateMipmap)
  {
    prototypeCalled = true;
    glConfig.m_glGenerateMipmap (target);
  }
  // GL_ARB_framebuffer_object - glGenerateMipmap
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glGenerateMipmap)
  {
    prototypeCalled = true;
    glConfig.m_glGenerateMipmap (target);
  }
  // GL_EXT_framebuffer_object - glGenerateMipmap
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glGenerateMipmapEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenerateMipmapEXT (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glBlitFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glBlitFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBlitFramebuffer (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  // GL_ES_VERSION_3_0 - glBlitFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glBlitFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBlitFramebuffer (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  // GL_ARB_framebuffer_object - glBlitFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glBlitFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBlitFramebuffer (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  // GL_EXT_framebuffer_blit - glBlitFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_blit] && glConfig.m_glBlitFramebufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlitFramebufferEXT (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  // GL_NV_framebuffer_blit - glBlitFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_framebuffer_blit] && glConfig.m_glBlitFramebufferNV)
  {
    prototypeCalled = true;
    glConfig.m_glBlitFramebufferNV (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glRenderbufferStorageMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glRenderbufferStorageMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisample (target, samples, internalformat, width, height);
  }
  // GL_ES_VERSION_3_0 - glRenderbufferStorageMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glRenderbufferStorageMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisample (target, samples, internalformat, width, height);
  }
  // GL_ARB_framebuffer_object - glRenderbufferStorageMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glRenderbufferStorageMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisample (target, samples, internalformat, width, height);
  }
  // GL_EXT_framebuffer_multisample - glRenderbufferStorageMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_multisample] && glConfig.m_glRenderbufferStorageMultisampleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisampleEXT (target, samples, internalformat, width, height);
  }
  // GL_NV_framebuffer_multisample - glRenderbufferStorageMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_framebuffer_multisample] && glConfig.m_glRenderbufferStorageMultisampleNV)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisampleNV (target, samples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTextureLayer (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glFramebufferTextureLayer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glFramebufferTextureLayer)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureLayer (target, attachment, texture, level, layer);
  }
  // GL_ES_VERSION_3_0 - glFramebufferTextureLayer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glFramebufferTextureLayer)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureLayer (target, attachment, texture, level, layer);
  }
  // GL_ARB_framebuffer_object - glFramebufferTextureLayer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] && glConfig.m_glFramebufferTextureLayer)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureLayer (target, attachment, texture, level, layer);
  }
  // GL_ARB_geometry_shader4 - glFramebufferTextureLayer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_geometry_shader4] && glConfig.m_glFramebufferTextureLayerARB)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureLayerARB (target, attachment, texture, level, layer);
  }
  // GL_EXT_texture_array - glFramebufferTextureLayer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_array] && glConfig.m_glFramebufferTextureLayerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureLayerEXT (target, attachment, texture, level, layer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void * _glew_gl_glMapBufferRange (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  void * result = ((void *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glMapBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glMapBufferRange)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapBufferRange (target, offset, length, access);
  }
  // GL_ES_VERSION_3_0 - glMapBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glMapBufferRange)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapBufferRange (target, offset, length, access);
  }
  // GL_ARB_map_buffer_range - glMapBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_map_buffer_range] && glConfig.m_glMapBufferRange)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapBufferRange (target, offset, length, access);
  }
  // GL_EXT_map_buffer_range - glMapBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_map_buffer_range] && glConfig.m_glMapBufferRangeEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapBufferRangeEXT (target, offset, length, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFlushMappedBufferRange (GLenum target, GLintptr offset, GLsizeiptr length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glFlushMappedBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glFlushMappedBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glFlushMappedBufferRange (target, offset, length);
  }
  // GL_ES_VERSION_3_0 - glFlushMappedBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glFlushMappedBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glFlushMappedBufferRange (target, offset, length);
  }
  // GL_ARB_map_buffer_range - glFlushMappedBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_map_buffer_range] && glConfig.m_glFlushMappedBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glFlushMappedBufferRange (target, offset, length);
  }
  // GL_APPLE_flush_buffer_range - glFlushMappedBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_flush_buffer_range] && glConfig.m_glFlushMappedBufferRangeAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glFlushMappedBufferRangeAPPLE (target, offset, length);
  }
  // GL_EXT_map_buffer_range - glFlushMappedBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_map_buffer_range] && glConfig.m_glFlushMappedBufferRangeEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFlushMappedBufferRangeEXT (target, offset, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindVertexArray (GLuint array)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glBindVertexArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glBindVertexArray)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexArray (array);
  }
  // GL_ES_VERSION_3_0 - glBindVertexArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glBindVertexArray)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexArray (array);
  }
  // GL_ARB_vertex_array_object - glBindVertexArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_array_object] && glConfig.m_glBindVertexArray)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexArray (array);
  }
  // GL_OES_vertex_array_object - glBindVertexArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_vertex_array_object] && glConfig.m_glBindVertexArrayOES)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexArrayOES (array);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteVertexArrays (GLsizei n, const GLuint * arrays)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glDeleteVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glDeleteVertexArrays)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteVertexArrays (n, arrays);
  }
  // GL_ES_VERSION_3_0 - glDeleteVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glDeleteVertexArrays)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteVertexArrays (n, arrays);
  }
  // GL_ARB_vertex_array_object - glDeleteVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_array_object] && glConfig.m_glDeleteVertexArrays)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteVertexArrays (n, arrays);
  }
  // GL_APPLE_vertex_array_object - glDeleteVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_object] && glConfig.m_glDeleteVertexArraysAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteVertexArraysAPPLE (n, arrays);
  }
  // GL_OES_vertex_array_object - glDeleteVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_vertex_array_object] && glConfig.m_glDeleteVertexArraysOES)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteVertexArraysOES (n, arrays);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenVertexArrays (GLsizei n, GLuint * arrays)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glGenVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glGenVertexArrays)
  {
    prototypeCalled = true;
    glConfig.m_glGenVertexArrays (n, arrays);
  }
  // GL_ES_VERSION_3_0 - glGenVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGenVertexArrays)
  {
    prototypeCalled = true;
    glConfig.m_glGenVertexArrays (n, arrays);
  }
  // GL_ARB_vertex_array_object - glGenVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_array_object] && glConfig.m_glGenVertexArrays)
  {
    prototypeCalled = true;
    glConfig.m_glGenVertexArrays (n, arrays);
  }
  // GL_APPLE_vertex_array_object - glGenVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_object] && glConfig.m_glGenVertexArraysAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glGenVertexArraysAPPLE (n, arrays);
  }
  // GL_OES_vertex_array_object - glGenVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_vertex_array_object] && glConfig.m_glGenVertexArraysOES)
  {
    prototypeCalled = true;
    glConfig.m_glGenVertexArraysOES (n, arrays);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsVertexArray (GLuint array)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_0 - glIsVertexArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_0] && glConfig.m_glIsVertexArray)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsVertexArray (array);
  }
  // GL_ES_VERSION_3_0 - glIsVertexArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glIsVertexArray)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsVertexArray (array);
  }
  // GL_ARB_vertex_array_object - glIsVertexArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_array_object] && glConfig.m_glIsVertexArray)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsVertexArray (array);
  }
  // GL_APPLE_vertex_array_object - glIsVertexArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_object] && glConfig.m_glIsVertexArrayAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsVertexArrayAPPLE (array);
  }
  // GL_OES_vertex_array_object - glIsVertexArray
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_vertex_array_object] && glConfig.m_glIsVertexArrayOES)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsVertexArrayOES (array);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawArraysInstanced (GLenum mode, GLint first, GLsizei count, GLsizei instancecount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glDrawArraysInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glDrawArraysInstanced)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstanced (mode, first, count, instancecount);
  }
  // GL_ES_VERSION_3_0 - glDrawArraysInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glDrawArraysInstanced)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstanced (mode, first, count, instancecount);
  }
  // GL_ANGLE_instanced_arrays - glDrawArraysInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ANGLE_instanced_arrays] && glConfig.m_glDrawArraysInstancedANGLE)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstancedANGLE (mode, first, count, instancecount);
  }
  // GL_EXT_instanced_arrays - glDrawArraysInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_instanced_arrays] && glConfig.m_glDrawArraysInstancedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstancedEXT (mode, first, count, instancecount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstanced (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glDrawElementsInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glDrawElementsInstanced)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstanced (mode, count, type, indices, instancecount);
  }
  // GL_ES_VERSION_3_0 - glDrawElementsInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glDrawElementsInstanced)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstanced (mode, count, type, indices, instancecount);
  }
  // GL_ANGLE_instanced_arrays - glDrawElementsInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ANGLE_instanced_arrays] && glConfig.m_glDrawElementsInstancedANGLE)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedANGLE (mode, count, type, indices, instancecount);
  }
  // GL_EXT_instanced_arrays - glDrawElementsInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_instanced_arrays] && glConfig.m_glDrawElementsInstancedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedEXT (mode, count, type, indices, instancecount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexBuffer (GLenum target, GLenum internalformat, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glTexBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glTexBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glTexBuffer (target, internalformat, buffer);
  }
  // GL_ES_VERSION_3_2 - glTexBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glTexBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glTexBuffer (target, internalformat, buffer);
  }
  // GL_ARB_texture_buffer_object - glTexBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_buffer_object] && glConfig.m_glTexBufferARB)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferARB (target, internalformat, buffer);
  }
  // GL_EXT_texture_buffer - glTexBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_buffer] && glConfig.m_glTexBufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferEXT (target, internalformat, buffer);
  }
  // GL_OES_texture_buffer - glTexBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_buffer] && glConfig.m_glTexBufferOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferOES (target, internalformat, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPrimitiveRestartIndex (GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glPrimitiveRestartIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glPrimitiveRestartIndex)
  {
    prototypeCalled = true;
    glConfig.m_glPrimitiveRestartIndex (index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyBufferSubData (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glCopyBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glCopyBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glCopyBufferSubData (readTarget, writeTarget, readOffset, writeOffset, size);
  }
  // GL_ES_VERSION_3_0 - glCopyBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glCopyBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glCopyBufferSubData (readTarget, writeTarget, readOffset, writeOffset, size);
  }
  // GL_ARB_copy_buffer - glCopyBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_copy_buffer] && glConfig.m_glCopyBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glCopyBufferSubData (readTarget, writeTarget, readOffset, writeOffset, size);
  }
  // GL_NV_copy_buffer - glCopyBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_copy_buffer] && glConfig.m_glCopyBufferSubDataNV)
  {
    prototypeCalled = true;
    glConfig.m_glCopyBufferSubDataNV (readTarget, writeTarget, readOffset, writeOffset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformIndices (GLuint program, GLsizei uniformCount, const GLchar *const* uniformNames, GLuint * uniformIndices)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glGetUniformIndices
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glGetUniformIndices)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformIndices (program, uniformCount, uniformNames, uniformIndices);
  }
  // GL_ES_VERSION_3_0 - glGetUniformIndices
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetUniformIndices)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformIndices (program, uniformCount, uniformNames, uniformIndices);
  }
  // GL_ARB_uniform_buffer_object - glGetUniformIndices
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object] && glConfig.m_glGetUniformIndices)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformIndices (program, uniformCount, uniformNames, uniformIndices);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveUniformsiv (GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glGetActiveUniformsiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glGetActiveUniformsiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformsiv (program, uniformCount, uniformIndices, pname, params);
  }
  // GL_ES_VERSION_3_0 - glGetActiveUniformsiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetActiveUniformsiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformsiv (program, uniformCount, uniformIndices, pname, params);
  }
  // GL_ARB_uniform_buffer_object - glGetActiveUniformsiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object] && glConfig.m_glGetActiveUniformsiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformsiv (program, uniformCount, uniformIndices, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveUniformName (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glGetActiveUniformName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glGetActiveUniformName)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformName (program, uniformIndex, bufSize, length, uniformName);
  }
  // GL_ARB_uniform_buffer_object - glGetActiveUniformName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object] && glConfig.m_glGetActiveUniformName)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformName (program, uniformIndex, bufSize, length, uniformName);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGetUniformBlockIndex (GLuint program, const GLchar * uniformBlockName)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glGetUniformBlockIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glGetUniformBlockIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetUniformBlockIndex (program, uniformBlockName);
  }
  // GL_ES_VERSION_3_0 - glGetUniformBlockIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetUniformBlockIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetUniformBlockIndex (program, uniformBlockName);
  }
  // GL_ARB_uniform_buffer_object - glGetUniformBlockIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object] && glConfig.m_glGetUniformBlockIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetUniformBlockIndex (program, uniformBlockName);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveUniformBlockiv (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glGetActiveUniformBlockiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glGetActiveUniformBlockiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformBlockiv (program, uniformBlockIndex, pname, params);
  }
  // GL_ES_VERSION_3_0 - glGetActiveUniformBlockiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetActiveUniformBlockiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformBlockiv (program, uniformBlockIndex, pname, params);
  }
  // GL_ARB_uniform_buffer_object - glGetActiveUniformBlockiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object] && glConfig.m_glGetActiveUniformBlockiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformBlockiv (program, uniformBlockIndex, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveUniformBlockName (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glGetActiveUniformBlockName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glGetActiveUniformBlockName)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformBlockName (program, uniformBlockIndex, bufSize, length, uniformBlockName);
  }
  // GL_ES_VERSION_3_0 - glGetActiveUniformBlockName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetActiveUniformBlockName)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformBlockName (program, uniformBlockIndex, bufSize, length, uniformBlockName);
  }
  // GL_ARB_uniform_buffer_object - glGetActiveUniformBlockName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object] && glConfig.m_glGetActiveUniformBlockName)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformBlockName (program, uniformBlockIndex, bufSize, length, uniformBlockName);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformBlockBinding (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_1 - glUniformBlockBinding
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_1] && glConfig.m_glUniformBlockBinding)
  {
    prototypeCalled = true;
    glConfig.m_glUniformBlockBinding (program, uniformBlockIndex, uniformBlockBinding);
  }
  // GL_ES_VERSION_3_0 - glUniformBlockBinding
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glUniformBlockBinding)
  {
    prototypeCalled = true;
    glConfig.m_glUniformBlockBinding (program, uniformBlockIndex, uniformBlockBinding);
  }
  // GL_ARB_uniform_buffer_object - glUniformBlockBinding
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object] && glConfig.m_glUniformBlockBinding)
  {
    prototypeCalled = true;
    glConfig.m_glUniformBlockBinding (program, uniformBlockIndex, uniformBlockBinding);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsBaseVertex (GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glDrawElementsBaseVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glDrawElementsBaseVertex)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsBaseVertex (mode, count, type, indices, basevertex);
  }
  // GL_ES_VERSION_3_2 - glDrawElementsBaseVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glDrawElementsBaseVertex)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsBaseVertex (mode, count, type, indices, basevertex);
  }
  // GL_ARB_draw_elements_base_vertex - glDrawElementsBaseVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_elements_base_vertex] && glConfig.m_glDrawElementsBaseVertex)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsBaseVertex (mode, count, type, indices, basevertex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawRangeElementsBaseVertex (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glDrawRangeElementsBaseVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glDrawRangeElementsBaseVertex)
  {
    prototypeCalled = true;
    glConfig.m_glDrawRangeElementsBaseVertex (mode, start, end, count, type, indices, basevertex);
  }
  // GL_ES_VERSION_3_2 - glDrawRangeElementsBaseVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glDrawRangeElementsBaseVertex)
  {
    prototypeCalled = true;
    glConfig.m_glDrawRangeElementsBaseVertex (mode, start, end, count, type, indices, basevertex);
  }
  // GL_ARB_draw_elements_base_vertex - glDrawRangeElementsBaseVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_elements_base_vertex] && glConfig.m_glDrawRangeElementsBaseVertex)
  {
    prototypeCalled = true;
    glConfig.m_glDrawRangeElementsBaseVertex (mode, start, end, count, type, indices, basevertex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstancedBaseVertex (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glDrawElementsInstancedBaseVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glDrawElementsInstancedBaseVertex)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedBaseVertex (mode, count, type, indices, instancecount, basevertex);
  }
  // GL_ES_VERSION_3_2 - glDrawElementsInstancedBaseVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glDrawElementsInstancedBaseVertex)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedBaseVertex (mode, count, type, indices, instancecount, basevertex);
  }
  // GL_ARB_draw_elements_base_vertex - glDrawElementsInstancedBaseVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_elements_base_vertex] && glConfig.m_glDrawElementsInstancedBaseVertex)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedBaseVertex (mode, count, type, indices, instancecount, basevertex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElementsBaseVertex (GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glMultiDrawElementsBaseVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glMultiDrawElementsBaseVertex)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsBaseVertex (mode, count, type, indices, drawcount, basevertex);
  }
  // GL_ARB_draw_elements_base_vertex - glMultiDrawElementsBaseVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_elements_base_vertex] && glConfig.m_glMultiDrawElementsBaseVertex)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsBaseVertex (mode, count, type, indices, drawcount, basevertex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProvokingVertex (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glProvokingVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glProvokingVertex)
  {
    prototypeCalled = true;
    glConfig.m_glProvokingVertex (mode);
  }
  // GL_ARB_provoking_vertex - glProvokingVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_provoking_vertex] && glConfig.m_glProvokingVertex)
  {
    prototypeCalled = true;
    glConfig.m_glProvokingVertex (mode);
  }
  // GL_EXT_provoking_vertex - glProvokingVertex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_provoking_vertex] && glConfig.m_glProvokingVertexEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProvokingVertexEXT (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLsync _glew_gl_glFenceSync (GLenum condition, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLsync result = ((GLsync)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glFenceSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glFenceSync)
  {
    prototypeCalled = true;
    result = glConfig.m_glFenceSync (condition, flags);
  }
  // GL_ES_VERSION_3_0 - glFenceSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glFenceSync)
  {
    prototypeCalled = true;
    result = glConfig.m_glFenceSync (condition, flags);
  }
  // GL_ARB_sync - glFenceSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sync] && glConfig.m_glFenceSync)
  {
    prototypeCalled = true;
    result = glConfig.m_glFenceSync (condition, flags);
  }
  // GL_APPLE_sync - glFenceSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glFenceSyncAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glFenceSyncAPPLE (condition, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsSync (GLsync sync)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glIsSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glIsSync)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsSync (sync);
  }
  // GL_ES_VERSION_3_0 - glIsSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glIsSync)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsSync (sync);
  }
  // GL_ARB_sync - glIsSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sync] && glConfig.m_glIsSync)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsSync (sync);
  }
  // GL_APPLE_sync - glIsSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glIsSyncAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsSyncAPPLE (sync);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteSync (GLsync sync)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glDeleteSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glDeleteSync)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteSync (sync);
  }
  // GL_ES_VERSION_3_0 - glDeleteSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glDeleteSync)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteSync (sync);
  }
  // GL_ARB_sync - glDeleteSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sync] && glConfig.m_glDeleteSync)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteSync (sync);
  }
  // GL_APPLE_sync - glDeleteSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glDeleteSyncAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteSyncAPPLE (sync);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glClientWaitSync (GLsync sync, GLbitfield flags, GLuint64 timeout)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glClientWaitSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glClientWaitSync)
  {
    prototypeCalled = true;
    result = glConfig.m_glClientWaitSync (sync, flags, timeout);
  }
  // GL_ES_VERSION_3_0 - glClientWaitSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glClientWaitSync)
  {
    prototypeCalled = true;
    result = glConfig.m_glClientWaitSync (sync, flags, timeout);
  }
  // GL_ARB_sync - glClientWaitSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sync] && glConfig.m_glClientWaitSync)
  {
    prototypeCalled = true;
    result = glConfig.m_glClientWaitSync (sync, flags, timeout);
  }
  // GL_APPLE_sync - glClientWaitSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glClientWaitSyncAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glClientWaitSyncAPPLE (sync, flags, timeout);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWaitSync (GLsync sync, GLbitfield flags, GLuint64 timeout)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glWaitSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glWaitSync)
  {
    prototypeCalled = true;
    glConfig.m_glWaitSync (sync, flags, timeout);
  }
  // GL_ES_VERSION_3_0 - glWaitSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glWaitSync)
  {
    prototypeCalled = true;
    glConfig.m_glWaitSync (sync, flags, timeout);
  }
  // GL_ARB_sync - glWaitSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sync] && glConfig.m_glWaitSync)
  {
    prototypeCalled = true;
    glConfig.m_glWaitSync (sync, flags, timeout);
  }
  // GL_APPLE_sync - glWaitSync
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glWaitSyncAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glWaitSyncAPPLE (sync, flags, timeout);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetInteger64v (GLenum pname, GLint64 * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glGetInteger64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glGetInteger64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetInteger64v (pname, data);
  }
  // GL_ES_VERSION_3_0 - glGetInteger64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetInteger64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetInteger64v (pname, data);
  }
  // GL_ARB_sync - glGetInteger64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sync] && glConfig.m_glGetInteger64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetInteger64v (pname, data);
  }
  // GL_APPLE_sync - glGetInteger64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glGetInteger64vAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glGetInteger64vAPPLE (pname, data);
  }
  // GL_EXT_disjoint_timer_query - glGetInteger64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glGetInteger64vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetInteger64vEXT (pname, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSynciv (GLsync sync, GLenum pname, GLsizei count, GLsizei * length, GLint * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glGetSynciv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glGetSynciv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSynciv (sync, pname, count, length, values);
  }
  // GL_ES_VERSION_3_0 - glGetSynciv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetSynciv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSynciv (sync, pname, count, length, values);
  }
  // GL_ARB_sync - glGetSynciv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sync] && glConfig.m_glGetSynciv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSynciv (sync, pname, count, length, values);
  }
  // GL_APPLE_sync - glGetSynciv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glGetSyncivAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glGetSyncivAPPLE (sync, pname, count, length, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetInteger64i_v (GLenum target, GLuint index, GLint64 * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glGetInteger64i_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glGetInteger64i_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetInteger64i_v (target, index, data);
  }
  // GL_ES_VERSION_3_0 - glGetInteger64i_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetInteger64i_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetInteger64i_v (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetBufferParameteri64v (GLenum target, GLenum pname, GLint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glGetBufferParameteri64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glGetBufferParameteri64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferParameteri64v (target, pname, params);
  }
  // GL_ES_VERSION_3_0 - glGetBufferParameteri64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetBufferParameteri64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferParameteri64v (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTexture (GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glFramebufferTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glFramebufferTexture)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture (target, attachment, texture, level);
  }
  // GL_ES_VERSION_3_2 - glFramebufferTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glFramebufferTexture)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture (target, attachment, texture, level);
  }
  // GL_ARB_geometry_shader4 - glFramebufferTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_geometry_shader4] && glConfig.m_glFramebufferTextureARB)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureARB (target, attachment, texture, level);
  }
  // GL_EXT_geometry_shader - glFramebufferTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_geometry_shader] && glConfig.m_glFramebufferTextureEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureEXT (target, attachment, texture, level);
  }
  // GL_OES_geometry_shader - glFramebufferTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_geometry_shader] && glConfig.m_glFramebufferTextureOES)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureOES (target, attachment, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexImage2DMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glTexImage2DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glTexImage2DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage2DMultisample (target, samples, internalformat, width, height, fixedsamplelocations);
  }
  // GL_ARB_texture_multisample - glTexImage2DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_multisample] && glConfig.m_glTexImage2DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage2DMultisample (target, samples, internalformat, width, height, fixedsamplelocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexImage3DMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glTexImage3DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glTexImage3DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage3DMultisample (target, samples, internalformat, width, height, depth, fixedsamplelocations);
  }
  // GL_ARB_texture_multisample - glTexImage3DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_multisample] && glConfig.m_glTexImage3DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage3DMultisample (target, samples, internalformat, width, height, depth, fixedsamplelocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultisamplefv (GLenum pname, GLuint index, GLfloat * val)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glGetMultisamplefv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glGetMultisamplefv)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultisamplefv (pname, index, val);
  }
  // GL_ES_VERSION_3_1 - glGetMultisamplefv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glGetMultisamplefv)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultisamplefv (pname, index, val);
  }
  // GL_ARB_texture_multisample - glGetMultisamplefv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_multisample] && glConfig.m_glGetMultisamplefv)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultisamplefv (pname, index, val);
  }
  // GL_NV_explicit_multisample - glGetMultisamplefv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_explicit_multisample] && glConfig.m_glGetMultisamplefvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultisamplefvNV (pname, index, val);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSampleMaski (GLuint maskNumber, GLbitfield mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_2 - glSampleMaski
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_2] && glConfig.m_glSampleMaski)
  {
    prototypeCalled = true;
    glConfig.m_glSampleMaski (maskNumber, mask);
  }
  // GL_ES_VERSION_3_1 - glSampleMaski
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glSampleMaski)
  {
    prototypeCalled = true;
    glConfig.m_glSampleMaski (maskNumber, mask);
  }
  // GL_ARB_texture_multisample - glSampleMaski
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_multisample] && glConfig.m_glSampleMaski)
  {
    prototypeCalled = true;
    glConfig.m_glSampleMaski (maskNumber, mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindFragDataLocationIndexed (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glBindFragDataLocationIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glBindFragDataLocationIndexed)
  {
    prototypeCalled = true;
    glConfig.m_glBindFragDataLocationIndexed (program, colorNumber, index, name);
  }
  // GL_ARB_blend_func_extended - glBindFragDataLocationIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_blend_func_extended] && glConfig.m_glBindFragDataLocationIndexed)
  {
    prototypeCalled = true;
    glConfig.m_glBindFragDataLocationIndexed (program, colorNumber, index, name);
  }
  // GL_EXT_blend_func_extended - glBindFragDataLocationIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_func_extended] && glConfig.m_glBindFragDataLocationIndexedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindFragDataLocationIndexedEXT (program, colorNumber, index, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetFragDataIndex (GLuint program, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glGetFragDataIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glGetFragDataIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetFragDataIndex (program, name);
  }
  // GL_ARB_blend_func_extended - glGetFragDataIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_blend_func_extended] && glConfig.m_glGetFragDataIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetFragDataIndex (program, name);
  }
  // GL_EXT_blend_func_extended - glGetFragDataIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_func_extended] && glConfig.m_glGetFragDataIndexEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetFragDataIndexEXT (program, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenSamplers (GLsizei count, GLuint * samplers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glGenSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glGenSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glGenSamplers (count, samplers);
  }
  // GL_ES_VERSION_3_0 - glGenSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGenSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glGenSamplers (count, samplers);
  }
  // GL_ARB_sampler_objects - glGenSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glGenSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glGenSamplers (count, samplers);
  }
  // GL_MESA_sampler_objects - glGenSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects] && glConfig.m_glGenSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glGenSamplers (count, samplers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteSamplers (GLsizei count, const GLuint * samplers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glDeleteSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glDeleteSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteSamplers (count, samplers);
  }
  // GL_ES_VERSION_3_0 - glDeleteSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glDeleteSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteSamplers (count, samplers);
  }
  // GL_ARB_sampler_objects - glDeleteSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glDeleteSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteSamplers (count, samplers);
  }
  // GL_MESA_sampler_objects - glDeleteSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects] && glConfig.m_glDeleteSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteSamplers (count, samplers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsSampler (GLuint sampler)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glIsSampler
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glIsSampler)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsSampler (sampler);
  }
  // GL_ES_VERSION_3_0 - glIsSampler
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glIsSampler)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsSampler (sampler);
  }
  // GL_ARB_sampler_objects - glIsSampler
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glIsSampler)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsSampler (sampler);
  }
  // GL_MESA_sampler_objects - glIsSampler
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects] && glConfig.m_glIsSampler)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsSampler (sampler);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindSampler (GLuint unit, GLuint sampler)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glBindSampler
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glBindSampler)
  {
    prototypeCalled = true;
    glConfig.m_glBindSampler (unit, sampler);
  }
  // GL_ES_VERSION_3_0 - glBindSampler
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glBindSampler)
  {
    prototypeCalled = true;
    glConfig.m_glBindSampler (unit, sampler);
  }
  // GL_ARB_sampler_objects - glBindSampler
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glBindSampler)
  {
    prototypeCalled = true;
    glConfig.m_glBindSampler (unit, sampler);
  }
  // GL_MESA_sampler_objects - glBindSampler
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects] && glConfig.m_glBindSampler)
  {
    prototypeCalled = true;
    glConfig.m_glBindSampler (unit, sampler);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplerParameteri (GLuint sampler, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glSamplerParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glSamplerParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameteri (sampler, pname, param);
  }
  // GL_ES_VERSION_3_0 - glSamplerParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glSamplerParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameteri (sampler, pname, param);
  }
  // GL_ARB_sampler_objects - glSamplerParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glSamplerParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameteri (sampler, pname, param);
  }
  // GL_MESA_sampler_objects - glSamplerParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects] && glConfig.m_glSamplerParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameteri (sampler, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplerParameteriv (GLuint sampler, GLenum pname, const GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glSamplerParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glSamplerParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameteriv (sampler, pname, param);
  }
  // GL_ES_VERSION_3_0 - glSamplerParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glSamplerParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameteriv (sampler, pname, param);
  }
  // GL_ARB_sampler_objects - glSamplerParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glSamplerParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameteriv (sampler, pname, param);
  }
  // GL_MESA_sampler_objects - glSamplerParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects] && glConfig.m_glSamplerParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameteriv (sampler, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplerParameterf (GLuint sampler, GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glSamplerParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glSamplerParameterf)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterf (sampler, pname, param);
  }
  // GL_ES_VERSION_3_0 - glSamplerParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glSamplerParameterf)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterf (sampler, pname, param);
  }
  // GL_ARB_sampler_objects - glSamplerParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glSamplerParameterf)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterf (sampler, pname, param);
  }
  // GL_MESA_sampler_objects - glSamplerParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects] && glConfig.m_glSamplerParameterf)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterf (sampler, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplerParameterfv (GLuint sampler, GLenum pname, const GLfloat * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glSamplerParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glSamplerParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterfv (sampler, pname, param);
  }
  // GL_ES_VERSION_3_0 - glSamplerParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glSamplerParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterfv (sampler, pname, param);
  }
  // GL_ARB_sampler_objects - glSamplerParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glSamplerParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterfv (sampler, pname, param);
  }
  // GL_MESA_sampler_objects - glSamplerParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects] && glConfig.m_glSamplerParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterfv (sampler, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplerParameterIiv (GLuint sampler, GLenum pname, const GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glSamplerParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glSamplerParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIiv (sampler, pname, param);
  }
  // GL_ES_VERSION_3_2 - glSamplerParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glSamplerParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIiv (sampler, pname, param);
  }
  // GL_ARB_sampler_objects - glSamplerParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glSamplerParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIiv (sampler, pname, param);
  }
  // GL_EXT_texture_border_clamp - glSamplerParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glSamplerParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIivEXT (sampler, pname, param);
  }
  // GL_OES_texture_border_clamp - glSamplerParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glSamplerParameterIivOES)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIivOES (sampler, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplerParameterIuiv (GLuint sampler, GLenum pname, const GLuint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glSamplerParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glSamplerParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIuiv (sampler, pname, param);
  }
  // GL_ES_VERSION_3_2 - glSamplerParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glSamplerParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIuiv (sampler, pname, param);
  }
  // GL_ARB_sampler_objects - glSamplerParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glSamplerParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIuiv (sampler, pname, param);
  }
  // GL_EXT_texture_border_clamp - glSamplerParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glSamplerParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIuivEXT (sampler, pname, param);
  }
  // GL_OES_texture_border_clamp - glSamplerParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glSamplerParameterIuivOES)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIuivOES (sampler, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSamplerParameteriv (GLuint sampler, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glGetSamplerParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glGetSamplerParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameteriv (sampler, pname, params);
  }
  // GL_ES_VERSION_3_0 - glGetSamplerParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetSamplerParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameteriv (sampler, pname, params);
  }
  // GL_ARB_sampler_objects - glGetSamplerParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glGetSamplerParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameteriv (sampler, pname, params);
  }
  // GL_MESA_sampler_objects - glGetSamplerParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects] && glConfig.m_glGetSamplerParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameteriv (sampler, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSamplerParameterIiv (GLuint sampler, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glGetSamplerParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glGetSamplerParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIiv (sampler, pname, params);
  }
  // GL_ES_VERSION_3_2 - glGetSamplerParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetSamplerParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIiv (sampler, pname, params);
  }
  // GL_ARB_sampler_objects - glGetSamplerParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glGetSamplerParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIiv (sampler, pname, params);
  }
  // GL_EXT_texture_border_clamp - glGetSamplerParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glGetSamplerParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIivEXT (sampler, pname, params);
  }
  // GL_OES_texture_border_clamp - glGetSamplerParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glGetSamplerParameterIivOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIivOES (sampler, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSamplerParameterfv (GLuint sampler, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glGetSamplerParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glGetSamplerParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterfv (sampler, pname, params);
  }
  // GL_ES_VERSION_3_0 - glGetSamplerParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetSamplerParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterfv (sampler, pname, params);
  }
  // GL_ARB_sampler_objects - glGetSamplerParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glGetSamplerParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterfv (sampler, pname, params);
  }
  // GL_MESA_sampler_objects - glGetSamplerParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects] && glConfig.m_glGetSamplerParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterfv (sampler, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSamplerParameterIuiv (GLuint sampler, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glGetSamplerParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glGetSamplerParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIuiv (sampler, pname, params);
  }
  // GL_ES_VERSION_3_2 - glGetSamplerParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetSamplerParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIuiv (sampler, pname, params);
  }
  // GL_ARB_sampler_objects - glGetSamplerParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] && glConfig.m_glGetSamplerParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIuiv (sampler, pname, params);
  }
  // GL_EXT_texture_border_clamp - glGetSamplerParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glGetSamplerParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIuivEXT (sampler, pname, params);
  }
  // GL_OES_texture_border_clamp - glGetSamplerParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glGetSamplerParameterIuivOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIuivOES (sampler, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glQueryCounter (GLuint id, GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glQueryCounter
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glQueryCounter)
  {
    prototypeCalled = true;
    glConfig.m_glQueryCounter (id, target);
  }
  // GL_ARB_timer_query - glQueryCounter
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_timer_query] && glConfig.m_glQueryCounter)
  {
    prototypeCalled = true;
    glConfig.m_glQueryCounter (id, target);
  }
  // GL_EXT_disjoint_timer_query - glQueryCounter
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glQueryCounterEXT)
  {
    prototypeCalled = true;
    glConfig.m_glQueryCounterEXT (id, target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryObjecti64v (GLuint id, GLenum pname, GLint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glGetQueryObjecti64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glGetQueryObjecti64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjecti64v (id, pname, params);
  }
  // GL_ARB_timer_query - glGetQueryObjecti64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_timer_query] && glConfig.m_glGetQueryObjecti64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjecti64v (id, pname, params);
  }
  // GL_EXT_disjoint_timer_query - glGetQueryObjecti64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glGetQueryObjecti64vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjecti64vEXT (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryObjectui64v (GLuint id, GLenum pname, GLuint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glGetQueryObjectui64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glGetQueryObjectui64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectui64v (id, pname, params);
  }
  // GL_ARB_timer_query - glGetQueryObjectui64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_timer_query] && glConfig.m_glGetQueryObjectui64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectui64v (id, pname, params);
  }
  // GL_EXT_disjoint_timer_query - glGetQueryObjectui64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glGetQueryObjectui64vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectui64vEXT (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribDivisor (GLuint index, GLuint divisor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexAttribDivisor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexAttribDivisor)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribDivisor (index, divisor);
  }
  // GL_ES_VERSION_3_0 - glVertexAttribDivisor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glVertexAttribDivisor)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribDivisor (index, divisor);
  }
  // GL_ANGLE_instanced_arrays - glVertexAttribDivisor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ANGLE_instanced_arrays] && glConfig.m_glVertexAttribDivisorANGLE)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribDivisorANGLE (index, divisor);
  }
  // GL_ARB_instanced_arrays - glVertexAttribDivisor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_instanced_arrays] && glConfig.m_glVertexAttribDivisorARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribDivisorARB (index, divisor);
  }
  // GL_EXT_instanced_arrays - glVertexAttribDivisor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_instanced_arrays] && glConfig.m_glVertexAttribDivisorEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribDivisorEXT (index, divisor);
  }
  // GL_NV_instanced_arrays - glVertexAttribDivisor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_instanced_arrays] && glConfig.m_glVertexAttribDivisorNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribDivisorNV (index, divisor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribP1ui (GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexAttribP1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexAttribP1ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP1ui (index, type, normalized, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexAttribP1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexAttribP1ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP1ui (index, type, normalized, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribP1uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexAttribP1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexAttribP1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP1uiv (index, type, normalized, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexAttribP1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexAttribP1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP1uiv (index, type, normalized, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribP2ui (GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexAttribP2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexAttribP2ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP2ui (index, type, normalized, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexAttribP2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexAttribP2ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP2ui (index, type, normalized, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribP2uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexAttribP2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexAttribP2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP2uiv (index, type, normalized, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexAttribP2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexAttribP2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP2uiv (index, type, normalized, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribP3ui (GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexAttribP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexAttribP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP3ui (index, type, normalized, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexAttribP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexAttribP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP3ui (index, type, normalized, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribP3uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexAttribP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexAttribP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP3uiv (index, type, normalized, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexAttribP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexAttribP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP3uiv (index, type, normalized, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribP4ui (GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexAttribP4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexAttribP4ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP4ui (index, type, normalized, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexAttribP4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexAttribP4ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP4ui (index, type, normalized, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribP4uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexAttribP4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexAttribP4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP4uiv (index, type, normalized, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexAttribP4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexAttribP4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribP4uiv (index, type, normalized, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexP2ui (GLenum type, GLuint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexP2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexP2ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP2ui (type, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexP2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexP2ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP2ui (type, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexP2uiv (GLenum type, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexP2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexP2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP2uiv (type, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexP2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexP2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP2uiv (type, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexP3ui (GLenum type, GLuint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP3ui (type, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP3ui (type, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexP3uiv (GLenum type, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP3uiv (type, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP3uiv (type, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexP4ui (GLenum type, GLuint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexP4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexP4ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP4ui (type, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexP4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexP4ui)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP4ui (type, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexP4uiv (GLenum type, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glVertexP4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glVertexP4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP4uiv (type, value);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glVertexP4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glVertexP4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexP4uiv (type, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordP1ui (GLenum type, GLuint coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glTexCoordP1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glTexCoordP1ui)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP1ui (type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glTexCoordP1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glTexCoordP1ui)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP1ui (type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordP1uiv (GLenum type, const GLuint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glTexCoordP1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glTexCoordP1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP1uiv (type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glTexCoordP1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glTexCoordP1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP1uiv (type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordP2ui (GLenum type, GLuint coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glTexCoordP2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glTexCoordP2ui)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP2ui (type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glTexCoordP2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glTexCoordP2ui)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP2ui (type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordP2uiv (GLenum type, const GLuint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glTexCoordP2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glTexCoordP2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP2uiv (type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glTexCoordP2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glTexCoordP2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP2uiv (type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordP3ui (GLenum type, GLuint coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glTexCoordP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glTexCoordP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP3ui (type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glTexCoordP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glTexCoordP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP3ui (type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordP3uiv (GLenum type, const GLuint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glTexCoordP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glTexCoordP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP3uiv (type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glTexCoordP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glTexCoordP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP3uiv (type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordP4ui (GLenum type, GLuint coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glTexCoordP4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glTexCoordP4ui)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP4ui (type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glTexCoordP4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glTexCoordP4ui)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP4ui (type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordP4uiv (GLenum type, const GLuint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glTexCoordP4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glTexCoordP4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP4uiv (type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glTexCoordP4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glTexCoordP4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordP4uiv (type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoordP1ui (GLenum texture, GLenum type, GLuint coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glMultiTexCoordP1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glMultiTexCoordP1ui)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP1ui (texture, type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glMultiTexCoordP1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glMultiTexCoordP1ui)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP1ui (texture, type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoordP1uiv (GLenum texture, GLenum type, const GLuint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glMultiTexCoordP1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glMultiTexCoordP1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP1uiv (texture, type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glMultiTexCoordP1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glMultiTexCoordP1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP1uiv (texture, type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoordP2ui (GLenum texture, GLenum type, GLuint coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glMultiTexCoordP2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glMultiTexCoordP2ui)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP2ui (texture, type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glMultiTexCoordP2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glMultiTexCoordP2ui)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP2ui (texture, type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoordP2uiv (GLenum texture, GLenum type, const GLuint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glMultiTexCoordP2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glMultiTexCoordP2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP2uiv (texture, type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glMultiTexCoordP2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glMultiTexCoordP2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP2uiv (texture, type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoordP3ui (GLenum texture, GLenum type, GLuint coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glMultiTexCoordP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glMultiTexCoordP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP3ui (texture, type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glMultiTexCoordP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glMultiTexCoordP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP3ui (texture, type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoordP3uiv (GLenum texture, GLenum type, const GLuint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glMultiTexCoordP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glMultiTexCoordP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP3uiv (texture, type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glMultiTexCoordP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glMultiTexCoordP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP3uiv (texture, type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoordP4ui (GLenum texture, GLenum type, GLuint coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glMultiTexCoordP4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glMultiTexCoordP4ui)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP4ui (texture, type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glMultiTexCoordP4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glMultiTexCoordP4ui)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP4ui (texture, type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoordP4uiv (GLenum texture, GLenum type, const GLuint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glMultiTexCoordP4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glMultiTexCoordP4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP4uiv (texture, type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glMultiTexCoordP4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glMultiTexCoordP4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordP4uiv (texture, type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalP3ui (GLenum type, GLuint coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glNormalP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glNormalP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glNormalP3ui (type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glNormalP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glNormalP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glNormalP3ui (type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalP3uiv (GLenum type, const GLuint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glNormalP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glNormalP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glNormalP3uiv (type, coords);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glNormalP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glNormalP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glNormalP3uiv (type, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorP3ui (GLenum type, GLuint color)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glColorP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glColorP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glColorP3ui (type, color);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glColorP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glColorP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glColorP3ui (type, color);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorP3uiv (GLenum type, const GLuint * color)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glColorP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glColorP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glColorP3uiv (type, color);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glColorP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glColorP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glColorP3uiv (type, color);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorP4ui (GLenum type, GLuint color)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glColorP4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glColorP4ui)
  {
    prototypeCalled = true;
    glConfig.m_glColorP4ui (type, color);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glColorP4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glColorP4ui)
  {
    prototypeCalled = true;
    glConfig.m_glColorP4ui (type, color);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorP4uiv (GLenum type, const GLuint * color)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glColorP4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glColorP4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glColorP4uiv (type, color);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glColorP4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glColorP4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glColorP4uiv (type, color);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColorP3ui (GLenum type, GLuint color)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glSecondaryColorP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glSecondaryColorP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColorP3ui (type, color);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glSecondaryColorP3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glSecondaryColorP3ui)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColorP3ui (type, color);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColorP3uiv (GLenum type, const GLuint * color)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_3_3 - glSecondaryColorP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_3_3] && glConfig.m_glSecondaryColorP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColorP3uiv (type, color);
  }
  // GL_ARB_vertex_type_2_10_10_10_rev - glSecondaryColorP3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] && glConfig.m_glSecondaryColorP3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColorP3uiv (type, color);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMinSampleShading (GLfloat value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glMinSampleShading
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glMinSampleShading)
  {
    prototypeCalled = true;
    glConfig.m_glMinSampleShading (value);
  }
  // GL_ES_VERSION_3_2 - glMinSampleShading
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glMinSampleShading)
  {
    prototypeCalled = true;
    glConfig.m_glMinSampleShading (value);
  }
  // GL_ARB_sample_shading - glMinSampleShading
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sample_shading] && glConfig.m_glMinSampleShadingARB)
  {
    prototypeCalled = true;
    glConfig.m_glMinSampleShadingARB (value);
  }
  // GL_OES_sample_shading - glMinSampleShading
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_sample_shading] && glConfig.m_glMinSampleShadingOES)
  {
    prototypeCalled = true;
    glConfig.m_glMinSampleShadingOES (value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationi (GLuint buf, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glBlendEquationi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glBlendEquationi)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationi (buf, mode);
  }
  // GL_ES_VERSION_3_2 - glBlendEquationi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glBlendEquationi)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationi (buf, mode);
  }
  // GL_EXT_draw_buffers_indexed - glBlendEquationi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glBlendEquationiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationiEXT (buf, mode);
  }
  // GL_OES_draw_buffers_indexed - glBlendEquationi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glBlendEquationiOES)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationiOES (buf, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationSeparatei (GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glBlendEquationSeparatei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glBlendEquationSeparatei)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparatei (buf, modeRGB, modeAlpha);
  }
  // GL_ES_VERSION_3_2 - glBlendEquationSeparatei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glBlendEquationSeparatei)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparatei (buf, modeRGB, modeAlpha);
  }
  // GL_EXT_draw_buffers_indexed - glBlendEquationSeparatei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glBlendEquationSeparateiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparateiEXT (buf, modeRGB, modeAlpha);
  }
  // GL_OES_draw_buffers_indexed - glBlendEquationSeparatei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glBlendEquationSeparateiOES)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparateiOES (buf, modeRGB, modeAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFunci (GLuint buf, GLenum src, GLenum dst)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glBlendFunci
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glBlendFunci)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFunci (buf, src, dst);
  }
  // GL_ES_VERSION_3_2 - glBlendFunci
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glBlendFunci)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFunci (buf, src, dst);
  }
  // GL_EXT_draw_buffers_indexed - glBlendFunci
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glBlendFunciEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFunciEXT (buf, src, dst);
  }
  // GL_OES_draw_buffers_indexed - glBlendFunci
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glBlendFunciOES)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFunciOES (buf, src, dst);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFuncSeparatei (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glBlendFuncSeparatei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glBlendFuncSeparatei)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparatei (buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  // GL_ES_VERSION_3_2 - glBlendFuncSeparatei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glBlendFuncSeparatei)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparatei (buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  // GL_EXT_draw_buffers_indexed - glBlendFuncSeparatei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glBlendFuncSeparateiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparateiEXT (buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  // GL_OES_draw_buffers_indexed - glBlendFuncSeparatei
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glBlendFuncSeparateiOES)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparateiOES (buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawArraysIndirect (GLenum mode, const void * indirect)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glDrawArraysIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glDrawArraysIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysIndirect (mode, indirect);
  }
  // GL_ES_VERSION_3_1 - glDrawArraysIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glDrawArraysIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysIndirect (mode, indirect);
  }
  // GL_ARB_draw_indirect - glDrawArraysIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_indirect] && glConfig.m_glDrawArraysIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysIndirect (mode, indirect);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsIndirect (GLenum mode, GLenum type, const void * indirect)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glDrawElementsIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glDrawElementsIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsIndirect (mode, type, indirect);
  }
  // GL_ES_VERSION_3_1 - glDrawElementsIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glDrawElementsIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsIndirect (mode, type, indirect);
  }
  // GL_ARB_draw_indirect - glDrawElementsIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_indirect] && glConfig.m_glDrawElementsIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsIndirect (mode, type, indirect);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1d (GLint location, GLdouble x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniform1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniform1d)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1d (location, x);
  }
  // GL_ARB_gpu_shader_fp64 - glUniform1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniform1d)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1d (location, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2d (GLint location, GLdouble x, GLdouble y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniform2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniform2d)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2d (location, x, y);
  }
  // GL_ARB_gpu_shader_fp64 - glUniform2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniform2d)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2d (location, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3d (GLint location, GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniform3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniform3d)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3d (location, x, y, z);
  }
  // GL_ARB_gpu_shader_fp64 - glUniform3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniform3d)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3d (location, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4d (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniform4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniform4d)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4d (location, x, y, z, w);
  }
  // GL_ARB_gpu_shader_fp64 - glUniform4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniform4d)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4d (location, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1dv (GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniform1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniform1dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1dv (location, count, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniform1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniform1dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1dv (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2dv (GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniform2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniform2dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2dv (location, count, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniform2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniform2dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2dv (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3dv (GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniform3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniform3dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3dv (location, count, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniform3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniform3dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3dv (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4dv (GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniform4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniform4dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4dv (location, count, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniform4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniform4dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4dv (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix2dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniformMatrix2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniformMatrix2dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2dv (location, count, transpose, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniformMatrix2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniformMatrix2dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2dv (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix3dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniformMatrix3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniformMatrix3dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3dv (location, count, transpose, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniformMatrix3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniformMatrix3dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3dv (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix4dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniformMatrix4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniformMatrix4dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4dv (location, count, transpose, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniformMatrix4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniformMatrix4dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4dv (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix2x3dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniformMatrix2x3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniformMatrix2x3dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x3dv (location, count, transpose, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniformMatrix2x3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniformMatrix2x3dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x3dv (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix2x4dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniformMatrix2x4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniformMatrix2x4dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x4dv (location, count, transpose, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniformMatrix2x4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniformMatrix2x4dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x4dv (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix3x2dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniformMatrix3x2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniformMatrix3x2dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x2dv (location, count, transpose, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniformMatrix3x2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniformMatrix3x2dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x2dv (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix3x4dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniformMatrix3x4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniformMatrix3x4dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x4dv (location, count, transpose, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniformMatrix3x4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniformMatrix3x4dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x4dv (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix4x2dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniformMatrix4x2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniformMatrix4x2dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x2dv (location, count, transpose, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniformMatrix4x2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniformMatrix4x2dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x2dv (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix4x3dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniformMatrix4x3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniformMatrix4x3dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x3dv (location, count, transpose, value);
  }
  // GL_ARB_gpu_shader_fp64 - glUniformMatrix4x3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glUniformMatrix4x3dv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x3dv (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformdv (GLuint program, GLint location, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glGetUniformdv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glGetUniformdv)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformdv (program, location, params);
  }
  // GL_ARB_gpu_shader_fp64 - glGetUniformdv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] && glConfig.m_glGetUniformdv)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformdv (program, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetSubroutineUniformLocation (GLuint program, GLenum shadertype, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glGetSubroutineUniformLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glGetSubroutineUniformLocation)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetSubroutineUniformLocation (program, shadertype, name);
  }
  // GL_ARB_shader_subroutine - glGetSubroutineUniformLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_subroutine] && glConfig.m_glGetSubroutineUniformLocation)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetSubroutineUniformLocation (program, shadertype, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGetSubroutineIndex (GLuint program, GLenum shadertype, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glGetSubroutineIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glGetSubroutineIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetSubroutineIndex (program, shadertype, name);
  }
  // GL_ARB_shader_subroutine - glGetSubroutineIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_subroutine] && glConfig.m_glGetSubroutineIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetSubroutineIndex (program, shadertype, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveSubroutineUniformiv (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glGetActiveSubroutineUniformiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glGetActiveSubroutineUniformiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveSubroutineUniformiv (program, shadertype, index, pname, values);
  }
  // GL_ARB_shader_subroutine - glGetActiveSubroutineUniformiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_subroutine] && glConfig.m_glGetActiveSubroutineUniformiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveSubroutineUniformiv (program, shadertype, index, pname, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveSubroutineUniformName (GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glGetActiveSubroutineUniformName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glGetActiveSubroutineUniformName)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveSubroutineUniformName (program, shadertype, index, bufSize, length, name);
  }
  // GL_ARB_shader_subroutine - glGetActiveSubroutineUniformName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_subroutine] && glConfig.m_glGetActiveSubroutineUniformName)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveSubroutineUniformName (program, shadertype, index, bufSize, length, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveSubroutineName (GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glGetActiveSubroutineName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glGetActiveSubroutineName)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveSubroutineName (program, shadertype, index, bufSize, length, name);
  }
  // GL_ARB_shader_subroutine - glGetActiveSubroutineName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_subroutine] && glConfig.m_glGetActiveSubroutineName)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveSubroutineName (program, shadertype, index, bufSize, length, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformSubroutinesuiv (GLenum shadertype, GLsizei count, const GLuint * indices)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glUniformSubroutinesuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glUniformSubroutinesuiv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformSubroutinesuiv (shadertype, count, indices);
  }
  // GL_ARB_shader_subroutine - glUniformSubroutinesuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_subroutine] && glConfig.m_glUniformSubroutinesuiv)
  {
    prototypeCalled = true;
    glConfig.m_glUniformSubroutinesuiv (shadertype, count, indices);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformSubroutineuiv (GLenum shadertype, GLint location, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glGetUniformSubroutineuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glGetUniformSubroutineuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformSubroutineuiv (shadertype, location, params);
  }
  // GL_ARB_shader_subroutine - glGetUniformSubroutineuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_subroutine] && glConfig.m_glGetUniformSubroutineuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformSubroutineuiv (shadertype, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramStageiv (GLuint program, GLenum shadertype, GLenum pname, GLint * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glGetProgramStageiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glGetProgramStageiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramStageiv (program, shadertype, pname, values);
  }
  // GL_ARB_shader_subroutine - glGetProgramStageiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_subroutine] && glConfig.m_glGetProgramStageiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramStageiv (program, shadertype, pname, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPatchParameteri (GLenum pname, GLint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glPatchParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glPatchParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glPatchParameteri (pname, value);
  }
  // GL_ES_VERSION_3_2 - glPatchParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glPatchParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glPatchParameteri (pname, value);
  }
  // GL_ARB_tessellation_shader - glPatchParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_tessellation_shader] && glConfig.m_glPatchParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glPatchParameteri (pname, value);
  }
  // GL_EXT_tessellation_shader - glPatchParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_tessellation_shader] && glConfig.m_glPatchParameteriEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPatchParameteriEXT (pname, value);
  }
  // GL_OES_tessellation_shader - glPatchParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_tessellation_shader] && glConfig.m_glPatchParameteriOES)
  {
    prototypeCalled = true;
    glConfig.m_glPatchParameteriOES (pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPatchParameterfv (GLenum pname, const GLfloat * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glPatchParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glPatchParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glPatchParameterfv (pname, values);
  }
  // GL_ARB_tessellation_shader - glPatchParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_tessellation_shader] && glConfig.m_glPatchParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glPatchParameterfv (pname, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindTransformFeedback (GLenum target, GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glBindTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glBindTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glBindTransformFeedback (target, id);
  }
  // GL_ES_VERSION_3_0 - glBindTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glBindTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glBindTransformFeedback (target, id);
  }
  // GL_ARB_transform_feedback2 - glBindTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback2] && glConfig.m_glBindTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glBindTransformFeedback (target, id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteTransformFeedbacks (GLsizei n, const GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glDeleteTransformFeedbacks
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glDeleteTransformFeedbacks)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteTransformFeedbacks (n, ids);
  }
  // GL_ES_VERSION_3_0 - glDeleteTransformFeedbacks
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glDeleteTransformFeedbacks)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteTransformFeedbacks (n, ids);
  }
  // GL_ARB_transform_feedback2 - glDeleteTransformFeedbacks
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback2] && glConfig.m_glDeleteTransformFeedbacks)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteTransformFeedbacks (n, ids);
  }
  // GL_NV_transform_feedback2 - glDeleteTransformFeedbacks
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glDeleteTransformFeedbacksNV)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteTransformFeedbacksNV (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenTransformFeedbacks (GLsizei n, GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glGenTransformFeedbacks
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glGenTransformFeedbacks)
  {
    prototypeCalled = true;
    glConfig.m_glGenTransformFeedbacks (n, ids);
  }
  // GL_ES_VERSION_3_0 - glGenTransformFeedbacks
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGenTransformFeedbacks)
  {
    prototypeCalled = true;
    glConfig.m_glGenTransformFeedbacks (n, ids);
  }
  // GL_ARB_transform_feedback2 - glGenTransformFeedbacks
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback2] && glConfig.m_glGenTransformFeedbacks)
  {
    prototypeCalled = true;
    glConfig.m_glGenTransformFeedbacks (n, ids);
  }
  // GL_NV_transform_feedback2 - glGenTransformFeedbacks
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glGenTransformFeedbacksNV)
  {
    prototypeCalled = true;
    glConfig.m_glGenTransformFeedbacksNV (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsTransformFeedback (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glIsTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glIsTransformFeedback)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsTransformFeedback (id);
  }
  // GL_ES_VERSION_3_0 - glIsTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glIsTransformFeedback)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsTransformFeedback (id);
  }
  // GL_ARB_transform_feedback2 - glIsTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback2] && glConfig.m_glIsTransformFeedback)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsTransformFeedback (id);
  }
  // GL_NV_transform_feedback2 - glIsTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glIsTransformFeedbackNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsTransformFeedbackNV (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPauseTransformFeedback ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glPauseTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glPauseTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glPauseTransformFeedback ();
  }
  // GL_ES_VERSION_3_0 - glPauseTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glPauseTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glPauseTransformFeedback ();
  }
  // GL_ARB_transform_feedback2 - glPauseTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback2] && glConfig.m_glPauseTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glPauseTransformFeedback ();
  }
  // GL_NV_transform_feedback2 - glPauseTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glPauseTransformFeedbackNV)
  {
    prototypeCalled = true;
    glConfig.m_glPauseTransformFeedbackNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glResumeTransformFeedback ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glResumeTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glResumeTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glResumeTransformFeedback ();
  }
  // GL_ES_VERSION_3_0 - glResumeTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glResumeTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glResumeTransformFeedback ();
  }
  // GL_ARB_transform_feedback2 - glResumeTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback2] && glConfig.m_glResumeTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glResumeTransformFeedback ();
  }
  // GL_NV_transform_feedback2 - glResumeTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glResumeTransformFeedbackNV)
  {
    prototypeCalled = true;
    glConfig.m_glResumeTransformFeedbackNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawTransformFeedback (GLenum mode, GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glDrawTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glDrawTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedback (mode, id);
  }
  // GL_ARB_transform_feedback2 - glDrawTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback2] && glConfig.m_glDrawTransformFeedback)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedback (mode, id);
  }
  // GL_NV_transform_feedback2 - glDrawTransformFeedback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glDrawTransformFeedbackNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedbackNV (mode, id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawTransformFeedbackStream (GLenum mode, GLuint id, GLuint stream)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glDrawTransformFeedbackStream
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glDrawTransformFeedbackStream)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedbackStream (mode, id, stream);
  }
  // GL_ARB_transform_feedback3 - glDrawTransformFeedbackStream
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback3] && glConfig.m_glDrawTransformFeedbackStream)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedbackStream (mode, id, stream);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginQueryIndexed (GLenum target, GLuint index, GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glBeginQueryIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glBeginQueryIndexed)
  {
    prototypeCalled = true;
    glConfig.m_glBeginQueryIndexed (target, index, id);
  }
  // GL_ARB_transform_feedback3 - glBeginQueryIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback3] && glConfig.m_glBeginQueryIndexed)
  {
    prototypeCalled = true;
    glConfig.m_glBeginQueryIndexed (target, index, id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndQueryIndexed (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glEndQueryIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glEndQueryIndexed)
  {
    prototypeCalled = true;
    glConfig.m_glEndQueryIndexed (target, index);
  }
  // GL_ARB_transform_feedback3 - glEndQueryIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback3] && glConfig.m_glEndQueryIndexed)
  {
    prototypeCalled = true;
    glConfig.m_glEndQueryIndexed (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryIndexediv (GLenum target, GLuint index, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_0 - glGetQueryIndexediv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_0] && glConfig.m_glGetQueryIndexediv)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryIndexediv (target, index, pname, params);
  }
  // GL_ARB_transform_feedback3 - glGetQueryIndexediv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback3] && glConfig.m_glGetQueryIndexediv)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryIndexediv (target, index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReleaseShaderCompiler ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glReleaseShaderCompiler
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glReleaseShaderCompiler)
  {
    prototypeCalled = true;
    glConfig.m_glReleaseShaderCompiler ();
  }
  // GL_ES_VERSION_2_0 - glReleaseShaderCompiler
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glReleaseShaderCompiler)
  {
    prototypeCalled = true;
    glConfig.m_glReleaseShaderCompiler ();
  }
  // GL_ARB_ES2_compatibility - glReleaseShaderCompiler
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_ES2_compatibility] && glConfig.m_glReleaseShaderCompiler)
  {
    prototypeCalled = true;
    glConfig.m_glReleaseShaderCompiler ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShaderBinary (GLsizei count, const GLuint * shaders, GLenum binaryFormat, const void * binary, GLsizei length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glShaderBinary
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glShaderBinary)
  {
    prototypeCalled = true;
    glConfig.m_glShaderBinary (count, shaders, binaryFormat, binary, length);
  }
  // GL_ES_VERSION_2_0 - glShaderBinary
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glShaderBinary)
  {
    prototypeCalled = true;
    glConfig.m_glShaderBinary (count, shaders, binaryFormat, binary, length);
  }
  // GL_ARB_ES2_compatibility - glShaderBinary
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_ES2_compatibility] && glConfig.m_glShaderBinary)
  {
    prototypeCalled = true;
    glConfig.m_glShaderBinary (count, shaders, binaryFormat, binary, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetShaderPrecisionFormat (GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glGetShaderPrecisionFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glGetShaderPrecisionFormat)
  {
    prototypeCalled = true;
    glConfig.m_glGetShaderPrecisionFormat (shadertype, precisiontype, range, precision);
  }
  // GL_ES_VERSION_2_0 - glGetShaderPrecisionFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glGetShaderPrecisionFormat)
  {
    prototypeCalled = true;
    glConfig.m_glGetShaderPrecisionFormat (shadertype, precisiontype, range, precision);
  }
  // GL_ARB_ES2_compatibility - glGetShaderPrecisionFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_ES2_compatibility] && glConfig.m_glGetShaderPrecisionFormat)
  {
    prototypeCalled = true;
    glConfig.m_glGetShaderPrecisionFormat (shadertype, precisiontype, range, precision);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangef (GLfloat n, GLfloat f)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glDepthRangef
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glDepthRangef)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangef (n, f);
  }
  // GL_ES_VERSION_2_0 - glDepthRangef
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glDepthRangef)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangef (n, f);
  }
  // GL_ARB_ES2_compatibility - glDepthRangef
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_ES2_compatibility] && glConfig.m_glDepthRangef)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangef (n, f);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearDepthf (GLfloat d)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glClearDepthf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glClearDepthf)
  {
    prototypeCalled = true;
    glConfig.m_glClearDepthf (d);
  }
  // GL_ES_VERSION_2_0 - glClearDepthf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] && glConfig.m_glClearDepthf)
  {
    prototypeCalled = true;
    glConfig.m_glClearDepthf (d);
  }
  // GL_ARB_ES2_compatibility - glClearDepthf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_ES2_compatibility] && glConfig.m_glClearDepthf)
  {
    prototypeCalled = true;
    glConfig.m_glClearDepthf (d);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramBinary (GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, void * binary)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glGetProgramBinary
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glGetProgramBinary)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramBinary (program, bufSize, length, binaryFormat, binary);
  }
  // GL_ES_VERSION_3_0 - glGetProgramBinary
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetProgramBinary)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramBinary (program, bufSize, length, binaryFormat, binary);
  }
  // GL_ARB_get_program_binary - glGetProgramBinary
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_get_program_binary] && glConfig.m_glGetProgramBinary)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramBinary (program, bufSize, length, binaryFormat, binary);
  }
  // GL_OES_get_program_binary - glGetProgramBinary
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_get_program_binary] && glConfig.m_glGetProgramBinaryOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramBinaryOES (program, bufSize, length, binaryFormat, binary);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramBinary (GLuint program, GLenum binaryFormat, const void * binary, GLsizei length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramBinary
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramBinary)
  {
    prototypeCalled = true;
    glConfig.m_glProgramBinary (program, binaryFormat, binary, length);
  }
  // GL_ES_VERSION_3_0 - glProgramBinary
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glProgramBinary)
  {
    prototypeCalled = true;
    glConfig.m_glProgramBinary (program, binaryFormat, binary, length);
  }
  // GL_ARB_get_program_binary - glProgramBinary
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_get_program_binary] && glConfig.m_glProgramBinary)
  {
    prototypeCalled = true;
    glConfig.m_glProgramBinary (program, binaryFormat, binary, length);
  }
  // GL_OES_get_program_binary - glProgramBinary
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_get_program_binary] && glConfig.m_glProgramBinaryOES)
  {
    prototypeCalled = true;
    glConfig.m_glProgramBinaryOES (program, binaryFormat, binary, (GLint) length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramParameteri (GLuint program, GLenum pname, GLint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameteri (program, pname, value);
  }
  // GL_VERSION_4_1 - glProgramParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameteri (program, pname, value);
  }
  // GL_ES_VERSION_3_0 - glProgramParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glProgramParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameteri (program, pname, value);
  }
  // GL_ARB_get_program_binary - glProgramParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_get_program_binary] && glConfig.m_glProgramParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameteri (program, pname, value);
  }
  // GL_ARB_separate_shader_objects - glProgramParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameteri (program, pname, value);
  }
  // GL_ARB_geometry_shader4 - glProgramParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_geometry_shader4] && glConfig.m_glProgramParameteriARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameteriARB (program, pname, value);
  }
  // GL_EXT_geometry_shader4 - glProgramParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_geometry_shader4] && glConfig.m_glProgramParameteriEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameteriEXT (program, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUseProgramStages (GLuint pipeline, GLbitfield stages, GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glUseProgramStages
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glUseProgramStages)
  {
    prototypeCalled = true;
    glConfig.m_glUseProgramStages (pipeline, stages, program);
  }
  // GL_ES_VERSION_3_1 - glUseProgramStages
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glUseProgramStages)
  {
    prototypeCalled = true;
    glConfig.m_glUseProgramStages (pipeline, stages, program);
  }
  // GL_ARB_separate_shader_objects - glUseProgramStages
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glUseProgramStages)
  {
    prototypeCalled = true;
    glConfig.m_glUseProgramStages (pipeline, stages, program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glActiveShaderProgram (GLuint pipeline, GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glActiveShaderProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glActiveShaderProgram)
  {
    prototypeCalled = true;
    glConfig.m_glActiveShaderProgram (pipeline, program);
  }
  // GL_ES_VERSION_3_1 - glActiveShaderProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glActiveShaderProgram)
  {
    prototypeCalled = true;
    glConfig.m_glActiveShaderProgram (pipeline, program);
  }
  // GL_ARB_separate_shader_objects - glActiveShaderProgram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glActiveShaderProgram)
  {
    prototypeCalled = true;
    glConfig.m_glActiveShaderProgram (pipeline, program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glCreateShaderProgramv (GLenum type, GLsizei count, const GLchar *const* strings)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glCreateShaderProgramv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glCreateShaderProgramv)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateShaderProgramv (type, count, strings);
  }
  // GL_ES_VERSION_3_1 - glCreateShaderProgramv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glCreateShaderProgramv)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateShaderProgramv (type, count, strings);
  }
  // GL_ARB_separate_shader_objects - glCreateShaderProgramv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glCreateShaderProgramv)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateShaderProgramv (type, count, strings);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindProgramPipeline (GLuint pipeline)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glBindProgramPipeline
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glBindProgramPipeline)
  {
    prototypeCalled = true;
    glConfig.m_glBindProgramPipeline (pipeline);
  }
  // GL_ES_VERSION_3_1 - glBindProgramPipeline
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glBindProgramPipeline)
  {
    prototypeCalled = true;
    glConfig.m_glBindProgramPipeline (pipeline);
  }
  // GL_ARB_separate_shader_objects - glBindProgramPipeline
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glBindProgramPipeline)
  {
    prototypeCalled = true;
    glConfig.m_glBindProgramPipeline (pipeline);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteProgramPipelines (GLsizei n, const GLuint * pipelines)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glDeleteProgramPipelines
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glDeleteProgramPipelines)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteProgramPipelines (n, pipelines);
  }
  // GL_ES_VERSION_3_1 - glDeleteProgramPipelines
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glDeleteProgramPipelines)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteProgramPipelines (n, pipelines);
  }
  // GL_ARB_separate_shader_objects - glDeleteProgramPipelines
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glDeleteProgramPipelines)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteProgramPipelines (n, pipelines);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenProgramPipelines (GLsizei n, GLuint * pipelines)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glGenProgramPipelines
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glGenProgramPipelines)
  {
    prototypeCalled = true;
    glConfig.m_glGenProgramPipelines (n, pipelines);
  }
  // GL_ES_VERSION_3_1 - glGenProgramPipelines
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glGenProgramPipelines)
  {
    prototypeCalled = true;
    glConfig.m_glGenProgramPipelines (n, pipelines);
  }
  // GL_ARB_separate_shader_objects - glGenProgramPipelines
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glGenProgramPipelines)
  {
    prototypeCalled = true;
    glConfig.m_glGenProgramPipelines (n, pipelines);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsProgramPipeline (GLuint pipeline)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glIsProgramPipeline
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glIsProgramPipeline)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsProgramPipeline (pipeline);
  }
  // GL_ES_VERSION_3_1 - glIsProgramPipeline
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glIsProgramPipeline)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsProgramPipeline (pipeline);
  }
  // GL_ARB_separate_shader_objects - glIsProgramPipeline
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glIsProgramPipeline)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsProgramPipeline (pipeline);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramPipelineiv (GLuint pipeline, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glGetProgramPipelineiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glGetProgramPipelineiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramPipelineiv (pipeline, pname, params);
  }
  // GL_ES_VERSION_3_1 - glGetProgramPipelineiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glGetProgramPipelineiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramPipelineiv (pipeline, pname, params);
  }
  // GL_ARB_separate_shader_objects - glGetProgramPipelineiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glGetProgramPipelineiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramPipelineiv (pipeline, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1i (GLuint program, GLint location, GLint v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform1i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform1i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1i (program, location, v0);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform1i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform1i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1i (program, location, v0);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform1i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform1i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1i (program, location, v0);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform1i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform1iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1iEXT (program, location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1iv (GLuint program, GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform1iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform1iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1iv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform1iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform1iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1iv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform1iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform1iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1iv (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform1iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform1ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1f (GLuint program, GLint location, GLfloat v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform1f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1f (program, location, v0);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform1f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1f (program, location, v0);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform1f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1f (program, location, v0);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform1f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform1fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1fEXT (program, location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1fv (GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform1fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1fv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform1fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1fv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform1fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1fv (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform1fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform1fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1fvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1d (GLuint program, GLint location, GLdouble v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform1d)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1d (program, location, v0);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform1d)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1d (program, location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1dv (GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform1dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1dv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform1dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1dv (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1ui (GLuint program, GLint location, GLuint v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform1ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ui (program, location, v0);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform1ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ui (program, location, v0);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform1ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform1ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ui (program, location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1uiv (GLuint program, GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1uiv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1uiv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform1uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform1uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1uiv (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2i (GLuint program, GLint location, GLint v0, GLint v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform2i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2i (program, location, v0, v1);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform2i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2i (program, location, v0, v1);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform2i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2i (program, location, v0, v1);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform2i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform2iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2iEXT (program, location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2iv (GLuint program, GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform2iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2iv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform2iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2iv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform2iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2iv (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform2iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform2ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2f (GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform2f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2f (program, location, v0, v1);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform2f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2f (program, location, v0, v1);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform2f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2f (program, location, v0, v1);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform2f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform2fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2fEXT (program, location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2fv (GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2fv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2fv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2fv (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform2fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2fvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2d (GLuint program, GLint location, GLdouble v0, GLdouble v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform2d)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2d (program, location, v0, v1);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform2d)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2d (program, location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2dv (GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform2dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2dv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform2dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2dv (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2ui (GLuint program, GLint location, GLuint v0, GLuint v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform2ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ui (program, location, v0, v1);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform2ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ui (program, location, v0, v1);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform2ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform2ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ui (program, location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2uiv (GLuint program, GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2uiv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2uiv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform2uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform2uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2uiv (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3i (GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform3i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3i (program, location, v0, v1, v2);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform3i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3i (program, location, v0, v1, v2);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform3i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3i (program, location, v0, v1, v2);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform3i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform3iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3iEXT (program, location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3iv (GLuint program, GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform3iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3iv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform3iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3iv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform3iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3iv (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform3iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform3ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3f (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform3f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3f (program, location, v0, v1, v2);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform3f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3f (program, location, v0, v1, v2);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform3f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3f (program, location, v0, v1, v2);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform3f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform3fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3fEXT (program, location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3fv (GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3fv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3fv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3fv (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3fvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3d (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform3d)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3d (program, location, v0, v1, v2);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform3d)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3d (program, location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3dv (GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform3dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3dv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform3dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3dv (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3ui (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform3ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ui (program, location, v0, v1, v2);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform3ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ui (program, location, v0, v1, v2);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform3ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform3ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ui (program, location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3uiv (GLuint program, GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3uiv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3uiv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform3uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform3uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3uiv (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4i (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform4i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4i (program, location, v0, v1, v2, v3);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform4i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4i (program, location, v0, v1, v2, v3);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform4i)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4i (program, location, v0, v1, v2, v3);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform4i
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform4iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4iEXT (program, location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4iv (GLuint program, GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform4iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4iv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform4iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4iv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform4iv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4iv (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform4iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform4ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4f (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform4f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4f (program, location, v0, v1, v2, v3);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform4f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4f (program, location, v0, v1, v2, v3);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform4f)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4f (program, location, v0, v1, v2, v3);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform4f
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform4fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4fEXT (program, location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4fv (GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4fv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4fv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4fv (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4fvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4d (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform4d)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4d (program, location, v0, v1, v2, v3);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform4d)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4d (program, location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4dv (GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform4dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4dv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform4dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4dv (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4ui (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform4ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ui (program, location, v0, v1, v2, v3);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform4ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ui (program, location, v0, v1, v2, v3);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform4ui
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform4ui)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ui (program, location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4uiv (GLuint program, GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniform4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniform4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4uiv (program, location, count, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniform4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniform4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4uiv (program, location, count, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniform4uiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniform4uiv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4uiv (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2fv (program, location, count, transpose, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniformMatrix2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniformMatrix2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2fv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2fv (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix2fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3fv (program, location, count, transpose, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniformMatrix3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniformMatrix3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3fv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3fv (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4fv (program, location, count, transpose, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniformMatrix4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniformMatrix4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4fv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4fv (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix2dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2dv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix2dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2dv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix3dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3dv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix3dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3dv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix4dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4dv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix4dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4dv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2x3fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix2x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix2x3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x3fv (program, location, count, transpose, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniformMatrix2x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniformMatrix2x3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x3fv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix2x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix2x3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x3fv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3x2fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix3x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix3x2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x2fv (program, location, count, transpose, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniformMatrix3x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniformMatrix3x2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x2fv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix3x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix3x2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x2fv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2x4fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix2x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix2x4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x4fv (program, location, count, transpose, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniformMatrix2x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniformMatrix2x4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x4fv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix2x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix2x4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x4fv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4x2fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix4x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix4x2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x2fv (program, location, count, transpose, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniformMatrix4x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniformMatrix4x2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x2fv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix4x2fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix4x2fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x2fv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3x4fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix3x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix3x4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x4fv (program, location, count, transpose, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniformMatrix3x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniformMatrix3x4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x4fv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix3x4fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix3x4fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x4fv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4x3fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix4x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix4x3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x3fv (program, location, count, transpose, value);
  }
  // GL_ES_VERSION_3_1 - glProgramUniformMatrix4x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glProgramUniformMatrix4x3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x3fv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix4x3fv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix4x3fv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x3fv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2x3dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix2x3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix2x3dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x3dv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix2x3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix2x3dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x3dv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3x2dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix3x2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix3x2dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x2dv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix3x2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix3x2dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x2dv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2x4dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix2x4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix2x4dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x4dv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix2x4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix2x4dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x4dv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4x2dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix4x2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix4x2dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x2dv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix4x2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix4x2dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x2dv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3x4dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix3x4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix3x4dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x4dv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix3x4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix3x4dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x4dv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4x3dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glProgramUniformMatrix4x3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glProgramUniformMatrix4x3dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x3dv (program, location, count, transpose, value);
  }
  // GL_ARB_separate_shader_objects - glProgramUniformMatrix4x3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glProgramUniformMatrix4x3dv)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x3dv (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glValidateProgramPipeline (GLuint pipeline)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glValidateProgramPipeline
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glValidateProgramPipeline)
  {
    prototypeCalled = true;
    glConfig.m_glValidateProgramPipeline (pipeline);
  }
  // GL_ES_VERSION_3_1 - glValidateProgramPipeline
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glValidateProgramPipeline)
  {
    prototypeCalled = true;
    glConfig.m_glValidateProgramPipeline (pipeline);
  }
  // GL_ARB_separate_shader_objects - glValidateProgramPipeline
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glValidateProgramPipeline)
  {
    prototypeCalled = true;
    glConfig.m_glValidateProgramPipeline (pipeline);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramPipelineInfoLog (GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glGetProgramPipelineInfoLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glGetProgramPipelineInfoLog)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramPipelineInfoLog (pipeline, bufSize, length, infoLog);
  }
  // GL_ES_VERSION_3_1 - glGetProgramPipelineInfoLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glGetProgramPipelineInfoLog)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramPipelineInfoLog (pipeline, bufSize, length, infoLog);
  }
  // GL_ARB_separate_shader_objects - glGetProgramPipelineInfoLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] && glConfig.m_glGetProgramPipelineInfoLog)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramPipelineInfoLog (pipeline, bufSize, length, infoLog);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL1d (GLuint index, GLdouble x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glVertexAttribL1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glVertexAttribL1d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1d (index, x);
  }
  // GL_ARB_vertex_attrib_64bit - glVertexAttribL1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit] && glConfig.m_glVertexAttribL1d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1d (index, x);
  }
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL1d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL1dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1dEXT (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL2d (GLuint index, GLdouble x, GLdouble y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glVertexAttribL2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glVertexAttribL2d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2d (index, x, y);
  }
  // GL_ARB_vertex_attrib_64bit - glVertexAttribL2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit] && glConfig.m_glVertexAttribL2d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2d (index, x, y);
  }
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL2d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL2dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2dEXT (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL3d (GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glVertexAttribL3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glVertexAttribL3d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3d (index, x, y, z);
  }
  // GL_ARB_vertex_attrib_64bit - glVertexAttribL3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit] && glConfig.m_glVertexAttribL3d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3d (index, x, y, z);
  }
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL3d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL3dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3dEXT (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glVertexAttribL4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glVertexAttribL4d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4d (index, x, y, z, w);
  }
  // GL_ARB_vertex_attrib_64bit - glVertexAttribL4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit] && glConfig.m_glVertexAttribL4d)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4d (index, x, y, z, w);
  }
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL4d
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL4dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4dEXT (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL1dv (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glVertexAttribL1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glVertexAttribL1dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1dv (index, v);
  }
  // GL_ARB_vertex_attrib_64bit - glVertexAttribL1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit] && glConfig.m_glVertexAttribL1dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1dv (index, v);
  }
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL1dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL1dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1dvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL2dv (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glVertexAttribL2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glVertexAttribL2dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2dv (index, v);
  }
  // GL_ARB_vertex_attrib_64bit - glVertexAttribL2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit] && glConfig.m_glVertexAttribL2dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2dv (index, v);
  }
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL2dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL2dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2dvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL3dv (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glVertexAttribL3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glVertexAttribL3dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3dv (index, v);
  }
  // GL_ARB_vertex_attrib_64bit - glVertexAttribL3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit] && glConfig.m_glVertexAttribL3dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3dv (index, v);
  }
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL3dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL3dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3dvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL4dv (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glVertexAttribL4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glVertexAttribL4dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4dv (index, v);
  }
  // GL_ARB_vertex_attrib_64bit - glVertexAttribL4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit] && glConfig.m_glVertexAttribL4dv)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4dv (index, v);
  }
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL4dv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL4dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4dvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribLPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glVertexAttribLPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glVertexAttribLPointer)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribLPointer (index, size, type, stride, pointer);
  }
  // GL_ARB_vertex_attrib_64bit - glVertexAttribLPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit] && glConfig.m_glVertexAttribLPointer)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribLPointer (index, size, type, stride, pointer);
  }
  // GL_EXT_vertex_attrib_64bit - glVertexAttribLPointer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribLPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribLPointerEXT (index, size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribLdv (GLuint index, GLenum pname, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glGetVertexAttribLdv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glGetVertexAttribLdv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribLdv (index, pname, params);
  }
  // GL_ARB_vertex_attrib_64bit - glGetVertexAttribLdv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit] && glConfig.m_glGetVertexAttribLdv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribLdv (index, pname, params);
  }
  // GL_EXT_vertex_attrib_64bit - glGetVertexAttribLdv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glGetVertexAttribLdvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribLdvEXT (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glViewportArrayv (GLuint first, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glViewportArrayv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glViewportArrayv)
  {
    prototypeCalled = true;
    glConfig.m_glViewportArrayv (first, count, v);
  }
  // GL_ARB_viewport_array - glViewportArrayv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glViewportArrayv)
  {
    prototypeCalled = true;
    glConfig.m_glViewportArrayv (first, count, v);
  }
  // GL_NV_viewport_array - glViewportArrayv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glViewportArrayvNV)
  {
    prototypeCalled = true;
    glConfig.m_glViewportArrayvNV (first, count, v);
  }
  // GL_OES_viewport_array - glViewportArrayv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glViewportArrayvOES)
  {
    prototypeCalled = true;
    glConfig.m_glViewportArrayvOES (first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glViewportIndexedf (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glViewportIndexedf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glViewportIndexedf)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedf (index, x, y, w, h);
  }
  // GL_ARB_viewport_array - glViewportIndexedf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glViewportIndexedf)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedf (index, x, y, w, h);
  }
  // GL_OES_viewport_array - glViewportIndexedf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glViewportIndexedfOES)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedfOES (index, x, y, w, h);
  }
  // GL_NV_viewport_array - glViewportIndexedf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glViewportIndexedfNV)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedfNV (index, x, y, w, h);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glViewportIndexedfv (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glViewportIndexedfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glViewportIndexedfv)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedfv (index, v);
  }
  // GL_ARB_viewport_array - glViewportIndexedfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glViewportIndexedfv)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedfv (index, v);
  }
  // GL_OES_viewport_array - glViewportIndexedfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glViewportIndexedfvOES)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedfvOES (index, v);
  }
  // GL_NV_viewport_array - glViewportIndexedfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glViewportIndexedfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedfvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScissorArrayv (GLuint first, GLsizei count, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glScissorArrayv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glScissorArrayv)
  {
    prototypeCalled = true;
    glConfig.m_glScissorArrayv (first, count, v);
  }
  // GL_ARB_viewport_array - glScissorArrayv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glScissorArrayv)
  {
    prototypeCalled = true;
    glConfig.m_glScissorArrayv (first, count, v);
  }
  // GL_NV_viewport_array - glScissorArrayv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glScissorArrayvNV)
  {
    prototypeCalled = true;
    glConfig.m_glScissorArrayvNV (first, count, v);
  }
  // GL_OES_viewport_array - glScissorArrayv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glScissorArrayvOES)
  {
    prototypeCalled = true;
    glConfig.m_glScissorArrayvOES (first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScissorIndexed (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glScissorIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glScissorIndexed)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexed (index, left, bottom, width, height);
  }
  // GL_ARB_viewport_array - glScissorIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glScissorIndexed)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexed (index, left, bottom, width, height);
  }
  // GL_NV_viewport_array - glScissorIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glScissorIndexedNV)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexedNV (index, left, bottom, width, height);
  }
  // GL_OES_viewport_array - glScissorIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glScissorIndexedOES)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexedOES (index, left, bottom, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScissorIndexedv (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glScissorIndexedv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glScissorIndexedv)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexedv (index, v);
  }
  // GL_ARB_viewport_array - glScissorIndexedv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glScissorIndexedv)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexedv (index, v);
  }
  // GL_NV_viewport_array - glScissorIndexedv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glScissorIndexedvNV)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexedvNV (index, v);
  }
  // GL_OES_viewport_array - glScissorIndexedv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glScissorIndexedvOES)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexedvOES (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangeArrayv (GLuint first, GLsizei count, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glDepthRangeArrayv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glDepthRangeArrayv)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangeArrayv (first, count, v);
  }
  // GL_ARB_viewport_array - glDepthRangeArrayv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glDepthRangeArrayv)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangeArrayv (first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangeIndexed (GLuint index, GLdouble n, GLdouble f)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glDepthRangeIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glDepthRangeIndexed)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangeIndexed (index, n, f);
  }
  // GL_ARB_viewport_array - glDepthRangeIndexed
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glDepthRangeIndexed)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangeIndexed (index, n, f);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFloati_v (GLenum target, GLuint index, GLfloat * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glGetFloati_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glGetFloati_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetFloati_v (target, index, data);
  }
  // GL_ARB_viewport_array - glGetFloati_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glGetFloati_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetFloati_v (target, index, data);
  }
  // GL_NV_viewport_array - glGetFloati_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glGetFloati_vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetFloati_vNV (target, index, data);
  }
  // GL_OES_viewport_array - glGetFloati_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glGetFloati_vOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetFloati_vOES (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetDoublei_v (GLenum target, GLuint index, GLdouble * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_1 - glGetDoublei_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_1] && glConfig.m_glGetDoublei_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetDoublei_v (target, index, data);
  }
  // GL_ARB_viewport_array - glGetDoublei_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glGetDoublei_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetDoublei_v (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawArraysInstancedBaseInstance (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glDrawArraysInstancedBaseInstance
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glDrawArraysInstancedBaseInstance)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstancedBaseInstance (mode, first, count, instancecount, baseinstance);
  }
  // GL_ARB_base_instance - glDrawArraysInstancedBaseInstance
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_base_instance] && glConfig.m_glDrawArraysInstancedBaseInstance)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstancedBaseInstance (mode, first, count, instancecount, baseinstance);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstancedBaseInstance (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glDrawElementsInstancedBaseInstance
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glDrawElementsInstancedBaseInstance)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedBaseInstance (mode, count, type, indices, instancecount, baseinstance);
  }
  // GL_ARB_base_instance - glDrawElementsInstancedBaseInstance
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_base_instance] && glConfig.m_glDrawElementsInstancedBaseInstance)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedBaseInstance (mode, count, type, indices, instancecount, baseinstance);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstancedBaseVertexBaseInstance (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glDrawElementsInstancedBaseVertexBaseInstance
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glDrawElementsInstancedBaseVertexBaseInstance)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedBaseVertexBaseInstance (mode, count, type, indices, instancecount, basevertex, baseinstance);
  }
  // GL_ARB_base_instance - glDrawElementsInstancedBaseVertexBaseInstance
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_base_instance] && glConfig.m_glDrawElementsInstancedBaseVertexBaseInstance)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedBaseVertexBaseInstance (mode, count, type, indices, instancecount, basevertex, baseinstance);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetInternalformativ (GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glGetInternalformativ
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glGetInternalformativ)
  {
    prototypeCalled = true;
    glConfig.m_glGetInternalformativ (target, internalformat, pname, count, params);
  }
  // GL_ES_VERSION_3_0 - glGetInternalformativ
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glGetInternalformativ)
  {
    prototypeCalled = true;
    glConfig.m_glGetInternalformativ (target, internalformat, pname, count, params);
  }
  // GL_ARB_internalformat_query - glGetInternalformativ
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_internalformat_query] && glConfig.m_glGetInternalformativ)
  {
    prototypeCalled = true;
    glConfig.m_glGetInternalformativ (target, internalformat, pname, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveAtomicCounterBufferiv (GLuint program, GLuint bufferIndex, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glGetActiveAtomicCounterBufferiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glGetActiveAtomicCounterBufferiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveAtomicCounterBufferiv (program, bufferIndex, pname, params);
  }
  // GL_ARB_shader_atomic_counters - glGetActiveAtomicCounterBufferiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_atomic_counters] && glConfig.m_glGetActiveAtomicCounterBufferiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveAtomicCounterBufferiv (program, bufferIndex, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindImageTexture (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glBindImageTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glBindImageTexture)
  {
    prototypeCalled = true;
    glConfig.m_glBindImageTexture (unit, texture, level, layered, layer, access, format);
  }
  // GL_ES_VERSION_3_1 - glBindImageTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glBindImageTexture)
  {
    prototypeCalled = true;
    glConfig.m_glBindImageTexture (unit, texture, level, layered, layer, access, format);
  }
  // GL_ARB_shader_image_load_store - glBindImageTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_image_load_store] && glConfig.m_glBindImageTexture)
  {
    prototypeCalled = true;
    glConfig.m_glBindImageTexture (unit, texture, level, layered, layer, access, format);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMemoryBarrier (GLbitfield barriers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glMemoryBarrier
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glMemoryBarrier)
  {
    prototypeCalled = true;
    glConfig.m_glMemoryBarrier (barriers);
  }
  // GL_ES_VERSION_3_1 - glMemoryBarrier
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glMemoryBarrier)
  {
    prototypeCalled = true;
    glConfig.m_glMemoryBarrier (barriers);
  }
  // GL_ARB_shader_image_load_store - glMemoryBarrier
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_image_load_store] && glConfig.m_glMemoryBarrier)
  {
    prototypeCalled = true;
    glConfig.m_glMemoryBarrier (barriers);
  }
  // GL_EXT_shader_image_load_store - glMemoryBarrier
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_shader_image_load_store] && glConfig.m_glMemoryBarrierEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMemoryBarrierEXT (barriers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorage1D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glTexStorage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glTexStorage1D)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage1D (target, levels, internalformat, width);
  }
  // GL_ARB_texture_storage - glTexStorage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_storage] && glConfig.m_glTexStorage1D)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage1D (target, levels, internalformat, width);
  }
  // GL_EXT_texture_storage - glTexStorage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_storage] && glConfig.m_glTexStorage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage1DEXT (target, levels, internalformat, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorage2D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glTexStorage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glTexStorage2D)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage2D (target, levels, internalformat, width, height);
  }
  // GL_ES_VERSION_3_0 - glTexStorage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glTexStorage2D)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage2D (target, levels, internalformat, width, height);
  }
  // GL_ARB_texture_storage - glTexStorage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_storage] && glConfig.m_glTexStorage2D)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage2D (target, levels, internalformat, width, height);
  }
  // GL_EXT_texture_storage - glTexStorage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_storage] && glConfig.m_glTexStorage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage2DEXT (target, levels, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorage3D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glTexStorage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glTexStorage3D)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage3D (target, levels, internalformat, width, height, depth);
  }
  // GL_ES_VERSION_3_0 - glTexStorage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glTexStorage3D)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage3D (target, levels, internalformat, width, height, depth);
  }
  // GL_ARB_texture_storage - glTexStorage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_storage] && glConfig.m_glTexStorage3D)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage3D (target, levels, internalformat, width, height, depth);
  }
  // GL_EXT_texture_storage - glTexStorage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_storage] && glConfig.m_glTexStorage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage3DEXT (target, levels, internalformat, width, height, depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawTransformFeedbackInstanced (GLenum mode, GLuint id, GLsizei instancecount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glDrawTransformFeedbackInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glDrawTransformFeedbackInstanced)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedbackInstanced (mode, id, instancecount);
  }
  // GL_ARB_transform_feedback_instanced - glDrawTransformFeedbackInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback_instanced] && glConfig.m_glDrawTransformFeedbackInstanced)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedbackInstanced (mode, id, instancecount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawTransformFeedbackStreamInstanced (GLenum mode, GLuint id, GLuint stream, GLsizei instancecount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_2 - glDrawTransformFeedbackStreamInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_2] && glConfig.m_glDrawTransformFeedbackStreamInstanced)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedbackStreamInstanced (mode, id, stream, instancecount);
  }
  // GL_ARB_transform_feedback_instanced - glDrawTransformFeedbackStreamInstanced
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback_instanced] && glConfig.m_glDrawTransformFeedbackStreamInstanced)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedbackStreamInstanced (mode, id, stream, instancecount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearBufferData (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glClearBufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glClearBufferData)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferData (target, internalformat, format, type, data);
  }
  // GL_ARB_clear_buffer_object - glClearBufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_clear_buffer_object] && glConfig.m_glClearBufferData)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferData (target, internalformat, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearBufferSubData (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glClearBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glClearBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferSubData (target, internalformat, offset, size, format, type, data);
  }
  // GL_ARB_clear_buffer_object - glClearBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_clear_buffer_object] && glConfig.m_glClearBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glClearBufferSubData (target, internalformat, offset, size, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDispatchCompute (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glDispatchCompute
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glDispatchCompute)
  {
    prototypeCalled = true;
    glConfig.m_glDispatchCompute (num_groups_x, num_groups_y, num_groups_z);
  }
  // GL_ES_VERSION_3_1 - glDispatchCompute
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glDispatchCompute)
  {
    prototypeCalled = true;
    glConfig.m_glDispatchCompute (num_groups_x, num_groups_y, num_groups_z);
  }
  // GL_ARB_compute_shader - glDispatchCompute
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_compute_shader] && glConfig.m_glDispatchCompute)
  {
    prototypeCalled = true;
    glConfig.m_glDispatchCompute (num_groups_x, num_groups_y, num_groups_z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDispatchComputeIndirect (GLintptr indirect)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glDispatchComputeIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glDispatchComputeIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glDispatchComputeIndirect (indirect);
  }
  // GL_ES_VERSION_3_1 - glDispatchComputeIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glDispatchComputeIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glDispatchComputeIndirect (indirect);
  }
  // GL_ARB_compute_shader - glDispatchComputeIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_compute_shader] && glConfig.m_glDispatchComputeIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glDispatchComputeIndirect (indirect);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyImageSubData (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glCopyImageSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glCopyImageSubData)
  {
    prototypeCalled = true;
    glConfig.m_glCopyImageSubData (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
  }
  // GL_ES_VERSION_3_2 - glCopyImageSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glCopyImageSubData)
  {
    prototypeCalled = true;
    glConfig.m_glCopyImageSubData (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
  }
  // GL_ARB_copy_image - glCopyImageSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_copy_image] && glConfig.m_glCopyImageSubData)
  {
    prototypeCalled = true;
    glConfig.m_glCopyImageSubData (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferParameteri (GLenum target, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glFramebufferParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glFramebufferParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferParameteri (target, pname, param);
  }
  // GL_ES_VERSION_3_1 - glFramebufferParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glFramebufferParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferParameteri (target, pname, param);
  }
  // GL_ARB_framebuffer_no_attachments - glFramebufferParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_no_attachments] && glConfig.m_glFramebufferParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferParameteri (target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glGetFramebufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetFramebufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetFramebufferParameteriv (target, pname, params);
  }
  // GL_ES_VERSION_3_1 - glGetFramebufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glGetFramebufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetFramebufferParameteriv (target, pname, params);
  }
  // GL_ARB_framebuffer_no_attachments - glGetFramebufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_no_attachments] && glConfig.m_glGetFramebufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetFramebufferParameteriv (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetInternalformati64v (GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glGetInternalformati64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetInternalformati64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetInternalformati64v (target, internalformat, pname, count, params);
  }
  // GL_ARB_internalformat_query2 - glGetInternalformati64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_internalformat_query2] && glConfig.m_glGetInternalformati64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetInternalformati64v (target, internalformat, pname, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInvalidateTexSubImage (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glInvalidateTexSubImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glInvalidateTexSubImage)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateTexSubImage (texture, level, xoffset, yoffset, zoffset, width, height, depth);
  }
  // GL_ARB_invalidate_subdata - glInvalidateTexSubImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_invalidate_subdata] && glConfig.m_glInvalidateTexSubImage)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateTexSubImage (texture, level, xoffset, yoffset, zoffset, width, height, depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInvalidateTexImage (GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glInvalidateTexImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glInvalidateTexImage)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateTexImage (texture, level);
  }
  // GL_ARB_invalidate_subdata - glInvalidateTexImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_invalidate_subdata] && glConfig.m_glInvalidateTexImage)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateTexImage (texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInvalidateBufferSubData (GLuint buffer, GLintptr offset, GLsizeiptr length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glInvalidateBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glInvalidateBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateBufferSubData (buffer, offset, length);
  }
  // GL_ARB_invalidate_subdata - glInvalidateBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_invalidate_subdata] && glConfig.m_glInvalidateBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateBufferSubData (buffer, offset, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInvalidateBufferData (GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glInvalidateBufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glInvalidateBufferData)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateBufferData (buffer);
  }
  // GL_ARB_invalidate_subdata - glInvalidateBufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_invalidate_subdata] && glConfig.m_glInvalidateBufferData)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateBufferData (buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInvalidateFramebuffer (GLenum target, GLsizei numAttachments, const GLenum * attachments)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glInvalidateFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glInvalidateFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateFramebuffer (target, numAttachments, attachments);
  }
  // GL_ES_VERSION_3_0 - glInvalidateFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glInvalidateFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateFramebuffer (target, numAttachments, attachments);
  }
  // GL_ARB_invalidate_subdata - glInvalidateFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_invalidate_subdata] && glConfig.m_glInvalidateFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateFramebuffer (target, numAttachments, attachments);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInvalidateSubFramebuffer (GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glInvalidateSubFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glInvalidateSubFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateSubFramebuffer (target, numAttachments, attachments, x, y, width, height);
  }
  // GL_ES_VERSION_3_0 - glInvalidateSubFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] && glConfig.m_glInvalidateSubFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateSubFramebuffer (target, numAttachments, attachments, x, y, width, height);
  }
  // GL_ARB_invalidate_subdata - glInvalidateSubFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_invalidate_subdata] && glConfig.m_glInvalidateSubFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateSubFramebuffer (target, numAttachments, attachments, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawArraysIndirect (GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glMultiDrawArraysIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glMultiDrawArraysIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawArraysIndirect (mode, indirect, drawcount, stride);
  }
  // GL_ARB_multi_draw_indirect - glMultiDrawArraysIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multi_draw_indirect] && glConfig.m_glMultiDrawArraysIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawArraysIndirect (mode, indirect, drawcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElementsIndirect (GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glMultiDrawElementsIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glMultiDrawElementsIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsIndirect (mode, type, indirect, drawcount, stride);
  }
  // GL_ARB_multi_draw_indirect - glMultiDrawElementsIndirect
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multi_draw_indirect] && glConfig.m_glMultiDrawElementsIndirect)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsIndirect (mode, type, indirect, drawcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramInterfaceiv (GLuint program, GLenum programInterface, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glGetProgramInterfaceiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetProgramInterfaceiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramInterfaceiv (program, programInterface, pname, params);
  }
  // GL_ES_VERSION_3_1 - glGetProgramInterfaceiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glGetProgramInterfaceiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramInterfaceiv (program, programInterface, pname, params);
  }
  // GL_ARB_program_interface_query - glGetProgramInterfaceiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_program_interface_query] && glConfig.m_glGetProgramInterfaceiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramInterfaceiv (program, programInterface, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGetProgramResourceIndex (GLuint program, GLenum programInterface, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glGetProgramResourceIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetProgramResourceIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetProgramResourceIndex (program, programInterface, name);
  }
  // GL_ES_VERSION_3_1 - glGetProgramResourceIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glGetProgramResourceIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetProgramResourceIndex (program, programInterface, name);
  }
  // GL_ARB_program_interface_query - glGetProgramResourceIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_program_interface_query] && glConfig.m_glGetProgramResourceIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetProgramResourceIndex (program, programInterface, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramResourceName (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glGetProgramResourceName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetProgramResourceName)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramResourceName (program, programInterface, index, bufSize, length, name);
  }
  // GL_ES_VERSION_3_1 - glGetProgramResourceName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glGetProgramResourceName)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramResourceName (program, programInterface, index, bufSize, length, name);
  }
  // GL_ARB_program_interface_query - glGetProgramResourceName
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_program_interface_query] && glConfig.m_glGetProgramResourceName)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramResourceName (program, programInterface, index, bufSize, length, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramResourceiv (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei count, GLsizei * length, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glGetProgramResourceiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetProgramResourceiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramResourceiv (program, programInterface, index, propCount, props, count, length, params);
  }
  // GL_ES_VERSION_3_1 - glGetProgramResourceiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glGetProgramResourceiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramResourceiv (program, programInterface, index, propCount, props, count, length, params);
  }
  // GL_ARB_program_interface_query - glGetProgramResourceiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_program_interface_query] && glConfig.m_glGetProgramResourceiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramResourceiv (program, programInterface, index, propCount, props, count, length, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetProgramResourceLocation (GLuint program, GLenum programInterface, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glGetProgramResourceLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetProgramResourceLocation)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetProgramResourceLocation (program, programInterface, name);
  }
  // GL_ES_VERSION_3_1 - glGetProgramResourceLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glGetProgramResourceLocation)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetProgramResourceLocation (program, programInterface, name);
  }
  // GL_ARB_program_interface_query - glGetProgramResourceLocation
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_program_interface_query] && glConfig.m_glGetProgramResourceLocation)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetProgramResourceLocation (program, programInterface, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetProgramResourceLocationIndex (GLuint program, GLenum programInterface, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glGetProgramResourceLocationIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetProgramResourceLocationIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetProgramResourceLocationIndex (program, programInterface, name);
  }
  // GL_ARB_program_interface_query - glGetProgramResourceLocationIndex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_program_interface_query] && glConfig.m_glGetProgramResourceLocationIndex)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetProgramResourceLocationIndex (program, programInterface, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShaderStorageBlockBinding (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glShaderStorageBlockBinding
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glShaderStorageBlockBinding)
  {
    prototypeCalled = true;
    glConfig.m_glShaderStorageBlockBinding (program, storageBlockIndex, storageBlockBinding);
  }
  // GL_ARB_shader_storage_buffer_object - glShaderStorageBlockBinding
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_storage_buffer_object] && glConfig.m_glShaderStorageBlockBinding)
  {
    prototypeCalled = true;
    glConfig.m_glShaderStorageBlockBinding (program, storageBlockIndex, storageBlockBinding);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexBufferRange (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glTexBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glTexBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferRange (target, internalformat, buffer, offset, size);
  }
  // GL_ES_VERSION_3_2 - glTexBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glTexBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferRange (target, internalformat, buffer, offset, size);
  }
  // GL_ARB_texture_buffer_range - glTexBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_buffer_range] && glConfig.m_glTexBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferRange (target, internalformat, buffer, offset, size);
  }
  // GL_EXT_texture_buffer - glTexBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_buffer] && glConfig.m_glTexBufferRangeEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferRangeEXT (target, internalformat, buffer, offset, size);
  }
  // GL_OES_texture_buffer - glTexBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_buffer] && glConfig.m_glTexBufferRangeOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferRangeOES (target, internalformat, buffer, offset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorage2DMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glTexStorage2DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glTexStorage2DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage2DMultisample (target, samples, internalformat, width, height, fixedsamplelocations);
  }
  // GL_ES_VERSION_3_1 - glTexStorage2DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glTexStorage2DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage2DMultisample (target, samples, internalformat, width, height, fixedsamplelocations);
  }
  // GL_ARB_texture_storage_multisample - glTexStorage2DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_storage_multisample] && glConfig.m_glTexStorage2DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage2DMultisample (target, samples, internalformat, width, height, fixedsamplelocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorage3DMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glTexStorage3DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glTexStorage3DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage3DMultisample (target, samples, internalformat, width, height, depth, fixedsamplelocations);
  }
  // GL_ES_VERSION_3_2 - glTexStorage3DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glTexStorage3DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage3DMultisample (target, samples, internalformat, width, height, depth, fixedsamplelocations);
  }
  // GL_ARB_texture_storage_multisample - glTexStorage3DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_storage_multisample] && glConfig.m_glTexStorage3DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage3DMultisample (target, samples, internalformat, width, height, depth, fixedsamplelocations);
  }
  // GL_OES_texture_storage_multisample_2d_array - glTexStorage3DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_storage_multisample_2d_array] && glConfig.m_glTexStorage3DMultisampleOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage3DMultisampleOES (target, samples, internalformat, width, height, depth, fixedsamplelocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureView (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glTextureView
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glTextureView)
  {
    prototypeCalled = true;
    glConfig.m_glTextureView (texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
  }
  // GL_ARB_texture_view - glTextureView
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_view] && glConfig.m_glTextureView)
  {
    prototypeCalled = true;
    glConfig.m_glTextureView (texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
  }
  // GL_EXT_texture_view - glTextureView
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_view] && glConfig.m_glTextureViewEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureViewEXT (texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
  }
  // GL_OES_texture_view - glTextureView
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_view] && glConfig.m_glTextureViewOES)
  {
    prototypeCalled = true;
    glConfig.m_glTextureViewOES (texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindVertexBuffer (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glBindVertexBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glBindVertexBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexBuffer (bindingindex, buffer, offset, stride);
  }
  // GL_ES_VERSION_3_1 - glBindVertexBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glBindVertexBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexBuffer (bindingindex, buffer, offset, stride);
  }
  // GL_ARB_vertex_attrib_binding - glBindVertexBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_binding] && glConfig.m_glBindVertexBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexBuffer (bindingindex, buffer, offset, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribFormat (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glVertexAttribFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glVertexAttribFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribFormat (attribindex, size, type, normalized, relativeoffset);
  }
  // GL_ES_VERSION_3_1 - glVertexAttribFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glVertexAttribFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribFormat (attribindex, size, type, normalized, relativeoffset);
  }
  // GL_ARB_vertex_attrib_binding - glVertexAttribFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_binding] && glConfig.m_glVertexAttribFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribFormat (attribindex, size, type, normalized, relativeoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribIFormat (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glVertexAttribIFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glVertexAttribIFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribIFormat (attribindex, size, type, relativeoffset);
  }
  // GL_ES_VERSION_3_1 - glVertexAttribIFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glVertexAttribIFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribIFormat (attribindex, size, type, relativeoffset);
  }
  // GL_ARB_vertex_attrib_binding - glVertexAttribIFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_binding] && glConfig.m_glVertexAttribIFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribIFormat (attribindex, size, type, relativeoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribLFormat (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glVertexAttribLFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glVertexAttribLFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribLFormat (attribindex, size, type, relativeoffset);
  }
  // GL_ARB_vertex_attrib_binding - glVertexAttribLFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_binding] && glConfig.m_glVertexAttribLFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribLFormat (attribindex, size, type, relativeoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribBinding (GLuint attribindex, GLuint bindingindex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glVertexAttribBinding
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glVertexAttribBinding)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribBinding (attribindex, bindingindex);
  }
  // GL_ES_VERSION_3_1 - glVertexAttribBinding
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glVertexAttribBinding)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribBinding (attribindex, bindingindex);
  }
  // GL_ARB_vertex_attrib_binding - glVertexAttribBinding
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_binding] && glConfig.m_glVertexAttribBinding)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribBinding (attribindex, bindingindex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexBindingDivisor (GLuint bindingindex, GLuint divisor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glVertexBindingDivisor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glVertexBindingDivisor)
  {
    prototypeCalled = true;
    glConfig.m_glVertexBindingDivisor (bindingindex, divisor);
  }
  // GL_ES_VERSION_3_1 - glVertexBindingDivisor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glVertexBindingDivisor)
  {
    prototypeCalled = true;
    glConfig.m_glVertexBindingDivisor (bindingindex, divisor);
  }
  // GL_ARB_vertex_attrib_binding - glVertexBindingDivisor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_binding] && glConfig.m_glVertexBindingDivisor)
  {
    prototypeCalled = true;
    glConfig.m_glVertexBindingDivisor (bindingindex, divisor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageControl (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glDebugMessageControl
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glDebugMessageControl)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageControl (source, type, severity, count, ids, enabled);
  }
  // GL_ES_VERSION_3_2 - glDebugMessageControl
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glDebugMessageControl)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageControl (source, type, severity, count, ids, enabled);
  }
  // GL_KHR_debug - glDebugMessageControl
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glDebugMessageControl)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageControl (source, type, severity, count, ids, enabled);
  }
  // GL_ARB_debug_output - glDebugMessageControl
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_debug_output] && glConfig.m_glDebugMessageControlARB)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageControlARB (source, type, severity, count, ids, enabled);
  }
  // GL_KHR_debug - glDebugMessageControl
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glDebugMessageControlKHR)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageControlKHR (source, type, severity, count, ids, enabled);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageInsert (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glDebugMessageInsert
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glDebugMessageInsert)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageInsert (source, type, id, severity, length, buf);
  }
  // GL_ES_VERSION_3_2 - glDebugMessageInsert
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glDebugMessageInsert)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageInsert (source, type, id, severity, length, buf);
  }
  // GL_KHR_debug - glDebugMessageInsert
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glDebugMessageInsert)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageInsert (source, type, id, severity, length, buf);
  }
  // GL_ARB_debug_output - glDebugMessageInsert
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_debug_output] && glConfig.m_glDebugMessageInsertARB)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageInsertARB (source, type, id, severity, length, buf);
  }
  // GL_KHR_debug - glDebugMessageInsert
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glDebugMessageInsertKHR)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageInsertKHR (source, type, id, severity, length, buf);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageCallback (GLDEBUGPROC callback, const void * userParam)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glDebugMessageCallback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glDebugMessageCallback)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageCallback (callback, userParam);
  }
  // GL_ES_VERSION_3_2 - glDebugMessageCallback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glDebugMessageCallback)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageCallback (callback, userParam);
  }
  // GL_KHR_debug - glDebugMessageCallback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glDebugMessageCallback)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageCallback (callback, userParam);
  }
  // GL_ARB_debug_output - glDebugMessageCallback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_debug_output] && glConfig.m_glDebugMessageCallbackARB)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageCallbackARB ((GLDEBUGPROCARB) callback, userParam);
  }
  // GL_KHR_debug - glDebugMessageCallback
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glDebugMessageCallbackKHR)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageCallbackKHR ((GLDEBUGPROCKHR) callback, userParam);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGetDebugMessageLog (GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glGetDebugMessageLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetDebugMessageLog)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetDebugMessageLog (count, bufSize, sources, types, ids, severities, lengths, messageLog);
  }
  // GL_ES_VERSION_3_2 - glGetDebugMessageLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetDebugMessageLog)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetDebugMessageLog (count, bufSize, sources, types, ids, severities, lengths, messageLog);
  }
  // GL_KHR_debug - glGetDebugMessageLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetDebugMessageLog)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetDebugMessageLog (count, bufSize, sources, types, ids, severities, lengths, messageLog);
  }
  // GL_ARB_debug_output - glGetDebugMessageLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_debug_output] && glConfig.m_glGetDebugMessageLogARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetDebugMessageLogARB (count, bufSize, sources, types, ids, severities, lengths, messageLog);
  }
  // GL_KHR_debug - glGetDebugMessageLog
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetDebugMessageLogKHR)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetDebugMessageLogKHR (count, bufSize, sources, types, ids, severities, lengths, messageLog);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPushDebugGroup (GLenum source, GLuint id, GLsizei length, const GLchar * message)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glPushDebugGroup
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glPushDebugGroup)
  {
    prototypeCalled = true;
    glConfig.m_glPushDebugGroup (source, id, length, message);
  }
  // GL_ES_VERSION_3_2 - glPushDebugGroup
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glPushDebugGroup)
  {
    prototypeCalled = true;
    glConfig.m_glPushDebugGroup (source, id, length, message);
  }
  // GL_KHR_debug - glPushDebugGroup
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glPushDebugGroup)
  {
    prototypeCalled = true;
    glConfig.m_glPushDebugGroup (source, id, length, message);
  }
  // GL_KHR_debug - glPushDebugGroup
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glPushDebugGroupKHR)
  {
    prototypeCalled = true;
    glConfig.m_glPushDebugGroupKHR (source, id, length, message);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPopDebugGroup ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glPopDebugGroup
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glPopDebugGroup)
  {
    prototypeCalled = true;
    glConfig.m_glPopDebugGroup ();
  }
  // GL_ES_VERSION_3_2 - glPopDebugGroup
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glPopDebugGroup)
  {
    prototypeCalled = true;
    glConfig.m_glPopDebugGroup ();
  }
  // GL_KHR_debug - glPopDebugGroup
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glPopDebugGroup)
  {
    prototypeCalled = true;
    glConfig.m_glPopDebugGroup ();
  }
  // GL_KHR_debug - glPopDebugGroup
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glPopDebugGroupKHR)
  {
    prototypeCalled = true;
    glConfig.m_glPopDebugGroupKHR ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glObjectLabel (GLenum identifier, GLuint name, GLsizei length, const GLchar * label)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glObjectLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glObjectLabel)
  {
    prototypeCalled = true;
    glConfig.m_glObjectLabel (identifier, name, length, label);
  }
  // GL_ES_VERSION_3_2 - glObjectLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glObjectLabel)
  {
    prototypeCalled = true;
    glConfig.m_glObjectLabel (identifier, name, length, label);
  }
  // GL_KHR_debug - glObjectLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glObjectLabel)
  {
    prototypeCalled = true;
    glConfig.m_glObjectLabel (identifier, name, length, label);
  }
  // GL_KHR_debug - glObjectLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glObjectLabelKHR)
  {
    prototypeCalled = true;
    glConfig.m_glObjectLabelKHR (identifier, name, length, label);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetObjectLabel (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glGetObjectLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetObjectLabel)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectLabel (identifier, name, bufSize, length, label);
  }
  // GL_ES_VERSION_3_2 - glGetObjectLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetObjectLabel)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectLabel (identifier, name, bufSize, length, label);
  }
  // GL_KHR_debug - glGetObjectLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetObjectLabel)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectLabel (identifier, name, bufSize, length, label);
  }
  // GL_KHR_debug - glGetObjectLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetObjectLabelKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectLabelKHR (identifier, name, bufSize, length, label);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glObjectPtrLabel (const void * ptr, GLsizei length, const GLchar * label)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glObjectPtrLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glObjectPtrLabel)
  {
    prototypeCalled = true;
    glConfig.m_glObjectPtrLabel (ptr, length, label);
  }
  // GL_ES_VERSION_3_2 - glObjectPtrLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glObjectPtrLabel)
  {
    prototypeCalled = true;
    glConfig.m_glObjectPtrLabel (ptr, length, label);
  }
  // GL_KHR_debug - glObjectPtrLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glObjectPtrLabel)
  {
    prototypeCalled = true;
    glConfig.m_glObjectPtrLabel (ptr, length, label);
  }
  // GL_KHR_debug - glObjectPtrLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glObjectPtrLabelKHR)
  {
    prototypeCalled = true;
    glConfig.m_glObjectPtrLabelKHR (ptr, length, label);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetObjectPtrLabel (const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_3 - glGetObjectPtrLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_3] && glConfig.m_glGetObjectPtrLabel)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectPtrLabel (ptr, bufSize, length, label);
  }
  // GL_ES_VERSION_3_2 - glGetObjectPtrLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetObjectPtrLabel)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectPtrLabel (ptr, bufSize, length, label);
  }
  // GL_KHR_debug - glGetObjectPtrLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetObjectPtrLabel)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectPtrLabel (ptr, bufSize, length, label);
  }
  // GL_KHR_debug - glGetObjectPtrLabel
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetObjectPtrLabelKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectPtrLabelKHR (ptr, bufSize, length, label);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferStorage (GLenum target, GLsizeiptr size, const void * data, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_4 - glBufferStorage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_4] && glConfig.m_glBufferStorage)
  {
    prototypeCalled = true;
    glConfig.m_glBufferStorage (target, size, data, flags);
  }
  // GL_ARB_buffer_storage - glBufferStorage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_buffer_storage] && glConfig.m_glBufferStorage)
  {
    prototypeCalled = true;
    glConfig.m_glBufferStorage (target, size, data, flags);
  }
  // GL_EXT_buffer_storage - glBufferStorage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_buffer_storage] && glConfig.m_glBufferStorageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBufferStorageEXT (target, size, data, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearTexImage (GLuint texture, GLint level, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_4 - glClearTexImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_4] && glConfig.m_glClearTexImage)
  {
    prototypeCalled = true;
    glConfig.m_glClearTexImage (texture, level, format, type, data);
  }
  // GL_ARB_clear_texture - glClearTexImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_clear_texture] && glConfig.m_glClearTexImage)
  {
    prototypeCalled = true;
    glConfig.m_glClearTexImage (texture, level, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearTexSubImage (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_4 - glClearTexSubImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_4] && glConfig.m_glClearTexSubImage)
  {
    prototypeCalled = true;
    glConfig.m_glClearTexSubImage (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
  }
  // GL_ARB_clear_texture - glClearTexSubImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_clear_texture] && glConfig.m_glClearTexSubImage)
  {
    prototypeCalled = true;
    glConfig.m_glClearTexSubImage (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBuffersBase (GLenum target, GLuint first, GLsizei count, const GLuint * buffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_4 - glBindBuffersBase
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_4] && glConfig.m_glBindBuffersBase)
  {
    prototypeCalled = true;
    glConfig.m_glBindBuffersBase (target, first, count, buffers);
  }
  // GL_ARB_multi_bind - glBindBuffersBase
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multi_bind] && glConfig.m_glBindBuffersBase)
  {
    prototypeCalled = true;
    glConfig.m_glBindBuffersBase (target, first, count, buffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBuffersRange (GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizeiptr * sizes)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_4 - glBindBuffersRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_4] && glConfig.m_glBindBuffersRange)
  {
    prototypeCalled = true;
    glConfig.m_glBindBuffersRange (target, first, count, buffers, offsets, sizes);
  }
  // GL_ARB_multi_bind - glBindBuffersRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multi_bind] && glConfig.m_glBindBuffersRange)
  {
    prototypeCalled = true;
    glConfig.m_glBindBuffersRange (target, first, count, buffers, offsets, sizes);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindTextures (GLuint first, GLsizei count, const GLuint * textures)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_4 - glBindTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_4] && glConfig.m_glBindTextures)
  {
    prototypeCalled = true;
    glConfig.m_glBindTextures (first, count, textures);
  }
  // GL_ARB_multi_bind - glBindTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multi_bind] && glConfig.m_glBindTextures)
  {
    prototypeCalled = true;
    glConfig.m_glBindTextures (first, count, textures);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindSamplers (GLuint first, GLsizei count, const GLuint * samplers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_4 - glBindSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_4] && glConfig.m_glBindSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glBindSamplers (first, count, samplers);
  }
  // GL_ARB_multi_bind - glBindSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multi_bind] && glConfig.m_glBindSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glBindSamplers (first, count, samplers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindImageTextures (GLuint first, GLsizei count, const GLuint * textures)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_4 - glBindImageTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_4] && glConfig.m_glBindImageTextures)
  {
    prototypeCalled = true;
    glConfig.m_glBindImageTextures (first, count, textures);
  }
  // GL_ARB_multi_bind - glBindImageTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multi_bind] && glConfig.m_glBindImageTextures)
  {
    prototypeCalled = true;
    glConfig.m_glBindImageTextures (first, count, textures);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindVertexBuffers (GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_4 - glBindVertexBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_4] && glConfig.m_glBindVertexBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexBuffers (first, count, buffers, offsets, strides);
  }
  // GL_ARB_multi_bind - glBindVertexBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multi_bind] && glConfig.m_glBindVertexBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexBuffers (first, count, buffers, offsets, strides);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClipControl (GLenum origin, GLenum depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glClipControl
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glClipControl)
  {
    prototypeCalled = true;
    glConfig.m_glClipControl (origin, depth);
  }
  // GL_ARB_clip_control - glClipControl
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_clip_control] && glConfig.m_glClipControl)
  {
    prototypeCalled = true;
    glConfig.m_glClipControl (origin, depth);
  }
  // GL_EXT_clip_control - glClipControl
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_clip_control] && glConfig.m_glClipControlEXT)
  {
    prototypeCalled = true;
    glConfig.m_glClipControlEXT (origin, depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateTransformFeedbacks (GLsizei n, GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCreateTransformFeedbacks
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCreateTransformFeedbacks)
  {
    prototypeCalled = true;
    glConfig.m_glCreateTransformFeedbacks (n, ids);
  }
  // GL_ARB_direct_state_access - glCreateTransformFeedbacks
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCreateTransformFeedbacks)
  {
    prototypeCalled = true;
    glConfig.m_glCreateTransformFeedbacks (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTransformFeedbackBufferBase (GLuint xfb, GLuint index, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTransformFeedbackBufferBase
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTransformFeedbackBufferBase)
  {
    prototypeCalled = true;
    glConfig.m_glTransformFeedbackBufferBase (xfb, index, buffer);
  }
  // GL_ARB_direct_state_access - glTransformFeedbackBufferBase
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTransformFeedbackBufferBase)
  {
    prototypeCalled = true;
    glConfig.m_glTransformFeedbackBufferBase (xfb, index, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTransformFeedbackBufferRange (GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTransformFeedbackBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTransformFeedbackBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glTransformFeedbackBufferRange (xfb, index, buffer, offset, size);
  }
  // GL_ARB_direct_state_access - glTransformFeedbackBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTransformFeedbackBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glTransformFeedbackBufferRange (xfb, index, buffer, offset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTransformFeedbackiv (GLuint xfb, GLenum pname, GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetTransformFeedbackiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetTransformFeedbackiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTransformFeedbackiv (xfb, pname, param);
  }
  // GL_ARB_direct_state_access - glGetTransformFeedbackiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetTransformFeedbackiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTransformFeedbackiv (xfb, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTransformFeedbacki_v (GLuint xfb, GLenum pname, GLuint index, GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetTransformFeedbacki_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetTransformFeedbacki_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetTransformFeedbacki_v (xfb, pname, index, param);
  }
  // GL_ARB_direct_state_access - glGetTransformFeedbacki_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetTransformFeedbacki_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetTransformFeedbacki_v (xfb, pname, index, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTransformFeedbacki64_v (GLuint xfb, GLenum pname, GLuint index, GLint64 * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetTransformFeedbacki64_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetTransformFeedbacki64_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetTransformFeedbacki64_v (xfb, pname, index, param);
  }
  // GL_ARB_direct_state_access - glGetTransformFeedbacki64_v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetTransformFeedbacki64_v)
  {
    prototypeCalled = true;
    glConfig.m_glGetTransformFeedbacki64_v (xfb, pname, index, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateBuffers (GLsizei n, GLuint * buffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCreateBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCreateBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glCreateBuffers (n, buffers);
  }
  // GL_ARB_direct_state_access - glCreateBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCreateBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glCreateBuffers (n, buffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferStorage (GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedBufferStorage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedBufferStorage)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferStorage (buffer, size, data, flags);
  }
  // GL_ARB_direct_state_access - glNamedBufferStorage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedBufferStorage)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferStorage (buffer, size, data, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferData (GLuint buffer, GLsizeiptr size, const void * data, GLenum usage)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedBufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedBufferData)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferData (buffer, size, data, usage);
  }
  // GL_ARB_direct_state_access - glNamedBufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedBufferData)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferData (buffer, size, data, usage);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferSubData (GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferSubData (buffer, offset, size, data);
  }
  // GL_ARB_direct_state_access - glNamedBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferSubData (buffer, offset, size, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyNamedBufferSubData (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCopyNamedBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCopyNamedBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glCopyNamedBufferSubData (readBuffer, writeBuffer, readOffset, writeOffset, size);
  }
  // GL_ARB_direct_state_access - glCopyNamedBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCopyNamedBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glCopyNamedBufferSubData (readBuffer, writeBuffer, readOffset, writeOffset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearNamedBufferData (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glClearNamedBufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glClearNamedBufferData)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedBufferData (buffer, internalformat, format, type, data);
  }
  // GL_ARB_direct_state_access - glClearNamedBufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glClearNamedBufferData)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedBufferData (buffer, internalformat, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearNamedBufferSubData (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glClearNamedBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glClearNamedBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedBufferSubData (buffer, internalformat, offset, size, format, type, data);
  }
  // GL_ARB_direct_state_access - glClearNamedBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glClearNamedBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedBufferSubData (buffer, internalformat, offset, size, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void * _glew_gl_glMapNamedBuffer (GLuint buffer, GLenum access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  void * result = ((void *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glMapNamedBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glMapNamedBuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapNamedBuffer (buffer, access);
  }
  // GL_ARB_direct_state_access - glMapNamedBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glMapNamedBuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapNamedBuffer (buffer, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void * _glew_gl_glMapNamedBufferRange (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  void * result = ((void *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glMapNamedBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glMapNamedBufferRange)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapNamedBufferRange (buffer, offset, length, access);
  }
  // GL_ARB_direct_state_access - glMapNamedBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glMapNamedBufferRange)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapNamedBufferRange (buffer, offset, length, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glUnmapNamedBuffer (GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glUnmapNamedBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glUnmapNamedBuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glUnmapNamedBuffer (buffer);
  }
  // GL_ARB_direct_state_access - glUnmapNamedBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glUnmapNamedBuffer)
  {
    prototypeCalled = true;
    result = glConfig.m_glUnmapNamedBuffer (buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFlushMappedNamedBufferRange (GLuint buffer, GLintptr offset, GLsizeiptr length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glFlushMappedNamedBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glFlushMappedNamedBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glFlushMappedNamedBufferRange (buffer, offset, length);
  }
  // GL_ARB_direct_state_access - glFlushMappedNamedBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glFlushMappedNamedBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glFlushMappedNamedBufferRange (buffer, offset, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedBufferParameteriv (GLuint buffer, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetNamedBufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetNamedBufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferParameteriv (buffer, pname, params);
  }
  // GL_ARB_direct_state_access - glGetNamedBufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetNamedBufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferParameteriv (buffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedBufferParameteri64v (GLuint buffer, GLenum pname, GLint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetNamedBufferParameteri64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetNamedBufferParameteri64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferParameteri64v (buffer, pname, params);
  }
  // GL_ARB_direct_state_access - glGetNamedBufferParameteri64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetNamedBufferParameteri64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferParameteri64v (buffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedBufferPointerv (GLuint buffer, GLenum pname, void ** params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetNamedBufferPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetNamedBufferPointerv)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferPointerv (buffer, pname, params);
  }
  // GL_ARB_direct_state_access - glGetNamedBufferPointerv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetNamedBufferPointerv)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferPointerv (buffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedBufferSubData (GLuint buffer, GLintptr offset, GLsizeiptr size, void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetNamedBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetNamedBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferSubData (buffer, offset, size, data);
  }
  // GL_ARB_direct_state_access - glGetNamedBufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetNamedBufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferSubData (buffer, offset, size, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateFramebuffers (GLsizei n, GLuint * framebuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCreateFramebuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCreateFramebuffers)
  {
    prototypeCalled = true;
    glConfig.m_glCreateFramebuffers (n, framebuffers);
  }
  // GL_ARB_direct_state_access - glCreateFramebuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCreateFramebuffers)
  {
    prototypeCalled = true;
    glConfig.m_glCreateFramebuffers (n, framebuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferRenderbuffer (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedFramebufferRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedFramebufferRenderbuffer)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferRenderbuffer (framebuffer, attachment, renderbuffertarget, renderbuffer);
  }
  // GL_ARB_direct_state_access - glNamedFramebufferRenderbuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedFramebufferRenderbuffer)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferRenderbuffer (framebuffer, attachment, renderbuffertarget, renderbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferParameteri (GLuint framebuffer, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedFramebufferParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedFramebufferParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferParameteri (framebuffer, pname, param);
  }
  // GL_ARB_direct_state_access - glNamedFramebufferParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedFramebufferParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferParameteri (framebuffer, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferTexture (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedFramebufferTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedFramebufferTexture)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferTexture (framebuffer, attachment, texture, level);
  }
  // GL_ARB_direct_state_access - glNamedFramebufferTexture
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedFramebufferTexture)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferTexture (framebuffer, attachment, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferTextureLayer (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedFramebufferTextureLayer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedFramebufferTextureLayer)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferTextureLayer (framebuffer, attachment, texture, level, layer);
  }
  // GL_ARB_direct_state_access - glNamedFramebufferTextureLayer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedFramebufferTextureLayer)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferTextureLayer (framebuffer, attachment, texture, level, layer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferDrawBuffer (GLuint framebuffer, GLenum buf)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedFramebufferDrawBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedFramebufferDrawBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferDrawBuffer (framebuffer, buf);
  }
  // GL_ARB_direct_state_access - glNamedFramebufferDrawBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedFramebufferDrawBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferDrawBuffer (framebuffer, buf);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferDrawBuffers (GLuint framebuffer, GLsizei n, const GLenum * bufs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedFramebufferDrawBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedFramebufferDrawBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferDrawBuffers (framebuffer, n, bufs);
  }
  // GL_ARB_direct_state_access - glNamedFramebufferDrawBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedFramebufferDrawBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferDrawBuffers (framebuffer, n, bufs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferReadBuffer (GLuint framebuffer, GLenum src)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedFramebufferReadBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedFramebufferReadBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferReadBuffer (framebuffer, src);
  }
  // GL_ARB_direct_state_access - glNamedFramebufferReadBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedFramebufferReadBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferReadBuffer (framebuffer, src);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInvalidateNamedFramebufferData (GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glInvalidateNamedFramebufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glInvalidateNamedFramebufferData)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateNamedFramebufferData (framebuffer, numAttachments, attachments);
  }
  // GL_ARB_direct_state_access - glInvalidateNamedFramebufferData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glInvalidateNamedFramebufferData)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateNamedFramebufferData (framebuffer, numAttachments, attachments);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInvalidateNamedFramebufferSubData (GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glInvalidateNamedFramebufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glInvalidateNamedFramebufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateNamedFramebufferSubData (framebuffer, numAttachments, attachments, x, y, width, height);
  }
  // GL_ARB_direct_state_access - glInvalidateNamedFramebufferSubData
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glInvalidateNamedFramebufferSubData)
  {
    prototypeCalled = true;
    glConfig.m_glInvalidateNamedFramebufferSubData (framebuffer, numAttachments, attachments, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearNamedFramebufferiv (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glClearNamedFramebufferiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glClearNamedFramebufferiv)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedFramebufferiv (framebuffer, buffer, drawbuffer, value);
  }
  // GL_ARB_direct_state_access - glClearNamedFramebufferiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glClearNamedFramebufferiv)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedFramebufferiv (framebuffer, buffer, drawbuffer, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearNamedFramebufferuiv (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glClearNamedFramebufferuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glClearNamedFramebufferuiv)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedFramebufferuiv (framebuffer, buffer, drawbuffer, value);
  }
  // GL_ARB_direct_state_access - glClearNamedFramebufferuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glClearNamedFramebufferuiv)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedFramebufferuiv (framebuffer, buffer, drawbuffer, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearNamedFramebufferfv (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glClearNamedFramebufferfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glClearNamedFramebufferfv)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedFramebufferfv (framebuffer, buffer, drawbuffer, value);
  }
  // GL_ARB_direct_state_access - glClearNamedFramebufferfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glClearNamedFramebufferfv)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedFramebufferfv (framebuffer, buffer, drawbuffer, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearNamedFramebufferfi (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glClearNamedFramebufferfi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glClearNamedFramebufferfi)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedFramebufferfi (framebuffer, buffer, drawbuffer, depth, stencil);
  }
  // GL_ARB_direct_state_access - glClearNamedFramebufferfi
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glClearNamedFramebufferfi)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedFramebufferfi (framebuffer, buffer, drawbuffer, depth, stencil);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlitNamedFramebuffer (GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glBlitNamedFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glBlitNamedFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBlitNamedFramebuffer (readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  // GL_ARB_direct_state_access - glBlitNamedFramebuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glBlitNamedFramebuffer)
  {
    prototypeCalled = true;
    glConfig.m_glBlitNamedFramebuffer (readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glCheckNamedFramebufferStatus (GLuint framebuffer, GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCheckNamedFramebufferStatus
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCheckNamedFramebufferStatus)
  {
    prototypeCalled = true;
    result = glConfig.m_glCheckNamedFramebufferStatus (framebuffer, target);
  }
  // GL_ARB_direct_state_access - glCheckNamedFramebufferStatus
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCheckNamedFramebufferStatus)
  {
    prototypeCalled = true;
    result = glConfig.m_glCheckNamedFramebufferStatus (framebuffer, target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedFramebufferParameteriv (GLuint framebuffer, GLenum pname, GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetNamedFramebufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetNamedFramebufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedFramebufferParameteriv (framebuffer, pname, param);
  }
  // GL_ARB_direct_state_access - glGetNamedFramebufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetNamedFramebufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedFramebufferParameteriv (framebuffer, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedFramebufferAttachmentParameteriv (GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetNamedFramebufferAttachmentParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetNamedFramebufferAttachmentParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedFramebufferAttachmentParameteriv (framebuffer, attachment, pname, params);
  }
  // GL_ARB_direct_state_access - glGetNamedFramebufferAttachmentParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetNamedFramebufferAttachmentParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedFramebufferAttachmentParameteriv (framebuffer, attachment, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateRenderbuffers (GLsizei n, GLuint * renderbuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCreateRenderbuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCreateRenderbuffers)
  {
    prototypeCalled = true;
    glConfig.m_glCreateRenderbuffers (n, renderbuffers);
  }
  // GL_ARB_direct_state_access - glCreateRenderbuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCreateRenderbuffers)
  {
    prototypeCalled = true;
    glConfig.m_glCreateRenderbuffers (n, renderbuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedRenderbufferStorage (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedRenderbufferStorage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedRenderbufferStorage)
  {
    prototypeCalled = true;
    glConfig.m_glNamedRenderbufferStorage (renderbuffer, internalformat, width, height);
  }
  // GL_ARB_direct_state_access - glNamedRenderbufferStorage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedRenderbufferStorage)
  {
    prototypeCalled = true;
    glConfig.m_glNamedRenderbufferStorage (renderbuffer, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedRenderbufferStorageMultisample (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glNamedRenderbufferStorageMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glNamedRenderbufferStorageMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glNamedRenderbufferStorageMultisample (renderbuffer, samples, internalformat, width, height);
  }
  // GL_ARB_direct_state_access - glNamedRenderbufferStorageMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glNamedRenderbufferStorageMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glNamedRenderbufferStorageMultisample (renderbuffer, samples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedRenderbufferParameteriv (GLuint renderbuffer, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetNamedRenderbufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetNamedRenderbufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedRenderbufferParameteriv (renderbuffer, pname, params);
  }
  // GL_ARB_direct_state_access - glGetNamedRenderbufferParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetNamedRenderbufferParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedRenderbufferParameteriv (renderbuffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateTextures (GLenum target, GLsizei n, GLuint * textures)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCreateTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCreateTextures)
  {
    prototypeCalled = true;
    glConfig.m_glCreateTextures (target, n, textures);
  }
  // GL_ARB_direct_state_access - glCreateTextures
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCreateTextures)
  {
    prototypeCalled = true;
    glConfig.m_glCreateTextures (target, n, textures);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureBuffer (GLuint texture, GLenum internalformat, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glTextureBuffer (texture, internalformat, buffer);
  }
  // GL_ARB_direct_state_access - glTextureBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glTextureBuffer (texture, internalformat, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureBufferRange (GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glTextureBufferRange (texture, internalformat, buffer, offset, size);
  }
  // GL_ARB_direct_state_access - glTextureBufferRange
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureBufferRange)
  {
    prototypeCalled = true;
    glConfig.m_glTextureBufferRange (texture, internalformat, buffer, offset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorage1D (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureStorage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureStorage1D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage1D (texture, levels, internalformat, width);
  }
  // GL_ARB_direct_state_access - glTextureStorage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureStorage1D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage1D (texture, levels, internalformat, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorage2D (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureStorage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureStorage2D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage2D (texture, levels, internalformat, width, height);
  }
  // GL_ARB_direct_state_access - glTextureStorage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureStorage2D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage2D (texture, levels, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorage3D (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureStorage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureStorage3D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage3D (texture, levels, internalformat, width, height, depth);
  }
  // GL_ARB_direct_state_access - glTextureStorage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureStorage3D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage3D (texture, levels, internalformat, width, height, depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorage2DMultisample (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureStorage2DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureStorage2DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage2DMultisample (texture, samples, internalformat, width, height, fixedsamplelocations);
  }
  // GL_ARB_direct_state_access - glTextureStorage2DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureStorage2DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage2DMultisample (texture, samples, internalformat, width, height, fixedsamplelocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorage3DMultisample (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureStorage3DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureStorage3DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage3DMultisample (texture, samples, internalformat, width, height, depth, fixedsamplelocations);
  }
  // GL_ARB_direct_state_access - glTextureStorage3DMultisample
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureStorage3DMultisample)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage3DMultisample (texture, samples, internalformat, width, height, depth, fixedsamplelocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureSubImage1D (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureSubImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureSubImage1D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureSubImage1D (texture, level, xoffset, width, format, type, pixels);
  }
  // GL_ARB_direct_state_access - glTextureSubImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureSubImage1D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureSubImage1D (texture, level, xoffset, width, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureSubImage2D (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureSubImage2D (texture, level, xoffset, yoffset, width, height, format, type, pixels);
  }
  // GL_ARB_direct_state_access - glTextureSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureSubImage2D (texture, level, xoffset, yoffset, width, height, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureSubImage3D (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureSubImage3D (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }
  // GL_ARB_direct_state_access - glTextureSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glTextureSubImage3D (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTextureSubImage1D (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCompressedTextureSubImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCompressedTextureSubImage1D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureSubImage1D (texture, level, xoffset, width, format, imageSize, data);
  }
  // GL_ARB_direct_state_access - glCompressedTextureSubImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCompressedTextureSubImage1D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureSubImage1D (texture, level, xoffset, width, format, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTextureSubImage2D (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCompressedTextureSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCompressedTextureSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureSubImage2D (texture, level, xoffset, yoffset, width, height, format, imageSize, data);
  }
  // GL_ARB_direct_state_access - glCompressedTextureSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCompressedTextureSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureSubImage2D (texture, level, xoffset, yoffset, width, height, format, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTextureSubImage3D (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCompressedTextureSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCompressedTextureSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureSubImage3D (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
  }
  // GL_ARB_direct_state_access - glCompressedTextureSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCompressedTextureSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureSubImage3D (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTextureSubImage1D (GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCopyTextureSubImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCopyTextureSubImage1D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureSubImage1D (texture, level, xoffset, x, y, width);
  }
  // GL_ARB_direct_state_access - glCopyTextureSubImage1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCopyTextureSubImage1D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureSubImage1D (texture, level, xoffset, x, y, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTextureSubImage2D (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCopyTextureSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCopyTextureSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureSubImage2D (texture, level, xoffset, yoffset, x, y, width, height);
  }
  // GL_ARB_direct_state_access - glCopyTextureSubImage2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCopyTextureSubImage2D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureSubImage2D (texture, level, xoffset, yoffset, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTextureSubImage3D (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCopyTextureSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCopyTextureSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureSubImage3D (texture, level, xoffset, yoffset, zoffset, x, y, width, height);
  }
  // GL_ARB_direct_state_access - glCopyTextureSubImage3D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCopyTextureSubImage3D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureSubImage3D (texture, level, xoffset, yoffset, zoffset, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameterf (GLuint texture, GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureParameterf)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterf (texture, pname, param);
  }
  // GL_ARB_direct_state_access - glTextureParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureParameterf)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterf (texture, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameterfv (GLuint texture, GLenum pname, const GLfloat * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterfv (texture, pname, param);
  }
  // GL_ARB_direct_state_access - glTextureParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterfv (texture, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameteri (GLuint texture, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameteri (texture, pname, param);
  }
  // GL_ARB_direct_state_access - glTextureParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameteri (texture, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameterIiv (GLuint texture, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterIiv (texture, pname, params);
  }
  // GL_ARB_direct_state_access - glTextureParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterIiv (texture, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameterIuiv (GLuint texture, GLenum pname, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterIuiv (texture, pname, params);
  }
  // GL_ARB_direct_state_access - glTextureParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterIuiv (texture, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameteriv (GLuint texture, GLenum pname, const GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameteriv (texture, pname, param);
  }
  // GL_ARB_direct_state_access - glTextureParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glTextureParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameteriv (texture, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenerateTextureMipmap (GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGenerateTextureMipmap
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGenerateTextureMipmap)
  {
    prototypeCalled = true;
    glConfig.m_glGenerateTextureMipmap (texture);
  }
  // GL_ARB_direct_state_access - glGenerateTextureMipmap
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGenerateTextureMipmap)
  {
    prototypeCalled = true;
    glConfig.m_glGenerateTextureMipmap (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindTextureUnit (GLuint unit, GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glBindTextureUnit
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glBindTextureUnit)
  {
    prototypeCalled = true;
    glConfig.m_glBindTextureUnit (unit, texture);
  }
  // GL_ARB_direct_state_access - glBindTextureUnit
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glBindTextureUnit)
  {
    prototypeCalled = true;
    glConfig.m_glBindTextureUnit (unit, texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureImage (GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetTextureImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetTextureImage)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureImage (texture, level, format, type, bufSize, pixels);
  }
  // GL_ARB_direct_state_access - glGetTextureImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetTextureImage)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureImage (texture, level, format, type, bufSize, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCompressedTextureImage (GLuint texture, GLint level, GLsizei bufSize, void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetCompressedTextureImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetCompressedTextureImage)
  {
    prototypeCalled = true;
    glConfig.m_glGetCompressedTextureImage (texture, level, bufSize, pixels);
  }
  // GL_ARB_direct_state_access - glGetCompressedTextureImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetCompressedTextureImage)
  {
    prototypeCalled = true;
    glConfig.m_glGetCompressedTextureImage (texture, level, bufSize, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureLevelParameterfv (GLuint texture, GLint level, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetTextureLevelParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetTextureLevelParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureLevelParameterfv (texture, level, pname, params);
  }
  // GL_ARB_direct_state_access - glGetTextureLevelParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetTextureLevelParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureLevelParameterfv (texture, level, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureLevelParameteriv (GLuint texture, GLint level, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetTextureLevelParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetTextureLevelParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureLevelParameteriv (texture, level, pname, params);
  }
  // GL_ARB_direct_state_access - glGetTextureLevelParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetTextureLevelParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureLevelParameteriv (texture, level, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureParameterfv (GLuint texture, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetTextureParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetTextureParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameterfv (texture, pname, params);
  }
  // GL_ARB_direct_state_access - glGetTextureParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetTextureParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameterfv (texture, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureParameterIiv (GLuint texture, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetTextureParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetTextureParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameterIiv (texture, pname, params);
  }
  // GL_ARB_direct_state_access - glGetTextureParameterIiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetTextureParameterIiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameterIiv (texture, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureParameterIuiv (GLuint texture, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetTextureParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetTextureParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameterIuiv (texture, pname, params);
  }
  // GL_ARB_direct_state_access - glGetTextureParameterIuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetTextureParameterIuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameterIuiv (texture, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureParameteriv (GLuint texture, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetTextureParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetTextureParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameteriv (texture, pname, params);
  }
  // GL_ARB_direct_state_access - glGetTextureParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetTextureParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameteriv (texture, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateVertexArrays (GLsizei n, GLuint * arrays)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCreateVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCreateVertexArrays)
  {
    prototypeCalled = true;
    glConfig.m_glCreateVertexArrays (n, arrays);
  }
  // GL_ARB_direct_state_access - glCreateVertexArrays
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCreateVertexArrays)
  {
    prototypeCalled = true;
    glConfig.m_glCreateVertexArrays (n, arrays);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableVertexArrayAttrib (GLuint vaobj, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glDisableVertexArrayAttrib
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glDisableVertexArrayAttrib)
  {
    prototypeCalled = true;
    glConfig.m_glDisableVertexArrayAttrib (vaobj, index);
  }
  // GL_ARB_direct_state_access - glDisableVertexArrayAttrib
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glDisableVertexArrayAttrib)
  {
    prototypeCalled = true;
    glConfig.m_glDisableVertexArrayAttrib (vaobj, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableVertexArrayAttrib (GLuint vaobj, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glEnableVertexArrayAttrib
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glEnableVertexArrayAttrib)
  {
    prototypeCalled = true;
    glConfig.m_glEnableVertexArrayAttrib (vaobj, index);
  }
  // GL_ARB_direct_state_access - glEnableVertexArrayAttrib
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glEnableVertexArrayAttrib)
  {
    prototypeCalled = true;
    glConfig.m_glEnableVertexArrayAttrib (vaobj, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayElementBuffer (GLuint vaobj, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glVertexArrayElementBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glVertexArrayElementBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayElementBuffer (vaobj, buffer);
  }
  // GL_ARB_direct_state_access - glVertexArrayElementBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glVertexArrayElementBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayElementBuffer (vaobj, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexBuffer (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glVertexArrayVertexBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glVertexArrayVertexBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexBuffer (vaobj, bindingindex, buffer, offset, stride);
  }
  // GL_ARB_direct_state_access - glVertexArrayVertexBuffer
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glVertexArrayVertexBuffer)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexBuffer (vaobj, bindingindex, buffer, offset, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexBuffers (GLuint vaobj, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glVertexArrayVertexBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glVertexArrayVertexBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexBuffers (vaobj, first, count, buffers, offsets, strides);
  }
  // GL_ARB_direct_state_access - glVertexArrayVertexBuffers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glVertexArrayVertexBuffers)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexBuffers (vaobj, first, count, buffers, offsets, strides);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayAttribBinding (GLuint vaobj, GLuint attribindex, GLuint bindingindex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glVertexArrayAttribBinding
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glVertexArrayAttribBinding)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayAttribBinding (vaobj, attribindex, bindingindex);
  }
  // GL_ARB_direct_state_access - glVertexArrayAttribBinding
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glVertexArrayAttribBinding)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayAttribBinding (vaobj, attribindex, bindingindex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayAttribFormat (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glVertexArrayAttribFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glVertexArrayAttribFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayAttribFormat (vaobj, attribindex, size, type, normalized, relativeoffset);
  }
  // GL_ARB_direct_state_access - glVertexArrayAttribFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glVertexArrayAttribFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayAttribFormat (vaobj, attribindex, size, type, normalized, relativeoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayAttribIFormat (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glVertexArrayAttribIFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glVertexArrayAttribIFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayAttribIFormat (vaobj, attribindex, size, type, relativeoffset);
  }
  // GL_ARB_direct_state_access - glVertexArrayAttribIFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glVertexArrayAttribIFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayAttribIFormat (vaobj, attribindex, size, type, relativeoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayAttribLFormat (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glVertexArrayAttribLFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glVertexArrayAttribLFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayAttribLFormat (vaobj, attribindex, size, type, relativeoffset);
  }
  // GL_ARB_direct_state_access - glVertexArrayAttribLFormat
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glVertexArrayAttribLFormat)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayAttribLFormat (vaobj, attribindex, size, type, relativeoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayBindingDivisor (GLuint vaobj, GLuint bindingindex, GLuint divisor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glVertexArrayBindingDivisor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glVertexArrayBindingDivisor)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayBindingDivisor (vaobj, bindingindex, divisor);
  }
  // GL_ARB_direct_state_access - glVertexArrayBindingDivisor
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glVertexArrayBindingDivisor)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayBindingDivisor (vaobj, bindingindex, divisor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexArrayiv (GLuint vaobj, GLenum pname, GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetVertexArrayiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetVertexArrayiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexArrayiv (vaobj, pname, param);
  }
  // GL_ARB_direct_state_access - glGetVertexArrayiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetVertexArrayiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexArrayiv (vaobj, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexArrayIndexediv (GLuint vaobj, GLuint index, GLenum pname, GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetVertexArrayIndexediv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetVertexArrayIndexediv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexArrayIndexediv (vaobj, index, pname, param);
  }
  // GL_ARB_direct_state_access - glGetVertexArrayIndexediv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetVertexArrayIndexediv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexArrayIndexediv (vaobj, index, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexArrayIndexed64iv (GLuint vaobj, GLuint index, GLenum pname, GLint64 * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetVertexArrayIndexed64iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetVertexArrayIndexed64iv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexArrayIndexed64iv (vaobj, index, pname, param);
  }
  // GL_ARB_direct_state_access - glGetVertexArrayIndexed64iv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetVertexArrayIndexed64iv)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexArrayIndexed64iv (vaobj, index, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateSamplers (GLsizei n, GLuint * samplers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCreateSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCreateSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glCreateSamplers (n, samplers);
  }
  // GL_ARB_direct_state_access - glCreateSamplers
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCreateSamplers)
  {
    prototypeCalled = true;
    glConfig.m_glCreateSamplers (n, samplers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateProgramPipelines (GLsizei n, GLuint * pipelines)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCreateProgramPipelines
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCreateProgramPipelines)
  {
    prototypeCalled = true;
    glConfig.m_glCreateProgramPipelines (n, pipelines);
  }
  // GL_ARB_direct_state_access - glCreateProgramPipelines
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCreateProgramPipelines)
  {
    prototypeCalled = true;
    glConfig.m_glCreateProgramPipelines (n, pipelines);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateQueries (GLenum target, GLsizei n, GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glCreateQueries
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glCreateQueries)
  {
    prototypeCalled = true;
    glConfig.m_glCreateQueries (target, n, ids);
  }
  // GL_ARB_direct_state_access - glCreateQueries
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glCreateQueries)
  {
    prototypeCalled = true;
    glConfig.m_glCreateQueries (target, n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryBufferObjecti64v (GLuint id, GLuint buffer, GLenum pname, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetQueryBufferObjecti64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetQueryBufferObjecti64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryBufferObjecti64v (id, buffer, pname, offset);
  }
  // GL_ARB_direct_state_access - glGetQueryBufferObjecti64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetQueryBufferObjecti64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryBufferObjecti64v (id, buffer, pname, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryBufferObjectiv (GLuint id, GLuint buffer, GLenum pname, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetQueryBufferObjectiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetQueryBufferObjectiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryBufferObjectiv (id, buffer, pname, offset);
  }
  // GL_ARB_direct_state_access - glGetQueryBufferObjectiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetQueryBufferObjectiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryBufferObjectiv (id, buffer, pname, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryBufferObjectui64v (GLuint id, GLuint buffer, GLenum pname, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetQueryBufferObjectui64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetQueryBufferObjectui64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryBufferObjectui64v (id, buffer, pname, offset);
  }
  // GL_ARB_direct_state_access - glGetQueryBufferObjectui64v
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetQueryBufferObjectui64v)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryBufferObjectui64v (id, buffer, pname, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryBufferObjectuiv (GLuint id, GLuint buffer, GLenum pname, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetQueryBufferObjectuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetQueryBufferObjectuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryBufferObjectuiv (id, buffer, pname, offset);
  }
  // GL_ARB_direct_state_access - glGetQueryBufferObjectuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] && glConfig.m_glGetQueryBufferObjectuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryBufferObjectuiv (id, buffer, pname, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMemoryBarrierByRegion (GLbitfield barriers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glMemoryBarrierByRegion
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glMemoryBarrierByRegion)
  {
    prototypeCalled = true;
    glConfig.m_glMemoryBarrierByRegion (barriers);
  }
  // GL_ES_VERSION_3_1 - glMemoryBarrierByRegion
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] && glConfig.m_glMemoryBarrierByRegion)
  {
    prototypeCalled = true;
    glConfig.m_glMemoryBarrierByRegion (barriers);
  }
  // GL_ARB_ES3_1_compatibility - glMemoryBarrierByRegion
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_ES3_1_compatibility] && glConfig.m_glMemoryBarrierByRegion)
  {
    prototypeCalled = true;
    glConfig.m_glMemoryBarrierByRegion (barriers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureSubImage (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetTextureSubImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetTextureSubImage)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureSubImage (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
  }
  // GL_ARB_get_texture_sub_image - glGetTextureSubImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_get_texture_sub_image] && glConfig.m_glGetTextureSubImage)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureSubImage (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCompressedTextureSubImage (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetCompressedTextureSubImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetCompressedTextureSubImage)
  {
    prototypeCalled = true;
    glConfig.m_glGetCompressedTextureSubImage (texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
  }
  // GL_ARB_get_texture_sub_image - glGetCompressedTextureSubImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_get_texture_sub_image] && glConfig.m_glGetCompressedTextureSubImage)
  {
    prototypeCalled = true;
    glConfig.m_glGetCompressedTextureSubImage (texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glGetGraphicsResetStatus ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetGraphicsResetStatus
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetGraphicsResetStatus)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetGraphicsResetStatus ();
  }
  // GL_ES_VERSION_3_2 - glGetGraphicsResetStatus
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetGraphicsResetStatus)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetGraphicsResetStatus ();
  }
  // GL_KHR_robustness - glGetGraphicsResetStatus
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetGraphicsResetStatus)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetGraphicsResetStatus ();
  }
  // GL_EXT_robustness - glGetGraphicsResetStatus
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_robustness] && glConfig.m_glGetGraphicsResetStatusEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetGraphicsResetStatusEXT ();
  }
  // GL_KHR_robustness - glGetGraphicsResetStatus
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetGraphicsResetStatusKHR)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetGraphicsResetStatusKHR ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnCompressedTexImage (GLenum target, GLint lod, GLsizei bufSize, void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnCompressedTexImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnCompressedTexImage)
  {
    prototypeCalled = true;
    glConfig.m_glGetnCompressedTexImage (target, lod, bufSize, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnTexImage
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnTexImage)
  {
    prototypeCalled = true;
    glConfig.m_glGetnTexImage (target, level, format, type, bufSize, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformdv (GLuint program, GLint location, GLsizei bufSize, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnUniformdv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnUniformdv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformdv (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformfv (GLuint program, GLint location, GLsizei bufSize, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnUniformfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnUniformfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformfv (program, location, bufSize, params);
  }
  // GL_ES_VERSION_3_2 - glGetnUniformfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetnUniformfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformfv (program, location, bufSize, params);
  }
  // GL_KHR_robustness - glGetnUniformfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetnUniformfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformfv (program, location, bufSize, params);
  }
  // GL_EXT_robustness - glGetnUniformfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_robustness] && glConfig.m_glGetnUniformfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformfvEXT (program, location, bufSize, params);
  }
  // GL_KHR_robustness - glGetnUniformfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetnUniformfvKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformfvKHR (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformiv (GLuint program, GLint location, GLsizei bufSize, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnUniformiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnUniformiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformiv (program, location, bufSize, params);
  }
  // GL_ES_VERSION_3_2 - glGetnUniformiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetnUniformiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformiv (program, location, bufSize, params);
  }
  // GL_KHR_robustness - glGetnUniformiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetnUniformiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformiv (program, location, bufSize, params);
  }
  // GL_EXT_robustness - glGetnUniformiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_robustness] && glConfig.m_glGetnUniformivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformivEXT (program, location, bufSize, params);
  }
  // GL_KHR_robustness - glGetnUniformiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetnUniformivKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformivKHR (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformuiv (GLuint program, GLint location, GLsizei bufSize, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnUniformuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnUniformuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformuiv (program, location, bufSize, params);
  }
  // GL_ES_VERSION_3_2 - glGetnUniformuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glGetnUniformuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformuiv (program, location, bufSize, params);
  }
  // GL_KHR_robustness - glGetnUniformuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetnUniformuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformuiv (program, location, bufSize, params);
  }
  // GL_KHR_robustness - glGetnUniformuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetnUniformuivKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformuivKHR (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReadnPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glReadnPixels
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glReadnPixels)
  {
    prototypeCalled = true;
    glConfig.m_glReadnPixels (x, y, width, height, format, type, bufSize, data);
  }
  // GL_ES_VERSION_3_2 - glReadnPixels
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glReadnPixels)
  {
    prototypeCalled = true;
    glConfig.m_glReadnPixels (x, y, width, height, format, type, bufSize, data);
  }
  // GL_KHR_robustness - glReadnPixels
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glReadnPixels)
  {
    prototypeCalled = true;
    glConfig.m_glReadnPixels (x, y, width, height, format, type, bufSize, data);
  }
  // GL_ARB_robustness - glReadnPixels
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glReadnPixelsARB)
  {
    prototypeCalled = true;
    glConfig.m_glReadnPixelsARB (x, y, width, height, format, type, bufSize, data);
  }
  // GL_EXT_robustness - glReadnPixels
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_robustness] && glConfig.m_glReadnPixelsEXT)
  {
    prototypeCalled = true;
    glConfig.m_glReadnPixelsEXT (x, y, width, height, format, type, bufSize, data);
  }
  // GL_KHR_robustness - glReadnPixels
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glReadnPixelsKHR)
  {
    prototypeCalled = true;
    glConfig.m_glReadnPixelsKHR (x, y, width, height, format, type, bufSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnMapdv (GLenum target, GLenum query, GLsizei bufSize, GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnMapdv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnMapdv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnMapdv (target, query, bufSize, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnMapfv (GLenum target, GLenum query, GLsizei bufSize, GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnMapfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnMapfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnMapfv (target, query, bufSize, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnMapiv (GLenum target, GLenum query, GLsizei bufSize, GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnMapiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnMapiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnMapiv (target, query, bufSize, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnPixelMapfv (GLenum map, GLsizei bufSize, GLfloat * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnPixelMapfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnPixelMapfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnPixelMapfv (map, bufSize, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnPixelMapuiv (GLenum map, GLsizei bufSize, GLuint * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnPixelMapuiv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnPixelMapuiv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnPixelMapuiv (map, bufSize, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnPixelMapusv (GLenum map, GLsizei bufSize, GLushort * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnPixelMapusv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnPixelMapusv)
  {
    prototypeCalled = true;
    glConfig.m_glGetnPixelMapusv (map, bufSize, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnPolygonStipple (GLsizei bufSize, GLubyte * pattern)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnPolygonStipple
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnPolygonStipple)
  {
    prototypeCalled = true;
    glConfig.m_glGetnPolygonStipple (bufSize, pattern);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnColorTable (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * table)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnColorTable
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnColorTable)
  {
    prototypeCalled = true;
    glConfig.m_glGetnColorTable (target, format, type, bufSize, table);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnConvolutionFilter (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * image)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnConvolutionFilter
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnConvolutionFilter)
  {
    prototypeCalled = true;
    glConfig.m_glGetnConvolutionFilter (target, format, type, bufSize, image);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnSeparableFilter (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void * row, GLsizei columnBufSize, void * column, void * span)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnSeparableFilter
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnSeparableFilter)
  {
    prototypeCalled = true;
    glConfig.m_glGetnSeparableFilter (target, format, type, rowBufSize, row, columnBufSize, column, span);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnHistogram (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnHistogram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnHistogram)
  {
    prototypeCalled = true;
    glConfig.m_glGetnHistogram (target, reset, format, type, bufSize, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnMinmax (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glGetnMinmax
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glGetnMinmax)
  {
    prototypeCalled = true;
    glConfig.m_glGetnMinmax (target, reset, format, type, bufSize, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureBarrier ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_5 - glTextureBarrier
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_5] && glConfig.m_glTextureBarrier)
  {
    prototypeCalled = true;
    glConfig.m_glTextureBarrier ();
  }
  // GL_ARB_texture_barrier - glTextureBarrier
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_barrier] && glConfig.m_glTextureBarrier)
  {
    prototypeCalled = true;
    glConfig.m_glTextureBarrier ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSpecializeShader (GLuint shader, const GLchar * pEntryPoint, GLuint numSpecializationConstants, const GLuint * pConstantIndex, const GLuint * pConstantValue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_6 - glSpecializeShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_6] && glConfig.m_glSpecializeShader)
  {
    prototypeCalled = true;
    glConfig.m_glSpecializeShader (shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
  }
  // GL_ARB_gl_spirv - glSpecializeShader
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gl_spirv] && glConfig.m_glSpecializeShaderARB)
  {
    prototypeCalled = true;
    glConfig.m_glSpecializeShaderARB (shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawArraysIndirectCount (GLenum mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_6 - glMultiDrawArraysIndirectCount
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_6] && glConfig.m_glMultiDrawArraysIndirectCount)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawArraysIndirectCount (mode, indirect, drawcount, maxdrawcount, stride);
  }
  // GL_ARB_indirect_parameters - glMultiDrawArraysIndirectCount
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_indirect_parameters] && glConfig.m_glMultiDrawArraysIndirectCountARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawArraysIndirectCountARB (mode, indirect, drawcount, maxdrawcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElementsIndirectCount (GLenum mode, GLenum type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_6 - glMultiDrawElementsIndirectCount
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_6] && glConfig.m_glMultiDrawElementsIndirectCount)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsIndirectCount (mode, type, indirect, drawcount, maxdrawcount, stride);
  }
  // GL_ARB_indirect_parameters - glMultiDrawElementsIndirectCount
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_indirect_parameters] && glConfig.m_glMultiDrawElementsIndirectCountARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsIndirectCountARB (mode, type, indirect, drawcount, maxdrawcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPolygonOffsetClamp (GLfloat factor, GLfloat units, GLfloat clamp)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_VERSION_4_6 - glPolygonOffsetClamp
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_VERSION_4_6] && glConfig.m_glPolygonOffsetClamp)
  {
    prototypeCalled = true;
    glConfig.m_glPolygonOffsetClamp (factor, units, clamp);
  }
  // GL_ARB_polygon_offset_clamp - glPolygonOffsetClamp
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_polygon_offset_clamp] && glConfig.m_glPolygonOffsetClamp)
  {
    prototypeCalled = true;
    glConfig.m_glPolygonOffsetClamp (factor, units, clamp);
  }
  // GL_EXT_polygon_offset_clamp - glPolygonOffsetClamp
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_polygon_offset_clamp] && glConfig.m_glPolygonOffsetClampEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPolygonOffsetClampEXT (factor, units, clamp);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendBarrier ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ES_VERSION_3_2 - glBlendBarrier
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glBlendBarrier)
  {
    prototypeCalled = true;
    glConfig.m_glBlendBarrier ();
  }
  // GL_KHR_blend_equation_advanced - glBlendBarrier
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_blend_equation_advanced] && glConfig.m_glBlendBarrierKHR)
  {
    prototypeCalled = true;
    glConfig.m_glBlendBarrierKHR ();
  }
  // GL_NV_blend_equation_advanced - glBlendBarrier
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_blend_equation_advanced] && glConfig.m_glBlendBarrierNV)
  {
    prototypeCalled = true;
    glConfig.m_glBlendBarrierNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPrimitiveBoundingBox (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ES_VERSION_3_2 - glPrimitiveBoundingBox
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] && glConfig.m_glPrimitiveBoundingBox)
  {
    prototypeCalled = true;
    glConfig.m_glPrimitiveBoundingBox (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
  }
  // GL_ARB_ES3_2_compatibility - glPrimitiveBoundingBox
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_ES3_2_compatibility] && glConfig.m_glPrimitiveBoundingBoxARB)
  {
    prototypeCalled = true;
    glConfig.m_glPrimitiveBoundingBoxARB (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
  }
  // GL_EXT_primitive_bounding_box - glPrimitiveBoundingBox
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_primitive_bounding_box] && glConfig.m_glPrimitiveBoundingBoxEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPrimitiveBoundingBoxEXT (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
  }
  // GL_OES_primitive_bounding_box - glPrimitiveBoundingBox
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_primitive_bounding_box] && glConfig.m_glPrimitiveBoundingBoxOES)
  {
    prototypeCalled = true;
    glConfig.m_glPrimitiveBoundingBoxOES (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTbufferMask3DFX (GLuint mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_3DFX_tbuffer - glTbufferMask3DFX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_3DFX_tbuffer] && glConfig.m_glTbufferMask3DFX)
  {
    prototypeCalled = true;
    glConfig.m_glTbufferMask3DFX (mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageEnableAMD (GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_debug_output - glDebugMessageEnableAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_debug_output] && glConfig.m_glDebugMessageEnableAMD)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageEnableAMD (category, severity, count, ids, enabled);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageInsertAMD (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_debug_output - glDebugMessageInsertAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_debug_output] && glConfig.m_glDebugMessageInsertAMD)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageInsertAMD (category, severity, id, length, buf);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageCallbackAMD (GLDEBUGPROCAMD callback, void * userParam)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_debug_output - glDebugMessageCallbackAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_debug_output] && glConfig.m_glDebugMessageCallbackAMD)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageCallbackAMD (callback, userParam);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGetDebugMessageLogAMD (GLuint count, GLsizei bufSize, GLenum * categories, GLenum * severities, GLuint * ids, GLsizei * lengths, GLchar * message)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_debug_output - glGetDebugMessageLogAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_debug_output] && glConfig.m_glGetDebugMessageLogAMD)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetDebugMessageLogAMD (count, bufSize, categories, severities, ids, lengths, message);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFuncIndexedAMD (GLuint buf, GLenum src, GLenum dst)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_draw_buffers_blend - glBlendFuncIndexedAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_draw_buffers_blend] && glConfig.m_glBlendFuncIndexedAMD)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncIndexedAMD (buf, src, dst);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFuncSeparateIndexedAMD (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_draw_buffers_blend - glBlendFuncSeparateIndexedAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_draw_buffers_blend] && glConfig.m_glBlendFuncSeparateIndexedAMD)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparateIndexedAMD (buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationIndexedAMD (GLuint buf, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_draw_buffers_blend - glBlendEquationIndexedAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_draw_buffers_blend] && glConfig.m_glBlendEquationIndexedAMD)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationIndexedAMD (buf, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationSeparateIndexedAMD (GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_draw_buffers_blend - glBlendEquationSeparateIndexedAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_draw_buffers_blend] && glConfig.m_glBlendEquationSeparateIndexedAMD)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparateIndexedAMD (buf, modeRGB, modeAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRenderbufferStorageMultisampleAdvancedAMD (GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_framebuffer_multisample_advanced - glRenderbufferStorageMultisampleAdvancedAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_framebuffer_multisample_advanced] && glConfig.m_glRenderbufferStorageMultisampleAdvancedAMD)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisampleAdvancedAMD (target, samples, storageSamples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedRenderbufferStorageMultisampleAdvancedAMD (GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_framebuffer_multisample_advanced - glNamedRenderbufferStorageMultisampleAdvancedAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_framebuffer_multisample_advanced] && glConfig.m_glNamedRenderbufferStorageMultisampleAdvancedAMD)
  {
    prototypeCalled = true;
    glConfig.m_glNamedRenderbufferStorageMultisampleAdvancedAMD (renderbuffer, samples, storageSamples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferSamplePositionsfvAMD (GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_framebuffer_sample_positions - glFramebufferSamplePositionsfvAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_framebuffer_sample_positions] && glConfig.m_glFramebufferSamplePositionsfvAMD)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferSamplePositionsfvAMD (target, numsamples, pixelindex, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferSamplePositionsfvAMD (GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_framebuffer_sample_positions - glNamedFramebufferSamplePositionsfvAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_framebuffer_sample_positions] && glConfig.m_glNamedFramebufferSamplePositionsfvAMD)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferSamplePositionsfvAMD (framebuffer, numsamples, pixelindex, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFramebufferParameterfvAMD (GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_framebuffer_sample_positions - glGetFramebufferParameterfvAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_framebuffer_sample_positions] && glConfig.m_glGetFramebufferParameterfvAMD)
  {
    prototypeCalled = true;
    glConfig.m_glGetFramebufferParameterfvAMD (target, pname, numsamples, pixelindex, size, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedFramebufferParameterfvAMD (GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_framebuffer_sample_positions - glGetNamedFramebufferParameterfvAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_framebuffer_sample_positions] && glConfig.m_glGetNamedFramebufferParameterfvAMD)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedFramebufferParameterfvAMD (framebuffer, pname, numsamples, pixelindex, size, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1i64NV (GLint location, GLint64EXT x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform1i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform1i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1i64NV (location, x);
  }
  // GL_NV_gpu_shader5 - glUniform1i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform1i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1i64NV (location, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2i64NV (GLint location, GLint64EXT x, GLint64EXT y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform2i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform2i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2i64NV (location, x, y);
  }
  // GL_NV_gpu_shader5 - glUniform2i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform2i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2i64NV (location, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3i64NV (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform3i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform3i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3i64NV (location, x, y, z);
  }
  // GL_NV_gpu_shader5 - glUniform3i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform3i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3i64NV (location, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4i64NV (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform4i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform4i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4i64NV (location, x, y, z, w);
  }
  // GL_NV_gpu_shader5 - glUniform4i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform4i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4i64NV (location, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1i64vNV (GLint location, GLsizei count, const GLint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform1i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform1i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1i64vNV (location, count, value);
  }
  // GL_NV_gpu_shader5 - glUniform1i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform1i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1i64vNV (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2i64vNV (GLint location, GLsizei count, const GLint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform2i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform2i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2i64vNV (location, count, value);
  }
  // GL_NV_gpu_shader5 - glUniform2i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform2i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2i64vNV (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3i64vNV (GLint location, GLsizei count, const GLint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform3i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform3i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3i64vNV (location, count, value);
  }
  // GL_NV_gpu_shader5 - glUniform3i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform3i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3i64vNV (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4i64vNV (GLint location, GLsizei count, const GLint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform4i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform4i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4i64vNV (location, count, value);
  }
  // GL_NV_gpu_shader5 - glUniform4i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform4i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4i64vNV (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1ui64NV (GLint location, GLuint64EXT x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform1ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform1ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1ui64NV (location, x);
  }
  // GL_NV_gpu_shader5 - glUniform1ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform1ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1ui64NV (location, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2ui64NV (GLint location, GLuint64EXT x, GLuint64EXT y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform2ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform2ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2ui64NV (location, x, y);
  }
  // GL_NV_gpu_shader5 - glUniform2ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform2ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2ui64NV (location, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3ui64NV (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform3ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform3ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3ui64NV (location, x, y, z);
  }
  // GL_NV_gpu_shader5 - glUniform3ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform3ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3ui64NV (location, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4ui64NV (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform4ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform4ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4ui64NV (location, x, y, z, w);
  }
  // GL_NV_gpu_shader5 - glUniform4ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform4ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4ui64NV (location, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1ui64vNV (GLint location, GLsizei count, const GLuint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform1ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform1ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1ui64vNV (location, count, value);
  }
  // GL_NV_gpu_shader5 - glUniform1ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform1ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1ui64vNV (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2ui64vNV (GLint location, GLsizei count, const GLuint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform2ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform2ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2ui64vNV (location, count, value);
  }
  // GL_NV_gpu_shader5 - glUniform2ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform2ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2ui64vNV (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3ui64vNV (GLint location, GLsizei count, const GLuint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform3ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform3ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3ui64vNV (location, count, value);
  }
  // GL_NV_gpu_shader5 - glUniform3ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform3ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3ui64vNV (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4ui64vNV (GLint location, GLsizei count, const GLuint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glUniform4ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glUniform4ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4ui64vNV (location, count, value);
  }
  // GL_NV_gpu_shader5 - glUniform4ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glUniform4ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4ui64vNV (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformi64vNV (GLuint program, GLint location, GLint64EXT * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glGetUniformi64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glGetUniformi64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformi64vNV (program, location, params);
  }
  // GL_NV_gpu_shader5 - glGetUniformi64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glGetUniformi64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformi64vNV (program, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformui64vNV (GLuint program, GLint location, GLuint64EXT * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glGetUniformui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glGetUniformui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformui64vNV (program, location, params);
  }
  // GL_NV_shader_buffer_load - glGetUniformui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glGetUniformui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformui64vNV (program, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1i64NV (GLuint program, GLint location, GLint64EXT x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform1i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform1i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1i64NV (program, location, x);
  }
  // GL_NV_gpu_shader5 - glProgramUniform1i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform1i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1i64NV (program, location, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2i64NV (GLuint program, GLint location, GLint64EXT x, GLint64EXT y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform2i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform2i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2i64NV (program, location, x, y);
  }
  // GL_NV_gpu_shader5 - glProgramUniform2i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform2i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2i64NV (program, location, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3i64NV (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform3i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform3i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3i64NV (program, location, x, y, z);
  }
  // GL_NV_gpu_shader5 - glProgramUniform3i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform3i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3i64NV (program, location, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4i64NV (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform4i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform4i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4i64NV (program, location, x, y, z, w);
  }
  // GL_NV_gpu_shader5 - glProgramUniform4i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform4i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4i64NV (program, location, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1i64vNV (GLuint program, GLint location, GLsizei count, const GLint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform1i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform1i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1i64vNV (program, location, count, value);
  }
  // GL_NV_gpu_shader5 - glProgramUniform1i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform1i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1i64vNV (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2i64vNV (GLuint program, GLint location, GLsizei count, const GLint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform2i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform2i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2i64vNV (program, location, count, value);
  }
  // GL_NV_gpu_shader5 - glProgramUniform2i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform2i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2i64vNV (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3i64vNV (GLuint program, GLint location, GLsizei count, const GLint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform3i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform3i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3i64vNV (program, location, count, value);
  }
  // GL_NV_gpu_shader5 - glProgramUniform3i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform3i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3i64vNV (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4i64vNV (GLuint program, GLint location, GLsizei count, const GLint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform4i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform4i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4i64vNV (program, location, count, value);
  }
  // GL_NV_gpu_shader5 - glProgramUniform4i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform4i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4i64vNV (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1ui64NV (GLuint program, GLint location, GLuint64EXT x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform1ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform1ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ui64NV (program, location, x);
  }
  // GL_NV_gpu_shader5 - glProgramUniform1ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform1ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ui64NV (program, location, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2ui64NV (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform2ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform2ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ui64NV (program, location, x, y);
  }
  // GL_NV_gpu_shader5 - glProgramUniform2ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform2ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ui64NV (program, location, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3ui64NV (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform3ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform3ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ui64NV (program, location, x, y, z);
  }
  // GL_NV_gpu_shader5 - glProgramUniform3ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform3ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ui64NV (program, location, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4ui64NV (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform4ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform4ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ui64NV (program, location, x, y, z, w);
  }
  // GL_NV_gpu_shader5 - glProgramUniform4ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform4ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ui64NV (program, location, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1ui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform1ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform1ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ui64vNV (program, location, count, value);
  }
  // GL_NV_gpu_shader5 - glProgramUniform1ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform1ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ui64vNV (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2ui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform2ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform2ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ui64vNV (program, location, count, value);
  }
  // GL_NV_gpu_shader5 - glProgramUniform2ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform2ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ui64vNV (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3ui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform3ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform3ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ui64vNV (program, location, count, value);
  }
  // GL_NV_gpu_shader5 - glProgramUniform3ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform3ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ui64vNV (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4ui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_gpu_shader_int64 - glProgramUniform4ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] && glConfig.m_glProgramUniform4ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ui64vNV (program, location, count, value);
  }
  // GL_NV_gpu_shader5 - glProgramUniform4ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] && glConfig.m_glProgramUniform4ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ui64vNV (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribParameteriAMD (GLuint index, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_interleaved_elements - glVertexAttribParameteriAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_interleaved_elements] && glConfig.m_glVertexAttribParameteriAMD)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribParameteriAMD (index, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawArraysIndirectAMD (GLenum mode, const void * indirect, GLsizei primcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_multi_draw_indirect - glMultiDrawArraysIndirectAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_multi_draw_indirect] && glConfig.m_glMultiDrawArraysIndirectAMD)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawArraysIndirectAMD (mode, indirect, primcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElementsIndirectAMD (GLenum mode, GLenum type, const void * indirect, GLsizei primcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_multi_draw_indirect - glMultiDrawElementsIndirectAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_multi_draw_indirect] && glConfig.m_glMultiDrawElementsIndirectAMD)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsIndirectAMD (mode, type, indirect, primcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenNamesAMD (GLenum identifier, GLuint num, GLuint * names)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_name_gen_delete - glGenNamesAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_name_gen_delete] && glConfig.m_glGenNamesAMD)
  {
    prototypeCalled = true;
    glConfig.m_glGenNamesAMD (identifier, num, names);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteNamesAMD (GLenum identifier, GLuint num, const GLuint * names)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_name_gen_delete - glDeleteNamesAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_name_gen_delete] && glConfig.m_glDeleteNamesAMD)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteNamesAMD (identifier, num, names);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsNameAMD (GLenum identifier, GLuint name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_name_gen_delete - glIsNameAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_name_gen_delete] && glConfig.m_glIsNameAMD)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsNameAMD (identifier, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glQueryObjectParameteruiAMD (GLenum target, GLuint id, GLenum pname, GLuint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_occlusion_query_event - glQueryObjectParameteruiAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_occlusion_query_event] && glConfig.m_glQueryObjectParameteruiAMD)
  {
    prototypeCalled = true;
    glConfig.m_glQueryObjectParameteruiAMD (target, id, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPerfMonitorGroupsAMD (GLint * numGroups, GLsizei groupsSize, GLuint * groups)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_performance_monitor - glGetPerfMonitorGroupsAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] && glConfig.m_glGetPerfMonitorGroupsAMD)
  {
    prototypeCalled = true;
    glConfig.m_glGetPerfMonitorGroupsAMD (numGroups, groupsSize, groups);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPerfMonitorCountersAMD (GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_performance_monitor - glGetPerfMonitorCountersAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] && glConfig.m_glGetPerfMonitorCountersAMD)
  {
    prototypeCalled = true;
    glConfig.m_glGetPerfMonitorCountersAMD (group, numCounters, maxActiveCounters, counterSize, counters);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPerfMonitorGroupStringAMD (GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_performance_monitor - glGetPerfMonitorGroupStringAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] && glConfig.m_glGetPerfMonitorGroupStringAMD)
  {
    prototypeCalled = true;
    glConfig.m_glGetPerfMonitorGroupStringAMD (group, bufSize, length, groupString);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPerfMonitorCounterStringAMD (GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_performance_monitor - glGetPerfMonitorCounterStringAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] && glConfig.m_glGetPerfMonitorCounterStringAMD)
  {
    prototypeCalled = true;
    glConfig.m_glGetPerfMonitorCounterStringAMD (group, counter, bufSize, length, counterString);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPerfMonitorCounterInfoAMD (GLuint group, GLuint counter, GLenum pname, void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_performance_monitor - glGetPerfMonitorCounterInfoAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] && glConfig.m_glGetPerfMonitorCounterInfoAMD)
  {
    prototypeCalled = true;
    glConfig.m_glGetPerfMonitorCounterInfoAMD (group, counter, pname, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenPerfMonitorsAMD (GLsizei n, GLuint * monitors)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_performance_monitor - glGenPerfMonitorsAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] && glConfig.m_glGenPerfMonitorsAMD)
  {
    prototypeCalled = true;
    glConfig.m_glGenPerfMonitorsAMD (n, monitors);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeletePerfMonitorsAMD (GLsizei n, GLuint * monitors)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_performance_monitor - glDeletePerfMonitorsAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] && glConfig.m_glDeletePerfMonitorsAMD)
  {
    prototypeCalled = true;
    glConfig.m_glDeletePerfMonitorsAMD (n, monitors);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSelectPerfMonitorCountersAMD (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_performance_monitor - glSelectPerfMonitorCountersAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] && glConfig.m_glSelectPerfMonitorCountersAMD)
  {
    prototypeCalled = true;
    glConfig.m_glSelectPerfMonitorCountersAMD (monitor, enable, group, numCounters, counterList);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginPerfMonitorAMD (GLuint monitor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_performance_monitor - glBeginPerfMonitorAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] && glConfig.m_glBeginPerfMonitorAMD)
  {
    prototypeCalled = true;
    glConfig.m_glBeginPerfMonitorAMD (monitor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndPerfMonitorAMD (GLuint monitor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_performance_monitor - glEndPerfMonitorAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] && glConfig.m_glEndPerfMonitorAMD)
  {
    prototypeCalled = true;
    glConfig.m_glEndPerfMonitorAMD (monitor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPerfMonitorCounterDataAMD (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_performance_monitor - glGetPerfMonitorCounterDataAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] && glConfig.m_glGetPerfMonitorCounterDataAMD)
  {
    prototypeCalled = true;
    glConfig.m_glGetPerfMonitorCounterDataAMD (monitor, pname, dataSize, data, bytesWritten);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSetMultisamplefvAMD (GLenum pname, GLuint index, const GLfloat * val)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_sample_positions - glSetMultisamplefvAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_sample_positions] && glConfig.m_glSetMultisamplefvAMD)
  {
    prototypeCalled = true;
    glConfig.m_glSetMultisamplefvAMD (pname, index, val);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorageSparseAMD (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_sparse_texture - glTexStorageSparseAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_sparse_texture] && glConfig.m_glTexStorageSparseAMD)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorageSparseAMD (target, internalFormat, width, height, depth, layers, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorageSparseAMD (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_sparse_texture - glTextureStorageSparseAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_sparse_texture] && glConfig.m_glTextureStorageSparseAMD)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorageSparseAMD (texture, target, internalFormat, width, height, depth, layers, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilOpValueAMD (GLenum face, GLuint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_stencil_operation_extended - glStencilOpValueAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_stencil_operation_extended] && glConfig.m_glStencilOpValueAMD)
  {
    prototypeCalled = true;
    glConfig.m_glStencilOpValueAMD (face, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTessellationFactorAMD (GLfloat factor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_vertex_shader_tessellator - glTessellationFactorAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_vertex_shader_tessellator] && glConfig.m_glTessellationFactorAMD)
  {
    prototypeCalled = true;
    glConfig.m_glTessellationFactorAMD (factor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTessellationModeAMD (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_AMD_vertex_shader_tessellator - glTessellationModeAMD
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_AMD_vertex_shader_tessellator] && glConfig.m_glTessellationModeAMD)
  {
    prototypeCalled = true;
    glConfig.m_glTessellationModeAMD (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlitFramebufferANGLE (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ANGLE_framebuffer_blit - glBlitFramebufferANGLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ANGLE_framebuffer_blit] && glConfig.m_glBlitFramebufferANGLE)
  {
    prototypeCalled = true;
    glConfig.m_glBlitFramebufferANGLE (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRenderbufferStorageMultisampleANGLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ANGLE_framebuffer_multisample - glRenderbufferStorageMultisampleANGLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ANGLE_framebuffer_multisample] && glConfig.m_glRenderbufferStorageMultisampleANGLE)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisampleANGLE (target, samples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawArraysInstancedANGLE (GLenum mode, GLint first, GLsizei count, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ANGLE_instanced_arrays - glDrawArraysInstancedANGLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ANGLE_instanced_arrays] && glConfig.m_glDrawArraysInstancedANGLE)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstancedANGLE (mode, first, count, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstancedANGLE (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ANGLE_instanced_arrays - glDrawElementsInstancedANGLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ANGLE_instanced_arrays] && glConfig.m_glDrawElementsInstancedANGLE)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedANGLE (mode, count, type, indices, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribDivisorANGLE (GLuint index, GLuint divisor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ANGLE_instanced_arrays - glVertexAttribDivisorANGLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ANGLE_instanced_arrays] && glConfig.m_glVertexAttribDivisorANGLE)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribDivisorANGLE (index, divisor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTranslatedShaderSourceANGLE (GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ANGLE_translated_shader_source - glGetTranslatedShaderSourceANGLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ANGLE_translated_shader_source] && glConfig.m_glGetTranslatedShaderSourceANGLE)
  {
    prototypeCalled = true;
    glConfig.m_glGetTranslatedShaderSourceANGLE (shader, bufSize, length, source);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTextureLevelsAPPLE (GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_copy_texture_levels - glCopyTextureLevelsAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_copy_texture_levels] && glConfig.m_glCopyTextureLevelsAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureLevelsAPPLE (destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glElementPointerAPPLE (GLenum type, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_element_array - glElementPointerAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_element_array] && glConfig.m_glElementPointerAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glElementPointerAPPLE (type, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementArrayAPPLE (GLenum mode, GLint first, GLsizei count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_element_array - glDrawElementArrayAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_element_array] && glConfig.m_glDrawElementArrayAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementArrayAPPLE (mode, first, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawRangeElementArrayAPPLE (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_element_array - glDrawRangeElementArrayAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_element_array] && glConfig.m_glDrawRangeElementArrayAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glDrawRangeElementArrayAPPLE (mode, start, end, first, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElementArrayAPPLE (GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_element_array - glMultiDrawElementArrayAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_element_array] && glConfig.m_glMultiDrawElementArrayAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementArrayAPPLE (mode, first, count, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawRangeElementArrayAPPLE (GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_element_array - glMultiDrawRangeElementArrayAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_element_array] && glConfig.m_glMultiDrawRangeElementArrayAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawRangeElementArrayAPPLE (mode, start, end, first, count, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenFencesAPPLE (GLsizei n, GLuint * fences)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_fence - glGenFencesAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_fence] && glConfig.m_glGenFencesAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glGenFencesAPPLE (n, fences);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteFencesAPPLE (GLsizei n, const GLuint * fences)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_fence - glDeleteFencesAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_fence] && glConfig.m_glDeleteFencesAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteFencesAPPLE (n, fences);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSetFenceAPPLE (GLuint fence)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_fence - glSetFenceAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_fence] && glConfig.m_glSetFenceAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glSetFenceAPPLE (fence);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsFenceAPPLE (GLuint fence)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_fence - glIsFenceAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_fence] && glConfig.m_glIsFenceAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsFenceAPPLE (fence);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glTestFenceAPPLE (GLuint fence)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_fence - glTestFenceAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_fence] && glConfig.m_glTestFenceAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glTestFenceAPPLE (fence);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFinishFenceAPPLE (GLuint fence)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_fence - glFinishFenceAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_fence] && glConfig.m_glFinishFenceAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glFinishFenceAPPLE (fence);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glTestObjectAPPLE (GLenum object, GLuint name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_fence - glTestObjectAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_fence] && glConfig.m_glTestObjectAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glTestObjectAPPLE (object, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFinishObjectAPPLE (GLenum object, GLint name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_fence - glFinishObjectAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_fence] && glConfig.m_glFinishObjectAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glFinishObjectAPPLE (object, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferParameteriAPPLE (GLenum target, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_flush_buffer_range - glBufferParameteriAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_flush_buffer_range] && glConfig.m_glBufferParameteriAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glBufferParameteriAPPLE (target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFlushMappedBufferRangeAPPLE (GLenum target, GLintptr offset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_flush_buffer_range - glFlushMappedBufferRangeAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_flush_buffer_range] && glConfig.m_glFlushMappedBufferRangeAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glFlushMappedBufferRangeAPPLE (target, offset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRenderbufferStorageMultisampleAPPLE (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_framebuffer_multisample - glRenderbufferStorageMultisampleAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_framebuffer_multisample] && glConfig.m_glRenderbufferStorageMultisampleAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisampleAPPLE (target, samples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glResolveMultisampleFramebufferAPPLE ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_framebuffer_multisample - glResolveMultisampleFramebufferAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_framebuffer_multisample] && glConfig.m_glResolveMultisampleFramebufferAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glResolveMultisampleFramebufferAPPLE ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glObjectPurgeableAPPLE (GLenum objectType, GLuint name, GLenum option)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_object_purgeable - glObjectPurgeableAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_object_purgeable] && glConfig.m_glObjectPurgeableAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glObjectPurgeableAPPLE (objectType, name, option);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glObjectUnpurgeableAPPLE (GLenum objectType, GLuint name, GLenum option)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_object_purgeable - glObjectUnpurgeableAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_object_purgeable] && glConfig.m_glObjectUnpurgeableAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glObjectUnpurgeableAPPLE (objectType, name, option);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetObjectParameterivAPPLE (GLenum objectType, GLuint name, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_object_purgeable - glGetObjectParameterivAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_object_purgeable] && glConfig.m_glGetObjectParameterivAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectParameterivAPPLE (objectType, name, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLsync _glew_gl_glFenceSyncAPPLE (GLenum condition, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLsync result = ((GLsync)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_sync - glFenceSyncAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glFenceSyncAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glFenceSyncAPPLE (condition, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsSyncAPPLE (GLsync sync)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_sync - glIsSyncAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glIsSyncAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsSyncAPPLE (sync);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteSyncAPPLE (GLsync sync)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_sync - glDeleteSyncAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glDeleteSyncAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteSyncAPPLE (sync);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glClientWaitSyncAPPLE (GLsync sync, GLbitfield flags, GLuint64 timeout)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_sync - glClientWaitSyncAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glClientWaitSyncAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glClientWaitSyncAPPLE (sync, flags, timeout);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWaitSyncAPPLE (GLsync sync, GLbitfield flags, GLuint64 timeout)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_sync - glWaitSyncAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glWaitSyncAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glWaitSyncAPPLE (sync, flags, timeout);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetInteger64vAPPLE (GLenum pname, GLint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_sync - glGetInteger64vAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glGetInteger64vAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glGetInteger64vAPPLE (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSyncivAPPLE (GLsync sync, GLenum pname, GLsizei count, GLsizei * length, GLint * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_sync - glGetSyncivAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_sync] && glConfig.m_glGetSyncivAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glGetSyncivAPPLE (sync, pname, count, length, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureRangeAPPLE (GLenum target, GLsizei length, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_texture_range - glTextureRangeAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_texture_range] && glConfig.m_glTextureRangeAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glTextureRangeAPPLE (target, length, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexParameterPointervAPPLE (GLenum target, GLenum pname, void ** params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_texture_range - glGetTexParameterPointervAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_texture_range] && glConfig.m_glGetTexParameterPointervAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterPointervAPPLE (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindVertexArrayAPPLE (GLuint array)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_array_object - glBindVertexArrayAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_object] && glConfig.m_glBindVertexArrayAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexArrayAPPLE (array);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteVertexArraysAPPLE (GLsizei n, const GLuint * arrays)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_array_object - glDeleteVertexArraysAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_object] && glConfig.m_glDeleteVertexArraysAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteVertexArraysAPPLE (n, arrays);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenVertexArraysAPPLE (GLsizei n, GLuint * arrays)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_array_object - glGenVertexArraysAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_object] && glConfig.m_glGenVertexArraysAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glGenVertexArraysAPPLE (n, arrays);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsVertexArrayAPPLE (GLuint array)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_array_object - glIsVertexArrayAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_object] && glConfig.m_glIsVertexArrayAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsVertexArrayAPPLE (array);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayRangeAPPLE (GLsizei length, void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_array_range - glVertexArrayRangeAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_range] && glConfig.m_glVertexArrayRangeAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayRangeAPPLE (length, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFlushVertexArrayRangeAPPLE (GLsizei length, void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_array_range - glFlushVertexArrayRangeAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_range] && glConfig.m_glFlushVertexArrayRangeAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glFlushVertexArrayRangeAPPLE (length, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayParameteriAPPLE (GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_array_range - glVertexArrayParameteriAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_range] && glConfig.m_glVertexArrayParameteriAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayParameteriAPPLE (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableVertexAttribAPPLE (GLuint index, GLenum pname)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_program_evaluators - glEnableVertexAttribAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_program_evaluators] && glConfig.m_glEnableVertexAttribAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glEnableVertexAttribAPPLE (index, pname);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableVertexAttribAPPLE (GLuint index, GLenum pname)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_program_evaluators - glDisableVertexAttribAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_program_evaluators] && glConfig.m_glDisableVertexAttribAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glDisableVertexAttribAPPLE (index, pname);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsVertexAttribEnabledAPPLE (GLuint index, GLenum pname)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_program_evaluators - glIsVertexAttribEnabledAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_program_evaluators] && glConfig.m_glIsVertexAttribEnabledAPPLE)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsVertexAttribEnabledAPPLE (index, pname);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMapVertexAttrib1dAPPLE (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_program_evaluators - glMapVertexAttrib1dAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_program_evaluators] && glConfig.m_glMapVertexAttrib1dAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glMapVertexAttrib1dAPPLE (index, size, u1, u2, stride, order, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMapVertexAttrib1fAPPLE (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_program_evaluators - glMapVertexAttrib1fAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_program_evaluators] && glConfig.m_glMapVertexAttrib1fAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glMapVertexAttrib1fAPPLE (index, size, u1, u2, stride, order, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMapVertexAttrib2dAPPLE (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_program_evaluators - glMapVertexAttrib2dAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_program_evaluators] && glConfig.m_glMapVertexAttrib2dAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glMapVertexAttrib2dAPPLE (index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMapVertexAttrib2fAPPLE (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_APPLE_vertex_program_evaluators - glMapVertexAttrib2fAPPLE
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_APPLE_vertex_program_evaluators] && glConfig.m_glMapVertexAttrib2fAPPLE)
  {
    prototypeCalled = true;
    glConfig.m_glMapVertexAttrib2fAPPLE (index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPrimitiveBoundingBoxARB (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_ES3_2_compatibility - glPrimitiveBoundingBoxARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_ES3_2_compatibility] && glConfig.m_glPrimitiveBoundingBoxARB)
  {
    prototypeCalled = true;
    glConfig.m_glPrimitiveBoundingBoxARB (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint64 _glew_gl_glGetTextureHandleARB (GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint64 result = ((GLuint64)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glGetTextureHandleARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glGetTextureHandleARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetTextureHandleARB (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint64 _glew_gl_glGetTextureSamplerHandleARB (GLuint texture, GLuint sampler)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint64 result = ((GLuint64)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glGetTextureSamplerHandleARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glGetTextureSamplerHandleARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetTextureSamplerHandleARB (texture, sampler);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeTextureHandleResidentARB (GLuint64 handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glMakeTextureHandleResidentARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glMakeTextureHandleResidentARB)
  {
    prototypeCalled = true;
    glConfig.m_glMakeTextureHandleResidentARB (handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeTextureHandleNonResidentARB (GLuint64 handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glMakeTextureHandleNonResidentARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glMakeTextureHandleNonResidentARB)
  {
    prototypeCalled = true;
    glConfig.m_glMakeTextureHandleNonResidentARB (handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint64 _glew_gl_glGetImageHandleARB (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint64 result = ((GLuint64)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glGetImageHandleARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glGetImageHandleARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetImageHandleARB (texture, level, layered, layer, format);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeImageHandleResidentARB (GLuint64 handle, GLenum access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glMakeImageHandleResidentARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glMakeImageHandleResidentARB)
  {
    prototypeCalled = true;
    glConfig.m_glMakeImageHandleResidentARB (handle, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeImageHandleNonResidentARB (GLuint64 handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glMakeImageHandleNonResidentARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glMakeImageHandleNonResidentARB)
  {
    prototypeCalled = true;
    glConfig.m_glMakeImageHandleNonResidentARB (handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformHandleui64ARB (GLint location, GLuint64 value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glUniformHandleui64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glUniformHandleui64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniformHandleui64ARB (location, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformHandleui64vARB (GLint location, GLsizei count, const GLuint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glUniformHandleui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glUniformHandleui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniformHandleui64vARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformHandleui64ARB (GLuint program, GLint location, GLuint64 value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glProgramUniformHandleui64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glProgramUniformHandleui64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformHandleui64ARB (program, location, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformHandleui64vARB (GLuint program, GLint location, GLsizei count, const GLuint64 * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glProgramUniformHandleui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glProgramUniformHandleui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformHandleui64vARB (program, location, count, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsTextureHandleResidentARB (GLuint64 handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glIsTextureHandleResidentARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glIsTextureHandleResidentARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsTextureHandleResidentARB (handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsImageHandleResidentARB (GLuint64 handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glIsImageHandleResidentARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glIsImageHandleResidentARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsImageHandleResidentARB (handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL1ui64ARB (GLuint index, GLuint64EXT x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glVertexAttribL1ui64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glVertexAttribL1ui64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1ui64ARB (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL1ui64vARB (GLuint index, const GLuint64EXT * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glVertexAttribL1ui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glVertexAttribL1ui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1ui64vARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribLui64vARB (GLuint index, GLenum pname, GLuint64EXT * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_bindless_texture - glGetVertexAttribLui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] && glConfig.m_glGetVertexAttribLui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribLui64vARB (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLsync _glew_gl_glCreateSyncFromCLeventARB (struct _cl_context * context, struct _cl_event * event, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLsync result = ((GLsync)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_cl_event - glCreateSyncFromCLeventARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_cl_event] && glConfig.m_glCreateSyncFromCLeventARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateSyncFromCLeventARB (context, event, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClampColorARB (GLenum target, GLenum clamp)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_color_buffer_float - glClampColorARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_color_buffer_float] && glConfig.m_glClampColorARB)
  {
    prototypeCalled = true;
    glConfig.m_glClampColorARB (target, clamp);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDispatchComputeGroupSizeARB (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_compute_variable_group_size - glDispatchComputeGroupSizeARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_compute_variable_group_size] && glConfig.m_glDispatchComputeGroupSizeARB)
  {
    prototypeCalled = true;
    glConfig.m_glDispatchComputeGroupSizeARB (num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageControlARB (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_debug_output - glDebugMessageControlARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_debug_output] && glConfig.m_glDebugMessageControlARB)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageControlARB (source, type, severity, count, ids, enabled);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageInsertARB (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_debug_output - glDebugMessageInsertARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_debug_output] && glConfig.m_glDebugMessageInsertARB)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageInsertARB (source, type, id, severity, length, buf);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageCallbackARB (GLDEBUGPROCARB callback, const void * userParam)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_debug_output - glDebugMessageCallbackARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_debug_output] && glConfig.m_glDebugMessageCallbackARB)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageCallbackARB (callback, userParam);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGetDebugMessageLogARB (GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_debug_output - glGetDebugMessageLogARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_debug_output] && glConfig.m_glGetDebugMessageLogARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetDebugMessageLogARB (count, bufSize, sources, types, ids, severities, lengths, messageLog);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawBuffersARB (GLsizei n, const GLenum * bufs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_draw_buffers - glDrawBuffersARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_buffers] && glConfig.m_glDrawBuffersARB)
  {
    prototypeCalled = true;
    glConfig.m_glDrawBuffersARB (n, bufs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationiARB (GLuint buf, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_draw_buffers_blend - glBlendEquationiARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_buffers_blend] && glConfig.m_glBlendEquationiARB)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationiARB (buf, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationSeparateiARB (GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_draw_buffers_blend - glBlendEquationSeparateiARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_buffers_blend] && glConfig.m_glBlendEquationSeparateiARB)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparateiARB (buf, modeRGB, modeAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFunciARB (GLuint buf, GLenum src, GLenum dst)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_draw_buffers_blend - glBlendFunciARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_buffers_blend] && glConfig.m_glBlendFunciARB)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFunciARB (buf, src, dst);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFuncSeparateiARB (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_draw_buffers_blend - glBlendFuncSeparateiARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_buffers_blend] && glConfig.m_glBlendFuncSeparateiARB)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparateiARB (buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawArraysInstancedARB (GLenum mode, GLint first, GLsizei count, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_draw_instanced - glDrawArraysInstancedARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_instanced] && glConfig.m_glDrawArraysInstancedARB)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstancedARB (mode, first, count, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstancedARB (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_draw_instanced - glDrawElementsInstancedARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_draw_instanced] && glConfig.m_glDrawElementsInstancedARB)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedARB (mode, count, type, indices, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramStringARB (GLenum target, GLenum format, GLsizei len, const void * string)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glProgramStringARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glProgramStringARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramStringARB (target, format, len, string);
  }
  // GL_ARB_vertex_program - glProgramStringARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glProgramStringARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramStringARB (target, format, len, string);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindProgramARB (GLenum target, GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glBindProgramARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glBindProgramARB)
  {
    prototypeCalled = true;
    glConfig.m_glBindProgramARB (target, program);
  }
  // GL_ARB_vertex_program - glBindProgramARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glBindProgramARB)
  {
    prototypeCalled = true;
    glConfig.m_glBindProgramARB (target, program);
  }
  // GL_NV_vertex_program - glBindProgramARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glBindProgramNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindProgramNV (target, program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteProgramsARB (GLsizei n, const GLuint * programs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glDeleteProgramsARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glDeleteProgramsARB)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteProgramsARB (n, programs);
  }
  // GL_ARB_vertex_program - glDeleteProgramsARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glDeleteProgramsARB)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteProgramsARB (n, programs);
  }
  // GL_NV_vertex_program - glDeleteProgramsARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glDeleteProgramsNV)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteProgramsNV (n, programs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenProgramsARB (GLsizei n, GLuint * programs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glGenProgramsARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glGenProgramsARB)
  {
    prototypeCalled = true;
    glConfig.m_glGenProgramsARB (n, programs);
  }
  // GL_ARB_vertex_program - glGenProgramsARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGenProgramsARB)
  {
    prototypeCalled = true;
    glConfig.m_glGenProgramsARB (n, programs);
  }
  // GL_NV_vertex_program - glGenProgramsARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGenProgramsNV)
  {
    prototypeCalled = true;
    glConfig.m_glGenProgramsNV (n, programs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramEnvParameter4dARB (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glProgramEnvParameter4dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glProgramEnvParameter4dARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameter4dARB (target, index, x, y, z, w);
  }
  // GL_ARB_vertex_program - glProgramEnvParameter4dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glProgramEnvParameter4dARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameter4dARB (target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramEnvParameter4dvARB (GLenum target, GLuint index, const GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glProgramEnvParameter4dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glProgramEnvParameter4dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameter4dvARB (target, index, params);
  }
  // GL_ARB_vertex_program - glProgramEnvParameter4dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glProgramEnvParameter4dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameter4dvARB (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramEnvParameter4fARB (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glProgramEnvParameter4fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glProgramEnvParameter4fARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameter4fARB (target, index, x, y, z, w);
  }
  // GL_ARB_vertex_program - glProgramEnvParameter4fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glProgramEnvParameter4fARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameter4fARB (target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramEnvParameter4fvARB (GLenum target, GLuint index, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glProgramEnvParameter4fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glProgramEnvParameter4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameter4fvARB (target, index, params);
  }
  // GL_ARB_vertex_program - glProgramEnvParameter4fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glProgramEnvParameter4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameter4fvARB (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramLocalParameter4dARB (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glProgramLocalParameter4dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glProgramLocalParameter4dARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameter4dARB (target, index, x, y, z, w);
  }
  // GL_ARB_vertex_program - glProgramLocalParameter4dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glProgramLocalParameter4dARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameter4dARB (target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramLocalParameter4dvARB (GLenum target, GLuint index, const GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glProgramLocalParameter4dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glProgramLocalParameter4dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameter4dvARB (target, index, params);
  }
  // GL_ARB_vertex_program - glProgramLocalParameter4dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glProgramLocalParameter4dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameter4dvARB (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramLocalParameter4fARB (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glProgramLocalParameter4fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glProgramLocalParameter4fARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameter4fARB (target, index, x, y, z, w);
  }
  // GL_ARB_vertex_program - glProgramLocalParameter4fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glProgramLocalParameter4fARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameter4fARB (target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramLocalParameter4fvARB (GLenum target, GLuint index, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glProgramLocalParameter4fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glProgramLocalParameter4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameter4fvARB (target, index, params);
  }
  // GL_ARB_vertex_program - glProgramLocalParameter4fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glProgramLocalParameter4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameter4fvARB (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramEnvParameterdvARB (GLenum target, GLuint index, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glGetProgramEnvParameterdvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glGetProgramEnvParameterdvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramEnvParameterdvARB (target, index, params);
  }
  // GL_ARB_vertex_program - glGetProgramEnvParameterdvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetProgramEnvParameterdvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramEnvParameterdvARB (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramEnvParameterfvARB (GLenum target, GLuint index, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glGetProgramEnvParameterfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glGetProgramEnvParameterfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramEnvParameterfvARB (target, index, params);
  }
  // GL_ARB_vertex_program - glGetProgramEnvParameterfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetProgramEnvParameterfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramEnvParameterfvARB (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramLocalParameterdvARB (GLenum target, GLuint index, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glGetProgramLocalParameterdvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glGetProgramLocalParameterdvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramLocalParameterdvARB (target, index, params);
  }
  // GL_ARB_vertex_program - glGetProgramLocalParameterdvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetProgramLocalParameterdvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramLocalParameterdvARB (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramLocalParameterfvARB (GLenum target, GLuint index, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glGetProgramLocalParameterfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glGetProgramLocalParameterfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramLocalParameterfvARB (target, index, params);
  }
  // GL_ARB_vertex_program - glGetProgramLocalParameterfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetProgramLocalParameterfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramLocalParameterfvARB (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramivARB (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glGetProgramivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glGetProgramivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramivARB (target, pname, params);
  }
  // GL_ARB_vertex_program - glGetProgramivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetProgramivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramivARB (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramStringARB (GLenum target, GLenum pname, void * string)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glGetProgramStringARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glGetProgramStringARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramStringARB (target, pname, string);
  }
  // GL_ARB_vertex_program - glGetProgramStringARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetProgramStringARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramStringARB (target, pname, string);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsProgramARB (GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_fragment_program - glIsProgramARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] && glConfig.m_glIsProgramARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsProgramARB (program);
  }
  // GL_ARB_vertex_program - glIsProgramARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glIsProgramARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsProgramARB (program);
  }
  // GL_NV_vertex_program - glIsProgramARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glIsProgramNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsProgramNV (program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramParameteriARB (GLuint program, GLenum pname, GLint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_geometry_shader4 - glProgramParameteriARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_geometry_shader4] && glConfig.m_glProgramParameteriARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameteriARB (program, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTextureARB (GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_geometry_shader4 - glFramebufferTextureARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_geometry_shader4] && glConfig.m_glFramebufferTextureARB)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureARB (target, attachment, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTextureLayerARB (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_geometry_shader4 - glFramebufferTextureLayerARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_geometry_shader4] && glConfig.m_glFramebufferTextureLayerARB)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureLayerARB (target, attachment, texture, level, layer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTextureFaceARB (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_geometry_shader4 - glFramebufferTextureFaceARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_geometry_shader4] && glConfig.m_glFramebufferTextureFaceARB)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureFaceARB (target, attachment, texture, level, face);
  }
  // GL_NV_geometry_program4 - glFramebufferTextureFaceARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_geometry_program4] && glConfig.m_glFramebufferTextureFaceEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureFaceEXT (target, attachment, texture, level, face);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSpecializeShaderARB (GLuint shader, const GLchar * pEntryPoint, GLuint numSpecializationConstants, const GLuint * pConstantIndex, const GLuint * pConstantValue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gl_spirv - glSpecializeShaderARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gl_spirv] && glConfig.m_glSpecializeShaderARB)
  {
    prototypeCalled = true;
    glConfig.m_glSpecializeShaderARB (shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1i64ARB (GLint location, GLint64 x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform1i64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform1i64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1i64ARB (location, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2i64ARB (GLint location, GLint64 x, GLint64 y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform2i64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform2i64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2i64ARB (location, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3i64ARB (GLint location, GLint64 x, GLint64 y, GLint64 z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform3i64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform3i64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3i64ARB (location, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4i64ARB (GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform4i64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform4i64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4i64ARB (location, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1i64vARB (GLint location, GLsizei count, const GLint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform1i64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform1i64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1i64vARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2i64vARB (GLint location, GLsizei count, const GLint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform2i64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform2i64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2i64vARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3i64vARB (GLint location, GLsizei count, const GLint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform3i64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform3i64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3i64vARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4i64vARB (GLint location, GLsizei count, const GLint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform4i64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform4i64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4i64vARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1ui64ARB (GLint location, GLuint64 x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform1ui64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform1ui64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1ui64ARB (location, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2ui64ARB (GLint location, GLuint64 x, GLuint64 y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform2ui64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform2ui64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2ui64ARB (location, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3ui64ARB (GLint location, GLuint64 x, GLuint64 y, GLuint64 z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform3ui64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform3ui64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3ui64ARB (location, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4ui64ARB (GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform4ui64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform4ui64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4ui64ARB (location, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1ui64vARB (GLint location, GLsizei count, const GLuint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform1ui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform1ui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1ui64vARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2ui64vARB (GLint location, GLsizei count, const GLuint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform2ui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform2ui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2ui64vARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3ui64vARB (GLint location, GLsizei count, const GLuint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform3ui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform3ui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3ui64vARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4ui64vARB (GLint location, GLsizei count, const GLuint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glUniform4ui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glUniform4ui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4ui64vARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformi64vARB (GLuint program, GLint location, GLint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glGetUniformi64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glGetUniformi64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformi64vARB (program, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformui64vARB (GLuint program, GLint location, GLuint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glGetUniformui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glGetUniformui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformui64vARB (program, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformi64vARB (GLuint program, GLint location, GLsizei bufSize, GLint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glGetnUniformi64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glGetnUniformi64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformi64vARB (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformui64vARB (GLuint program, GLint location, GLsizei bufSize, GLuint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glGetnUniformui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glGetnUniformui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformui64vARB (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1i64ARB (GLuint program, GLint location, GLint64 x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform1i64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform1i64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1i64ARB (program, location, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2i64ARB (GLuint program, GLint location, GLint64 x, GLint64 y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform2i64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform2i64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2i64ARB (program, location, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3i64ARB (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform3i64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform3i64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3i64ARB (program, location, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4i64ARB (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform4i64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform4i64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4i64ARB (program, location, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1i64vARB (GLuint program, GLint location, GLsizei count, const GLint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform1i64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform1i64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1i64vARB (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2i64vARB (GLuint program, GLint location, GLsizei count, const GLint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform2i64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform2i64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2i64vARB (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3i64vARB (GLuint program, GLint location, GLsizei count, const GLint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform3i64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform3i64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3i64vARB (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4i64vARB (GLuint program, GLint location, GLsizei count, const GLint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform4i64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform4i64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4i64vARB (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1ui64ARB (GLuint program, GLint location, GLuint64 x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform1ui64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform1ui64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ui64ARB (program, location, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2ui64ARB (GLuint program, GLint location, GLuint64 x, GLuint64 y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform2ui64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform2ui64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ui64ARB (program, location, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3ui64ARB (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform3ui64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform3ui64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ui64ARB (program, location, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4ui64ARB (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform4ui64ARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform4ui64ARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ui64ARB (program, location, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1ui64vARB (GLuint program, GLint location, GLsizei count, const GLuint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform1ui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform1ui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ui64vARB (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2ui64vARB (GLuint program, GLint location, GLsizei count, const GLuint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform2ui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform2ui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ui64vARB (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3ui64vARB (GLuint program, GLint location, GLsizei count, const GLuint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform3ui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform3ui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ui64vARB (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4ui64vARB (GLuint program, GLint location, GLsizei count, const GLuint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_gpu_shader_int64 - glProgramUniform4ui64vARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] && glConfig.m_glProgramUniform4ui64vARB)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ui64vARB (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorTable (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * table)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glColorTable
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glColorTable)
  {
    prototypeCalled = true;
    glConfig.m_glColorTable (target, internalformat, width, format, type, table);
  }
  // GL_EXT_paletted_texture - glColorTable
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_paletted_texture] && glConfig.m_glColorTableEXT)
  {
    prototypeCalled = true;
    glConfig.m_glColorTableEXT (target, internalformat, width, format, type, table);
  }
  // GL_SGI_color_table - glColorTable
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGI_color_table] && glConfig.m_glColorTableSGI)
  {
    prototypeCalled = true;
    glConfig.m_glColorTableSGI (target, internalformat, width, format, type, table);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorTableParameterfv (GLenum target, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glColorTableParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glColorTableParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glColorTableParameterfv (target, pname, params);
  }
  // GL_SGI_color_table - glColorTableParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGI_color_table] && glConfig.m_glColorTableParameterfvSGI)
  {
    prototypeCalled = true;
    glConfig.m_glColorTableParameterfvSGI (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorTableParameteriv (GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glColorTableParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glColorTableParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glColorTableParameteriv (target, pname, params);
  }
  // GL_SGI_color_table - glColorTableParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGI_color_table] && glConfig.m_glColorTableParameterivSGI)
  {
    prototypeCalled = true;
    glConfig.m_glColorTableParameterivSGI (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyColorTable (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glCopyColorTable
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glCopyColorTable)
  {
    prototypeCalled = true;
    glConfig.m_glCopyColorTable (target, internalformat, x, y, width);
  }
  // GL_SGI_color_table - glCopyColorTable
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGI_color_table] && glConfig.m_glCopyColorTableSGI)
  {
    prototypeCalled = true;
    glConfig.m_glCopyColorTableSGI (target, internalformat, x, y, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetColorTable (GLenum target, GLenum format, GLenum type, void * table)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetColorTable
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetColorTable)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTable (target, format, type, table);
  }
  // GL_EXT_paletted_texture - glGetColorTable
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_paletted_texture] && glConfig.m_glGetColorTableEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTableEXT (target, format, type, table);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetColorTableParameterfv (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetColorTableParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetColorTableParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTableParameterfv (target, pname, params);
  }
  // GL_EXT_paletted_texture - glGetColorTableParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_paletted_texture] && glConfig.m_glGetColorTableParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTableParameterfvEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetColorTableParameteriv (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetColorTableParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetColorTableParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTableParameteriv (target, pname, params);
  }
  // GL_EXT_paletted_texture - glGetColorTableParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_paletted_texture] && glConfig.m_glGetColorTableParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTableParameterivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorSubTable (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glColorSubTable
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glColorSubTable)
  {
    prototypeCalled = true;
    glConfig.m_glColorSubTable (target, start, count, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyColorSubTable (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glCopyColorSubTable
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glCopyColorSubTable)
  {
    prototypeCalled = true;
    glConfig.m_glCopyColorSubTable (target, start, x, y, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionFilter1D (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * image)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glConvolutionFilter1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glConvolutionFilter1D)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionFilter1D (target, internalformat, width, format, type, image);
  }
  // GL_EXT_convolution - glConvolutionFilter1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionFilter1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionFilter1DEXT (target, internalformat, width, format, type, image);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * image)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glConvolutionFilter2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glConvolutionFilter2D)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionFilter2D (target, internalformat, width, height, format, type, image);
  }
  // GL_EXT_convolution - glConvolutionFilter2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionFilter2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionFilter2DEXT (target, internalformat, width, height, format, type, image);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionParameterf (GLenum target, GLenum pname, GLfloat params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glConvolutionParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glConvolutionParameterf)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameterf (target, pname, params);
  }
  // GL_EXT_convolution - glConvolutionParameterf
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionParameterfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameterfEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionParameterfv (GLenum target, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glConvolutionParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glConvolutionParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameterfv (target, pname, params);
  }
  // GL_EXT_convolution - glConvolutionParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameterfvEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionParameteri (GLenum target, GLenum pname, GLint params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glConvolutionParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glConvolutionParameteri)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameteri (target, pname, params);
  }
  // GL_EXT_convolution - glConvolutionParameteri
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionParameteriEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameteriEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionParameteriv (GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glConvolutionParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glConvolutionParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameteriv (target, pname, params);
  }
  // GL_EXT_convolution - glConvolutionParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameterivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyConvolutionFilter1D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glCopyConvolutionFilter1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glCopyConvolutionFilter1D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyConvolutionFilter1D (target, internalformat, x, y, width);
  }
  // GL_EXT_convolution - glCopyConvolutionFilter1D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glCopyConvolutionFilter1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyConvolutionFilter1DEXT (target, internalformat, x, y, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyConvolutionFilter2D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glCopyConvolutionFilter2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glCopyConvolutionFilter2D)
  {
    prototypeCalled = true;
    glConfig.m_glCopyConvolutionFilter2D (target, internalformat, x, y, width, height);
  }
  // GL_EXT_convolution - glCopyConvolutionFilter2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glCopyConvolutionFilter2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyConvolutionFilter2DEXT (target, internalformat, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetConvolutionFilter (GLenum target, GLenum format, GLenum type, void * image)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetConvolutionFilter
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetConvolutionFilter)
  {
    prototypeCalled = true;
    glConfig.m_glGetConvolutionFilter (target, format, type, image);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetConvolutionParameterfv (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetConvolutionParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetConvolutionParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetConvolutionParameterfv (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetConvolutionParameteriv (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetConvolutionParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetConvolutionParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetConvolutionParameteriv (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSeparableFilter (GLenum target, GLenum format, GLenum type, void * row, void * column, void * span)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetSeparableFilter
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetSeparableFilter)
  {
    prototypeCalled = true;
    glConfig.m_glGetSeparableFilter (target, format, type, row, column, span);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSeparableFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * row, const void * column)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glSeparableFilter2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glSeparableFilter2D)
  {
    prototypeCalled = true;
    glConfig.m_glSeparableFilter2D (target, internalformat, width, height, format, type, row, column);
  }
  // GL_EXT_convolution - glSeparableFilter2D
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glSeparableFilter2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSeparableFilter2DEXT (target, internalformat, width, height, format, type, row, column);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetHistogram (GLenum target, GLboolean reset, GLenum format, GLenum type, void * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetHistogram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetHistogram)
  {
    prototypeCalled = true;
    glConfig.m_glGetHistogram (target, reset, format, type, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetHistogramParameterfv (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetHistogramParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetHistogramParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetHistogramParameterfv (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetHistogramParameteriv (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetHistogramParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetHistogramParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetHistogramParameteriv (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMinmax (GLenum target, GLboolean reset, GLenum format, GLenum type, void * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetMinmax
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetMinmax)
  {
    prototypeCalled = true;
    glConfig.m_glGetMinmax (target, reset, format, type, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMinmaxParameterfv (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetMinmaxParameterfv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetMinmaxParameterfv)
  {
    prototypeCalled = true;
    glConfig.m_glGetMinmaxParameterfv (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMinmaxParameteriv (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glGetMinmaxParameteriv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glGetMinmaxParameteriv)
  {
    prototypeCalled = true;
    glConfig.m_glGetMinmaxParameteriv (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glHistogram (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glHistogram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glHistogram)
  {
    prototypeCalled = true;
    glConfig.m_glHistogram (target, width, internalformat, sink);
  }
  // GL_EXT_histogram - glHistogram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glHistogramEXT)
  {
    prototypeCalled = true;
    glConfig.m_glHistogramEXT (target, width, internalformat, sink);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMinmax (GLenum target, GLenum internalformat, GLboolean sink)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glMinmax
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glMinmax)
  {
    prototypeCalled = true;
    glConfig.m_glMinmax (target, internalformat, sink);
  }
  // GL_EXT_histogram - glMinmax
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glMinmaxEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMinmaxEXT (target, internalformat, sink);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glResetHistogram (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glResetHistogram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glResetHistogram)
  {
    prototypeCalled = true;
    glConfig.m_glResetHistogram (target);
  }
  // GL_EXT_histogram - glResetHistogram
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glResetHistogramEXT)
  {
    prototypeCalled = true;
    glConfig.m_glResetHistogramEXT (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glResetMinmax (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_imaging - glResetMinmax
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_imaging] && glConfig.m_glResetMinmax)
  {
    prototypeCalled = true;
    glConfig.m_glResetMinmax (target);
  }
  // GL_EXT_histogram - glResetMinmax
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glResetMinmaxEXT)
  {
    prototypeCalled = true;
    glConfig.m_glResetMinmaxEXT (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawArraysIndirectCountARB (GLenum mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_indirect_parameters - glMultiDrawArraysIndirectCountARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_indirect_parameters] && glConfig.m_glMultiDrawArraysIndirectCountARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawArraysIndirectCountARB (mode, indirect, drawcount, maxdrawcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElementsIndirectCountARB (GLenum mode, GLenum type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_indirect_parameters - glMultiDrawElementsIndirectCountARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_indirect_parameters] && glConfig.m_glMultiDrawElementsIndirectCountARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsIndirectCountARB (mode, type, indirect, drawcount, maxdrawcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribDivisorARB (GLuint index, GLuint divisor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_instanced_arrays - glVertexAttribDivisorARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_instanced_arrays] && glConfig.m_glVertexAttribDivisorARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribDivisorARB (index, divisor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCurrentPaletteMatrixARB (GLint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_matrix_palette - glCurrentPaletteMatrixARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_matrix_palette] && glConfig.m_glCurrentPaletteMatrixARB)
  {
    prototypeCalled = true;
    glConfig.m_glCurrentPaletteMatrixARB (index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixIndexubvARB (GLint size, const GLubyte * indices)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_matrix_palette - glMatrixIndexubvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_matrix_palette] && glConfig.m_glMatrixIndexubvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixIndexubvARB (size, indices);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixIndexusvARB (GLint size, const GLushort * indices)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_matrix_palette - glMatrixIndexusvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_matrix_palette] && glConfig.m_glMatrixIndexusvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixIndexusvARB (size, indices);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixIndexuivARB (GLint size, const GLuint * indices)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_matrix_palette - glMatrixIndexuivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_matrix_palette] && glConfig.m_glMatrixIndexuivARB)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixIndexuivARB (size, indices);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixIndexPointerARB (GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_matrix_palette - glMatrixIndexPointerARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_matrix_palette] && glConfig.m_glMatrixIndexPointerARB)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixIndexPointerARB (size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSampleCoverageARB (GLfloat value, GLboolean invert)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multisample - glSampleCoverageARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multisample] && glConfig.m_glSampleCoverageARB)
  {
    prototypeCalled = true;
    glConfig.m_glSampleCoverageARB (value, invert);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glActiveTextureARB (GLenum texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glActiveTextureARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glActiveTextureARB)
  {
    prototypeCalled = true;
    glConfig.m_glActiveTextureARB (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClientActiveTextureARB (GLenum texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glClientActiveTextureARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glClientActiveTextureARB)
  {
    prototypeCalled = true;
    glConfig.m_glClientActiveTextureARB (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1dARB (GLenum target, GLdouble s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord1dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1dARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1dARB (target, s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1dvARB (GLenum target, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord1dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1dvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1fARB (GLenum target, GLfloat s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord1fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1fARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1fARB (target, s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1fvARB (GLenum target, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord1fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1fvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1iARB (GLenum target, GLint s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord1iARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1iARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1iARB (target, s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1ivARB (GLenum target, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord1ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1ivARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1sARB (GLenum target, GLshort s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord1sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1sARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1sARB (target, s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1svARB (GLenum target, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord1svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord1svARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1svARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2dARB (GLenum target, GLdouble s, GLdouble t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord2dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2dARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2dARB (target, s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2dvARB (GLenum target, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord2dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2dvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2fARB (GLenum target, GLfloat s, GLfloat t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord2fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2fARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2fARB (target, s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2fvARB (GLenum target, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord2fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2fvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2iARB (GLenum target, GLint s, GLint t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord2iARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2iARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2iARB (target, s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2ivARB (GLenum target, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord2ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2ivARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2sARB (GLenum target, GLshort s, GLshort t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord2sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2sARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2sARB (target, s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2svARB (GLenum target, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord2svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord2svARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2svARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3dARB (GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord3dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3dARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3dARB (target, s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3dvARB (GLenum target, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord3dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3dvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3fARB (GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord3fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3fARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3fARB (target, s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3fvARB (GLenum target, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord3fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3fvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3iARB (GLenum target, GLint s, GLint t, GLint r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord3iARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3iARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3iARB (target, s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3ivARB (GLenum target, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord3ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3ivARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3sARB (GLenum target, GLshort s, GLshort t, GLshort r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord3sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3sARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3sARB (target, s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3svARB (GLenum target, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord3svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord3svARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3svARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4dARB (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord4dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4dARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4dARB (target, s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4dvARB (GLenum target, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord4dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4dvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4fARB (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord4fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4fARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4fARB (target, s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4fvARB (GLenum target, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord4fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4fvARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4iARB (GLenum target, GLint s, GLint t, GLint r, GLint q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord4iARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4iARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4iARB (target, s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4ivARB (GLenum target, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord4ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4ivARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4sARB (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord4sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4sARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4sARB (target, s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4svARB (GLenum target, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_multitexture - glMultiTexCoord4svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_multitexture] && glConfig.m_glMultiTexCoord4svARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4svARB (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenQueriesARB (GLsizei n, GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_occlusion_query - glGenQueriesARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glGenQueriesARB)
  {
    prototypeCalled = true;
    glConfig.m_glGenQueriesARB (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteQueriesARB (GLsizei n, const GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_occlusion_query - glDeleteQueriesARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glDeleteQueriesARB)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteQueriesARB (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsQueryARB (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_occlusion_query - glIsQueryARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glIsQueryARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsQueryARB (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginQueryARB (GLenum target, GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_occlusion_query - glBeginQueryARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glBeginQueryARB)
  {
    prototypeCalled = true;
    glConfig.m_glBeginQueryARB (target, id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndQueryARB (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_occlusion_query - glEndQueryARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glEndQueryARB)
  {
    prototypeCalled = true;
    glConfig.m_glEndQueryARB (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryivARB (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_occlusion_query - glGetQueryivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glGetQueryivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryivARB (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryObjectivARB (GLuint id, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_occlusion_query - glGetQueryObjectivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glGetQueryObjectivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectivARB (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryObjectuivARB (GLuint id, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_occlusion_query - glGetQueryObjectuivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] && glConfig.m_glGetQueryObjectuivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectuivARB (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMaxShaderCompilerThreadsARB (GLuint count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_parallel_shader_compile - glMaxShaderCompilerThreadsARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_parallel_shader_compile] && glConfig.m_glMaxShaderCompilerThreadsARB)
  {
    prototypeCalled = true;
    glConfig.m_glMaxShaderCompilerThreadsARB (count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameterfARB (GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_point_parameters - glPointParameterfARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_point_parameters] && glConfig.m_glPointParameterfARB)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfARB (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameterfvARB (GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_point_parameters - glPointParameterfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_point_parameters] && glConfig.m_glPointParameterfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfvARB (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glGetGraphicsResetStatusARB ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetGraphicsResetStatusARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetGraphicsResetStatusARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetGraphicsResetStatusARB ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnTexImageARB (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * img)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnTexImageARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnTexImageARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnTexImageARB (target, level, format, type, bufSize, img);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReadnPixelsARB (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glReadnPixelsARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glReadnPixelsARB)
  {
    prototypeCalled = true;
    glConfig.m_glReadnPixelsARB (x, y, width, height, format, type, bufSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnCompressedTexImageARB (GLenum target, GLint lod, GLsizei bufSize, void * img)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnCompressedTexImageARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnCompressedTexImageARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnCompressedTexImageARB (target, lod, bufSize, img);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformfvARB (GLuint program, GLint location, GLsizei bufSize, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnUniformfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnUniformfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformfvARB (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformivARB (GLuint program, GLint location, GLsizei bufSize, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnUniformivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnUniformivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformivARB (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformuivARB (GLuint program, GLint location, GLsizei bufSize, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnUniformuivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnUniformuivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformuivARB (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformdvARB (GLuint program, GLint location, GLsizei bufSize, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnUniformdvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnUniformdvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformdvARB (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnMapdvARB (GLenum target, GLenum query, GLsizei bufSize, GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnMapdvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnMapdvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnMapdvARB (target, query, bufSize, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnMapfvARB (GLenum target, GLenum query, GLsizei bufSize, GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnMapfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnMapfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnMapfvARB (target, query, bufSize, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnMapivARB (GLenum target, GLenum query, GLsizei bufSize, GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnMapivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnMapivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnMapivARB (target, query, bufSize, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnPixelMapfvARB (GLenum map, GLsizei bufSize, GLfloat * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnPixelMapfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnPixelMapfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnPixelMapfvARB (map, bufSize, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnPixelMapuivARB (GLenum map, GLsizei bufSize, GLuint * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnPixelMapuivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnPixelMapuivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnPixelMapuivARB (map, bufSize, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnPixelMapusvARB (GLenum map, GLsizei bufSize, GLushort * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnPixelMapusvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnPixelMapusvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnPixelMapusvARB (map, bufSize, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnPolygonStippleARB (GLsizei bufSize, GLubyte * pattern)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnPolygonStippleARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnPolygonStippleARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnPolygonStippleARB (bufSize, pattern);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnColorTableARB (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * table)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnColorTableARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnColorTableARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnColorTableARB (target, format, type, bufSize, table);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnConvolutionFilterARB (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * image)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnConvolutionFilterARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnConvolutionFilterARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnConvolutionFilterARB (target, format, type, bufSize, image);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnSeparableFilterARB (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void * row, GLsizei columnBufSize, void * column, void * span)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnSeparableFilterARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnSeparableFilterARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnSeparableFilterARB (target, format, type, rowBufSize, row, columnBufSize, column, span);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnHistogramARB (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnHistogramARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnHistogramARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnHistogramARB (target, reset, format, type, bufSize, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnMinmaxARB (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_robustness - glGetnMinmaxARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_robustness] && glConfig.m_glGetnMinmaxARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetnMinmaxARB (target, reset, format, type, bufSize, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferSampleLocationsfvARB (GLenum target, GLuint start, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_sample_locations - glFramebufferSampleLocationsfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sample_locations] && glConfig.m_glFramebufferSampleLocationsfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferSampleLocationsfvARB (target, start, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferSampleLocationsfvARB (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_sample_locations - glNamedFramebufferSampleLocationsfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sample_locations] && glConfig.m_glNamedFramebufferSampleLocationsfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferSampleLocationsfvARB (framebuffer, start, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEvaluateDepthValuesARB ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_sample_locations - glEvaluateDepthValuesARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sample_locations] && glConfig.m_glEvaluateDepthValuesARB)
  {
    prototypeCalled = true;
    glConfig.m_glEvaluateDepthValuesARB ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMinSampleShadingARB (GLfloat value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_sample_shading - glMinSampleShadingARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sample_shading] && glConfig.m_glMinSampleShadingARB)
  {
    prototypeCalled = true;
    glConfig.m_glMinSampleShadingARB (value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteObjectARB (GLhandleARB obj)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glDeleteObjectARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glDeleteObjectARB)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteObjectARB (obj);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLhandleARB _glew_gl_glGetHandleARB (GLenum pname)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLhandleARB result = ((GLhandleARB)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glGetHandleARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetHandleARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetHandleARB (pname);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDetachObjectARB (GLhandleARB containerObj, GLhandleARB attachedObj)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glDetachObjectARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glDetachObjectARB)
  {
    prototypeCalled = true;
    glConfig.m_glDetachObjectARB (containerObj, attachedObj);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLhandleARB _glew_gl_glCreateShaderObjectARB (GLenum shaderType)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLhandleARB result = ((GLhandleARB)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glCreateShaderObjectARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glCreateShaderObjectARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateShaderObjectARB (shaderType);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShaderSourceARB (GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint * length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glShaderSourceARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glShaderSourceARB)
  {
    prototypeCalled = true;
    glConfig.m_glShaderSourceARB (shaderObj, count, string, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompileShaderARB (GLhandleARB shaderObj)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glCompileShaderARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glCompileShaderARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompileShaderARB (shaderObj);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLhandleARB _glew_gl_glCreateProgramObjectARB ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLhandleARB result = ((GLhandleARB)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glCreateProgramObjectARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glCreateProgramObjectARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateProgramObjectARB ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glAttachObjectARB (GLhandleARB containerObj, GLhandleARB obj)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glAttachObjectARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glAttachObjectARB)
  {
    prototypeCalled = true;
    glConfig.m_glAttachObjectARB (containerObj, obj);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLinkProgramARB (GLhandleARB programObj)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glLinkProgramARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glLinkProgramARB)
  {
    prototypeCalled = true;
    glConfig.m_glLinkProgramARB (programObj);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUseProgramObjectARB (GLhandleARB programObj)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUseProgramObjectARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUseProgramObjectARB)
  {
    prototypeCalled = true;
    glConfig.m_glUseProgramObjectARB (programObj);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glValidateProgramARB (GLhandleARB programObj)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glValidateProgramARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glValidateProgramARB)
  {
    prototypeCalled = true;
    glConfig.m_glValidateProgramARB (programObj);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1fARB (GLint location, GLfloat v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform1fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform1fARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1fARB (location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2fARB (GLint location, GLfloat v0, GLfloat v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform2fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform2fARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2fARB (location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3fARB (GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform3fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform3fARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3fARB (location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4fARB (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform4fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform4fARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4fARB (location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1iARB (GLint location, GLint v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform1iARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform1iARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1iARB (location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2iARB (GLint location, GLint v0, GLint v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform2iARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform2iARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2iARB (location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3iARB (GLint location, GLint v0, GLint v1, GLint v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform3iARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform3iARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3iARB (location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4iARB (GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform4iARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform4iARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4iARB (location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1fvARB (GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform1fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform1fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1fvARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2fvARB (GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform2fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform2fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2fvARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3fvARB (GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform3fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform3fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3fvARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4fvARB (GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform4fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4fvARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1ivARB (GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform1ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform1ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1ivARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2ivARB (GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform2ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform2ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2ivARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3ivARB (GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform3ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform3ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3ivARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4ivARB (GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniform4ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniform4ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4ivARB (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix2fvARB (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniformMatrix2fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniformMatrix2fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2fvARB (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix3fvARB (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniformMatrix3fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniformMatrix3fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3fvARB (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix4fvARB (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glUniformMatrix4fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glUniformMatrix4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4fvARB (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetObjectParameterfvARB (GLhandleARB obj, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glGetObjectParameterfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetObjectParameterfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectParameterfvARB (obj, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetObjectParameterivARB (GLhandleARB obj, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glGetObjectParameterivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetObjectParameterivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectParameterivARB (obj, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetInfoLogARB (GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glGetInfoLogARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetInfoLogARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetInfoLogARB (obj, maxLength, length, infoLog);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetAttachedObjectsARB (GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glGetAttachedObjectsARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetAttachedObjectsARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetAttachedObjectsARB (containerObj, maxCount, count, obj);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetUniformLocationARB (GLhandleARB programObj, const GLcharARB * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glGetUniformLocationARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetUniformLocationARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetUniformLocationARB (programObj, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveUniformARB (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glGetActiveUniformARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetActiveUniformARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveUniformARB (programObj, index, maxLength, length, size, type, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformfvARB (GLhandleARB programObj, GLint location, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glGetUniformfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetUniformfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformfvARB (programObj, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformivARB (GLhandleARB programObj, GLint location, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glGetUniformivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetUniformivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformivARB (programObj, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetShaderSourceARB (GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * source)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shader_objects - glGetShaderSourceARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] && glConfig.m_glGetShaderSourceARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetShaderSourceARB (obj, maxLength, length, source);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedStringARB (GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shading_language_include - glNamedStringARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shading_language_include] && glConfig.m_glNamedStringARB)
  {
    prototypeCalled = true;
    glConfig.m_glNamedStringARB (type, namelen, name, stringlen, string);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteNamedStringARB (GLint namelen, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shading_language_include - glDeleteNamedStringARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shading_language_include] && glConfig.m_glDeleteNamedStringARB)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteNamedStringARB (namelen, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompileShaderIncludeARB (GLuint shader, GLsizei count, const GLchar *const* path, const GLint * length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shading_language_include - glCompileShaderIncludeARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shading_language_include] && glConfig.m_glCompileShaderIncludeARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompileShaderIncludeARB (shader, count, path, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsNamedStringARB (GLint namelen, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shading_language_include - glIsNamedStringARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shading_language_include] && glConfig.m_glIsNamedStringARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsNamedStringARB (namelen, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedStringARB (GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shading_language_include - glGetNamedStringARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shading_language_include] && glConfig.m_glGetNamedStringARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedStringARB (namelen, name, bufSize, stringlen, string);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedStringivARB (GLint namelen, const GLchar * name, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_shading_language_include - glGetNamedStringivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_shading_language_include] && glConfig.m_glGetNamedStringivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedStringivARB (namelen, name, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferPageCommitmentARB (GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_sparse_buffer - glBufferPageCommitmentARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sparse_buffer] && glConfig.m_glBufferPageCommitmentARB)
  {
    prototypeCalled = true;
    glConfig.m_glBufferPageCommitmentARB (target, offset, size, commit);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferPageCommitmentEXT (GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_sparse_buffer - glNamedBufferPageCommitmentEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sparse_buffer] && glConfig.m_glNamedBufferPageCommitmentEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferPageCommitmentEXT (buffer, offset, size, commit);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferPageCommitmentARB (GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_sparse_buffer - glNamedBufferPageCommitmentARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sparse_buffer] && glConfig.m_glNamedBufferPageCommitmentARB)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferPageCommitmentARB (buffer, offset, size, commit);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexPageCommitmentARB (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_sparse_texture - glTexPageCommitmentARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_sparse_texture] && glConfig.m_glTexPageCommitmentARB)
  {
    prototypeCalled = true;
    glConfig.m_glTexPageCommitmentARB (target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
  }
  // GL_EXT_sparse_texture - glTexPageCommitmentARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_sparse_texture] && glConfig.m_glTexPageCommitmentEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexPageCommitmentEXT (target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexBufferARB (GLenum target, GLenum internalformat, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_texture_buffer_object - glTexBufferARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_buffer_object] && glConfig.m_glTexBufferARB)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferARB (target, internalformat, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexImage3DARB (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_texture_compression - glCompressedTexImage3DARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexImage3DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage3DARB (target, level, internalformat, width, height, depth, border, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexImage2DARB (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_texture_compression - glCompressedTexImage2DARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexImage2DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage2DARB (target, level, internalformat, width, height, border, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexImage1DARB (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_texture_compression - glCompressedTexImage1DARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexImage1DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage1DARB (target, level, internalformat, width, border, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexSubImage3DARB (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_texture_compression - glCompressedTexSubImage3DARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexSubImage3DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage3DARB (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexSubImage2DARB (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_texture_compression - glCompressedTexSubImage2DARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexSubImage2DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage2DARB (target, level, xoffset, yoffset, width, height, format, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexSubImage1DARB (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_texture_compression - glCompressedTexSubImage1DARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glCompressedTexSubImage1DARB)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage1DARB (target, level, xoffset, width, format, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCompressedTexImageARB (GLenum target, GLint level, void * img)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_texture_compression - glGetCompressedTexImageARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] && glConfig.m_glGetCompressedTexImageARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetCompressedTexImageARB (target, level, img);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLoadTransposeMatrixfARB (const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_transpose_matrix - glLoadTransposeMatrixfARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transpose_matrix] && glConfig.m_glLoadTransposeMatrixfARB)
  {
    prototypeCalled = true;
    glConfig.m_glLoadTransposeMatrixfARB (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLoadTransposeMatrixdARB (const GLdouble * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_transpose_matrix - glLoadTransposeMatrixdARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transpose_matrix] && glConfig.m_glLoadTransposeMatrixdARB)
  {
    prototypeCalled = true;
    glConfig.m_glLoadTransposeMatrixdARB (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultTransposeMatrixfARB (const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_transpose_matrix - glMultTransposeMatrixfARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transpose_matrix] && glConfig.m_glMultTransposeMatrixfARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultTransposeMatrixfARB (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultTransposeMatrixdARB (const GLdouble * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_transpose_matrix - glMultTransposeMatrixdARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_transpose_matrix] && glConfig.m_glMultTransposeMatrixdARB)
  {
    prototypeCalled = true;
    glConfig.m_glMultTransposeMatrixdARB (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWeightbvARB (GLint size, const GLbyte * weights)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_blend - glWeightbvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend] && glConfig.m_glWeightbvARB)
  {
    prototypeCalled = true;
    glConfig.m_glWeightbvARB (size, weights);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWeightsvARB (GLint size, const GLshort * weights)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_blend - glWeightsvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend] && glConfig.m_glWeightsvARB)
  {
    prototypeCalled = true;
    glConfig.m_glWeightsvARB (size, weights);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWeightivARB (GLint size, const GLint * weights)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_blend - glWeightivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend] && glConfig.m_glWeightivARB)
  {
    prototypeCalled = true;
    glConfig.m_glWeightivARB (size, weights);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWeightfvARB (GLint size, const GLfloat * weights)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_blend - glWeightfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend] && glConfig.m_glWeightfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glWeightfvARB (size, weights);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWeightdvARB (GLint size, const GLdouble * weights)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_blend - glWeightdvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend] && glConfig.m_glWeightdvARB)
  {
    prototypeCalled = true;
    glConfig.m_glWeightdvARB (size, weights);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWeightubvARB (GLint size, const GLubyte * weights)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_blend - glWeightubvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend] && glConfig.m_glWeightubvARB)
  {
    prototypeCalled = true;
    glConfig.m_glWeightubvARB (size, weights);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWeightusvARB (GLint size, const GLushort * weights)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_blend - glWeightusvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend] && glConfig.m_glWeightusvARB)
  {
    prototypeCalled = true;
    glConfig.m_glWeightusvARB (size, weights);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWeightuivARB (GLint size, const GLuint * weights)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_blend - glWeightuivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend] && glConfig.m_glWeightuivARB)
  {
    prototypeCalled = true;
    glConfig.m_glWeightuivARB (size, weights);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWeightPointerARB (GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_blend - glWeightPointerARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend] && glConfig.m_glWeightPointerARB)
  {
    prototypeCalled = true;
    glConfig.m_glWeightPointerARB (size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexBlendARB (GLint count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_blend - glVertexBlendARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend] && glConfig.m_glVertexBlendARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexBlendARB (count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBufferARB (GLenum target, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_buffer_object - glBindBufferARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glBindBufferARB)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferARB (target, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteBuffersARB (GLsizei n, const GLuint * buffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_buffer_object - glDeleteBuffersARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glDeleteBuffersARB)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteBuffersARB (n, buffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenBuffersARB (GLsizei n, GLuint * buffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_buffer_object - glGenBuffersARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glGenBuffersARB)
  {
    prototypeCalled = true;
    glConfig.m_glGenBuffersARB (n, buffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsBufferARB (GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_buffer_object - glIsBufferARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glIsBufferARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsBufferARB (buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferDataARB (GLenum target, GLsizeiptrARB size, const void * data, GLenum usage)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_buffer_object - glBufferDataARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glBufferDataARB)
  {
    prototypeCalled = true;
    glConfig.m_glBufferDataARB (target, size, data, usage);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferSubDataARB (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_buffer_object - glBufferSubDataARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glBufferSubDataARB)
  {
    prototypeCalled = true;
    glConfig.m_glBufferSubDataARB (target, offset, size, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetBufferSubDataARB (GLenum target, GLintptrARB offset, GLsizeiptrARB size, void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_buffer_object - glGetBufferSubDataARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glGetBufferSubDataARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferSubDataARB (target, offset, size, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void * _glew_gl_glMapBufferARB (GLenum target, GLenum access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  void * result = ((void *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_buffer_object - glMapBufferARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glMapBufferARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapBufferARB (target, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glUnmapBufferARB (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_buffer_object - glUnmapBufferARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glUnmapBufferARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glUnmapBufferARB (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetBufferParameterivARB (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_buffer_object - glGetBufferParameterivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glGetBufferParameterivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferParameterivARB (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetBufferPointervARB (GLenum target, GLenum pname, void ** params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_buffer_object - glGetBufferPointervARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] && glConfig.m_glGetBufferPointervARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferPointervARB (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1dARB (GLuint index, GLdouble x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib1dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1dARB (index, x);
  }
  // GL_ARB_vertex_shader - glVertexAttrib1dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib1dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1dARB (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1dvARB (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib1dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1dvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib1dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib1dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1dvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1fARB (GLuint index, GLfloat x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib1fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fARB (index, x);
  }
  // GL_ARB_vertex_shader - glVertexAttrib1fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib1fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fARB (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1fvARB (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib1fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib1fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib1fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1sARB (GLuint index, GLshort x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib1sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1sARB (index, x);
  }
  // GL_ARB_vertex_shader - glVertexAttrib1sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib1sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1sARB (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1svARB (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib1svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib1svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1svARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib1svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib1svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1svARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2dARB (GLuint index, GLdouble x, GLdouble y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib2dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2dARB (index, x, y);
  }
  // GL_ARB_vertex_shader - glVertexAttrib2dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib2dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2dARB (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2dvARB (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib2dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2dvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib2dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib2dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2dvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2fARB (GLuint index, GLfloat x, GLfloat y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib2fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fARB (index, x, y);
  }
  // GL_ARB_vertex_shader - glVertexAttrib2fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib2fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fARB (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2fvARB (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib2fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib2fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib2fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2sARB (GLuint index, GLshort x, GLshort y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib2sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2sARB (index, x, y);
  }
  // GL_ARB_vertex_shader - glVertexAttrib2sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib2sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2sARB (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2svARB (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib2svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib2svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2svARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib2svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib2svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2svARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3dARB (GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib3dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3dARB (index, x, y, z);
  }
  // GL_ARB_vertex_shader - glVertexAttrib3dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib3dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3dARB (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3dvARB (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib3dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3dvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib3dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib3dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3dvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3fARB (GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib3fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fARB (index, x, y, z);
  }
  // GL_ARB_vertex_shader - glVertexAttrib3fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib3fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fARB (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3fvARB (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib3fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib3fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib3fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3sARB (GLuint index, GLshort x, GLshort y, GLshort z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib3sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3sARB (index, x, y, z);
  }
  // GL_ARB_vertex_shader - glVertexAttrib3sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib3sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3sARB (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3svARB (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib3svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib3svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3svARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib3svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib3svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3svARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4NbvARB (GLuint index, const GLbyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4NbvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NbvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NbvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4NbvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4NbvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NbvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4NivARB (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4NivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NivARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4NivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4NivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NivARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4NsvARB (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4NsvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NsvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NsvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4NsvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4NsvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NsvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4NubARB (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4NubARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NubARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NubARB (index, x, y, z, w);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4NubARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4NubARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NubARB (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4NubvARB (GLuint index, const GLubyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4NubvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NubvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NubvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4NubvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4NubvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NubvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4NuivARB (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4NuivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NuivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NuivARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4NuivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4NuivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NuivARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4NusvARB (GLuint index, const GLushort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4NusvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4NusvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NusvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4NusvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4NusvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4NusvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4bvARB (GLuint index, const GLbyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4bvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4bvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4bvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4bvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4bvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4bvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4dARB (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4dARB (index, x, y, z, w);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4dARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4dARB (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4dvARB (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4dvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4dvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4fARB (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fARB (index, x, y, z, w);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4fARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fARB (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4fvARB (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4ivARB (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4ivARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4ivARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4sARB (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4sARB (index, x, y, z, w);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4sARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4sARB (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4svARB (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4svARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4svARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4svARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4ubvARB (GLuint index, const GLubyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4ubvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4ubvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4ubvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4ubvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4ubvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4ubvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4uivARB (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4uivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4uivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4uivARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4uivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4uivARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4uivARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4usvARB (GLuint index, const GLushort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttrib4usvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttrib4usvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4usvARB (index, v);
  }
  // GL_ARB_vertex_shader - glVertexAttrib4usvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttrib4usvARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4usvARB (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribPointerARB (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glVertexAttribPointerARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glVertexAttribPointerARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribPointerARB (index, size, type, normalized, stride, pointer);
  }
  // GL_ARB_vertex_shader - glVertexAttribPointerARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glVertexAttribPointerARB)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribPointerARB (index, size, type, normalized, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableVertexAttribArrayARB (GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glEnableVertexAttribArrayARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glEnableVertexAttribArrayARB)
  {
    prototypeCalled = true;
    glConfig.m_glEnableVertexAttribArrayARB (index);
  }
  // GL_ARB_vertex_shader - glEnableVertexAttribArrayARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glEnableVertexAttribArrayARB)
  {
    prototypeCalled = true;
    glConfig.m_glEnableVertexAttribArrayARB (index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableVertexAttribArrayARB (GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glDisableVertexAttribArrayARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glDisableVertexAttribArrayARB)
  {
    prototypeCalled = true;
    glConfig.m_glDisableVertexAttribArrayARB (index);
  }
  // GL_ARB_vertex_shader - glDisableVertexAttribArrayARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glDisableVertexAttribArrayARB)
  {
    prototypeCalled = true;
    glConfig.m_glDisableVertexAttribArrayARB (index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribdvARB (GLuint index, GLenum pname, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glGetVertexAttribdvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetVertexAttribdvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribdvARB (index, pname, params);
  }
  // GL_ARB_vertex_shader - glGetVertexAttribdvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glGetVertexAttribdvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribdvARB (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribfvARB (GLuint index, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glGetVertexAttribfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetVertexAttribfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribfvARB (index, pname, params);
  }
  // GL_ARB_vertex_shader - glGetVertexAttribfvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glGetVertexAttribfvARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribfvARB (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribivARB (GLuint index, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glGetVertexAttribivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetVertexAttribivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribivARB (index, pname, params);
  }
  // GL_ARB_vertex_shader - glGetVertexAttribivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glGetVertexAttribivARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribivARB (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribPointervARB (GLuint index, GLenum pname, void ** pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_program - glGetVertexAttribPointervARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] && glConfig.m_glGetVertexAttribPointervARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribPointervARB (index, pname, pointer);
  }
  // GL_ARB_vertex_shader - glGetVertexAttribPointervARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glGetVertexAttribPointervARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribPointervARB (index, pname, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindAttribLocationARB (GLhandleARB programObj, GLuint index, const GLcharARB * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_shader - glBindAttribLocationARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glBindAttribLocationARB)
  {
    prototypeCalled = true;
    glConfig.m_glBindAttribLocationARB (programObj, index, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveAttribARB (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_shader - glGetActiveAttribARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glGetActiveAttribARB)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveAttribARB (programObj, index, maxLength, length, size, type, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetAttribLocationARB (GLhandleARB programObj, const GLcharARB * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_vertex_shader - glGetAttribLocationARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] && glConfig.m_glGetAttribLocationARB)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetAttribLocationARB (programObj, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangeArraydvNV (GLuint first, GLsizei count, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_viewport_array - glDepthRangeArraydvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glDepthRangeArraydvNV)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangeArraydvNV (first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangeIndexeddNV (GLuint index, GLdouble n, GLdouble f)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_viewport_array - glDepthRangeIndexeddNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] && glConfig.m_glDepthRangeIndexeddNV)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangeIndexeddNV (index, n, f);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2dARB (GLdouble x, GLdouble y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos2dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos2dARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2dARB (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2dvARB (const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos2dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos2dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2dvARB (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2fARB (GLfloat x, GLfloat y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos2fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos2fARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2fARB (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2fvARB (const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos2fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos2fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2fvARB (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2iARB (GLint x, GLint y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos2iARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos2iARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2iARB (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2ivARB (const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos2ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos2ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2ivARB (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2sARB (GLshort x, GLshort y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos2sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos2sARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2sARB (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2svARB (const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos2svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos2svARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2svARB (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3dARB (GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos3dARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos3dARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3dARB (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3dvARB (const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos3dvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos3dvARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3dvARB (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3fARB (GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos3fARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos3fARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3fARB (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3fvARB (const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos3fvARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos3fvARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3fvARB (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3iARB (GLint x, GLint y, GLint z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos3iARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos3iARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3iARB (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3ivARB (const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos3ivARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos3ivARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3ivARB (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3sARB (GLshort x, GLshort y, GLshort z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos3sARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos3sARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3sARB (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3svARB (const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARB_window_pos - glWindowPos3svARB
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_window_pos] && glConfig.m_glWindowPos3svARB)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3svARB (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMaxActiveShaderCoresARM (GLuint count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ARM_shader_core_properties - glMaxActiveShaderCoresARM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARM_shader_core_properties] && glConfig.m_glMaxActiveShaderCoresARM)
  {
    prototypeCalled = true;
    glConfig.m_glMaxActiveShaderCoresARM (count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawBuffersATI (GLsizei n, const GLenum * bufs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_draw_buffers - glDrawBuffersATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_draw_buffers] && glConfig.m_glDrawBuffersATI)
  {
    prototypeCalled = true;
    glConfig.m_glDrawBuffersATI (n, bufs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glElementPointerATI (GLenum type, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_element_array - glElementPointerATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_element_array] && glConfig.m_glElementPointerATI)
  {
    prototypeCalled = true;
    glConfig.m_glElementPointerATI (type, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementArrayATI (GLenum mode, GLsizei count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_element_array - glDrawElementArrayATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_element_array] && glConfig.m_glDrawElementArrayATI)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementArrayATI (mode, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawRangeElementArrayATI (GLenum mode, GLuint start, GLuint end, GLsizei count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_element_array - glDrawRangeElementArrayATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_element_array] && glConfig.m_glDrawRangeElementArrayATI)
  {
    prototypeCalled = true;
    glConfig.m_glDrawRangeElementArrayATI (mode, start, end, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexBumpParameterivATI (GLenum pname, const GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_envmap_bumpmap - glTexBumpParameterivATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_envmap_bumpmap] && glConfig.m_glTexBumpParameterivATI)
  {
    prototypeCalled = true;
    glConfig.m_glTexBumpParameterivATI (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexBumpParameterfvATI (GLenum pname, const GLfloat * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_envmap_bumpmap - glTexBumpParameterfvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_envmap_bumpmap] && glConfig.m_glTexBumpParameterfvATI)
  {
    prototypeCalled = true;
    glConfig.m_glTexBumpParameterfvATI (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexBumpParameterivATI (GLenum pname, GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_envmap_bumpmap - glGetTexBumpParameterivATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_envmap_bumpmap] && glConfig.m_glGetTexBumpParameterivATI)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexBumpParameterivATI (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexBumpParameterfvATI (GLenum pname, GLfloat * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_envmap_bumpmap - glGetTexBumpParameterfvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_envmap_bumpmap] && glConfig.m_glGetTexBumpParameterfvATI)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexBumpParameterfvATI (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGenFragmentShadersATI (GLuint range)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glGenFragmentShadersATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glGenFragmentShadersATI)
  {
    prototypeCalled = true;
    result = glConfig.m_glGenFragmentShadersATI (range);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindFragmentShaderATI (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glBindFragmentShaderATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glBindFragmentShaderATI)
  {
    prototypeCalled = true;
    glConfig.m_glBindFragmentShaderATI (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteFragmentShaderATI (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glDeleteFragmentShaderATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glDeleteFragmentShaderATI)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteFragmentShaderATI (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginFragmentShaderATI ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glBeginFragmentShaderATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glBeginFragmentShaderATI)
  {
    prototypeCalled = true;
    glConfig.m_glBeginFragmentShaderATI ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndFragmentShaderATI ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glEndFragmentShaderATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glEndFragmentShaderATI)
  {
    prototypeCalled = true;
    glConfig.m_glEndFragmentShaderATI ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPassTexCoordATI (GLuint dst, GLuint coord, GLenum swizzle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glPassTexCoordATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glPassTexCoordATI)
  {
    prototypeCalled = true;
    glConfig.m_glPassTexCoordATI (dst, coord, swizzle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSampleMapATI (GLuint dst, GLuint interp, GLenum swizzle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glSampleMapATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glSampleMapATI)
  {
    prototypeCalled = true;
    glConfig.m_glSampleMapATI (dst, interp, swizzle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorFragmentOp1ATI (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glColorFragmentOp1ATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glColorFragmentOp1ATI)
  {
    prototypeCalled = true;
    glConfig.m_glColorFragmentOp1ATI (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorFragmentOp2ATI (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glColorFragmentOp2ATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glColorFragmentOp2ATI)
  {
    prototypeCalled = true;
    glConfig.m_glColorFragmentOp2ATI (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorFragmentOp3ATI (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glColorFragmentOp3ATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glColorFragmentOp3ATI)
  {
    prototypeCalled = true;
    glConfig.m_glColorFragmentOp3ATI (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glAlphaFragmentOp1ATI (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glAlphaFragmentOp1ATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glAlphaFragmentOp1ATI)
  {
    prototypeCalled = true;
    glConfig.m_glAlphaFragmentOp1ATI (op, dst, dstMod, arg1, arg1Rep, arg1Mod);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glAlphaFragmentOp2ATI (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glAlphaFragmentOp2ATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glAlphaFragmentOp2ATI)
  {
    prototypeCalled = true;
    glConfig.m_glAlphaFragmentOp2ATI (op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glAlphaFragmentOp3ATI (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glAlphaFragmentOp3ATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glAlphaFragmentOp3ATI)
  {
    prototypeCalled = true;
    glConfig.m_glAlphaFragmentOp3ATI (op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSetFragmentShaderConstantATI (GLuint dst, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_fragment_shader - glSetFragmentShaderConstantATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] && glConfig.m_glSetFragmentShaderConstantATI)
  {
    prototypeCalled = true;
    glConfig.m_glSetFragmentShaderConstantATI (dst, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void * _glew_gl_glMapObjectBufferATI (GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  void * result = ((void *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_map_object_buffer - glMapObjectBufferATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_map_object_buffer] && glConfig.m_glMapObjectBufferATI)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapObjectBufferATI (buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUnmapObjectBufferATI (GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_map_object_buffer - glUnmapObjectBufferATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_map_object_buffer] && glConfig.m_glUnmapObjectBufferATI)
  {
    prototypeCalled = true;
    glConfig.m_glUnmapObjectBufferATI (buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPNTrianglesiATI (GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_pn_triangles - glPNTrianglesiATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_pn_triangles] && glConfig.m_glPNTrianglesiATI)
  {
    prototypeCalled = true;
    glConfig.m_glPNTrianglesiATI (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPNTrianglesfATI (GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_pn_triangles - glPNTrianglesfATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_pn_triangles] && glConfig.m_glPNTrianglesfATI)
  {
    prototypeCalled = true;
    glConfig.m_glPNTrianglesfATI (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilOpSeparateATI (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_separate_stencil - glStencilOpSeparateATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_separate_stencil] && glConfig.m_glStencilOpSeparateATI)
  {
    prototypeCalled = true;
    glConfig.m_glStencilOpSeparateATI (face, sfail, dpfail, dppass);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilFuncSeparateATI (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_separate_stencil - glStencilFuncSeparateATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_separate_stencil] && glConfig.m_glStencilFuncSeparateATI)
  {
    prototypeCalled = true;
    glConfig.m_glStencilFuncSeparateATI (frontfunc, backfunc, ref, mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glNewObjectBufferATI (GLsizei size, const void * pointer, GLenum usage)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glNewObjectBufferATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glNewObjectBufferATI)
  {
    prototypeCalled = true;
    result = glConfig.m_glNewObjectBufferATI (size, pointer, usage);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsObjectBufferATI (GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glIsObjectBufferATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glIsObjectBufferATI)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsObjectBufferATI (buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUpdateObjectBufferATI (GLuint buffer, GLuint offset, GLsizei size, const void * pointer, GLenum preserve)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glUpdateObjectBufferATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glUpdateObjectBufferATI)
  {
    prototypeCalled = true;
    glConfig.m_glUpdateObjectBufferATI (buffer, offset, size, pointer, preserve);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetObjectBufferfvATI (GLuint buffer, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glGetObjectBufferfvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glGetObjectBufferfvATI)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectBufferfvATI (buffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetObjectBufferivATI (GLuint buffer, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glGetObjectBufferivATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glGetObjectBufferivATI)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectBufferivATI (buffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFreeObjectBufferATI (GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glFreeObjectBufferATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glFreeObjectBufferATI)
  {
    prototypeCalled = true;
    glConfig.m_glFreeObjectBufferATI (buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glArrayObjectATI (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glArrayObjectATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glArrayObjectATI)
  {
    prototypeCalled = true;
    glConfig.m_glArrayObjectATI (array, size, type, stride, buffer, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetArrayObjectfvATI (GLenum array, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glGetArrayObjectfvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glGetArrayObjectfvATI)
  {
    prototypeCalled = true;
    glConfig.m_glGetArrayObjectfvATI (array, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetArrayObjectivATI (GLenum array, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glGetArrayObjectivATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glGetArrayObjectivATI)
  {
    prototypeCalled = true;
    glConfig.m_glGetArrayObjectivATI (array, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVariantArrayObjectATI (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glVariantArrayObjectATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glVariantArrayObjectATI)
  {
    prototypeCalled = true;
    glConfig.m_glVariantArrayObjectATI (id, type, stride, buffer, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVariantArrayObjectfvATI (GLuint id, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glGetVariantArrayObjectfvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glGetVariantArrayObjectfvATI)
  {
    prototypeCalled = true;
    glConfig.m_glGetVariantArrayObjectfvATI (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVariantArrayObjectivATI (GLuint id, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_array_object - glGetVariantArrayObjectivATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] && glConfig.m_glGetVariantArrayObjectivATI)
  {
    prototypeCalled = true;
    glConfig.m_glGetVariantArrayObjectivATI (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribArrayObjectATI (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_attrib_array_object - glVertexAttribArrayObjectATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_attrib_array_object] && glConfig.m_glVertexAttribArrayObjectATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribArrayObjectATI (index, size, type, normalized, stride, buffer, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribArrayObjectfvATI (GLuint index, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_attrib_array_object - glGetVertexAttribArrayObjectfvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_attrib_array_object] && glConfig.m_glGetVertexAttribArrayObjectfvATI)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribArrayObjectfvATI (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribArrayObjectivATI (GLuint index, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_attrib_array_object - glGetVertexAttribArrayObjectivATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_attrib_array_object] && glConfig.m_glGetVertexAttribArrayObjectivATI)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribArrayObjectivATI (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream1sATI (GLenum stream, GLshort x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream1sATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream1sATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream1sATI (stream, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream1svATI (GLenum stream, const GLshort * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream1svATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream1svATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream1svATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream1iATI (GLenum stream, GLint x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream1iATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream1iATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream1iATI (stream, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream1ivATI (GLenum stream, const GLint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream1ivATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream1ivATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream1ivATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream1fATI (GLenum stream, GLfloat x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream1fATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream1fATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream1fATI (stream, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream1fvATI (GLenum stream, const GLfloat * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream1fvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream1fvATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream1fvATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream1dATI (GLenum stream, GLdouble x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream1dATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream1dATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream1dATI (stream, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream1dvATI (GLenum stream, const GLdouble * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream1dvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream1dvATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream1dvATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream2sATI (GLenum stream, GLshort x, GLshort y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream2sATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream2sATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream2sATI (stream, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream2svATI (GLenum stream, const GLshort * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream2svATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream2svATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream2svATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream2iATI (GLenum stream, GLint x, GLint y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream2iATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream2iATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream2iATI (stream, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream2ivATI (GLenum stream, const GLint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream2ivATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream2ivATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream2ivATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream2fATI (GLenum stream, GLfloat x, GLfloat y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream2fATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream2fATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream2fATI (stream, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream2fvATI (GLenum stream, const GLfloat * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream2fvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream2fvATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream2fvATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream2dATI (GLenum stream, GLdouble x, GLdouble y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream2dATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream2dATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream2dATI (stream, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream2dvATI (GLenum stream, const GLdouble * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream2dvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream2dvATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream2dvATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream3sATI (GLenum stream, GLshort x, GLshort y, GLshort z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream3sATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream3sATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream3sATI (stream, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream3svATI (GLenum stream, const GLshort * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream3svATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream3svATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream3svATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream3iATI (GLenum stream, GLint x, GLint y, GLint z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream3iATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream3iATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream3iATI (stream, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream3ivATI (GLenum stream, const GLint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream3ivATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream3ivATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream3ivATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream3fATI (GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream3fATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream3fATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream3fATI (stream, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream3fvATI (GLenum stream, const GLfloat * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream3fvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream3fvATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream3fvATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream3dATI (GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream3dATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream3dATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream3dATI (stream, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream3dvATI (GLenum stream, const GLdouble * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream3dvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream3dvATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream3dvATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream4sATI (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream4sATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream4sATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream4sATI (stream, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream4svATI (GLenum stream, const GLshort * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream4svATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream4svATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream4svATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream4iATI (GLenum stream, GLint x, GLint y, GLint z, GLint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream4iATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream4iATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream4iATI (stream, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream4ivATI (GLenum stream, const GLint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream4ivATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream4ivATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream4ivATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream4fATI (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream4fATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream4fATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream4fATI (stream, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream4fvATI (GLenum stream, const GLfloat * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream4fvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream4fvATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream4fvATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream4dATI (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream4dATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream4dATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream4dATI (stream, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexStream4dvATI (GLenum stream, const GLdouble * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexStream4dvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexStream4dvATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexStream4dvATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalStream3bATI (GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glNormalStream3bATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glNormalStream3bATI)
  {
    prototypeCalled = true;
    glConfig.m_glNormalStream3bATI (stream, nx, ny, nz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalStream3bvATI (GLenum stream, const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glNormalStream3bvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glNormalStream3bvATI)
  {
    prototypeCalled = true;
    glConfig.m_glNormalStream3bvATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalStream3sATI (GLenum stream, GLshort nx, GLshort ny, GLshort nz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glNormalStream3sATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glNormalStream3sATI)
  {
    prototypeCalled = true;
    glConfig.m_glNormalStream3sATI (stream, nx, ny, nz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalStream3svATI (GLenum stream, const GLshort * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glNormalStream3svATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glNormalStream3svATI)
  {
    prototypeCalled = true;
    glConfig.m_glNormalStream3svATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalStream3iATI (GLenum stream, GLint nx, GLint ny, GLint nz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glNormalStream3iATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glNormalStream3iATI)
  {
    prototypeCalled = true;
    glConfig.m_glNormalStream3iATI (stream, nx, ny, nz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalStream3ivATI (GLenum stream, const GLint * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glNormalStream3ivATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glNormalStream3ivATI)
  {
    prototypeCalled = true;
    glConfig.m_glNormalStream3ivATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalStream3fATI (GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glNormalStream3fATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glNormalStream3fATI)
  {
    prototypeCalled = true;
    glConfig.m_glNormalStream3fATI (stream, nx, ny, nz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalStream3fvATI (GLenum stream, const GLfloat * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glNormalStream3fvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glNormalStream3fvATI)
  {
    prototypeCalled = true;
    glConfig.m_glNormalStream3fvATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalStream3dATI (GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glNormalStream3dATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glNormalStream3dATI)
  {
    prototypeCalled = true;
    glConfig.m_glNormalStream3dATI (stream, nx, ny, nz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalStream3dvATI (GLenum stream, const GLdouble * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glNormalStream3dvATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glNormalStream3dvATI)
  {
    prototypeCalled = true;
    glConfig.m_glNormalStream3dvATI (stream, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClientActiveVertexStreamATI (GLenum stream)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glClientActiveVertexStreamATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glClientActiveVertexStreamATI)
  {
    prototypeCalled = true;
    glConfig.m_glClientActiveVertexStreamATI (stream);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexBlendEnviATI (GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexBlendEnviATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexBlendEnviATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexBlendEnviATI (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexBlendEnvfATI (GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_ATI_vertex_streams - glVertexBlendEnvfATI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] && glConfig.m_glVertexBlendEnvfATI)
  {
    prototypeCalled = true;
    glConfig.m_glVertexBlendEnvfATI (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEGLImageTargetTexStorageEXT (GLenum target, GLeglImageOES image, const GLint*  attrib_list)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_EGL_image_storage - glEGLImageTargetTexStorageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_EGL_image_storage] && glConfig.m_glEGLImageTargetTexStorageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEGLImageTargetTexStorageEXT (target, image, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEGLImageTargetTextureStorageEXT (GLuint texture, GLeglImageOES image, const GLint*  attrib_list)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_EGL_image_storage - glEGLImageTargetTextureStorageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_EGL_image_storage] && glConfig.m_glEGLImageTargetTextureStorageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEGLImageTargetTextureStorageEXT (texture, image, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawArraysInstancedBaseInstanceEXT (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_base_instance - glDrawArraysInstancedBaseInstanceEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_base_instance] && glConfig.m_glDrawArraysInstancedBaseInstanceEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstancedBaseInstanceEXT (mode, first, count, instancecount, baseinstance);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstancedBaseInstanceEXT (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_base_instance - glDrawElementsInstancedBaseInstanceEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_base_instance] && glConfig.m_glDrawElementsInstancedBaseInstanceEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedBaseInstanceEXT (mode, count, type, indices, instancecount, baseinstance);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstancedBaseVertexBaseInstanceEXT (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_base_instance - glDrawElementsInstancedBaseVertexBaseInstanceEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_base_instance] && glConfig.m_glDrawElementsInstancedBaseVertexBaseInstanceEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedBaseVertexBaseInstanceEXT (mode, count, type, indices, instancecount, basevertex, baseinstance);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformBufferEXT (GLuint program, GLint location, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_bindable_uniform - glUniformBufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_bindable_uniform] && glConfig.m_glUniformBufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniformBufferEXT (program, location, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetUniformBufferSizeEXT (GLuint program, GLint location)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_bindable_uniform - glGetUniformBufferSizeEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_bindable_uniform] && glConfig.m_glGetUniformBufferSizeEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetUniformBufferSizeEXT (program, location);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLintptr _glew_gl_glGetUniformOffsetEXT (GLuint program, GLint location)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLintptr result = ((GLintptr)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_bindable_uniform - glGetUniformOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_bindable_uniform] && glConfig.m_glGetUniformOffsetEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetUniformOffsetEXT (program, location);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendColorEXT (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_blend_color - glBlendColorEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_color] && glConfig.m_glBlendColorEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendColorEXT (red, green, blue, alpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationSeparateEXT (GLenum modeRGB, GLenum modeAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_blend_equation_separate - glBlendEquationSeparateEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_equation_separate] && glConfig.m_glBlendEquationSeparateEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparateEXT (modeRGB, modeAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindFragDataLocationIndexedEXT (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_blend_func_extended - glBindFragDataLocationIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_func_extended] && glConfig.m_glBindFragDataLocationIndexedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindFragDataLocationIndexedEXT (program, colorNumber, index, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindFragDataLocationEXT (GLuint program, GLuint color, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_blend_func_extended - glBindFragDataLocationEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_func_extended] && glConfig.m_glBindFragDataLocationEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindFragDataLocationEXT (program, color, name);
  }
  // GL_EXT_gpu_shader4 - glBindFragDataLocationEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glBindFragDataLocationEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindFragDataLocationEXT (program, color, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetProgramResourceLocationIndexEXT (GLuint program, GLenum programInterface, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_blend_func_extended - glGetProgramResourceLocationIndexEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_func_extended] && glConfig.m_glGetProgramResourceLocationIndexEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetProgramResourceLocationIndexEXT (program, programInterface, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetFragDataIndexEXT (GLuint program, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_blend_func_extended - glGetFragDataIndexEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_func_extended] && glConfig.m_glGetFragDataIndexEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetFragDataIndexEXT (program, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFuncSeparateEXT (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_blend_func_separate - glBlendFuncSeparateEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_func_separate] && glConfig.m_glBlendFuncSeparateEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparateEXT (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationEXT (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_blend_minmax - glBlendEquationEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_blend_minmax] && glConfig.m_glBlendEquationEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationEXT (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferStorageEXT (GLenum target, GLsizeiptr size, const void * data, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_buffer_storage - glBufferStorageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_buffer_storage] && glConfig.m_glBufferStorageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBufferStorageEXT (target, size, data, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearTexImageEXT (GLuint texture, GLint level, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_clear_texture - glClearTexImageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_clear_texture] && glConfig.m_glClearTexImageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glClearTexImageEXT (texture, level, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearTexSubImageEXT (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_clear_texture - glClearTexSubImageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_clear_texture] && glConfig.m_glClearTexSubImageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glClearTexSubImageEXT (texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClipControlEXT (GLenum origin, GLenum depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_clip_control - glClipControlEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_clip_control] && glConfig.m_glClipControlEXT)
  {
    prototypeCalled = true;
    glConfig.m_glClipControlEXT (origin, depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorSubTableEXT (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_color_subtable - glColorSubTableEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_color_subtable] && glConfig.m_glColorSubTableEXT)
  {
    prototypeCalled = true;
    glConfig.m_glColorSubTableEXT (target, start, count, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyColorSubTableEXT (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_color_subtable - glCopyColorSubTableEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_color_subtable] && glConfig.m_glCopyColorSubTableEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyColorSubTableEXT (target, start, x, y, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLockArraysEXT (GLint first, GLsizei count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_compiled_vertex_array - glLockArraysEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_compiled_vertex_array] && glConfig.m_glLockArraysEXT)
  {
    prototypeCalled = true;
    glConfig.m_glLockArraysEXT (first, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUnlockArraysEXT ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_compiled_vertex_array - glUnlockArraysEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_compiled_vertex_array] && glConfig.m_glUnlockArraysEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUnlockArraysEXT ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionFilter1DEXT (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * image)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glConvolutionFilter1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionFilter1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionFilter1DEXT (target, internalformat, width, format, type, image);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionFilter2DEXT (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * image)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glConvolutionFilter2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionFilter2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionFilter2DEXT (target, internalformat, width, height, format, type, image);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionParameterfEXT (GLenum target, GLenum pname, GLfloat params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glConvolutionParameterfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionParameterfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameterfEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionParameterfvEXT (GLenum target, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glConvolutionParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameterfvEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionParameteriEXT (GLenum target, GLenum pname, GLint params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glConvolutionParameteriEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionParameteriEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameteriEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionParameterivEXT (GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glConvolutionParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glConvolutionParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameterivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyConvolutionFilter1DEXT (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glCopyConvolutionFilter1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glCopyConvolutionFilter1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyConvolutionFilter1DEXT (target, internalformat, x, y, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyConvolutionFilter2DEXT (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glCopyConvolutionFilter2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glCopyConvolutionFilter2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyConvolutionFilter2DEXT (target, internalformat, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetConvolutionFilterEXT (GLenum target, GLenum format, GLenum type, void * image)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glGetConvolutionFilterEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glGetConvolutionFilterEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetConvolutionFilterEXT (target, format, type, image);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetConvolutionParameterfvEXT (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glGetConvolutionParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glGetConvolutionParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetConvolutionParameterfvEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetConvolutionParameterivEXT (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glGetConvolutionParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glGetConvolutionParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetConvolutionParameterivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSeparableFilterEXT (GLenum target, GLenum format, GLenum type, void * row, void * column, void * span)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glGetSeparableFilterEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glGetSeparableFilterEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetSeparableFilterEXT (target, format, type, row, column, span);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSeparableFilter2DEXT (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * row, const void * column)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_convolution - glSeparableFilter2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_convolution] && glConfig.m_glSeparableFilter2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSeparableFilter2DEXT (target, internalformat, width, height, format, type, row, column);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTangent3bEXT (GLbyte tx, GLbyte ty, GLbyte tz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glTangent3bEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glTangent3bEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTangent3bEXT (tx, ty, tz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTangent3bvEXT (const GLbyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glTangent3bvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glTangent3bvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTangent3bvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTangent3dEXT (GLdouble tx, GLdouble ty, GLdouble tz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glTangent3dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glTangent3dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTangent3dEXT (tx, ty, tz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTangent3dvEXT (const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glTangent3dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glTangent3dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTangent3dvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTangent3fEXT (GLfloat tx, GLfloat ty, GLfloat tz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glTangent3fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glTangent3fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTangent3fEXT (tx, ty, tz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTangent3fvEXT (const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glTangent3fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glTangent3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTangent3fvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTangent3iEXT (GLint tx, GLint ty, GLint tz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glTangent3iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glTangent3iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTangent3iEXT (tx, ty, tz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTangent3ivEXT (const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glTangent3ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glTangent3ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTangent3ivEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTangent3sEXT (GLshort tx, GLshort ty, GLshort tz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glTangent3sEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glTangent3sEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTangent3sEXT (tx, ty, tz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTangent3svEXT (const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glTangent3svEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glTangent3svEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTangent3svEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBinormal3bEXT (GLbyte bx, GLbyte by, GLbyte bz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glBinormal3bEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glBinormal3bEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBinormal3bEXT (bx, by, bz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBinormal3bvEXT (const GLbyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glBinormal3bvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glBinormal3bvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBinormal3bvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBinormal3dEXT (GLdouble bx, GLdouble by, GLdouble bz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glBinormal3dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glBinormal3dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBinormal3dEXT (bx, by, bz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBinormal3dvEXT (const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glBinormal3dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glBinormal3dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBinormal3dvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBinormal3fEXT (GLfloat bx, GLfloat by, GLfloat bz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glBinormal3fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glBinormal3fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBinormal3fEXT (bx, by, bz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBinormal3fvEXT (const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glBinormal3fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glBinormal3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBinormal3fvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBinormal3iEXT (GLint bx, GLint by, GLint bz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glBinormal3iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glBinormal3iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBinormal3iEXT (bx, by, bz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBinormal3ivEXT (const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glBinormal3ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glBinormal3ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBinormal3ivEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBinormal3sEXT (GLshort bx, GLshort by, GLshort bz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glBinormal3sEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glBinormal3sEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBinormal3sEXT (bx, by, bz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBinormal3svEXT (const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glBinormal3svEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glBinormal3svEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBinormal3svEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTangentPointerEXT (GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glTangentPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glTangentPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTangentPointerEXT (type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBinormalPointerEXT (GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_coordinate_frame - glBinormalPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] && glConfig.m_glBinormalPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBinormalPointerEXT (type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyImageSubDataEXT (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_copy_image - glCopyImageSubDataEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_copy_image] && glConfig.m_glCopyImageSubDataEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyImageSubDataEXT (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTexImage1DEXT (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_copy_texture - glCopyTexImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_copy_texture] && glConfig.m_glCopyTexImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexImage1DEXT (target, level, internalformat, x, y, width, border);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTexImage2DEXT (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_copy_texture - glCopyTexImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_copy_texture] && glConfig.m_glCopyTexImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexImage2DEXT (target, level, internalformat, x, y, width, height, border);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTexSubImage1DEXT (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_copy_texture - glCopyTexSubImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_copy_texture] && glConfig.m_glCopyTexSubImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexSubImage1DEXT (target, level, xoffset, x, y, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTexSubImage2DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_copy_texture - glCopyTexSubImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_copy_texture] && glConfig.m_glCopyTexSubImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexSubImage2DEXT (target, level, xoffset, yoffset, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTexSubImage3DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_copy_texture - glCopyTexSubImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_copy_texture] && glConfig.m_glCopyTexSubImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexSubImage3DEXT (target, level, xoffset, yoffset, zoffset, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCullParameterdvEXT (GLenum pname, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_cull_vertex - glCullParameterdvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_cull_vertex] && glConfig.m_glCullParameterdvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCullParameterdvEXT (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCullParameterfvEXT (GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_cull_vertex - glCullParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_cull_vertex] && glConfig.m_glCullParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCullParameterfvEXT (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLabelObjectEXT (GLenum type, GLuint object, GLsizei length, const GLchar * label)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_debug_label - glLabelObjectEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_debug_label] && glConfig.m_glLabelObjectEXT)
  {
    prototypeCalled = true;
    glConfig.m_glLabelObjectEXT (type, object, length, label);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetObjectLabelEXT (GLenum type, GLuint object, GLsizei bufSize, GLsizei * length, GLchar * label)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_debug_label - glGetObjectLabelEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_debug_label] && glConfig.m_glGetObjectLabelEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectLabelEXT (type, object, bufSize, length, label);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInsertEventMarkerEXT (GLsizei length, const GLchar * marker)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_debug_marker - glInsertEventMarkerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_debug_marker] && glConfig.m_glInsertEventMarkerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glInsertEventMarkerEXT (length, marker);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPushGroupMarkerEXT (GLsizei length, const GLchar * marker)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_debug_marker - glPushGroupMarkerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_debug_marker] && glConfig.m_glPushGroupMarkerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPushGroupMarkerEXT (length, marker);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPopGroupMarkerEXT ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_debug_marker - glPopGroupMarkerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_debug_marker] && glConfig.m_glPopGroupMarkerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPopGroupMarkerEXT ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthBoundsEXT (GLclampd zmin, GLclampd zmax)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_depth_bounds_test - glDepthBoundsEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_depth_bounds_test] && glConfig.m_glDepthBoundsEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDepthBoundsEXT (zmin, zmax);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixLoadfEXT (GLenum mode, const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixLoadfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixLoadfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoadfEXT (mode, m);
  }
  // GL_NV_path_rendering - glMatrixLoadfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixLoadfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoadfEXT (mode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixLoaddEXT (GLenum mode, const GLdouble * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixLoaddEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixLoaddEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoaddEXT (mode, m);
  }
  // GL_NV_path_rendering - glMatrixLoaddEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixLoaddEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoaddEXT (mode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixMultfEXT (GLenum mode, const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixMultfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixMultfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixMultfEXT (mode, m);
  }
  // GL_NV_path_rendering - glMatrixMultfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixMultfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixMultfEXT (mode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixMultdEXT (GLenum mode, const GLdouble * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixMultdEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixMultdEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixMultdEXT (mode, m);
  }
  // GL_NV_path_rendering - glMatrixMultdEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixMultdEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixMultdEXT (mode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixLoadIdentityEXT (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixLoadIdentityEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixLoadIdentityEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoadIdentityEXT (mode);
  }
  // GL_NV_path_rendering - glMatrixLoadIdentityEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixLoadIdentityEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoadIdentityEXT (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixRotatefEXT (GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixRotatefEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixRotatefEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixRotatefEXT (mode, angle, x, y, z);
  }
  // GL_NV_path_rendering - glMatrixRotatefEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixRotatefEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixRotatefEXT (mode, angle, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixRotatedEXT (GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixRotatedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixRotatedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixRotatedEXT (mode, angle, x, y, z);
  }
  // GL_NV_path_rendering - glMatrixRotatedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixRotatedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixRotatedEXT (mode, angle, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixScalefEXT (GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixScalefEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixScalefEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixScalefEXT (mode, x, y, z);
  }
  // GL_NV_path_rendering - glMatrixScalefEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixScalefEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixScalefEXT (mode, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixScaledEXT (GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixScaledEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixScaledEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixScaledEXT (mode, x, y, z);
  }
  // GL_NV_path_rendering - glMatrixScaledEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixScaledEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixScaledEXT (mode, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixTranslatefEXT (GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixTranslatefEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixTranslatefEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixTranslatefEXT (mode, x, y, z);
  }
  // GL_NV_path_rendering - glMatrixTranslatefEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixTranslatefEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixTranslatefEXT (mode, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixTranslatedEXT (GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixTranslatedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixTranslatedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixTranslatedEXT (mode, x, y, z);
  }
  // GL_NV_path_rendering - glMatrixTranslatedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixTranslatedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixTranslatedEXT (mode, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixFrustumEXT (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixFrustumEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixFrustumEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixFrustumEXT (mode, left, right, bottom, top, zNear, zFar);
  }
  // GL_NV_path_rendering - glMatrixFrustumEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixFrustumEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixFrustumEXT (mode, left, right, bottom, top, zNear, zFar);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixOrthoEXT (GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixOrthoEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixOrthoEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixOrthoEXT (mode, left, right, bottom, top, zNear, zFar);
  }
  // GL_NV_path_rendering - glMatrixOrthoEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixOrthoEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixOrthoEXT (mode, left, right, bottom, top, zNear, zFar);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixPopEXT (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixPopEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixPopEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixPopEXT (mode);
  }
  // GL_NV_path_rendering - glMatrixPopEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixPopEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixPopEXT (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixPushEXT (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixPushEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixPushEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixPushEXT (mode);
  }
  // GL_NV_path_rendering - glMatrixPushEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixPushEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixPushEXT (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClientAttribDefaultEXT (GLbitfield mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glClientAttribDefaultEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glClientAttribDefaultEXT)
  {
    prototypeCalled = true;
    glConfig.m_glClientAttribDefaultEXT (mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPushClientAttribDefaultEXT (GLbitfield mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glPushClientAttribDefaultEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glPushClientAttribDefaultEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPushClientAttribDefaultEXT (mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameterfEXT (GLuint texture, GLenum target, GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureParameterfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureParameterfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterfEXT (texture, target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameterfvEXT (GLuint texture, GLenum target, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterfvEXT (texture, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameteriEXT (GLuint texture, GLenum target, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureParameteriEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureParameteriEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameteriEXT (texture, target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameterivEXT (GLuint texture, GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterivEXT (texture, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureImage1DEXT (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureImage1DEXT (texture, target, level, internalformat, width, border, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureImage2DEXT (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureImage2DEXT (texture, target, level, internalformat, width, height, border, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureSubImage1DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureSubImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureSubImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureSubImage1DEXT (texture, target, level, xoffset, width, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureSubImage2DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureSubImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureSubImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureSubImage2DEXT (texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTextureImage1DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCopyTextureImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCopyTextureImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureImage1DEXT (texture, target, level, internalformat, x, y, width, border);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTextureImage2DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCopyTextureImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCopyTextureImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureImage2DEXT (texture, target, level, internalformat, x, y, width, height, border);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTextureSubImage1DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCopyTextureSubImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCopyTextureSubImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureSubImage1DEXT (texture, target, level, xoffset, x, y, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTextureSubImage2DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCopyTextureSubImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCopyTextureSubImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureSubImage2DEXT (texture, target, level, xoffset, yoffset, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureImageEXT (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetTextureImageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetTextureImageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureImageEXT (texture, target, level, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureParameterfvEXT (GLuint texture, GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetTextureParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetTextureParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameterfvEXT (texture, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureParameterivEXT (GLuint texture, GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetTextureParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetTextureParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameterivEXT (texture, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureLevelParameterfvEXT (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetTextureLevelParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetTextureLevelParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureLevelParameterfvEXT (texture, target, level, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureLevelParameterivEXT (GLuint texture, GLenum target, GLint level, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetTextureLevelParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetTextureLevelParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureLevelParameterivEXT (texture, target, level, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureImage3DEXT (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureImage3DEXT (texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureSubImage3DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureSubImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureSubImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureSubImage3DEXT (texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTextureSubImage3DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCopyTextureSubImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCopyTextureSubImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTextureSubImage3DEXT (texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindMultiTextureEXT (GLenum texunit, GLenum target, GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glBindMultiTextureEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glBindMultiTextureEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindMultiTextureEXT (texunit, target, texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoordPointerEXT (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexCoordPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexCoordPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoordPointerEXT (texunit, size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexEnvfEXT (GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexEnvfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexEnvfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexEnvfEXT (texunit, target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexEnvfvEXT (GLenum texunit, GLenum target, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexEnvfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexEnvfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexEnvfvEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexEnviEXT (GLenum texunit, GLenum target, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexEnviEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexEnviEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexEnviEXT (texunit, target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexEnvivEXT (GLenum texunit, GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexEnvivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexEnvivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexEnvivEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexGendEXT (GLenum texunit, GLenum coord, GLenum pname, GLdouble param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexGendEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexGendEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexGendEXT (texunit, coord, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexGendvEXT (GLenum texunit, GLenum coord, GLenum pname, const GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexGendvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexGendvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexGendvEXT (texunit, coord, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexGenfEXT (GLenum texunit, GLenum coord, GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexGenfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexGenfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexGenfEXT (texunit, coord, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexGenfvEXT (GLenum texunit, GLenum coord, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexGenfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexGenfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexGenfvEXT (texunit, coord, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexGeniEXT (GLenum texunit, GLenum coord, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexGeniEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexGeniEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexGeniEXT (texunit, coord, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexGenivEXT (GLenum texunit, GLenum coord, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexGenivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexGenivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexGenivEXT (texunit, coord, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexEnvfvEXT (GLenum texunit, GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexEnvfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexEnvfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexEnvfvEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexEnvivEXT (GLenum texunit, GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexEnvivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexEnvivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexEnvivEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexGendvEXT (GLenum texunit, GLenum coord, GLenum pname, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexGendvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexGendvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexGendvEXT (texunit, coord, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexGenfvEXT (GLenum texunit, GLenum coord, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexGenfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexGenfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexGenfvEXT (texunit, coord, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexGenivEXT (GLenum texunit, GLenum coord, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexGenivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexGenivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexGenivEXT (texunit, coord, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexParameteriEXT (GLenum texunit, GLenum target, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexParameteriEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexParameteriEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexParameteriEXT (texunit, target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexParameterivEXT (GLenum texunit, GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexParameterivEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexParameterfEXT (GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexParameterfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexParameterfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexParameterfEXT (texunit, target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexParameterfvEXT (GLenum texunit, GLenum target, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexParameterfvEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexImage1DEXT (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexImage1DEXT (texunit, target, level, internalformat, width, border, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexImage2DEXT (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexImage2DEXT (texunit, target, level, internalformat, width, height, border, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexSubImage1DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexSubImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexSubImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexSubImage1DEXT (texunit, target, level, xoffset, width, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexSubImage2DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexSubImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexSubImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexSubImage2DEXT (texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyMultiTexImage1DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCopyMultiTexImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCopyMultiTexImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyMultiTexImage1DEXT (texunit, target, level, internalformat, x, y, width, border);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyMultiTexImage2DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCopyMultiTexImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCopyMultiTexImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyMultiTexImage2DEXT (texunit, target, level, internalformat, x, y, width, height, border);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyMultiTexSubImage1DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCopyMultiTexSubImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCopyMultiTexSubImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyMultiTexSubImage1DEXT (texunit, target, level, xoffset, x, y, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyMultiTexSubImage2DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCopyMultiTexSubImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCopyMultiTexSubImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyMultiTexSubImage2DEXT (texunit, target, level, xoffset, yoffset, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexImageEXT (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexImageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexImageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexImageEXT (texunit, target, level, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexParameterfvEXT (GLenum texunit, GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexParameterfvEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexParameterivEXT (GLenum texunit, GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexParameterivEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexLevelParameterfvEXT (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexLevelParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexLevelParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexLevelParameterfvEXT (texunit, target, level, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexLevelParameterivEXT (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexLevelParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexLevelParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexLevelParameterivEXT (texunit, target, level, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexImage3DEXT (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexImage3DEXT (texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexSubImage3DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexSubImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexSubImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexSubImage3DEXT (texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyMultiTexSubImage3DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCopyMultiTexSubImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCopyMultiTexSubImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCopyMultiTexSubImage3DEXT (texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableClientStateIndexedEXT (GLenum array, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glEnableClientStateIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glEnableClientStateIndexedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEnableClientStateIndexedEXT (array, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableClientStateIndexedEXT (GLenum array, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glDisableClientStateIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glDisableClientStateIndexedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDisableClientStateIndexedEXT (array, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFloatIndexedvEXT (GLenum target, GLuint index, GLfloat * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetFloatIndexedvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetFloatIndexedvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetFloatIndexedvEXT (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetDoubleIndexedvEXT (GLenum target, GLuint index, GLdouble * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetDoubleIndexedvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetDoubleIndexedvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetDoubleIndexedvEXT (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPointerIndexedvEXT (GLenum target, GLuint index, void ** data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetPointerIndexedvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetPointerIndexedvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetPointerIndexedvEXT (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableIndexedEXT (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glEnableIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glEnableIndexedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEnableIndexedEXT (target, index);
  }
  // GL_EXT_draw_buffers2 - glEnableIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers2] && glConfig.m_glEnableIndexedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEnableIndexedEXT (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableIndexedEXT (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glDisableIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glDisableIndexedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDisableIndexedEXT (target, index);
  }
  // GL_EXT_draw_buffers2 - glDisableIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers2] && glConfig.m_glDisableIndexedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDisableIndexedEXT (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsEnabledIndexedEXT (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glIsEnabledIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glIsEnabledIndexedEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsEnabledIndexedEXT (target, index);
  }
  // GL_EXT_draw_buffers2 - glIsEnabledIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers2] && glConfig.m_glIsEnabledIndexedEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsEnabledIndexedEXT (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetIntegerIndexedvEXT (GLenum target, GLuint index, GLint * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetIntegerIndexedvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetIntegerIndexedvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetIntegerIndexedvEXT (target, index, data);
  }
  // GL_EXT_draw_buffers2 - glGetIntegerIndexedvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers2] && glConfig.m_glGetIntegerIndexedvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetIntegerIndexedvEXT (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetBooleanIndexedvEXT (GLenum target, GLuint index, GLboolean * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetBooleanIndexedvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetBooleanIndexedvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetBooleanIndexedvEXT (target, index, data);
  }
  // GL_EXT_draw_buffers2 - glGetBooleanIndexedvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers2] && glConfig.m_glGetBooleanIndexedvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetBooleanIndexedvEXT (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTextureImage3DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedTextureImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedTextureImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureImage3DEXT (texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTextureImage2DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedTextureImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedTextureImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureImage2DEXT (texture, target, level, internalformat, width, height, border, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTextureImage1DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedTextureImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedTextureImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureImage1DEXT (texture, target, level, internalformat, width, border, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTextureSubImage3DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedTextureSubImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedTextureSubImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureSubImage3DEXT (texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTextureSubImage2DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedTextureSubImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedTextureSubImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureSubImage2DEXT (texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTextureSubImage1DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedTextureSubImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedTextureSubImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTextureSubImage1DEXT (texture, target, level, xoffset, width, format, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCompressedTextureImageEXT (GLuint texture, GLenum target, GLint lod, void * img)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetCompressedTextureImageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetCompressedTextureImageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetCompressedTextureImageEXT (texture, target, lod, img);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedMultiTexImage3DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedMultiTexImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedMultiTexImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedMultiTexImage3DEXT (texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedMultiTexImage2DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedMultiTexImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedMultiTexImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedMultiTexImage2DEXT (texunit, target, level, internalformat, width, height, border, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedMultiTexImage1DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedMultiTexImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedMultiTexImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedMultiTexImage1DEXT (texunit, target, level, internalformat, width, border, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedMultiTexSubImage3DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedMultiTexSubImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedMultiTexSubImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedMultiTexSubImage3DEXT (texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedMultiTexSubImage2DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedMultiTexSubImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedMultiTexSubImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedMultiTexSubImage2DEXT (texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedMultiTexSubImage1DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * bits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCompressedMultiTexSubImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCompressedMultiTexSubImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedMultiTexSubImage1DEXT (texunit, target, level, xoffset, width, format, imageSize, bits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCompressedMultiTexImageEXT (GLenum texunit, GLenum target, GLint lod, void * img)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetCompressedMultiTexImageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetCompressedMultiTexImageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetCompressedMultiTexImageEXT (texunit, target, lod, img);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixLoadTransposefEXT (GLenum mode, const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixLoadTransposefEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixLoadTransposefEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoadTransposefEXT (mode, m);
  }
  // GL_NV_path_rendering - glMatrixLoadTransposefEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixLoadTransposefEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoadTransposefEXT (mode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixLoadTransposedEXT (GLenum mode, const GLdouble * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixLoadTransposedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixLoadTransposedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoadTransposedEXT (mode, m);
  }
  // GL_NV_path_rendering - glMatrixLoadTransposedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixLoadTransposedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoadTransposedEXT (mode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixMultTransposefEXT (GLenum mode, const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixMultTransposefEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixMultTransposefEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixMultTransposefEXT (mode, m);
  }
  // GL_NV_path_rendering - glMatrixMultTransposefEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixMultTransposefEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixMultTransposefEXT (mode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixMultTransposedEXT (GLenum mode, const GLdouble * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMatrixMultTransposedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMatrixMultTransposedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixMultTransposedEXT (mode, m);
  }
  // GL_NV_path_rendering - glMatrixMultTransposedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixMultTransposedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixMultTransposedEXT (mode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferDataEXT (GLuint buffer, GLsizeiptr size, const void * data, GLenum usage)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedBufferDataEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedBufferDataEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferDataEXT (buffer, size, data, usage);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferSubDataEXT (GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedBufferSubDataEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedBufferSubDataEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferSubDataEXT (buffer, offset, size, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void * _glew_gl_glMapNamedBufferEXT (GLuint buffer, GLenum access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  void * result = ((void *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMapNamedBufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMapNamedBufferEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapNamedBufferEXT (buffer, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glUnmapNamedBufferEXT (GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glUnmapNamedBufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glUnmapNamedBufferEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glUnmapNamedBufferEXT (buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedBufferParameterivEXT (GLuint buffer, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedBufferParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedBufferParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferParameterivEXT (buffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedBufferPointervEXT (GLuint buffer, GLenum pname, void ** params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedBufferPointervEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedBufferPointervEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferPointervEXT (buffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedBufferSubDataEXT (GLuint buffer, GLintptr offset, GLsizeiptr size, void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedBufferSubDataEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedBufferSubDataEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferSubDataEXT (buffer, offset, size, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1fEXT (GLuint program, GLint location, GLfloat v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform1fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform1fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1fEXT (program, location, v0);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform1fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform1fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1fEXT (program, location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2fEXT (GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform2fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform2fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2fEXT (program, location, v0, v1);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform2fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform2fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2fEXT (program, location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3fEXT (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform3fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform3fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3fEXT (program, location, v0, v1, v2);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform3fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform3fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3fEXT (program, location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4fEXT (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform4fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform4fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4fEXT (program, location, v0, v1, v2, v3);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform4fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform4fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4fEXT (program, location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1iEXT (GLuint program, GLint location, GLint v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform1iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform1iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1iEXT (program, location, v0);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform1iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform1iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1iEXT (program, location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2iEXT (GLuint program, GLint location, GLint v0, GLint v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform2iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform2iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2iEXT (program, location, v0, v1);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform2iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform2iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2iEXT (program, location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3iEXT (GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform3iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform3iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3iEXT (program, location, v0, v1, v2);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform3iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform3iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3iEXT (program, location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4iEXT (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform4iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform4iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4iEXT (program, location, v0, v1, v2, v3);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform4iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform4iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4iEXT (program, location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1fvEXT (GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform1fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform1fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1fvEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform1fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform1fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1fvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2fvEXT (GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform2fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform2fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2fvEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform2fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform2fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2fvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3fvEXT (GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform3fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3fvEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform3fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3fvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4fvEXT (GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4fvEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4fvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1ivEXT (GLuint program, GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform1ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform1ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ivEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform1ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform1ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1ivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2ivEXT (GLuint program, GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform2ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform2ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ivEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform2ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform2ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2ivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3ivEXT (GLuint program, GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform3ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform3ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ivEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform3ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform3ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3ivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4ivEXT (GLuint program, GLint location, GLsizei count, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform4ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform4ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ivEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform4ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform4ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4ivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2fvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix2fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix2fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2fvEXT (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix2fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix2fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3fvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix3fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3fvEXT (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix3fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4fvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4fvEXT (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2x3fvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix2x3fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix2x3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x3fvEXT (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix2x3fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix2x3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x3fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3x2fvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix3x2fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix3x2fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x2fvEXT (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix3x2fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix3x2fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x2fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2x4fvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix2x4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix2x4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x4fvEXT (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix2x4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix2x4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x4fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4x2fvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix4x2fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix4x2fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x2fvEXT (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix4x2fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix4x2fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x2fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3x4fvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix3x4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix3x4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x4fvEXT (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix3x4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix3x4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x4fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4x3fvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix4x3fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix4x3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x3fvEXT (program, location, count, transpose, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniformMatrix4x3fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniformMatrix4x3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x3fvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureBufferEXT (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureBufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureBufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureBufferEXT (texture, target, internalformat, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexBufferEXT (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexBufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexBufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexBufferEXT (texunit, target, internalformat, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameterIivEXT (GLuint texture, GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureParameterIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterIivEXT (texture, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureParameterIuivEXT (GLuint texture, GLenum target, GLenum pname, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureParameterIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureParameterIuivEXT (texture, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureParameterIivEXT (GLuint texture, GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetTextureParameterIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetTextureParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameterIivEXT (texture, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTextureParameterIuivEXT (GLuint texture, GLenum target, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetTextureParameterIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetTextureParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTextureParameterIuivEXT (texture, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexParameterIivEXT (GLenum texunit, GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexParameterIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexParameterIivEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexParameterIuivEXT (GLenum texunit, GLenum target, GLenum pname, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexParameterIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexParameterIuivEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexParameterIivEXT (GLenum texunit, GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexParameterIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexParameterIivEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultiTexParameterIuivEXT (GLenum texunit, GLenum target, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetMultiTexParameterIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetMultiTexParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultiTexParameterIuivEXT (texunit, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1uiEXT (GLuint program, GLint location, GLuint v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform1uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform1uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1uiEXT (program, location, v0);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform1uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform1uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1uiEXT (program, location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2uiEXT (GLuint program, GLint location, GLuint v0, GLuint v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform2uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform2uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2uiEXT (program, location, v0, v1);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform2uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform2uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2uiEXT (program, location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3uiEXT (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform3uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform3uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3uiEXT (program, location, v0, v1, v2);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform3uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform3uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3uiEXT (program, location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4uiEXT (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform4uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform4uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4uiEXT (program, location, v0, v1, v2, v3);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform4uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform4uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4uiEXT (program, location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1uivEXT (GLuint program, GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform1uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform1uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1uivEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform1uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform1uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1uivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2uivEXT (GLuint program, GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform2uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform2uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2uivEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform2uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform2uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2uivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3uivEXT (GLuint program, GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform3uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform3uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3uivEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform3uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform3uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3uivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4uivEXT (GLuint program, GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform4uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform4uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4uivEXT (program, location, count, value);
  }
  // GL_EXT_separate_shader_objects - glProgramUniform4uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramUniform4uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4uivEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramLocalParameters4fvEXT (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramLocalParameters4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramLocalParameters4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramLocalParameters4fvEXT (program, target, index, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramLocalParameterI4iEXT (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramLocalParameterI4iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramLocalParameterI4iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramLocalParameterI4iEXT (program, target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramLocalParameterI4ivEXT (GLuint program, GLenum target, GLuint index, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramLocalParameterI4ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramLocalParameterI4ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramLocalParameterI4ivEXT (program, target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramLocalParametersI4ivEXT (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramLocalParametersI4ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramLocalParametersI4ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramLocalParametersI4ivEXT (program, target, index, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramLocalParameterI4uiEXT (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramLocalParameterI4uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramLocalParameterI4uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramLocalParameterI4uiEXT (program, target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramLocalParameterI4uivEXT (GLuint program, GLenum target, GLuint index, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramLocalParameterI4uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramLocalParameterI4uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramLocalParameterI4uivEXT (program, target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramLocalParametersI4uivEXT (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramLocalParametersI4uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramLocalParametersI4uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramLocalParametersI4uivEXT (program, target, index, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedProgramLocalParameterIivEXT (GLuint program, GLenum target, GLuint index, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedProgramLocalParameterIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedProgramLocalParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedProgramLocalParameterIivEXT (program, target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedProgramLocalParameterIuivEXT (GLuint program, GLenum target, GLuint index, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedProgramLocalParameterIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedProgramLocalParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedProgramLocalParameterIuivEXT (program, target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableClientStateiEXT (GLenum array, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glEnableClientStateiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glEnableClientStateiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEnableClientStateiEXT (array, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableClientStateiEXT (GLenum array, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glDisableClientStateiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glDisableClientStateiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDisableClientStateiEXT (array, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFloati_vEXT (GLenum pname, GLuint index, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetFloati_vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetFloati_vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetFloati_vEXT (pname, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetDoublei_vEXT (GLenum pname, GLuint index, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetDoublei_vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetDoublei_vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetDoublei_vEXT (pname, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPointeri_vEXT (GLenum pname, GLuint index, void ** params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetPointeri_vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetPointeri_vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetPointeri_vEXT (pname, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramStringEXT (GLuint program, GLenum target, GLenum format, GLsizei len, const void * string)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramStringEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramStringEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramStringEXT (program, target, format, len, string);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramLocalParameter4dEXT (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramLocalParameter4dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramLocalParameter4dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramLocalParameter4dEXT (program, target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramLocalParameter4dvEXT (GLuint program, GLenum target, GLuint index, const GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramLocalParameter4dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramLocalParameter4dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramLocalParameter4dvEXT (program, target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramLocalParameter4fEXT (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramLocalParameter4fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramLocalParameter4fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramLocalParameter4fEXT (program, target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedProgramLocalParameter4fvEXT (GLuint program, GLenum target, GLuint index, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedProgramLocalParameter4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedProgramLocalParameter4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedProgramLocalParameter4fvEXT (program, target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedProgramLocalParameterdvEXT (GLuint program, GLenum target, GLuint index, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedProgramLocalParameterdvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedProgramLocalParameterdvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedProgramLocalParameterdvEXT (program, target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedProgramLocalParameterfvEXT (GLuint program, GLenum target, GLuint index, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedProgramLocalParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedProgramLocalParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedProgramLocalParameterfvEXT (program, target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedProgramivEXT (GLuint program, GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedProgramivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedProgramivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedProgramivEXT (program, target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedProgramStringEXT (GLuint program, GLenum target, GLenum pname, void * string)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedProgramStringEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedProgramStringEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedProgramStringEXT (program, target, pname, string);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedRenderbufferStorageEXT (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedRenderbufferStorageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedRenderbufferStorageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedRenderbufferStorageEXT (renderbuffer, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedRenderbufferParameterivEXT (GLuint renderbuffer, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedRenderbufferParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedRenderbufferParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedRenderbufferParameterivEXT (renderbuffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedRenderbufferStorageMultisampleEXT (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedRenderbufferStorageMultisampleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedRenderbufferStorageMultisampleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedRenderbufferStorageMultisampleEXT (renderbuffer, samples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedRenderbufferStorageMultisampleCoverageEXT (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedRenderbufferStorageMultisampleCoverageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedRenderbufferStorageMultisampleCoverageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedRenderbufferStorageMultisampleCoverageEXT (renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glCheckNamedFramebufferStatusEXT (GLuint framebuffer, GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glCheckNamedFramebufferStatusEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glCheckNamedFramebufferStatusEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glCheckNamedFramebufferStatusEXT (framebuffer, target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferTexture1DEXT (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedFramebufferTexture1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedFramebufferTexture1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferTexture1DEXT (framebuffer, attachment, textarget, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferTexture2DEXT (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedFramebufferTexture2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedFramebufferTexture2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferTexture2DEXT (framebuffer, attachment, textarget, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferTexture3DEXT (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedFramebufferTexture3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedFramebufferTexture3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferTexture3DEXT (framebuffer, attachment, textarget, texture, level, zoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferRenderbufferEXT (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedFramebufferRenderbufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedFramebufferRenderbufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferRenderbufferEXT (framebuffer, attachment, renderbuffertarget, renderbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedFramebufferAttachmentParameterivEXT (GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedFramebufferAttachmentParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedFramebufferAttachmentParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedFramebufferAttachmentParameterivEXT (framebuffer, attachment, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenerateTextureMipmapEXT (GLuint texture, GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGenerateTextureMipmapEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGenerateTextureMipmapEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenerateTextureMipmapEXT (texture, target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenerateMultiTexMipmapEXT (GLenum texunit, GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGenerateMultiTexMipmapEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGenerateMultiTexMipmapEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenerateMultiTexMipmapEXT (texunit, target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferDrawBufferEXT (GLuint framebuffer, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glFramebufferDrawBufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glFramebufferDrawBufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferDrawBufferEXT (framebuffer, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferDrawBuffersEXT (GLuint framebuffer, GLsizei n, const GLenum * bufs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glFramebufferDrawBuffersEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glFramebufferDrawBuffersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferDrawBuffersEXT (framebuffer, n, bufs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferReadBufferEXT (GLuint framebuffer, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glFramebufferReadBufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glFramebufferReadBufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferReadBufferEXT (framebuffer, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFramebufferParameterivEXT (GLuint framebuffer, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetFramebufferParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetFramebufferParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetFramebufferParameterivEXT (framebuffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedCopyBufferSubDataEXT (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedCopyBufferSubDataEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedCopyBufferSubDataEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedCopyBufferSubDataEXT (readBuffer, writeBuffer, readOffset, writeOffset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferTextureEXT (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedFramebufferTextureEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedFramebufferTextureEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferTextureEXT (framebuffer, attachment, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferTextureLayerEXT (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedFramebufferTextureLayerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedFramebufferTextureLayerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferTextureLayerEXT (framebuffer, attachment, texture, level, layer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferTextureFaceEXT (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedFramebufferTextureFaceEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedFramebufferTextureFaceEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferTextureFaceEXT (framebuffer, attachment, texture, level, face);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureRenderbufferEXT (GLuint texture, GLenum target, GLuint renderbuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureRenderbufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureRenderbufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureRenderbufferEXT (texture, target, renderbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexRenderbufferEXT (GLenum texunit, GLenum target, GLuint renderbuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMultiTexRenderbufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMultiTexRenderbufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexRenderbufferEXT (texunit, target, renderbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexOffsetEXT (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayVertexOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayVertexOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexOffsetEXT (vaobj, buffer, size, type, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayColorOffsetEXT (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayColorOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayColorOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayColorOffsetEXT (vaobj, buffer, size, type, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayEdgeFlagOffsetEXT (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayEdgeFlagOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayEdgeFlagOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayEdgeFlagOffsetEXT (vaobj, buffer, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayIndexOffsetEXT (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayIndexOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayIndexOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayIndexOffsetEXT (vaobj, buffer, type, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayNormalOffsetEXT (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayNormalOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayNormalOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayNormalOffsetEXT (vaobj, buffer, type, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayTexCoordOffsetEXT (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayTexCoordOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayTexCoordOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayTexCoordOffsetEXT (vaobj, buffer, size, type, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayMultiTexCoordOffsetEXT (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayMultiTexCoordOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayMultiTexCoordOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayMultiTexCoordOffsetEXT (vaobj, buffer, texunit, size, type, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayFogCoordOffsetEXT (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayFogCoordOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayFogCoordOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayFogCoordOffsetEXT (vaobj, buffer, type, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArraySecondaryColorOffsetEXT (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArraySecondaryColorOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArraySecondaryColorOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArraySecondaryColorOffsetEXT (vaobj, buffer, size, type, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexAttribOffsetEXT (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayVertexAttribOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayVertexAttribOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexAttribOffsetEXT (vaobj, buffer, index, size, type, normalized, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexAttribIOffsetEXT (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayVertexAttribIOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayVertexAttribIOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexAttribIOffsetEXT (vaobj, buffer, index, size, type, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableVertexArrayEXT (GLuint vaobj, GLenum array)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glEnableVertexArrayEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glEnableVertexArrayEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEnableVertexArrayEXT (vaobj, array);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableVertexArrayEXT (GLuint vaobj, GLenum array)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glDisableVertexArrayEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glDisableVertexArrayEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDisableVertexArrayEXT (vaobj, array);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableVertexArrayAttribEXT (GLuint vaobj, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glEnableVertexArrayAttribEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glEnableVertexArrayAttribEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEnableVertexArrayAttribEXT (vaobj, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableVertexArrayAttribEXT (GLuint vaobj, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glDisableVertexArrayAttribEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glDisableVertexArrayAttribEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDisableVertexArrayAttribEXT (vaobj, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexArrayIntegervEXT (GLuint vaobj, GLenum pname, GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetVertexArrayIntegervEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetVertexArrayIntegervEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexArrayIntegervEXT (vaobj, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexArrayPointervEXT (GLuint vaobj, GLenum pname, void ** param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetVertexArrayPointervEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetVertexArrayPointervEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexArrayPointervEXT (vaobj, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexArrayIntegeri_vEXT (GLuint vaobj, GLuint index, GLenum pname, GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetVertexArrayIntegeri_vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetVertexArrayIntegeri_vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexArrayIntegeri_vEXT (vaobj, index, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexArrayPointeri_vEXT (GLuint vaobj, GLuint index, GLenum pname, void ** param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetVertexArrayPointeri_vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetVertexArrayPointeri_vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexArrayPointeri_vEXT (vaobj, index, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void * _glew_gl_glMapNamedBufferRangeEXT (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  void * result = ((void *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glMapNamedBufferRangeEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glMapNamedBufferRangeEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapNamedBufferRangeEXT (buffer, offset, length, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFlushMappedNamedBufferRangeEXT (GLuint buffer, GLintptr offset, GLsizeiptr length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glFlushMappedNamedBufferRangeEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glFlushMappedNamedBufferRangeEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFlushMappedNamedBufferRangeEXT (buffer, offset, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferStorageEXT (GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedBufferStorageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedBufferStorageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferStorageEXT (buffer, size, data, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearNamedBufferDataEXT (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glClearNamedBufferDataEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glClearNamedBufferDataEXT)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedBufferDataEXT (buffer, internalformat, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearNamedBufferSubDataEXT (GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glClearNamedBufferSubDataEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glClearNamedBufferSubDataEXT)
  {
    prototypeCalled = true;
    glConfig.m_glClearNamedBufferSubDataEXT (buffer, internalformat, offset, size, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferParameteriEXT (GLuint framebuffer, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glNamedFramebufferParameteriEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glNamedFramebufferParameteriEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferParameteriEXT (framebuffer, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedFramebufferParameterivEXT (GLuint framebuffer, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glGetNamedFramebufferParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glGetNamedFramebufferParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedFramebufferParameterivEXT (framebuffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1dEXT (GLuint program, GLint location, GLdouble x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform1dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform1dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1dEXT (program, location, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2dEXT (GLuint program, GLint location, GLdouble x, GLdouble y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform2dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform2dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2dEXT (program, location, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3dEXT (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform3dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform3dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3dEXT (program, location, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4dEXT (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform4dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform4dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4dEXT (program, location, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform1dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform1dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform1dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform1dvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform2dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform2dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform2dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform2dvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform3dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform3dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform3dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform3dvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniform4dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniform4dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniform4dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniform4dvEXT (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix2dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix2dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2dvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix3dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix3dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3dvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix4dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix4dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4dvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2x3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix2x3dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix2x3dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x3dvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix2x4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix2x4dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix2x4dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix2x4dvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3x2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix3x2dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix3x2dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x2dvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix3x4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix3x4dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix3x4dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix3x4dvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4x2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix4x2dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix4x2dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x2dvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformMatrix4x3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glProgramUniformMatrix4x3dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glProgramUniformMatrix4x3dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformMatrix4x3dvEXT (program, location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureBufferRangeEXT (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureBufferRangeEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureBufferRangeEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureBufferRangeEXT (texture, target, internalformat, buffer, offset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorage1DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureStorage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureStorage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage1DEXT (texture, target, levels, internalformat, width);
  }
  // GL_EXT_texture_storage - glTextureStorage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_storage] && glConfig.m_glTextureStorage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage1DEXT (texture, target, levels, internalformat, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorage2DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureStorage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureStorage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage2DEXT (texture, target, levels, internalformat, width, height);
  }
  // GL_EXT_texture_storage - glTextureStorage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_storage] && glConfig.m_glTextureStorage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage2DEXT (texture, target, levels, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorage3DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureStorage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureStorage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage3DEXT (texture, target, levels, internalformat, width, height, depth);
  }
  // GL_EXT_texture_storage - glTextureStorage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_storage] && glConfig.m_glTextureStorage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage3DEXT (texture, target, levels, internalformat, width, height, depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorage2DMultisampleEXT (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureStorage2DMultisampleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureStorage2DMultisampleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage2DMultisampleEXT (texture, target, samples, internalformat, width, height, fixedsamplelocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorage3DMultisampleEXT (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTextureStorage3DMultisampleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTextureStorage3DMultisampleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorage3DMultisampleEXT (texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayBindVertexBufferEXT (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayBindVertexBufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayBindVertexBufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayBindVertexBufferEXT (vaobj, bindingindex, buffer, offset, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexAttribFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayVertexAttribFormatEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayVertexAttribFormatEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexAttribFormatEXT (vaobj, attribindex, size, type, normalized, relativeoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexAttribIFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayVertexAttribIFormatEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayVertexAttribIFormatEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexAttribIFormatEXT (vaobj, attribindex, size, type, relativeoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexAttribLFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayVertexAttribLFormatEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayVertexAttribLFormatEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexAttribLFormatEXT (vaobj, attribindex, size, type, relativeoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexAttribBindingEXT (GLuint vaobj, GLuint attribindex, GLuint bindingindex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayVertexAttribBindingEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayVertexAttribBindingEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexAttribBindingEXT (vaobj, attribindex, bindingindex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexBindingDivisorEXT (GLuint vaobj, GLuint bindingindex, GLuint divisor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayVertexBindingDivisorEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayVertexBindingDivisorEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexBindingDivisorEXT (vaobj, bindingindex, divisor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexAttribLOffsetEXT (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayVertexAttribLOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayVertexAttribLOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexAttribLOffsetEXT (vaobj, buffer, index, size, type, stride, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexturePageCommitmentEXT (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glTexturePageCommitmentEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glTexturePageCommitmentEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexturePageCommitmentEXT (texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayVertexAttribDivisorEXT (GLuint vaobj, GLuint index, GLuint divisor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_direct_state_access - glVertexArrayVertexAttribDivisorEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] && glConfig.m_glVertexArrayVertexAttribDivisorEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayVertexAttribDivisorEXT (vaobj, index, divisor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDiscardFramebufferEXT (GLenum target, GLsizei numAttachments, const GLenum * attachments)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_discard_framebuffer - glDiscardFramebufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_discard_framebuffer] && glConfig.m_glDiscardFramebufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDiscardFramebufferEXT (target, numAttachments, attachments);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenQueriesEXT (GLsizei n, GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glGenQueriesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glGenQueriesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenQueriesEXT (n, ids);
  }
  // GL_EXT_occlusion_query_boolean - glGenQueriesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_occlusion_query_boolean] && glConfig.m_glGenQueriesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenQueriesEXT (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteQueriesEXT (GLsizei n, const GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glDeleteQueriesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glDeleteQueriesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteQueriesEXT (n, ids);
  }
  // GL_EXT_occlusion_query_boolean - glDeleteQueriesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_occlusion_query_boolean] && glConfig.m_glDeleteQueriesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteQueriesEXT (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsQueryEXT (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glIsQueryEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glIsQueryEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsQueryEXT (id);
  }
  // GL_EXT_occlusion_query_boolean - glIsQueryEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_occlusion_query_boolean] && glConfig.m_glIsQueryEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsQueryEXT (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginQueryEXT (GLenum target, GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glBeginQueryEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glBeginQueryEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBeginQueryEXT (target, id);
  }
  // GL_EXT_occlusion_query_boolean - glBeginQueryEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_occlusion_query_boolean] && glConfig.m_glBeginQueryEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBeginQueryEXT (target, id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndQueryEXT (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glEndQueryEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glEndQueryEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEndQueryEXT (target);
  }
  // GL_EXT_occlusion_query_boolean - glEndQueryEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_occlusion_query_boolean] && glConfig.m_glEndQueryEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEndQueryEXT (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glQueryCounterEXT (GLuint id, GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glQueryCounterEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glQueryCounterEXT)
  {
    prototypeCalled = true;
    glConfig.m_glQueryCounterEXT (id, target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryivEXT (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glGetQueryivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glGetQueryivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryivEXT (target, pname, params);
  }
  // GL_EXT_occlusion_query_boolean - glGetQueryivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_occlusion_query_boolean] && glConfig.m_glGetQueryivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryObjectivEXT (GLuint id, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glGetQueryObjectivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glGetQueryObjectivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectivEXT (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryObjectuivEXT (GLuint id, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glGetQueryObjectuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glGetQueryObjectuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectuivEXT (id, pname, params);
  }
  // GL_EXT_occlusion_query_boolean - glGetQueryObjectuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_occlusion_query_boolean] && glConfig.m_glGetQueryObjectuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectuivEXT (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryObjecti64vEXT (GLuint id, GLenum pname, GLint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glGetQueryObjecti64vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glGetQueryObjecti64vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjecti64vEXT (id, pname, params);
  }
  // GL_EXT_timer_query - glGetQueryObjecti64vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_timer_query] && glConfig.m_glGetQueryObjecti64vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjecti64vEXT (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetQueryObjectui64vEXT (GLuint id, GLenum pname, GLuint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glGetQueryObjectui64vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glGetQueryObjectui64vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectui64vEXT (id, pname, params);
  }
  // GL_EXT_timer_query - glGetQueryObjectui64vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_timer_query] && glConfig.m_glGetQueryObjectui64vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetQueryObjectui64vEXT (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetInteger64vEXT (GLenum pname, GLint64 * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_disjoint_timer_query - glGetInteger64vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] && glConfig.m_glGetInteger64vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetInteger64vEXT (pname, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawBuffersEXT (GLsizei n, const GLenum * bufs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_buffers - glDrawBuffersEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers] && glConfig.m_glDrawBuffersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawBuffersEXT (n, bufs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorMaskIndexedEXT (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_buffers2 - glColorMaskIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers2] && glConfig.m_glColorMaskIndexedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glColorMaskIndexedEXT (index, r, g, b, a);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableiEXT (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_buffers_indexed - glEnableiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glEnableiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEnableiEXT (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableiEXT (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_buffers_indexed - glDisableiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glDisableiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDisableiEXT (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationiEXT (GLuint buf, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_buffers_indexed - glBlendEquationiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glBlendEquationiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationiEXT (buf, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationSeparateiEXT (GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_buffers_indexed - glBlendEquationSeparateiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glBlendEquationSeparateiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparateiEXT (buf, modeRGB, modeAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFunciEXT (GLuint buf, GLenum src, GLenum dst)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_buffers_indexed - glBlendFunciEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glBlendFunciEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFunciEXT (buf, src, dst);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFuncSeparateiEXT (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_buffers_indexed - glBlendFuncSeparateiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glBlendFuncSeparateiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparateiEXT (buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorMaskiEXT (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_buffers_indexed - glColorMaskiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glColorMaskiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glColorMaskiEXT (index, r, g, b, a);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsEnablediEXT (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_buffers_indexed - glIsEnablediEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] && glConfig.m_glIsEnablediEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsEnablediEXT (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsBaseVertexEXT (GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_elements_base_vertex - glDrawElementsBaseVertexEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_elements_base_vertex] && glConfig.m_glDrawElementsBaseVertexEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsBaseVertexEXT (mode, count, type, indices, basevertex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawRangeElementsBaseVertexEXT (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_elements_base_vertex - glDrawRangeElementsBaseVertexEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_elements_base_vertex] && glConfig.m_glDrawRangeElementsBaseVertexEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawRangeElementsBaseVertexEXT (mode, start, end, count, type, indices, basevertex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstancedBaseVertexEXT (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_elements_base_vertex - glDrawElementsInstancedBaseVertexEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_elements_base_vertex] && glConfig.m_glDrawElementsInstancedBaseVertexEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedBaseVertexEXT (mode, count, type, indices, instancecount, basevertex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElementsBaseVertexEXT (GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_elements_base_vertex - glMultiDrawElementsBaseVertexEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_elements_base_vertex] && glConfig.m_glMultiDrawElementsBaseVertexEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsBaseVertexEXT (mode, count, type, indices, drawcount, basevertex);
  }
  // GL_OES_draw_elements_base_vertex - glMultiDrawElementsBaseVertexEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_elements_base_vertex] && glConfig.m_glMultiDrawElementsBaseVertexEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsBaseVertexEXT (mode, count, type, indices, drawcount, basevertex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawArraysInstancedEXT (GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_instanced - glDrawArraysInstancedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_instanced] && glConfig.m_glDrawArraysInstancedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstancedEXT (mode, start, count, primcount);
  }
  // GL_EXT_instanced_arrays - glDrawArraysInstancedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_instanced_arrays] && glConfig.m_glDrawArraysInstancedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstancedEXT (mode, start, count, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstancedEXT (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_instanced - glDrawElementsInstancedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_instanced] && glConfig.m_glDrawElementsInstancedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedEXT (mode, count, type, indices, primcount);
  }
  // GL_EXT_instanced_arrays - glDrawElementsInstancedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_instanced_arrays] && glConfig.m_glDrawElementsInstancedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedEXT (mode, count, type, indices, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawRangeElementsEXT (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_range_elements - glDrawRangeElementsEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_range_elements] && glConfig.m_glDrawRangeElementsEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawRangeElementsEXT (mode, start, end, count, type, indices);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawTransformFeedbackEXT (GLenum mode, GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_transform_feedback - glDrawTransformFeedbackEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_transform_feedback] && glConfig.m_glDrawTransformFeedbackEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedbackEXT (mode, id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawTransformFeedbackInstancedEXT (GLenum mode, GLuint id, GLsizei instancecount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_draw_transform_feedback - glDrawTransformFeedbackInstancedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_draw_transform_feedback] && glConfig.m_glDrawTransformFeedbackInstancedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedbackInstancedEXT (mode, id, instancecount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferStorageExternalEXT (GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_external_buffer - glBufferStorageExternalEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_external_buffer] && glConfig.m_glBufferStorageExternalEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBufferStorageExternalEXT (target, offset, size, clientBuffer, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferStorageExternalEXT (GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_external_buffer - glNamedBufferStorageExternalEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_external_buffer] && glConfig.m_glNamedBufferStorageExternalEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferStorageExternalEXT (buffer, offset, size, clientBuffer, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoordfEXT (GLfloat coord)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_fog_coord - glFogCoordfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fog_coord] && glConfig.m_glFogCoordfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordfEXT (coord);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoordfvEXT (const GLfloat * coord)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_fog_coord - glFogCoordfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fog_coord] && glConfig.m_glFogCoordfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordfvEXT (coord);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoorddEXT (GLdouble coord)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_fog_coord - glFogCoorddEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fog_coord] && glConfig.m_glFogCoorddEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoorddEXT (coord);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoorddvEXT (const GLdouble * coord)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_fog_coord - glFogCoorddvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fog_coord] && glConfig.m_glFogCoorddvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoorddvEXT (coord);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoordPointerEXT (GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_fog_coord - glFogCoordPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fog_coord] && glConfig.m_glFogCoordPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordPointerEXT (type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFragmentShadingRatesEXT (GLsizei samples, GLsizei maxCount, GLsizei * count, GLenum * shadingRates)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_fragment_shading_rate - glGetFragmentShadingRatesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fragment_shading_rate] && glConfig.m_glGetFragmentShadingRatesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetFragmentShadingRatesEXT (samples, maxCount, count, shadingRates);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShadingRateEXT (GLenum rate)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_fragment_shading_rate - glShadingRateEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fragment_shading_rate] && glConfig.m_glShadingRateEXT)
  {
    prototypeCalled = true;
    glConfig.m_glShadingRateEXT (rate);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShadingRateCombinerOpsEXT (GLenum combinerOp0, GLenum combinerOp1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_fragment_shading_rate - glShadingRateCombinerOpsEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fragment_shading_rate] && glConfig.m_glShadingRateCombinerOpsEXT)
  {
    prototypeCalled = true;
    glConfig.m_glShadingRateCombinerOpsEXT (combinerOp0, combinerOp1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferShadingRateEXT (GLenum target, GLenum attachment, GLuint texture, GLint baseLayer, GLsizei numLayers, GLsizei texelWidth, GLsizei texelHeight)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_fragment_shading_rate - glFramebufferShadingRateEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_fragment_shading_rate] && glConfig.m_glFramebufferShadingRateEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferShadingRateEXT (target, attachment, texture, baseLayer, numLayers, texelWidth, texelHeight);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlitFramebufferEXT (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_blit - glBlitFramebufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_blit] && glConfig.m_glBlitFramebufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlitFramebufferEXT (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlitFramebufferLayersEXT (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_blit_layers - glBlitFramebufferLayersEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_blit_layers] && glConfig.m_glBlitFramebufferLayersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlitFramebufferLayersEXT (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlitFramebufferLayerEXT (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint srcLayer, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLint dstLayer, GLbitfield mask, GLenum filter)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_blit_layers - glBlitFramebufferLayerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_blit_layers] && glConfig.m_glBlitFramebufferLayerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBlitFramebufferLayerEXT (srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, filter);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRenderbufferStorageMultisampleEXT (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_multisample - glRenderbufferStorageMultisampleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_multisample] && glConfig.m_glRenderbufferStorageMultisampleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisampleEXT (target, samples, internalformat, width, height);
  }
  // GL_EXT_multisampled_render_to_texture - glRenderbufferStorageMultisampleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_multisampled_render_to_texture] && glConfig.m_glRenderbufferStorageMultisampleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisampleEXT (target, samples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsRenderbufferEXT (GLuint renderbuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glIsRenderbufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glIsRenderbufferEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsRenderbufferEXT (renderbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindRenderbufferEXT (GLenum target, GLuint renderbuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glBindRenderbufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glBindRenderbufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindRenderbufferEXT (target, renderbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteRenderbuffersEXT (GLsizei n, const GLuint * renderbuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glDeleteRenderbuffersEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glDeleteRenderbuffersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteRenderbuffersEXT (n, renderbuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenRenderbuffersEXT (GLsizei n, GLuint * renderbuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glGenRenderbuffersEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glGenRenderbuffersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenRenderbuffersEXT (n, renderbuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRenderbufferStorageEXT (GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glRenderbufferStorageEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glRenderbufferStorageEXT)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageEXT (target, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetRenderbufferParameterivEXT (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glGetRenderbufferParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glGetRenderbufferParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetRenderbufferParameterivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsFramebufferEXT (GLuint framebuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glIsFramebufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glIsFramebufferEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsFramebufferEXT (framebuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindFramebufferEXT (GLenum target, GLuint framebuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glBindFramebufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glBindFramebufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindFramebufferEXT (target, framebuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteFramebuffersEXT (GLsizei n, const GLuint * framebuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glDeleteFramebuffersEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glDeleteFramebuffersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteFramebuffersEXT (n, framebuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenFramebuffersEXT (GLsizei n, GLuint * framebuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glGenFramebuffersEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glGenFramebuffersEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenFramebuffersEXT (n, framebuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glCheckFramebufferStatusEXT (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glCheckFramebufferStatusEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glCheckFramebufferStatusEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glCheckFramebufferStatusEXT (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTexture1DEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glFramebufferTexture1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glFramebufferTexture1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture1DEXT (target, attachment, textarget, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTexture2DEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glFramebufferTexture2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glFramebufferTexture2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture2DEXT (target, attachment, textarget, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTexture3DEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glFramebufferTexture3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glFramebufferTexture3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture3DEXT (target, attachment, textarget, texture, level, zoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferRenderbufferEXT (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glFramebufferRenderbufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glFramebufferRenderbufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferRenderbufferEXT (target, attachment, renderbuffertarget, renderbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFramebufferAttachmentParameterivEXT (GLenum target, GLenum attachment, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glGetFramebufferAttachmentParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glGetFramebufferAttachmentParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetFramebufferAttachmentParameterivEXT (target, attachment, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenerateMipmapEXT (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_framebuffer_object - glGenerateMipmapEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] && glConfig.m_glGenerateMipmapEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenerateMipmapEXT (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTextureEXT (GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_geometry_shader - glFramebufferTextureEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_geometry_shader] && glConfig.m_glFramebufferTextureEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureEXT (target, attachment, texture, level);
  }
  // GL_NV_geometry_program4 - glFramebufferTextureEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_geometry_program4] && glConfig.m_glFramebufferTextureEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureEXT (target, attachment, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramParameteriEXT (GLuint program, GLenum pname, GLint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_geometry_shader4 - glProgramParameteriEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_geometry_shader4] && glConfig.m_glProgramParameteriEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameteriEXT (program, pname, value);
  }
  // GL_EXT_separate_shader_objects - glProgramParameteriEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glProgramParameteriEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameteriEXT (program, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramEnvParameters4fvEXT (GLenum target, GLuint index, GLsizei count, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_program_parameters - glProgramEnvParameters4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_program_parameters] && glConfig.m_glProgramEnvParameters4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameters4fvEXT (target, index, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramLocalParameters4fvEXT (GLenum target, GLuint index, GLsizei count, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_program_parameters - glProgramLocalParameters4fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_program_parameters] && glConfig.m_glProgramLocalParameters4fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameters4fvEXT (target, index, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUniformuivEXT (GLuint program, GLint location, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glGetUniformuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glGetUniformuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetUniformuivEXT (program, location, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetFragDataLocationEXT (GLuint program, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glGetFragDataLocationEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glGetFragDataLocationEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetFragDataLocationEXT (program, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1uiEXT (GLint location, GLuint v0)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glUniform1uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform1uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1uiEXT (location, v0);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2uiEXT (GLint location, GLuint v0, GLuint v1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glUniform2uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform2uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2uiEXT (location, v0, v1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3uiEXT (GLint location, GLuint v0, GLuint v1, GLuint v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glUniform3uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform3uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3uiEXT (location, v0, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4uiEXT (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glUniform4uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform4uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4uiEXT (location, v0, v1, v2, v3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform1uivEXT (GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glUniform1uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform1uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform1uivEXT (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform2uivEXT (GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glUniform2uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform2uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform2uivEXT (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform3uivEXT (GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glUniform3uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform3uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform3uivEXT (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniform4uivEXT (GLint location, GLsizei count, const GLuint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glUniform4uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glUniform4uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUniform4uivEXT (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI1iEXT (GLuint index, GLint x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI1iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI1iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1iEXT (index, x);
  }
  // GL_NV_vertex_program4 - glVertexAttribI1iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI1iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1iEXT (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI2iEXT (GLuint index, GLint x, GLint y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI2iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI2iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2iEXT (index, x, y);
  }
  // GL_NV_vertex_program4 - glVertexAttribI2iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI2iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2iEXT (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI3iEXT (GLuint index, GLint x, GLint y, GLint z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI3iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI3iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3iEXT (index, x, y, z);
  }
  // GL_NV_vertex_program4 - glVertexAttribI3iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI3iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3iEXT (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4iEXT (GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI4iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4iEXT (index, x, y, z, w);
  }
  // GL_NV_vertex_program4 - glVertexAttribI4iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI4iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4iEXT (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI1uiEXT (GLuint index, GLuint x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI1uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI1uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1uiEXT (index, x);
  }
  // GL_NV_vertex_program4 - glVertexAttribI1uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI1uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1uiEXT (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI2uiEXT (GLuint index, GLuint x, GLuint y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI2uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI2uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2uiEXT (index, x, y);
  }
  // GL_NV_vertex_program4 - glVertexAttribI2uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI2uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2uiEXT (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI3uiEXT (GLuint index, GLuint x, GLuint y, GLuint z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI3uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI3uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3uiEXT (index, x, y, z);
  }
  // GL_NV_vertex_program4 - glVertexAttribI3uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI3uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3uiEXT (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4uiEXT (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI4uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4uiEXT (index, x, y, z, w);
  }
  // GL_NV_vertex_program4 - glVertexAttribI4uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI4uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4uiEXT (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI1ivEXT (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI1ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI1ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1ivEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI1ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI1ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1ivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI2ivEXT (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI2ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI2ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2ivEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI2ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI2ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2ivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI3ivEXT (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI3ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI3ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3ivEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI3ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI3ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3ivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4ivEXT (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI4ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4ivEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI4ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI4ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4ivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI1uivEXT (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI1uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI1uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1uivEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI1uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI1uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI1uivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI2uivEXT (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI2uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI2uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2uivEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI2uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI2uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI2uivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI3uivEXT (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI3uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI3uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3uivEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI3uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI3uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI3uivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4uivEXT (GLuint index, const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI4uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4uivEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI4uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI4uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4uivEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4bvEXT (GLuint index, const GLbyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI4bvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4bvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4bvEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI4bvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI4bvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4bvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4svEXT (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI4svEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4svEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4svEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI4svEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI4svEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4svEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4ubvEXT (GLuint index, const GLubyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI4ubvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4ubvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4ubvEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI4ubvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI4ubvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4ubvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribI4usvEXT (GLuint index, const GLushort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribI4usvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribI4usvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4usvEXT (index, v);
  }
  // GL_NV_vertex_program4 - glVertexAttribI4usvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribI4usvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribI4usvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribIPointerEXT (GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glVertexAttribIPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glVertexAttribIPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribIPointerEXT (index, size, type, stride, pointer);
  }
  // GL_NV_vertex_program4 - glVertexAttribIPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glVertexAttribIPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribIPointerEXT (index, size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribIivEXT (GLuint index, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glGetVertexAttribIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glGetVertexAttribIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribIivEXT (index, pname, params);
  }
  // GL_NV_vertex_program4 - glGetVertexAttribIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glGetVertexAttribIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribIivEXT (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribIuivEXT (GLuint index, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_gpu_shader4 - glGetVertexAttribIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] && glConfig.m_glGetVertexAttribIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribIuivEXT (index, pname, params);
  }
  // GL_NV_vertex_program4 - glGetVertexAttribIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] && glConfig.m_glGetVertexAttribIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribIuivEXT (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetHistogramEXT (GLenum target, GLboolean reset, GLenum format, GLenum type, void * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_histogram - glGetHistogramEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glGetHistogramEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetHistogramEXT (target, reset, format, type, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetHistogramParameterfvEXT (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_histogram - glGetHistogramParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glGetHistogramParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetHistogramParameterfvEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetHistogramParameterivEXT (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_histogram - glGetHistogramParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glGetHistogramParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetHistogramParameterivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMinmaxEXT (GLenum target, GLboolean reset, GLenum format, GLenum type, void * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_histogram - glGetMinmaxEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glGetMinmaxEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMinmaxEXT (target, reset, format, type, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMinmaxParameterfvEXT (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_histogram - glGetMinmaxParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glGetMinmaxParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMinmaxParameterfvEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMinmaxParameterivEXT (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_histogram - glGetMinmaxParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glGetMinmaxParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMinmaxParameterivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glHistogramEXT (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_histogram - glHistogramEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glHistogramEXT)
  {
    prototypeCalled = true;
    glConfig.m_glHistogramEXT (target, width, internalformat, sink);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMinmaxEXT (GLenum target, GLenum internalformat, GLboolean sink)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_histogram - glMinmaxEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glMinmaxEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMinmaxEXT (target, internalformat, sink);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glResetHistogramEXT (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_histogram - glResetHistogramEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glResetHistogramEXT)
  {
    prototypeCalled = true;
    glConfig.m_glResetHistogramEXT (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glResetMinmaxEXT (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_histogram - glResetMinmaxEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_histogram] && glConfig.m_glResetMinmaxEXT)
  {
    prototypeCalled = true;
    glConfig.m_glResetMinmaxEXT (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glIndexFuncEXT (GLenum func, GLclampf ref)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_index_func - glIndexFuncEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_index_func] && glConfig.m_glIndexFuncEXT)
  {
    prototypeCalled = true;
    glConfig.m_glIndexFuncEXT (func, ref);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glIndexMaterialEXT (GLenum face, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_index_material - glIndexMaterialEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_index_material] && glConfig.m_glIndexMaterialEXT)
  {
    prototypeCalled = true;
    glConfig.m_glIndexMaterialEXT (face, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribDivisorEXT (GLuint index, GLuint divisor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_instanced_arrays - glVertexAttribDivisorEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_instanced_arrays] && glConfig.m_glVertexAttribDivisorEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribDivisorEXT (index, divisor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glApplyTextureEXT (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_light_texture - glApplyTextureEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_light_texture] && glConfig.m_glApplyTextureEXT)
  {
    prototypeCalled = true;
    glConfig.m_glApplyTextureEXT (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureLightEXT (GLenum pname)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_light_texture - glTextureLightEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_light_texture] && glConfig.m_glTextureLightEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureLightEXT (pname);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureMaterialEXT (GLenum face, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_light_texture - glTextureMaterialEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_light_texture] && glConfig.m_glTextureMaterialEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureMaterialEXT (face, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void * _glew_gl_glMapBufferRangeEXT (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  void * result = ((void *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_map_buffer_range - glMapBufferRangeEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_map_buffer_range] && glConfig.m_glMapBufferRangeEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapBufferRangeEXT (target, offset, length, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFlushMappedBufferRangeEXT (GLenum target, GLintptr offset, GLsizeiptr length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_map_buffer_range - glFlushMappedBufferRangeEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_map_buffer_range] && glConfig.m_glFlushMappedBufferRangeEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFlushMappedBufferRangeEXT (target, offset, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUnsignedBytevEXT (GLenum pname, GLubyte * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glGetUnsignedBytevEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glGetUnsignedBytevEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetUnsignedBytevEXT (pname, data);
  }
  // GL_EXT_semaphore - glGetUnsignedBytevEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore] && glConfig.m_glGetUnsignedBytevEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetUnsignedBytevEXT (pname, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetUnsignedBytei_vEXT (GLenum target, GLuint index, GLubyte * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glGetUnsignedBytei_vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glGetUnsignedBytei_vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetUnsignedBytei_vEXT (target, index, data);
  }
  // GL_EXT_semaphore - glGetUnsignedBytei_vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore] && glConfig.m_glGetUnsignedBytei_vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetUnsignedBytei_vEXT (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteMemoryObjectsEXT (GLsizei n, const GLuint * memoryObjects)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glDeleteMemoryObjectsEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glDeleteMemoryObjectsEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteMemoryObjectsEXT (n, memoryObjects);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsMemoryObjectEXT (GLuint memoryObject)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glIsMemoryObjectEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glIsMemoryObjectEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsMemoryObjectEXT (memoryObject);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateMemoryObjectsEXT (GLsizei n, GLuint * memoryObjects)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glCreateMemoryObjectsEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glCreateMemoryObjectsEXT)
  {
    prototypeCalled = true;
    glConfig.m_glCreateMemoryObjectsEXT (n, memoryObjects);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMemoryObjectParameterivEXT (GLuint memoryObject, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glMemoryObjectParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glMemoryObjectParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMemoryObjectParameterivEXT (memoryObject, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMemoryObjectParameterivEXT (GLuint memoryObject, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glGetMemoryObjectParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glGetMemoryObjectParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetMemoryObjectParameterivEXT (memoryObject, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorageMem2DEXT (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glTexStorageMem2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glTexStorageMem2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorageMem2DEXT (target, levels, internalFormat, width, height, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorageMem2DMultisampleEXT (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glTexStorageMem2DMultisampleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glTexStorageMem2DMultisampleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorageMem2DMultisampleEXT (target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorageMem3DEXT (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glTexStorageMem3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glTexStorageMem3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorageMem3DEXT (target, levels, internalFormat, width, height, depth, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorageMem3DMultisampleEXT (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glTexStorageMem3DMultisampleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glTexStorageMem3DMultisampleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorageMem3DMultisampleEXT (target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferStorageMemEXT (GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glBufferStorageMemEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glBufferStorageMemEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBufferStorageMemEXT (target, size, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorageMem2DEXT (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glTextureStorageMem2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glTextureStorageMem2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorageMem2DEXT (texture, levels, internalFormat, width, height, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorageMem2DMultisampleEXT (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glTextureStorageMem2DMultisampleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glTextureStorageMem2DMultisampleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorageMem2DMultisampleEXT (texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorageMem3DEXT (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glTextureStorageMem3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glTextureStorageMem3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorageMem3DEXT (texture, levels, internalFormat, width, height, depth, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorageMem3DMultisampleEXT (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glTextureStorageMem3DMultisampleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glTextureStorageMem3DMultisampleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorageMem3DMultisampleEXT (texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferStorageMemEXT (GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glNamedBufferStorageMemEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glNamedBufferStorageMemEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferStorageMemEXT (buffer, size, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorageMem1DEXT (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glTexStorageMem1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glTexStorageMem1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorageMem1DEXT (target, levels, internalFormat, width, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureStorageMem1DEXT (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object - glTextureStorageMem1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object] && glConfig.m_glTextureStorageMem1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureStorageMem1DEXT (texture, levels, internalFormat, width, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glImportMemoryFdEXT (GLuint memory, GLuint64 size, GLenum handleType, GLint fd)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object_fd - glImportMemoryFdEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object_fd] && glConfig.m_glImportMemoryFdEXT)
  {
    prototypeCalled = true;
    glConfig.m_glImportMemoryFdEXT (memory, size, handleType, fd);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glImportMemoryWin32HandleEXT (GLuint memory, GLuint64 size, GLenum handleType, void * handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object_win32 - glImportMemoryWin32HandleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object_win32] && glConfig.m_glImportMemoryWin32HandleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glImportMemoryWin32HandleEXT (memory, size, handleType, handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glImportMemoryWin32NameEXT (GLuint memory, GLuint64 size, GLenum handleType, const void * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_memory_object_win32 - glImportMemoryWin32NameEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_memory_object_win32] && glConfig.m_glImportMemoryWin32NameEXT)
  {
    prototypeCalled = true;
    glConfig.m_glImportMemoryWin32NameEXT (memory, size, handleType, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawArraysEXT (GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_multi_draw_arrays - glMultiDrawArraysEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_multi_draw_arrays] && glConfig.m_glMultiDrawArraysEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawArraysEXT (mode, first, count, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElementsEXT (GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_multi_draw_arrays - glMultiDrawElementsEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_multi_draw_arrays] && glConfig.m_glMultiDrawElementsEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsEXT (mode, count, type, indices, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawArraysIndirectEXT (GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_multi_draw_indirect - glMultiDrawArraysIndirectEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_multi_draw_indirect] && glConfig.m_glMultiDrawArraysIndirectEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawArraysIndirectEXT (mode, indirect, drawcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElementsIndirectEXT (GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_multi_draw_indirect - glMultiDrawElementsIndirectEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_multi_draw_indirect] && glConfig.m_glMultiDrawElementsIndirectEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsIndirectEXT (mode, type, indirect, drawcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSampleMaskEXT (GLclampf value, GLboolean invert)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_multisample - glSampleMaskEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_multisample] && glConfig.m_glSampleMaskEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSampleMaskEXT (value, invert);
  }
  // GL_SGIS_multisample - glSampleMaskEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_multisample] && glConfig.m_glSampleMaskSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glSampleMaskSGIS (value, invert);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplePatternEXT (GLenum pattern)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_multisample - glSamplePatternEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_multisample] && glConfig.m_glSamplePatternEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSamplePatternEXT (pattern);
  }
  // GL_SGIS_multisample - glSamplePatternEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_multisample] && glConfig.m_glSamplePatternSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glSamplePatternSGIS (pattern);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTexture2DMultisampleEXT (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_multisampled_render_to_texture - glFramebufferTexture2DMultisampleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_multisampled_render_to_texture] && glConfig.m_glFramebufferTexture2DMultisampleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture2DMultisampleEXT (target, attachment, textarget, texture, level, samples);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReadBufferIndexedEXT (GLenum src, GLint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_multiview_draw_buffers - glReadBufferIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_multiview_draw_buffers] && glConfig.m_glReadBufferIndexedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glReadBufferIndexedEXT (src, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawBuffersIndexedEXT (GLint n, const GLenum * location, const GLint * indices)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_multiview_draw_buffers - glDrawBuffersIndexedEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_multiview_draw_buffers] && glConfig.m_glDrawBuffersIndexedEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawBuffersIndexedEXT (n, location, indices);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetIntegeri_vEXT (GLenum target, GLuint index, GLint * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_multiview_draw_buffers - glGetIntegeri_vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_multiview_draw_buffers] && glConfig.m_glGetIntegeri_vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetIntegeri_vEXT (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorTableEXT (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void * table)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_paletted_texture - glColorTableEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_paletted_texture] && glConfig.m_glColorTableEXT)
  {
    prototypeCalled = true;
    glConfig.m_glColorTableEXT (target, internalFormat, width, format, type, table);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetColorTableEXT (GLenum target, GLenum format, GLenum type, void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_paletted_texture - glGetColorTableEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_paletted_texture] && glConfig.m_glGetColorTableEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTableEXT (target, format, type, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetColorTableParameterivEXT (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_paletted_texture - glGetColorTableParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_paletted_texture] && glConfig.m_glGetColorTableParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTableParameterivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetColorTableParameterfvEXT (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_paletted_texture - glGetColorTableParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_paletted_texture] && glConfig.m_glGetColorTableParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTableParameterfvEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelTransformParameteriEXT (GLenum target, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_pixel_transform - glPixelTransformParameteriEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_pixel_transform] && glConfig.m_glPixelTransformParameteriEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPixelTransformParameteriEXT (target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelTransformParameterfEXT (GLenum target, GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_pixel_transform - glPixelTransformParameterfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_pixel_transform] && glConfig.m_glPixelTransformParameterfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPixelTransformParameterfEXT (target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelTransformParameterivEXT (GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_pixel_transform - glPixelTransformParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_pixel_transform] && glConfig.m_glPixelTransformParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPixelTransformParameterivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelTransformParameterfvEXT (GLenum target, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_pixel_transform - glPixelTransformParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_pixel_transform] && glConfig.m_glPixelTransformParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPixelTransformParameterfvEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPixelTransformParameterivEXT (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_pixel_transform - glGetPixelTransformParameterivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_pixel_transform] && glConfig.m_glGetPixelTransformParameterivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetPixelTransformParameterivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPixelTransformParameterfvEXT (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_pixel_transform - glGetPixelTransformParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_pixel_transform] && glConfig.m_glGetPixelTransformParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetPixelTransformParameterfvEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameterfEXT (GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_point_parameters - glPointParameterfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_point_parameters] && glConfig.m_glPointParameterfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfEXT (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameterfvEXT (GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_point_parameters - glPointParameterfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_point_parameters] && glConfig.m_glPointParameterfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfvEXT (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPolygonOffsetEXT (GLfloat factor, GLfloat bias)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_polygon_offset - glPolygonOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_polygon_offset] && glConfig.m_glPolygonOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPolygonOffsetEXT (factor, bias);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPolygonOffsetClampEXT (GLfloat factor, GLfloat units, GLfloat clamp)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_polygon_offset_clamp - glPolygonOffsetClampEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_polygon_offset_clamp] && glConfig.m_glPolygonOffsetClampEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPolygonOffsetClampEXT (factor, units, clamp);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPrimitiveBoundingBoxEXT (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_primitive_bounding_box - glPrimitiveBoundingBoxEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_primitive_bounding_box] && glConfig.m_glPrimitiveBoundingBoxEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPrimitiveBoundingBoxEXT (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProvokingVertexEXT (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_provoking_vertex - glProvokingVertexEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_provoking_vertex] && glConfig.m_glProvokingVertexEXT)
  {
    prototypeCalled = true;
    glConfig.m_glProvokingVertexEXT (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRasterSamplesEXT (GLuint samples, GLboolean fixedsamplelocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_raster_multisample - glRasterSamplesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_raster_multisample] && glConfig.m_glRasterSamplesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glRasterSamplesEXT (samples, fixedsamplelocations);
  }
  // GL_NV_framebuffer_mixed_samples - glRasterSamplesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_framebuffer_mixed_samples] && glConfig.m_glRasterSamplesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glRasterSamplesEXT (samples, fixedsamplelocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glGetGraphicsResetStatusEXT ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_robustness - glGetGraphicsResetStatusEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_robustness] && glConfig.m_glGetGraphicsResetStatusEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetGraphicsResetStatusEXT ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReadnPixelsEXT (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_robustness - glReadnPixelsEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_robustness] && glConfig.m_glReadnPixelsEXT)
  {
    prototypeCalled = true;
    glConfig.m_glReadnPixelsEXT (x, y, width, height, format, type, bufSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformfvEXT (GLuint program, GLint location, GLsizei bufSize, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_robustness - glGetnUniformfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_robustness] && glConfig.m_glGetnUniformfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformfvEXT (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformivEXT (GLuint program, GLint location, GLsizei bufSize, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_robustness - glGetnUniformivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_robustness] && glConfig.m_glGetnUniformivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformivEXT (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenSemaphoresEXT (GLsizei n, GLuint * semaphores)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_semaphore - glGenSemaphoresEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore] && glConfig.m_glGenSemaphoresEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenSemaphoresEXT (n, semaphores);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteSemaphoresEXT (GLsizei n, const GLuint * semaphores)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_semaphore - glDeleteSemaphoresEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore] && glConfig.m_glDeleteSemaphoresEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteSemaphoresEXT (n, semaphores);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsSemaphoreEXT (GLuint semaphore)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_semaphore - glIsSemaphoreEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore] && glConfig.m_glIsSemaphoreEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsSemaphoreEXT (semaphore);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSemaphoreParameterui64vEXT (GLuint semaphore, GLenum pname, const GLuint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_semaphore - glSemaphoreParameterui64vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore] && glConfig.m_glSemaphoreParameterui64vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSemaphoreParameterui64vEXT (semaphore, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSemaphoreParameterui64vEXT (GLuint semaphore, GLenum pname, GLuint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_semaphore - glGetSemaphoreParameterui64vEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore] && glConfig.m_glGetSemaphoreParameterui64vEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetSemaphoreParameterui64vEXT (semaphore, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWaitSemaphoreEXT (GLuint semaphore, GLuint numBufferBarriers, const GLuint * buffers, GLuint numTextureBarriers, const GLuint * textures, const GLenum * srcLayouts)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_semaphore - glWaitSemaphoreEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore] && glConfig.m_glWaitSemaphoreEXT)
  {
    prototypeCalled = true;
    glConfig.m_glWaitSemaphoreEXT (semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSignalSemaphoreEXT (GLuint semaphore, GLuint numBufferBarriers, const GLuint * buffers, GLuint numTextureBarriers, const GLuint * textures, const GLenum * dstLayouts)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_semaphore - glSignalSemaphoreEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore] && glConfig.m_glSignalSemaphoreEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSignalSemaphoreEXT (semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glImportSemaphoreFdEXT (GLuint semaphore, GLenum handleType, GLint fd)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_semaphore_fd - glImportSemaphoreFdEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore_fd] && glConfig.m_glImportSemaphoreFdEXT)
  {
    prototypeCalled = true;
    glConfig.m_glImportSemaphoreFdEXT (semaphore, handleType, fd);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glImportSemaphoreWin32HandleEXT (GLuint semaphore, GLenum handleType, void * handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_semaphore_win32 - glImportSemaphoreWin32HandleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore_win32] && glConfig.m_glImportSemaphoreWin32HandleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glImportSemaphoreWin32HandleEXT (semaphore, handleType, handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glImportSemaphoreWin32NameEXT (GLuint semaphore, GLenum handleType, const void * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_semaphore_win32 - glImportSemaphoreWin32NameEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_semaphore_win32] && glConfig.m_glImportSemaphoreWin32NameEXT)
  {
    prototypeCalled = true;
    glConfig.m_glImportSemaphoreWin32NameEXT (semaphore, handleType, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3bEXT (GLbyte red, GLbyte green, GLbyte blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3bEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3bEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3bEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3bvEXT (const GLbyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3bvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3bvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3bvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3dEXT (GLdouble red, GLdouble green, GLdouble blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3dEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3dvEXT (const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3dvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3fEXT (GLfloat red, GLfloat green, GLfloat blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3fEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3fEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3fEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3fvEXT (const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3fvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3fvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3fvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3iEXT (GLint red, GLint green, GLint blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3iEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3iEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3iEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3ivEXT (const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3ivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3ivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3ivEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3sEXT (GLshort red, GLshort green, GLshort blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3sEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3sEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3sEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3svEXT (const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3svEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3svEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3svEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3ubEXT (GLubyte red, GLubyte green, GLubyte blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3ubEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3ubEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3ubEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3ubvEXT (const GLubyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3ubvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3ubvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3ubvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3uiEXT (GLuint red, GLuint green, GLuint blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3uiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3uiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3uiEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3uivEXT (const GLuint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3uivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3uivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3uivEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3usEXT (GLushort red, GLushort green, GLushort blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3usEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3usEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3usEXT (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3usvEXT (const GLushort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColor3usvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColor3usvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3usvEXT (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColorPointerEXT (GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_secondary_color - glSecondaryColorPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] && glConfig.m_glSecondaryColorPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColorPointerEXT (size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUseShaderProgramEXT (GLenum type, GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glUseShaderProgramEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glUseShaderProgramEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUseShaderProgramEXT (type, program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glActiveProgramEXT (GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glActiveProgramEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glActiveProgramEXT)
  {
    prototypeCalled = true;
    glConfig.m_glActiveProgramEXT (program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glCreateShaderProgramEXT (GLenum type, const GLchar * string)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glCreateShaderProgramEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glCreateShaderProgramEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateShaderProgramEXT (type, string);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glActiveShaderProgramEXT (GLuint pipeline, GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glActiveShaderProgramEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glActiveShaderProgramEXT)
  {
    prototypeCalled = true;
    glConfig.m_glActiveShaderProgramEXT (pipeline, program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindProgramPipelineEXT (GLuint pipeline)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glBindProgramPipelineEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glBindProgramPipelineEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindProgramPipelineEXT (pipeline);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glCreateShaderProgramvEXT (GLenum type, GLsizei count, const GLchar *const* strings)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glCreateShaderProgramvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glCreateShaderProgramvEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateShaderProgramvEXT (type, count, strings);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteProgramPipelinesEXT (GLsizei n, const GLuint * pipelines)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glDeleteProgramPipelinesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glDeleteProgramPipelinesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteProgramPipelinesEXT (n, pipelines);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenProgramPipelinesEXT (GLsizei n, GLuint * pipelines)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glGenProgramPipelinesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glGenProgramPipelinesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenProgramPipelinesEXT (n, pipelines);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramPipelineInfoLogEXT (GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glGetProgramPipelineInfoLogEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glGetProgramPipelineInfoLogEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramPipelineInfoLogEXT (pipeline, bufSize, length, infoLog);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramPipelineivEXT (GLuint pipeline, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glGetProgramPipelineivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glGetProgramPipelineivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramPipelineivEXT (pipeline, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsProgramPipelineEXT (GLuint pipeline)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glIsProgramPipelineEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glIsProgramPipelineEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsProgramPipelineEXT (pipeline);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUseProgramStagesEXT (GLuint pipeline, GLbitfield stages, GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glUseProgramStagesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glUseProgramStagesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glUseProgramStagesEXT (pipeline, stages, program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glValidateProgramPipelineEXT (GLuint pipeline)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_separate_shader_objects - glValidateProgramPipelineEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] && glConfig.m_glValidateProgramPipelineEXT)
  {
    prototypeCalled = true;
    glConfig.m_glValidateProgramPipelineEXT (pipeline);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferFetchBarrierEXT ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_shader_framebuffer_fetch_non_coherent - glFramebufferFetchBarrierEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_shader_framebuffer_fetch_non_coherent] && glConfig.m_glFramebufferFetchBarrierEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferFetchBarrierEXT ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindImageTextureEXT (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_shader_image_load_store - glBindImageTextureEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_shader_image_load_store] && glConfig.m_glBindImageTextureEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindImageTextureEXT (index, texture, level, layered, layer, access, format);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMemoryBarrierEXT (GLbitfield barriers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_shader_image_load_store - glMemoryBarrierEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_shader_image_load_store] && glConfig.m_glMemoryBarrierEXT)
  {
    prototypeCalled = true;
    glConfig.m_glMemoryBarrierEXT (barriers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferPixelLocalStorageSizeEXT (GLuint target, GLsizei size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_shader_pixel_local_storage2 - glFramebufferPixelLocalStorageSizeEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_shader_pixel_local_storage2] && glConfig.m_glFramebufferPixelLocalStorageSizeEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferPixelLocalStorageSizeEXT (target, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLsizei _glew_gl_glGetFramebufferPixelLocalStorageSizeEXT (GLuint target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLsizei result = ((GLsizei)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_shader_pixel_local_storage2 - glGetFramebufferPixelLocalStorageSizeEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_shader_pixel_local_storage2] && glConfig.m_glGetFramebufferPixelLocalStorageSizeEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetFramebufferPixelLocalStorageSizeEXT (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearPixelLocalStorageuiEXT (GLsizei offset, GLsizei n, const GLuint * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_shader_pixel_local_storage2 - glClearPixelLocalStorageuiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_shader_pixel_local_storage2] && glConfig.m_glClearPixelLocalStorageuiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glClearPixelLocalStorageuiEXT (offset, n, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexPageCommitmentEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_sparse_texture - glTexPageCommitmentEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_sparse_texture] && glConfig.m_glTexPageCommitmentEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexPageCommitmentEXT (target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilClearTagEXT (GLsizei stencilTagBits, GLuint stencilClearTag)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_stencil_clear_tag - glStencilClearTagEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_stencil_clear_tag] && glConfig.m_glStencilClearTagEXT)
  {
    prototypeCalled = true;
    glConfig.m_glStencilClearTagEXT (stencilTagBits, stencilClearTag);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glActiveStencilFaceEXT (GLenum face)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_stencil_two_side - glActiveStencilFaceEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_stencil_two_side] && glConfig.m_glActiveStencilFaceEXT)
  {
    prototypeCalled = true;
    glConfig.m_glActiveStencilFaceEXT (face);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexSubImage1DEXT (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_subtexture - glTexSubImage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_subtexture] && glConfig.m_glTexSubImage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexSubImage1DEXT (target, level, xoffset, width, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexSubImage2DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_subtexture - glTexSubImage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_subtexture] && glConfig.m_glTexSubImage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexSubImage2DEXT (target, level, xoffset, yoffset, width, height, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPatchParameteriEXT (GLenum pname, GLint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_tessellation_shader - glPatchParameteriEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_tessellation_shader] && glConfig.m_glPatchParameteriEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPatchParameteriEXT (pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexImage3DEXT (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture3D - glTexImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture3D] && glConfig.m_glTexImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage3DEXT (target, level, internalformat, width, height, depth, border, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexSubImage3DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture3D - glTexSubImage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture3D] && glConfig.m_glTexSubImage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexSubImage3DEXT (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTextureLayerEXT (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_array - glFramebufferTextureLayerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_array] && glConfig.m_glFramebufferTextureLayerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureLayerEXT (target, attachment, texture, level, layer);
  }
  // GL_NV_geometry_program4 - glFramebufferTextureLayerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_geometry_program4] && glConfig.m_glFramebufferTextureLayerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureLayerEXT (target, attachment, texture, level, layer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexParameterIivEXT (GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_border_clamp - glTexParameterIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glTexParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIivEXT (target, pname, params);
  }
  // GL_EXT_texture_integer - glTexParameterIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_integer] && glConfig.m_glTexParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexParameterIuivEXT (GLenum target, GLenum pname, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_border_clamp - glTexParameterIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glTexParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIuivEXT (target, pname, params);
  }
  // GL_EXT_texture_integer - glTexParameterIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_integer] && glConfig.m_glTexParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIuivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexParameterIivEXT (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_border_clamp - glGetTexParameterIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glGetTexParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIivEXT (target, pname, params);
  }
  // GL_EXT_texture_integer - glGetTexParameterIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_integer] && glConfig.m_glGetTexParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexParameterIuivEXT (GLenum target, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_border_clamp - glGetTexParameterIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glGetTexParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIuivEXT (target, pname, params);
  }
  // GL_EXT_texture_integer - glGetTexParameterIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_integer] && glConfig.m_glGetTexParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIuivEXT (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplerParameterIivEXT (GLuint sampler, GLenum pname, const GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_border_clamp - glSamplerParameterIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glSamplerParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIivEXT (sampler, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplerParameterIuivEXT (GLuint sampler, GLenum pname, const GLuint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_border_clamp - glSamplerParameterIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glSamplerParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIuivEXT (sampler, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSamplerParameterIivEXT (GLuint sampler, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_border_clamp - glGetSamplerParameterIivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glGetSamplerParameterIivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIivEXT (sampler, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSamplerParameterIuivEXT (GLuint sampler, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_border_clamp - glGetSamplerParameterIuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] && glConfig.m_glGetSamplerParameterIuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIuivEXT (sampler, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexBufferEXT (GLenum target, GLenum internalformat, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_buffer - glTexBufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_buffer] && glConfig.m_glTexBufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferEXT (target, internalformat, buffer);
  }
  // GL_EXT_texture_buffer_object - glTexBufferEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_buffer_object] && glConfig.m_glTexBufferEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferEXT (target, internalformat, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexBufferRangeEXT (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_buffer - glTexBufferRangeEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_buffer] && glConfig.m_glTexBufferRangeEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferRangeEXT (target, internalformat, buffer, offset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearColorIiEXT (GLint red, GLint green, GLint blue, GLint alpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_integer - glClearColorIiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_integer] && glConfig.m_glClearColorIiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glClearColorIiEXT (red, green, blue, alpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearColorIuiEXT (GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_integer - glClearColorIuiEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_integer] && glConfig.m_glClearColorIuiEXT)
  {
    prototypeCalled = true;
    glConfig.m_glClearColorIuiEXT (red, green, blue, alpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glAreTexturesResidentEXT (GLsizei n, const GLuint * textures, GLboolean * residences)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_object - glAreTexturesResidentEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_object] && glConfig.m_glAreTexturesResidentEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glAreTexturesResidentEXT (n, textures, residences);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindTextureEXT (GLenum target, GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_object - glBindTextureEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_object] && glConfig.m_glBindTextureEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindTextureEXT (target, texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteTexturesEXT (GLsizei n, const GLuint * textures)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_object - glDeleteTexturesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_object] && glConfig.m_glDeleteTexturesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteTexturesEXT (n, textures);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenTexturesEXT (GLsizei n, GLuint * textures)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_object - glGenTexturesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_object] && glConfig.m_glGenTexturesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGenTexturesEXT (n, textures);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsTextureEXT (GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_object - glIsTextureEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_object] && glConfig.m_glIsTextureEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsTextureEXT (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPrioritizeTexturesEXT (GLsizei n, const GLuint * textures, const GLclampf * priorities)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_object - glPrioritizeTexturesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_object] && glConfig.m_glPrioritizeTexturesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glPrioritizeTexturesEXT (n, textures, priorities);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureNormalEXT (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_perturb_normal - glTextureNormalEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_perturb_normal] && glConfig.m_glTextureNormalEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureNormalEXT (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorage1DEXT (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_storage - glTexStorage1DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_storage] && glConfig.m_glTexStorage1DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage1DEXT (target, levels, internalformat, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorage2DEXT (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_storage - glTexStorage2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_storage] && glConfig.m_glTexStorage2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage2DEXT (target, levels, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorage3DEXT (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_storage - glTexStorage3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_storage] && glConfig.m_glTexStorage3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage3DEXT (target, levels, internalformat, width, height, depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorageAttribs2DEXT (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, const GLint*  attrib_list)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_storage_compression - glTexStorageAttribs2DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_storage_compression] && glConfig.m_glTexStorageAttribs2DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorageAttribs2DEXT (target, levels, internalformat, width, height, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorageAttribs3DEXT (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, const GLint*  attrib_list)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_storage_compression - glTexStorageAttribs3DEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_storage_compression] && glConfig.m_glTexStorageAttribs3DEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorageAttribs3DEXT (target, levels, internalformat, width, height, depth, attrib_list);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureViewEXT (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_texture_view - glTextureViewEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_texture_view] && glConfig.m_glTextureViewEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTextureViewEXT (texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateSemaphoresNV (GLsizei n, GLuint * semaphores)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_timeline_semaphore - glCreateSemaphoresNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_timeline_semaphore] && glConfig.m_glCreateSemaphoresNV)
  {
    prototypeCalled = true;
    glConfig.m_glCreateSemaphoresNV (n, semaphores);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSemaphoreParameterivNV (GLuint semaphore, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_timeline_semaphore - glSemaphoreParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_timeline_semaphore] && glConfig.m_glSemaphoreParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glSemaphoreParameterivNV (semaphore, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSemaphoreParameterivNV (GLuint semaphore, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_timeline_semaphore - glGetSemaphoreParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_timeline_semaphore] && glConfig.m_glGetSemaphoreParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetSemaphoreParameterivNV (semaphore, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginTransformFeedbackEXT (GLenum primitiveMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_transform_feedback - glBeginTransformFeedbackEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glBeginTransformFeedbackEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBeginTransformFeedbackEXT (primitiveMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndTransformFeedbackEXT ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_transform_feedback - glEndTransformFeedbackEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glEndTransformFeedbackEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEndTransformFeedbackEXT ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBufferRangeEXT (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_transform_feedback - glBindBufferRangeEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glBindBufferRangeEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferRangeEXT (target, index, buffer, offset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBufferOffsetEXT (GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_transform_feedback - glBindBufferOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glBindBufferOffsetEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferOffsetEXT (target, index, buffer, offset);
  }
  // GL_NV_transform_feedback - glBindBufferOffsetEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glBindBufferOffsetNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferOffsetNV (target, index, buffer, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBufferBaseEXT (GLenum target, GLuint index, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_transform_feedback - glBindBufferBaseEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glBindBufferBaseEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferBaseEXT (target, index, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTransformFeedbackVaryingsEXT (GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_transform_feedback - glTransformFeedbackVaryingsEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glTransformFeedbackVaryingsEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTransformFeedbackVaryingsEXT (program, count, varyings, bufferMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTransformFeedbackVaryingEXT (GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_transform_feedback - glGetTransformFeedbackVaryingEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] && glConfig.m_glGetTransformFeedbackVaryingEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetTransformFeedbackVaryingEXT (program, index, bufSize, length, size, type, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glArrayElementEXT (GLint i)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_array - glArrayElementEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glArrayElementEXT)
  {
    prototypeCalled = true;
    glConfig.m_glArrayElementEXT (i);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_array - glColorPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glColorPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glColorPointerEXT (size, type, stride, count, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawArraysEXT (GLenum mode, GLint first, GLsizei count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_array - glDrawArraysEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glDrawArraysEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysEXT (mode, first, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEdgeFlagPointerEXT (GLsizei stride, GLsizei count, const GLboolean * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_array - glEdgeFlagPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glEdgeFlagPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEdgeFlagPointerEXT (stride, count, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPointervEXT (GLenum pname, void ** params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_array - glGetPointervEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glGetPointervEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetPointervEXT (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glIndexPointerEXT (GLenum type, GLsizei stride, GLsizei count, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_array - glIndexPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glIndexPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glIndexPointerEXT (type, stride, count, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalPointerEXT (GLenum type, GLsizei stride, GLsizei count, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_array - glNormalPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glNormalPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glNormalPointerEXT (type, stride, count, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_array - glTexCoordPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glTexCoordPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordPointerEXT (size, type, stride, count, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_array - glVertexPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] && glConfig.m_glVertexPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexPointerEXT (size, type, stride, count, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL1dEXT (GLuint index, GLdouble x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL1dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL1dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1dEXT (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL2dEXT (GLuint index, GLdouble x, GLdouble y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL2dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL2dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2dEXT (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL3dEXT (GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL3dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL3dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3dEXT (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL4dEXT (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL4dEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL4dEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4dEXT (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL1dvEXT (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL1dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL1dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1dvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL2dvEXT (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL2dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL2dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2dvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL3dvEXT (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL3dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL3dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3dvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL4dvEXT (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_attrib_64bit - glVertexAttribL4dvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribL4dvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4dvEXT (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribLPointerEXT (GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_attrib_64bit - glVertexAttribLPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glVertexAttribLPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribLPointerEXT (index, size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribLdvEXT (GLuint index, GLenum pname, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_attrib_64bit - glGetVertexAttribLdvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] && glConfig.m_glGetVertexAttribLdvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribLdvEXT (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginVertexShaderEXT ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glBeginVertexShaderEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glBeginVertexShaderEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBeginVertexShaderEXT ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndVertexShaderEXT ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glEndVertexShaderEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glEndVertexShaderEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEndVertexShaderEXT ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindVertexShaderEXT (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glBindVertexShaderEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glBindVertexShaderEXT)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexShaderEXT (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGenVertexShadersEXT (GLuint range)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGenVertexShadersEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGenVertexShadersEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGenVertexShadersEXT (range);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteVertexShaderEXT (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glDeleteVertexShaderEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glDeleteVertexShaderEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteVertexShaderEXT (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShaderOp1EXT (GLenum op, GLuint res, GLuint arg1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glShaderOp1EXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glShaderOp1EXT)
  {
    prototypeCalled = true;
    glConfig.m_glShaderOp1EXT (op, res, arg1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShaderOp2EXT (GLenum op, GLuint res, GLuint arg1, GLuint arg2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glShaderOp2EXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glShaderOp2EXT)
  {
    prototypeCalled = true;
    glConfig.m_glShaderOp2EXT (op, res, arg1, arg2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShaderOp3EXT (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glShaderOp3EXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glShaderOp3EXT)
  {
    prototypeCalled = true;
    glConfig.m_glShaderOp3EXT (op, res, arg1, arg2, arg3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSwizzleEXT (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glSwizzleEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glSwizzleEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSwizzleEXT (res, in, outX, outY, outZ, outW);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWriteMaskEXT (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glWriteMaskEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glWriteMaskEXT)
  {
    prototypeCalled = true;
    glConfig.m_glWriteMaskEXT (res, in, outX, outY, outZ, outW);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInsertComponentEXT (GLuint res, GLuint src, GLuint num)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glInsertComponentEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glInsertComponentEXT)
  {
    prototypeCalled = true;
    glConfig.m_glInsertComponentEXT (res, src, num);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtractComponentEXT (GLuint res, GLuint src, GLuint num)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glExtractComponentEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glExtractComponentEXT)
  {
    prototypeCalled = true;
    glConfig.m_glExtractComponentEXT (res, src, num);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGenSymbolsEXT (GLenum datatype, GLenum storagetype, GLenum range, GLuint components)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGenSymbolsEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGenSymbolsEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glGenSymbolsEXT (datatype, storagetype, range, components);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSetInvariantEXT (GLuint id, GLenum type, const void * addr)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glSetInvariantEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glSetInvariantEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSetInvariantEXT (id, type, addr);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSetLocalConstantEXT (GLuint id, GLenum type, const void * addr)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glSetLocalConstantEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glSetLocalConstantEXT)
  {
    prototypeCalled = true;
    glConfig.m_glSetLocalConstantEXT (id, type, addr);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVariantbvEXT (GLuint id, const GLbyte * addr)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glVariantbvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glVariantbvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVariantbvEXT (id, addr);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVariantsvEXT (GLuint id, const GLshort * addr)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glVariantsvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glVariantsvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVariantsvEXT (id, addr);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVariantivEXT (GLuint id, const GLint * addr)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glVariantivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glVariantivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVariantivEXT (id, addr);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVariantfvEXT (GLuint id, const GLfloat * addr)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glVariantfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glVariantfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVariantfvEXT (id, addr);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVariantdvEXT (GLuint id, const GLdouble * addr)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glVariantdvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glVariantdvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVariantdvEXT (id, addr);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVariantubvEXT (GLuint id, const GLubyte * addr)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glVariantubvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glVariantubvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVariantubvEXT (id, addr);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVariantusvEXT (GLuint id, const GLushort * addr)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glVariantusvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glVariantusvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVariantusvEXT (id, addr);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVariantuivEXT (GLuint id, const GLuint * addr)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glVariantuivEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glVariantuivEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVariantuivEXT (id, addr);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVariantPointerEXT (GLuint id, GLenum type, GLuint stride, const void * addr)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glVariantPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glVariantPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVariantPointerEXT (id, type, stride, addr);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableVariantClientStateEXT (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glEnableVariantClientStateEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glEnableVariantClientStateEXT)
  {
    prototypeCalled = true;
    glConfig.m_glEnableVariantClientStateEXT (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableVariantClientStateEXT (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glDisableVariantClientStateEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glDisableVariantClientStateEXT)
  {
    prototypeCalled = true;
    glConfig.m_glDisableVariantClientStateEXT (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glBindLightParameterEXT (GLenum light, GLenum value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glBindLightParameterEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glBindLightParameterEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glBindLightParameterEXT (light, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glBindMaterialParameterEXT (GLenum face, GLenum value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glBindMaterialParameterEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glBindMaterialParameterEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glBindMaterialParameterEXT (face, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glBindTexGenParameterEXT (GLenum unit, GLenum coord, GLenum value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glBindTexGenParameterEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glBindTexGenParameterEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glBindTexGenParameterEXT (unit, coord, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glBindTextureUnitParameterEXT (GLenum unit, GLenum value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glBindTextureUnitParameterEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glBindTextureUnitParameterEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glBindTextureUnitParameterEXT (unit, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glBindParameterEXT (GLenum value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glBindParameterEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glBindParameterEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glBindParameterEXT (value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsVariantEnabledEXT (GLuint id, GLenum cap)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glIsVariantEnabledEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glIsVariantEnabledEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsVariantEnabledEXT (id, cap);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVariantBooleanvEXT (GLuint id, GLenum value, GLboolean * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGetVariantBooleanvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGetVariantBooleanvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVariantBooleanvEXT (id, value, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVariantIntegervEXT (GLuint id, GLenum value, GLint * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGetVariantIntegervEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGetVariantIntegervEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVariantIntegervEXT (id, value, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVariantFloatvEXT (GLuint id, GLenum value, GLfloat * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGetVariantFloatvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGetVariantFloatvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVariantFloatvEXT (id, value, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVariantPointervEXT (GLuint id, GLenum value, void ** data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGetVariantPointervEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGetVariantPointervEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetVariantPointervEXT (id, value, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetInvariantBooleanvEXT (GLuint id, GLenum value, GLboolean * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGetInvariantBooleanvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGetInvariantBooleanvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetInvariantBooleanvEXT (id, value, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetInvariantIntegervEXT (GLuint id, GLenum value, GLint * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGetInvariantIntegervEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGetInvariantIntegervEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetInvariantIntegervEXT (id, value, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetInvariantFloatvEXT (GLuint id, GLenum value, GLfloat * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGetInvariantFloatvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGetInvariantFloatvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetInvariantFloatvEXT (id, value, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetLocalConstantBooleanvEXT (GLuint id, GLenum value, GLboolean * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGetLocalConstantBooleanvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGetLocalConstantBooleanvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetLocalConstantBooleanvEXT (id, value, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetLocalConstantIntegervEXT (GLuint id, GLenum value, GLint * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGetLocalConstantIntegervEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGetLocalConstantIntegervEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetLocalConstantIntegervEXT (id, value, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetLocalConstantFloatvEXT (GLuint id, GLenum value, GLfloat * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_shader - glGetLocalConstantFloatvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] && glConfig.m_glGetLocalConstantFloatvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glGetLocalConstantFloatvEXT (id, value, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexWeightfEXT (GLfloat weight)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_weighting - glVertexWeightfEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_weighting] && glConfig.m_glVertexWeightfEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexWeightfEXT (weight);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexWeightfvEXT (const GLfloat * weight)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_weighting - glVertexWeightfvEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_weighting] && glConfig.m_glVertexWeightfvEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexWeightfvEXT (weight);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexWeightPointerEXT (GLint size, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_vertex_weighting - glVertexWeightPointerEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_vertex_weighting] && glConfig.m_glVertexWeightPointerEXT)
  {
    prototypeCalled = true;
    glConfig.m_glVertexWeightPointerEXT (size, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glAcquireKeyedMutexWin32EXT (GLuint memory, GLuint64 key, GLuint timeout)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_win32_keyed_mutex - glAcquireKeyedMutexWin32EXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_win32_keyed_mutex] && glConfig.m_glAcquireKeyedMutexWin32EXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glAcquireKeyedMutexWin32EXT (memory, key, timeout);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glReleaseKeyedMutexWin32EXT (GLuint memory, GLuint64 key)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_win32_keyed_mutex - glReleaseKeyedMutexWin32EXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_win32_keyed_mutex] && glConfig.m_glReleaseKeyedMutexWin32EXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glReleaseKeyedMutexWin32EXT (memory, key);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowRectanglesEXT (GLenum mode, GLsizei count, const GLint * box)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_window_rectangles - glWindowRectanglesEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_window_rectangles] && glConfig.m_glWindowRectanglesEXT)
  {
    prototypeCalled = true;
    glConfig.m_glWindowRectanglesEXT (mode, count, box);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLsync _glew_gl_glImportSyncEXT (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLsync result = ((GLsync)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_EXT_x11_sync_object - glImportSyncEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_EXT_x11_sync_object] && glConfig.m_glImportSyncEXT)
  {
    prototypeCalled = true;
    result = glConfig.m_glImportSyncEXT (external_sync_type, external_sync, flags);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFrameTerminatorGREMEDY ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_GREMEDY_frame_terminator - glFrameTerminatorGREMEDY
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_GREMEDY_frame_terminator] && glConfig.m_glFrameTerminatorGREMEDY)
  {
    prototypeCalled = true;
    glConfig.m_glFrameTerminatorGREMEDY ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStringMarkerGREMEDY (GLsizei len, const void * string)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_GREMEDY_string_marker - glStringMarkerGREMEDY
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_GREMEDY_string_marker] && glConfig.m_glStringMarkerGREMEDY)
  {
    prototypeCalled = true;
    glConfig.m_glStringMarkerGREMEDY (len, string);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glImageTransformParameteriHP (GLenum target, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_HP_image_transform - glImageTransformParameteriHP
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_HP_image_transform] && glConfig.m_glImageTransformParameteriHP)
  {
    prototypeCalled = true;
    glConfig.m_glImageTransformParameteriHP (target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glImageTransformParameterfHP (GLenum target, GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_HP_image_transform - glImageTransformParameterfHP
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_HP_image_transform] && glConfig.m_glImageTransformParameterfHP)
  {
    prototypeCalled = true;
    glConfig.m_glImageTransformParameterfHP (target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glImageTransformParameterivHP (GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_HP_image_transform - glImageTransformParameterivHP
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_HP_image_transform] && glConfig.m_glImageTransformParameterivHP)
  {
    prototypeCalled = true;
    glConfig.m_glImageTransformParameterivHP (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glImageTransformParameterfvHP (GLenum target, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_HP_image_transform - glImageTransformParameterfvHP
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_HP_image_transform] && glConfig.m_glImageTransformParameterfvHP)
  {
    prototypeCalled = true;
    glConfig.m_glImageTransformParameterfvHP (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetImageTransformParameterivHP (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_HP_image_transform - glGetImageTransformParameterivHP
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_HP_image_transform] && glConfig.m_glGetImageTransformParameterivHP)
  {
    prototypeCalled = true;
    glConfig.m_glGetImageTransformParameterivHP (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetImageTransformParameterfvHP (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_HP_image_transform - glGetImageTransformParameterfvHP
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_HP_image_transform] && glConfig.m_glGetImageTransformParameterfvHP)
  {
    prototypeCalled = true;
    glConfig.m_glGetImageTransformParameterfvHP (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiModeDrawArraysIBM (const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IBM_multimode_draw_arrays - glMultiModeDrawArraysIBM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IBM_multimode_draw_arrays] && glConfig.m_glMultiModeDrawArraysIBM)
  {
    prototypeCalled = true;
    glConfig.m_glMultiModeDrawArraysIBM (mode, first, count, primcount, modestride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiModeDrawElementsIBM (const GLenum * mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei primcount, GLint modestride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IBM_multimode_draw_arrays - glMultiModeDrawElementsIBM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IBM_multimode_draw_arrays] && glConfig.m_glMultiModeDrawElementsIBM)
  {
    prototypeCalled = true;
    glConfig.m_glMultiModeDrawElementsIBM (mode, count, type, indices, primcount, modestride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFlushStaticDataIBM (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IBM_static_data - glFlushStaticDataIBM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IBM_static_data] && glConfig.m_glFlushStaticDataIBM)
  {
    prototypeCalled = true;
    glConfig.m_glFlushStaticDataIBM (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorPointerListIBM (GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IBM_vertex_array_lists - glColorPointerListIBM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IBM_vertex_array_lists] && glConfig.m_glColorPointerListIBM)
  {
    prototypeCalled = true;
    glConfig.m_glColorPointerListIBM (size, type, stride, pointer, ptrstride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColorPointerListIBM (GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IBM_vertex_array_lists - glSecondaryColorPointerListIBM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IBM_vertex_array_lists] && glConfig.m_glSecondaryColorPointerListIBM)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColorPointerListIBM (size, type, stride, pointer, ptrstride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEdgeFlagPointerListIBM (GLint stride, const GLboolean ** pointer, GLint ptrstride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IBM_vertex_array_lists - glEdgeFlagPointerListIBM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IBM_vertex_array_lists] && glConfig.m_glEdgeFlagPointerListIBM)
  {
    prototypeCalled = true;
    glConfig.m_glEdgeFlagPointerListIBM (stride, pointer, ptrstride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoordPointerListIBM (GLenum type, GLint stride, const void ** pointer, GLint ptrstride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IBM_vertex_array_lists - glFogCoordPointerListIBM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IBM_vertex_array_lists] && glConfig.m_glFogCoordPointerListIBM)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordPointerListIBM (type, stride, pointer, ptrstride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glIndexPointerListIBM (GLenum type, GLint stride, const void ** pointer, GLint ptrstride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IBM_vertex_array_lists - glIndexPointerListIBM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IBM_vertex_array_lists] && glConfig.m_glIndexPointerListIBM)
  {
    prototypeCalled = true;
    glConfig.m_glIndexPointerListIBM (type, stride, pointer, ptrstride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalPointerListIBM (GLenum type, GLint stride, const void ** pointer, GLint ptrstride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IBM_vertex_array_lists - glNormalPointerListIBM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IBM_vertex_array_lists] && glConfig.m_glNormalPointerListIBM)
  {
    prototypeCalled = true;
    glConfig.m_glNormalPointerListIBM (type, stride, pointer, ptrstride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordPointerListIBM (GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IBM_vertex_array_lists - glTexCoordPointerListIBM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IBM_vertex_array_lists] && glConfig.m_glTexCoordPointerListIBM)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordPointerListIBM (size, type, stride, pointer, ptrstride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexPointerListIBM (GLint size, GLenum type, GLint stride, const void ** pointer, GLint ptrstride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IBM_vertex_array_lists - glVertexPointerListIBM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IBM_vertex_array_lists] && glConfig.m_glVertexPointerListIBM)
  {
    prototypeCalled = true;
    glConfig.m_glVertexPointerListIBM (size, type, stride, pointer, ptrstride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint64 _glew_gl_glGetTextureHandleIMG (GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint64 result = ((GLuint64)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IMG_bindless_texture - glGetTextureHandleIMG
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IMG_bindless_texture] && glConfig.m_glGetTextureHandleIMG)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetTextureHandleIMG (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint64 _glew_gl_glGetTextureSamplerHandleIMG (GLuint texture, GLuint sampler)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint64 result = ((GLuint64)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IMG_bindless_texture - glGetTextureSamplerHandleIMG
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IMG_bindless_texture] && glConfig.m_glGetTextureSamplerHandleIMG)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetTextureSamplerHandleIMG (texture, sampler);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformHandleui64IMG (GLint location, GLuint64 value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IMG_bindless_texture - glUniformHandleui64IMG
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IMG_bindless_texture] && glConfig.m_glUniformHandleui64IMG)
  {
    prototypeCalled = true;
    glConfig.m_glUniformHandleui64IMG (location, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformHandleui64vIMG (GLint location, GLsizei count, const GLuint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IMG_bindless_texture - glUniformHandleui64vIMG
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IMG_bindless_texture] && glConfig.m_glUniformHandleui64vIMG)
  {
    prototypeCalled = true;
    glConfig.m_glUniformHandleui64vIMG (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformHandleui64IMG (GLuint program, GLint location, GLuint64 value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IMG_bindless_texture - glProgramUniformHandleui64IMG
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IMG_bindless_texture] && glConfig.m_glProgramUniformHandleui64IMG)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformHandleui64IMG (program, location, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformHandleui64vIMG (GLuint program, GLint location, GLsizei count, const GLuint64 * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IMG_bindless_texture - glProgramUniformHandleui64vIMG
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IMG_bindless_texture] && glConfig.m_glProgramUniformHandleui64vIMG)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformHandleui64vIMG (program, location, count, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTexture2DDownsampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IMG_framebuffer_downsample - glFramebufferTexture2DDownsampleIMG
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IMG_framebuffer_downsample] && glConfig.m_glFramebufferTexture2DDownsampleIMG)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture2DDownsampleIMG (target, attachment, textarget, texture, level, xscale, yscale);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTextureLayerDownsampleIMG (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IMG_framebuffer_downsample - glFramebufferTextureLayerDownsampleIMG
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IMG_framebuffer_downsample] && glConfig.m_glFramebufferTextureLayerDownsampleIMG)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureLayerDownsampleIMG (target, attachment, texture, level, layer, xscale, yscale);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRenderbufferStorageMultisampleIMG (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IMG_multisampled_render_to_texture - glRenderbufferStorageMultisampleIMG
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IMG_multisampled_render_to_texture] && glConfig.m_glRenderbufferStorageMultisampleIMG)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisampleIMG (target, samples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTexture2DMultisampleIMG (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_IMG_multisampled_render_to_texture - glFramebufferTexture2DMultisampleIMG
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_IMG_multisampled_render_to_texture] && glConfig.m_glFramebufferTexture2DMultisampleIMG)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture2DMultisampleIMG (target, attachment, textarget, texture, level, samples);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFuncSeparateINGR (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INGR_blend_func_separate - glBlendFuncSeparateINGR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INGR_blend_func_separate] && glConfig.m_glBlendFuncSeparateINGR)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparateINGR (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glApplyFramebufferAttachmentCMAAINTEL ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_framebuffer_CMAA - glApplyFramebufferAttachmentCMAAINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_framebuffer_CMAA] && glConfig.m_glApplyFramebufferAttachmentCMAAINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glApplyFramebufferAttachmentCMAAINTEL ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSyncTextureINTEL (GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_map_texture - glSyncTextureINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_map_texture] && glConfig.m_glSyncTextureINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glSyncTextureINTEL (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUnmapTexture2DINTEL (GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_map_texture - glUnmapTexture2DINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_map_texture] && glConfig.m_glUnmapTexture2DINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glUnmapTexture2DINTEL (texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void * _glew_gl_glMapTexture2DINTEL (GLuint texture, GLint level, GLbitfield access, GLint * stride, GLenum * layout)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  void * result = ((void *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_map_texture - glMapTexture2DINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_map_texture] && glConfig.m_glMapTexture2DINTEL)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapTexture2DINTEL (texture, level, access, stride, layout);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexPointervINTEL (GLint size, GLenum type, const void ** pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_parallel_arrays - glVertexPointervINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_parallel_arrays] && glConfig.m_glVertexPointervINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glVertexPointervINTEL (size, type, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalPointervINTEL (GLenum type, const void ** pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_parallel_arrays - glNormalPointervINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_parallel_arrays] && glConfig.m_glNormalPointervINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glNormalPointervINTEL (type, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorPointervINTEL (GLint size, GLenum type, const void ** pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_parallel_arrays - glColorPointervINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_parallel_arrays] && glConfig.m_glColorPointervINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glColorPointervINTEL (size, type, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordPointervINTEL (GLint size, GLenum type, const void ** pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_parallel_arrays - glTexCoordPointervINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_parallel_arrays] && glConfig.m_glTexCoordPointervINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordPointervINTEL (size, type, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginPerfQueryINTEL (GLuint queryHandle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_performance_query - glBeginPerfQueryINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_performance_query] && glConfig.m_glBeginPerfQueryINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glBeginPerfQueryINTEL (queryHandle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreatePerfQueryINTEL (GLuint queryId, GLuint * queryHandle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_performance_query - glCreatePerfQueryINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_performance_query] && glConfig.m_glCreatePerfQueryINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glCreatePerfQueryINTEL (queryId, queryHandle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeletePerfQueryINTEL (GLuint queryHandle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_performance_query - glDeletePerfQueryINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_performance_query] && glConfig.m_glDeletePerfQueryINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glDeletePerfQueryINTEL (queryHandle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndPerfQueryINTEL (GLuint queryHandle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_performance_query - glEndPerfQueryINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_performance_query] && glConfig.m_glEndPerfQueryINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glEndPerfQueryINTEL (queryHandle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFirstPerfQueryIdINTEL (GLuint * queryId)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_performance_query - glGetFirstPerfQueryIdINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_performance_query] && glConfig.m_glGetFirstPerfQueryIdINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glGetFirstPerfQueryIdINTEL (queryId);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNextPerfQueryIdINTEL (GLuint queryId, GLuint * nextQueryId)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_performance_query - glGetNextPerfQueryIdINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_performance_query] && glConfig.m_glGetNextPerfQueryIdINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glGetNextPerfQueryIdINTEL (queryId, nextQueryId);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPerfCounterInfoINTEL (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar * counterName, GLuint counterDescLength, GLchar * counterDesc, GLuint * counterOffset, GLuint * counterDataSize, GLuint * counterTypeEnum, GLuint * counterDataTypeEnum, GLuint64 * rawCounterMaxValue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_performance_query - glGetPerfCounterInfoINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_performance_query] && glConfig.m_glGetPerfCounterInfoINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glGetPerfCounterInfoINTEL (queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPerfQueryDataINTEL (GLuint queryHandle, GLuint flags, GLsizei dataSize, void * data, GLuint * bytesWritten)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_performance_query - glGetPerfQueryDataINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_performance_query] && glConfig.m_glGetPerfQueryDataINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glGetPerfQueryDataINTEL (queryHandle, flags, dataSize, data, bytesWritten);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPerfQueryIdByNameINTEL (GLchar * queryName, GLuint * queryId)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_performance_query - glGetPerfQueryIdByNameINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_performance_query] && glConfig.m_glGetPerfQueryIdByNameINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glGetPerfQueryIdByNameINTEL (queryName, queryId);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPerfQueryInfoINTEL (GLuint queryId, GLuint queryNameLength, GLchar * queryName, GLuint * dataSize, GLuint * noCounters, GLuint * noInstances, GLuint * capsMask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_INTEL_performance_query - glGetPerfQueryInfoINTEL
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_INTEL_performance_query] && glConfig.m_glGetPerfQueryInfoINTEL)
  {
    prototypeCalled = true;
    glConfig.m_glGetPerfQueryInfoINTEL (queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendBarrierKHR ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_blend_equation_advanced - glBlendBarrierKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_blend_equation_advanced] && glConfig.m_glBlendBarrierKHR)
  {
    prototypeCalled = true;
    glConfig.m_glBlendBarrierKHR ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageControlKHR (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_debug - glDebugMessageControlKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glDebugMessageControlKHR)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageControlKHR (source, type, severity, count, ids, enabled);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageInsertKHR (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_debug - glDebugMessageInsertKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glDebugMessageInsertKHR)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageInsertKHR (source, type, id, severity, length, buf);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDebugMessageCallbackKHR (GLDEBUGPROCKHR callback, const void * userParam)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_debug - glDebugMessageCallbackKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glDebugMessageCallbackKHR)
  {
    prototypeCalled = true;
    glConfig.m_glDebugMessageCallbackKHR (callback, userParam);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGetDebugMessageLogKHR (GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_debug - glGetDebugMessageLogKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetDebugMessageLogKHR)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetDebugMessageLogKHR (count, bufSize, sources, types, ids, severities, lengths, messageLog);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPushDebugGroupKHR (GLenum source, GLuint id, GLsizei length, const GLchar * message)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_debug - glPushDebugGroupKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glPushDebugGroupKHR)
  {
    prototypeCalled = true;
    glConfig.m_glPushDebugGroupKHR (source, id, length, message);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPopDebugGroupKHR ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_debug - glPopDebugGroupKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glPopDebugGroupKHR)
  {
    prototypeCalled = true;
    glConfig.m_glPopDebugGroupKHR ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glObjectLabelKHR (GLenum identifier, GLuint name, GLsizei length, const GLchar * label)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_debug - glObjectLabelKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glObjectLabelKHR)
  {
    prototypeCalled = true;
    glConfig.m_glObjectLabelKHR (identifier, name, length, label);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetObjectLabelKHR (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_debug - glGetObjectLabelKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetObjectLabelKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectLabelKHR (identifier, name, bufSize, length, label);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glObjectPtrLabelKHR (const void * ptr, GLsizei length, const GLchar * label)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_debug - glObjectPtrLabelKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glObjectPtrLabelKHR)
  {
    prototypeCalled = true;
    glConfig.m_glObjectPtrLabelKHR (ptr, length, label);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetObjectPtrLabelKHR (const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_debug - glGetObjectPtrLabelKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetObjectPtrLabelKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetObjectPtrLabelKHR (ptr, bufSize, length, label);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPointervKHR (GLenum pname, void ** params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_debug - glGetPointervKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_debug] && glConfig.m_glGetPointervKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetPointervKHR (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glGetGraphicsResetStatusKHR ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_robustness - glGetGraphicsResetStatusKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetGraphicsResetStatusKHR)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetGraphicsResetStatusKHR ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReadnPixelsKHR (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_robustness - glReadnPixelsKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glReadnPixelsKHR)
  {
    prototypeCalled = true;
    glConfig.m_glReadnPixelsKHR (x, y, width, height, format, type, bufSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformfvKHR (GLuint program, GLint location, GLsizei bufSize, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_robustness - glGetnUniformfvKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetnUniformfvKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformfvKHR (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformivKHR (GLuint program, GLint location, GLsizei bufSize, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_robustness - glGetnUniformivKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetnUniformivKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformivKHR (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetnUniformuivKHR (GLuint program, GLint location, GLsizei bufSize, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_robustness - glGetnUniformuivKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_robustness] && glConfig.m_glGetnUniformuivKHR)
  {
    prototypeCalled = true;
    glConfig.m_glGetnUniformuivKHR (program, location, bufSize, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMaxShaderCompilerThreadsKHR (GLuint count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_KHR_parallel_shader_compile - glMaxShaderCompilerThreadsKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_KHR_parallel_shader_compile] && glConfig.m_glMaxShaderCompilerThreadsKHR)
  {
    prototypeCalled = true;
    glConfig.m_glMaxShaderCompilerThreadsKHR (count);
  }
  // GL_ARB_parallel_shader_compile - glMaxShaderCompilerThreadsKHR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_ARB_parallel_shader_compile] && glConfig.m_glMaxShaderCompilerThreadsARB)
  {
    prototypeCalled = true;
    glConfig.m_glMaxShaderCompilerThreadsARB (count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferParameteriMESA (GLenum target, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_framebuffer_flip_y - glFramebufferParameteriMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_framebuffer_flip_y] && glConfig.m_glFramebufferParameteriMESA)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferParameteriMESA (target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFramebufferParameterivMESA (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_framebuffer_flip_y - glGetFramebufferParameterivMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_framebuffer_flip_y] && glConfig.m_glGetFramebufferParameterivMESA)
  {
    prototypeCalled = true;
    glConfig.m_glGetFramebufferParameterivMESA (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glResizeBuffersMESA ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_resize_buffers - glResizeBuffersMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_resize_buffers] && glConfig.m_glResizeBuffersMESA)
  {
    prototypeCalled = true;
    glConfig.m_glResizeBuffersMESA ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2dMESA (GLdouble x, GLdouble y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos2dMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos2dMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2dMESA (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2dvMESA (const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos2dvMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos2dvMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2dvMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2fMESA (GLfloat x, GLfloat y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos2fMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos2fMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2fMESA (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2fvMESA (const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos2fvMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos2fvMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2fvMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2iMESA (GLint x, GLint y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos2iMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos2iMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2iMESA (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2ivMESA (const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos2ivMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos2ivMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2ivMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2sMESA (GLshort x, GLshort y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos2sMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos2sMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2sMESA (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos2svMESA (const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos2svMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos2svMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos2svMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3dMESA (GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos3dMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos3dMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3dMESA (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3dvMESA (const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos3dvMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos3dvMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3dvMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3fMESA (GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos3fMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos3fMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3fMESA (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3fvMESA (const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos3fvMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos3fvMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3fvMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3iMESA (GLint x, GLint y, GLint z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos3iMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos3iMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3iMESA (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3ivMESA (const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos3ivMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos3ivMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3ivMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3sMESA (GLshort x, GLshort y, GLshort z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos3sMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos3sMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3sMESA (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos3svMESA (const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos3svMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos3svMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos3svMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos4dMESA (GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos4dMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos4dMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos4dMESA (x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos4dvMESA (const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos4dvMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos4dvMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos4dvMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos4fMESA (GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos4fMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos4fMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos4fMESA (x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos4fvMESA (const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos4fvMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos4fvMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos4fvMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos4iMESA (GLint x, GLint y, GLint z, GLint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos4iMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos4iMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos4iMESA (x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos4ivMESA (const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos4ivMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos4ivMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos4ivMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos4sMESA (GLshort x, GLshort y, GLshort z, GLshort w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos4sMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos4sMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos4sMESA (x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWindowPos4svMESA (const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_MESA_window_pos - glWindowPos4svMESA
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_MESA_window_pos] && glConfig.m_glWindowPos4svMESA)
  {
    prototypeCalled = true;
    glConfig.m_glWindowPos4svMESA (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginConditionalRenderNVX (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_conditional_render - glBeginConditionalRenderNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_conditional_render] && glConfig.m_glBeginConditionalRenderNVX)
  {
    prototypeCalled = true;
    glConfig.m_glBeginConditionalRenderNVX (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndConditionalRenderNVX ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_conditional_render - glEndConditionalRenderNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_conditional_render] && glConfig.m_glEndConditionalRenderNVX)
  {
    prototypeCalled = true;
    glConfig.m_glEndConditionalRenderNVX ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLGPUNamedBufferSubDataNVX (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_linked_gpu_multicast - glLGPUNamedBufferSubDataNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_linked_gpu_multicast] && glConfig.m_glLGPUNamedBufferSubDataNVX)
  {
    prototypeCalled = true;
    glConfig.m_glLGPUNamedBufferSubDataNVX (gpuMask, buffer, offset, size, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLGPUCopyImageSubDataNVX (GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_linked_gpu_multicast - glLGPUCopyImageSubDataNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_linked_gpu_multicast] && glConfig.m_glLGPUCopyImageSubDataNVX)
  {
    prototypeCalled = true;
    glConfig.m_glLGPUCopyImageSubDataNVX (sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLGPUInterlockNVX ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_linked_gpu_multicast - glLGPUInterlockNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_linked_gpu_multicast] && glConfig.m_glLGPUInterlockNVX)
  {
    prototypeCalled = true;
    glConfig.m_glLGPUInterlockNVX ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glAlphaToCoverageDitherControlNV (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_alpha_to_coverage_dither_control - glAlphaToCoverageDitherControlNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_alpha_to_coverage_dither_control] && glConfig.m_glAlphaToCoverageDitherControlNV)
  {
    prototypeCalled = true;
    glConfig.m_glAlphaToCoverageDitherControlNV (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawArraysIndirectBindlessNV (GLenum mode, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_multi_draw_indirect - glMultiDrawArraysIndirectBindlessNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_multi_draw_indirect] && glConfig.m_glMultiDrawArraysIndirectBindlessNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawArraysIndirectBindlessNV (mode, indirect, drawCount, stride, vertexBufferCount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElementsIndirectBindlessNV (GLenum mode, GLenum type, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_multi_draw_indirect - glMultiDrawElementsIndirectBindlessNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_multi_draw_indirect] && glConfig.m_glMultiDrawElementsIndirectBindlessNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsIndirectBindlessNV (mode, type, indirect, drawCount, stride, vertexBufferCount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawArraysIndirectBindlessCountNV (GLenum mode, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_multi_draw_indirect_count - glMultiDrawArraysIndirectBindlessCountNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_multi_draw_indirect_count] && glConfig.m_glMultiDrawArraysIndirectBindlessCountNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawArraysIndirectBindlessCountNV (mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawElementsIndirectBindlessCountNV (GLenum mode, GLenum type, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_multi_draw_indirect_count - glMultiDrawElementsIndirectBindlessCountNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_multi_draw_indirect_count] && glConfig.m_glMultiDrawElementsIndirectBindlessCountNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawElementsIndirectBindlessCountNV (mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint64 _glew_gl_glGetTextureHandleNV (GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint64 result = ((GLuint64)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glGetTextureHandleNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glGetTextureHandleNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetTextureHandleNV (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint64 _glew_gl_glGetTextureSamplerHandleNV (GLuint texture, GLuint sampler)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint64 result = ((GLuint64)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glGetTextureSamplerHandleNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glGetTextureSamplerHandleNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetTextureSamplerHandleNV (texture, sampler);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeTextureHandleResidentNV (GLuint64 handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glMakeTextureHandleResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glMakeTextureHandleResidentNV)
  {
    prototypeCalled = true;
    glConfig.m_glMakeTextureHandleResidentNV (handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeTextureHandleNonResidentNV (GLuint64 handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glMakeTextureHandleNonResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glMakeTextureHandleNonResidentNV)
  {
    prototypeCalled = true;
    glConfig.m_glMakeTextureHandleNonResidentNV (handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint64 _glew_gl_glGetImageHandleNV (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint64 result = ((GLuint64)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glGetImageHandleNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glGetImageHandleNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetImageHandleNV (texture, level, layered, layer, format);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeImageHandleResidentNV (GLuint64 handle, GLenum access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glMakeImageHandleResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glMakeImageHandleResidentNV)
  {
    prototypeCalled = true;
    glConfig.m_glMakeImageHandleResidentNV (handle, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeImageHandleNonResidentNV (GLuint64 handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glMakeImageHandleNonResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glMakeImageHandleNonResidentNV)
  {
    prototypeCalled = true;
    glConfig.m_glMakeImageHandleNonResidentNV (handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformHandleui64NV (GLint location, GLuint64 value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glUniformHandleui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glUniformHandleui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformHandleui64NV (location, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformHandleui64vNV (GLint location, GLsizei count, const GLuint64 * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glUniformHandleui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glUniformHandleui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformHandleui64vNV (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformHandleui64NV (GLuint program, GLint location, GLuint64 value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glProgramUniformHandleui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glProgramUniformHandleui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformHandleui64NV (program, location, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformHandleui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64 * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glProgramUniformHandleui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glProgramUniformHandleui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformHandleui64vNV (program, location, count, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsTextureHandleResidentNV (GLuint64 handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glIsTextureHandleResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glIsTextureHandleResidentNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsTextureHandleResidentNV (handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsImageHandleResidentNV (GLuint64 handle)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_bindless_texture - glIsImageHandleResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] && glConfig.m_glIsImageHandleResidentNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsImageHandleResidentNV (handle);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendParameteriNV (GLenum pname, GLint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_blend_equation_advanced - glBlendParameteriNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_blend_equation_advanced] && glConfig.m_glBlendParameteriNV)
  {
    prototypeCalled = true;
    glConfig.m_glBlendParameteriNV (pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendBarrierNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_blend_equation_advanced - glBlendBarrierNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_blend_equation_advanced] && glConfig.m_glBlendBarrierNV)
  {
    prototypeCalled = true;
    glConfig.m_glBlendBarrierNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glViewportPositionWScaleNV (GLuint index, GLfloat xcoeff, GLfloat ycoeff)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_clip_space_w_scaling - glViewportPositionWScaleNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_clip_space_w_scaling] && glConfig.m_glViewportPositionWScaleNV)
  {
    prototypeCalled = true;
    glConfig.m_glViewportPositionWScaleNV (index, xcoeff, ycoeff);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateStatesNV (GLsizei n, GLuint * states)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glCreateStatesNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glCreateStatesNV)
  {
    prototypeCalled = true;
    glConfig.m_glCreateStatesNV (n, states);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteStatesNV (GLsizei n, const GLuint * states)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glDeleteStatesNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glDeleteStatesNV)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteStatesNV (n, states);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsStateNV (GLuint state)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glIsStateNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glIsStateNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsStateNV (state);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStateCaptureNV (GLuint state, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glStateCaptureNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glStateCaptureNV)
  {
    prototypeCalled = true;
    glConfig.m_glStateCaptureNV (state, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGetCommandHeaderNV (GLenum tokenID, GLuint size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glGetCommandHeaderNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glGetCommandHeaderNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetCommandHeaderNV (tokenID, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLushort _glew_gl_glGetStageIndexNV (GLenum shadertype)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLushort result = ((GLushort)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glGetStageIndexNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glGetStageIndexNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetStageIndexNV (shadertype);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawCommandsNV (GLenum primitiveMode, GLuint buffer, const GLintptr * indirects, const GLsizei * sizes, GLuint count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glDrawCommandsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glDrawCommandsNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawCommandsNV (primitiveMode, buffer, indirects, sizes, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawCommandsAddressNV (GLenum primitiveMode, const GLuint64 * indirects, const GLsizei * sizes, GLuint count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glDrawCommandsAddressNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glDrawCommandsAddressNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawCommandsAddressNV (primitiveMode, indirects, sizes, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawCommandsStatesNV (GLuint buffer, const GLintptr * indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glDrawCommandsStatesNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glDrawCommandsStatesNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawCommandsStatesNV (buffer, indirects, sizes, states, fbos, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawCommandsStatesAddressNV (const GLuint64 * indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glDrawCommandsStatesAddressNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glDrawCommandsStatesAddressNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawCommandsStatesAddressNV (indirects, sizes, states, fbos, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCreateCommandListsNV (GLsizei n, GLuint * lists)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glCreateCommandListsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glCreateCommandListsNV)
  {
    prototypeCalled = true;
    glConfig.m_glCreateCommandListsNV (n, lists);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteCommandListsNV (GLsizei n, const GLuint * lists)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glDeleteCommandListsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glDeleteCommandListsNV)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteCommandListsNV (n, lists);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsCommandListNV (GLuint list)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glIsCommandListNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glIsCommandListNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsCommandListNV (list);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glListDrawCommandsStatesClientNV (GLuint list, GLuint segment, const void ** indirects, const GLsizei * sizes, const GLuint * states, const GLuint * fbos, GLuint count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glListDrawCommandsStatesClientNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glListDrawCommandsStatesClientNV)
  {
    prototypeCalled = true;
    glConfig.m_glListDrawCommandsStatesClientNV (list, segment, indirects, sizes, states, fbos, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCommandListSegmentsNV (GLuint list, GLuint segments)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glCommandListSegmentsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glCommandListSegmentsNV)
  {
    prototypeCalled = true;
    glConfig.m_glCommandListSegmentsNV (list, segments);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompileCommandListNV (GLuint list)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glCompileCommandListNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glCompileCommandListNV)
  {
    prototypeCalled = true;
    glConfig.m_glCompileCommandListNV (list);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCallCommandListNV (GLuint list)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_command_list - glCallCommandListNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_command_list] && glConfig.m_glCallCommandListNV)
  {
    prototypeCalled = true;
    glConfig.m_glCallCommandListNV (list);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginConditionalRenderNV (GLuint id, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_conditional_render - glBeginConditionalRenderNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_conditional_render] && glConfig.m_glBeginConditionalRenderNV)
  {
    prototypeCalled = true;
    glConfig.m_glBeginConditionalRenderNV (id, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndConditionalRenderNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_conditional_render - glEndConditionalRenderNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_conditional_render] && glConfig.m_glEndConditionalRenderNV)
  {
    prototypeCalled = true;
    glConfig.m_glEndConditionalRenderNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSubpixelPrecisionBiasNV (GLuint xbits, GLuint ybits)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_conservative_raster - glSubpixelPrecisionBiasNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_conservative_raster] && glConfig.m_glSubpixelPrecisionBiasNV)
  {
    prototypeCalled = true;
    glConfig.m_glSubpixelPrecisionBiasNV (xbits, ybits);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConservativeRasterParameterfNV (GLenum pname, GLfloat value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_conservative_raster_dilate - glConservativeRasterParameterfNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_conservative_raster_dilate] && glConfig.m_glConservativeRasterParameterfNV)
  {
    prototypeCalled = true;
    glConfig.m_glConservativeRasterParameterfNV (pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConservativeRasterParameteriNV (GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_conservative_raster_pre_snap_triangles - glConservativeRasterParameteriNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_conservative_raster_pre_snap_triangles] && glConfig.m_glConservativeRasterParameteriNV)
  {
    prototypeCalled = true;
    glConfig.m_glConservativeRasterParameteriNV (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyBufferSubDataNV (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_copy_buffer - glCopyBufferSubDataNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_copy_buffer] && glConfig.m_glCopyBufferSubDataNV)
  {
    prototypeCalled = true;
    glConfig.m_glCopyBufferSubDataNV (readTarget, writeTarget, readOffset, writeOffset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyImageSubDataNV (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_copy_image - glCopyImageSubDataNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_copy_image] && glConfig.m_glCopyImageSubDataNV)
  {
    prototypeCalled = true;
    glConfig.m_glCopyImageSubDataNV (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCoverageMaskNV (GLboolean mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_coverage_sample - glCoverageMaskNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_coverage_sample] && glConfig.m_glCoverageMaskNV)
  {
    prototypeCalled = true;
    glConfig.m_glCoverageMaskNV (mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCoverageOperationNV (GLenum operation)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_coverage_sample - glCoverageOperationNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_coverage_sample] && glConfig.m_glCoverageOperationNV)
  {
    prototypeCalled = true;
    glConfig.m_glCoverageOperationNV (operation);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangedNV (GLdouble zNear, GLdouble zFar)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_depth_buffer_float - glDepthRangedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_depth_buffer_float] && glConfig.m_glDepthRangedNV)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangedNV (zNear, zFar);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearDepthdNV (GLdouble depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_depth_buffer_float - glClearDepthdNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_depth_buffer_float] && glConfig.m_glClearDepthdNV)
  {
    prototypeCalled = true;
    glConfig.m_glClearDepthdNV (depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthBoundsdNV (GLdouble zmin, GLdouble zmax)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_depth_buffer_float - glDepthBoundsdNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_depth_buffer_float] && glConfig.m_glDepthBoundsdNV)
  {
    prototypeCalled = true;
    glConfig.m_glDepthBoundsdNV (zmin, zmax);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawBuffersNV (GLsizei n, const GLenum * bufs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_draw_buffers - glDrawBuffersNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_draw_buffers] && glConfig.m_glDrawBuffersNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawBuffersNV (n, bufs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawArraysInstancedNV (GLenum mode, GLint first, GLsizei count, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_draw_instanced - glDrawArraysInstancedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_draw_instanced] && glConfig.m_glDrawArraysInstancedNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawArraysInstancedNV (mode, first, count, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstancedNV (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_draw_instanced - glDrawElementsInstancedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_draw_instanced] && glConfig.m_glDrawElementsInstancedNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedNV (mode, count, type, indices, primcount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawTextureNV (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_draw_texture - glDrawTextureNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_draw_texture] && glConfig.m_glDrawTextureNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTextureNV (texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawVkImageNV (GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_draw_vulkan_image - glDrawVkImageNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_draw_vulkan_image] && glConfig.m_glDrawVkImageNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawVkImageNV (vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLVULKANPROCNV _glew_gl_glGetVkProcAddrNV (const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLVULKANPROCNV result = ((GLVULKANPROCNV)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_draw_vulkan_image - glGetVkProcAddrNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_draw_vulkan_image] && glConfig.m_glGetVkProcAddrNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetVkProcAddrNV (name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWaitVkSemaphoreNV (GLuint64 vkSemaphore)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_draw_vulkan_image - glWaitVkSemaphoreNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_draw_vulkan_image] && glConfig.m_glWaitVkSemaphoreNV)
  {
    prototypeCalled = true;
    glConfig.m_glWaitVkSemaphoreNV (vkSemaphore);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSignalVkSemaphoreNV (GLuint64 vkSemaphore)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_draw_vulkan_image - glSignalVkSemaphoreNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_draw_vulkan_image] && glConfig.m_glSignalVkSemaphoreNV)
  {
    prototypeCalled = true;
    glConfig.m_glSignalVkSemaphoreNV (vkSemaphore);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSignalVkFenceNV (GLuint64 vkFence)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_draw_vulkan_image - glSignalVkFenceNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_draw_vulkan_image] && glConfig.m_glSignalVkFenceNV)
  {
    prototypeCalled = true;
    glConfig.m_glSignalVkFenceNV (vkFence);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMapControlPointsNV (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_evaluators - glMapControlPointsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_evaluators] && glConfig.m_glMapControlPointsNV)
  {
    prototypeCalled = true;
    glConfig.m_glMapControlPointsNV (target, index, type, ustride, vstride, uorder, vorder, packed, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMapParameterivNV (GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_evaluators - glMapParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_evaluators] && glConfig.m_glMapParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glMapParameterivNV (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMapParameterfvNV (GLenum target, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_evaluators - glMapParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_evaluators] && glConfig.m_glMapParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glMapParameterfvNV (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMapControlPointsNV (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_evaluators - glGetMapControlPointsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_evaluators] && glConfig.m_glGetMapControlPointsNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetMapControlPointsNV (target, index, type, ustride, vstride, packed, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMapParameterivNV (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_evaluators - glGetMapParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_evaluators] && glConfig.m_glGetMapParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetMapParameterivNV (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMapParameterfvNV (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_evaluators - glGetMapParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_evaluators] && glConfig.m_glGetMapParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetMapParameterfvNV (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMapAttribParameterivNV (GLenum target, GLuint index, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_evaluators - glGetMapAttribParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_evaluators] && glConfig.m_glGetMapAttribParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetMapAttribParameterivNV (target, index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMapAttribParameterfvNV (GLenum target, GLuint index, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_evaluators - glGetMapAttribParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_evaluators] && glConfig.m_glGetMapAttribParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetMapAttribParameterfvNV (target, index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEvalMapsNV (GLenum target, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_evaluators - glEvalMapsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_evaluators] && glConfig.m_glEvalMapsNV)
  {
    prototypeCalled = true;
    glConfig.m_glEvalMapsNV (target, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMultisamplefvNV (GLenum pname, GLuint index, GLfloat * val)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_explicit_multisample - glGetMultisamplefvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_explicit_multisample] && glConfig.m_glGetMultisamplefvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetMultisamplefvNV (pname, index, val);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSampleMaskIndexedNV (GLuint index, GLbitfield mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_explicit_multisample - glSampleMaskIndexedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_explicit_multisample] && glConfig.m_glSampleMaskIndexedNV)
  {
    prototypeCalled = true;
    glConfig.m_glSampleMaskIndexedNV (index, mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexRenderbufferNV (GLenum target, GLuint renderbuffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_explicit_multisample - glTexRenderbufferNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_explicit_multisample] && glConfig.m_glTexRenderbufferNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexRenderbufferNV (target, renderbuffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteFencesNV (GLsizei n, const GLuint * fences)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fence - glDeleteFencesNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fence] && glConfig.m_glDeleteFencesNV)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteFencesNV (n, fences);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenFencesNV (GLsizei n, GLuint * fences)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fence - glGenFencesNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fence] && glConfig.m_glGenFencesNV)
  {
    prototypeCalled = true;
    glConfig.m_glGenFencesNV (n, fences);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsFenceNV (GLuint fence)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fence - glIsFenceNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fence] && glConfig.m_glIsFenceNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsFenceNV (fence);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glTestFenceNV (GLuint fence)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fence - glTestFenceNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fence] && glConfig.m_glTestFenceNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glTestFenceNV (fence);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFenceivNV (GLuint fence, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fence - glGetFenceivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fence] && glConfig.m_glGetFenceivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetFenceivNV (fence, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFinishFenceNV (GLuint fence)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fence - glFinishFenceNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fence] && glConfig.m_glFinishFenceNV)
  {
    prototypeCalled = true;
    glConfig.m_glFinishFenceNV (fence);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSetFenceNV (GLuint fence, GLenum condition)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fence - glSetFenceNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fence] && glConfig.m_glSetFenceNV)
  {
    prototypeCalled = true;
    glConfig.m_glSetFenceNV (fence, condition);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentCoverageColorNV (GLuint color)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fragment_coverage_to_color - glFragmentCoverageColorNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fragment_coverage_to_color] && glConfig.m_glFragmentCoverageColorNV)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentCoverageColorNV (color);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramNamedParameter4fNV (GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fragment_program - glProgramNamedParameter4fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fragment_program] && glConfig.m_glProgramNamedParameter4fNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramNamedParameter4fNV (id, len, name, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramNamedParameter4fvNV (GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fragment_program - glProgramNamedParameter4fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fragment_program] && glConfig.m_glProgramNamedParameter4fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramNamedParameter4fvNV (id, len, name, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramNamedParameter4dNV (GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fragment_program - glProgramNamedParameter4dNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fragment_program] && glConfig.m_glProgramNamedParameter4dNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramNamedParameter4dNV (id, len, name, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramNamedParameter4dvNV (GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fragment_program - glProgramNamedParameter4dvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fragment_program] && glConfig.m_glProgramNamedParameter4dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramNamedParameter4dvNV (id, len, name, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramNamedParameterfvNV (GLuint id, GLsizei len, const GLubyte * name, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fragment_program - glGetProgramNamedParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fragment_program] && glConfig.m_glGetProgramNamedParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramNamedParameterfvNV (id, len, name, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramNamedParameterdvNV (GLuint id, GLsizei len, const GLubyte * name, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_fragment_program - glGetProgramNamedParameterdvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_fragment_program] && glConfig.m_glGetProgramNamedParameterdvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramNamedParameterdvNV (id, len, name, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlitFramebufferNV (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_framebuffer_blit - glBlitFramebufferNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_framebuffer_blit] && glConfig.m_glBlitFramebufferNV)
  {
    prototypeCalled = true;
    glConfig.m_glBlitFramebufferNV (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCoverageModulationTableNV (GLsizei n, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_framebuffer_mixed_samples - glCoverageModulationTableNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_framebuffer_mixed_samples] && glConfig.m_glCoverageModulationTableNV)
  {
    prototypeCalled = true;
    glConfig.m_glCoverageModulationTableNV (n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCoverageModulationTableNV (GLsizei bufSize, GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_framebuffer_mixed_samples - glGetCoverageModulationTableNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_framebuffer_mixed_samples] && glConfig.m_glGetCoverageModulationTableNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetCoverageModulationTableNV (bufSize, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCoverageModulationNV (GLenum components)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_framebuffer_mixed_samples - glCoverageModulationNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_framebuffer_mixed_samples] && glConfig.m_glCoverageModulationNV)
  {
    prototypeCalled = true;
    glConfig.m_glCoverageModulationNV (components);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRenderbufferStorageMultisampleNV (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_framebuffer_multisample - glRenderbufferStorageMultisampleNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_framebuffer_multisample] && glConfig.m_glRenderbufferStorageMultisampleNV)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisampleNV (target, samples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRenderbufferStorageMultisampleCoverageNV (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_framebuffer_multisample_coverage - glRenderbufferStorageMultisampleCoverageNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_framebuffer_multisample_coverage] && glConfig.m_glRenderbufferStorageMultisampleCoverageNV)
  {
    prototypeCalled = true;
    glConfig.m_glRenderbufferStorageMultisampleCoverageNV (target, coverageSamples, colorSamples, internalformat, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramVertexLimitNV (GLenum target, GLint limit)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_geometry_program4 - glProgramVertexLimitNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_geometry_program4] && glConfig.m_glProgramVertexLimitNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramVertexLimitNV (target, limit);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTextureFaceEXT (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_geometry_program4 - glFramebufferTextureFaceEXT
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_geometry_program4] && glConfig.m_glFramebufferTextureFaceEXT)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureFaceEXT (target, attachment, texture, level, face);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramLocalParameterI4iNV (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramLocalParameterI4iNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramLocalParameterI4iNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameterI4iNV (target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramLocalParameterI4ivNV (GLenum target, GLuint index, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramLocalParameterI4ivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramLocalParameterI4ivNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameterI4ivNV (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramLocalParametersI4ivNV (GLenum target, GLuint index, GLsizei count, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramLocalParametersI4ivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramLocalParametersI4ivNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParametersI4ivNV (target, index, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramLocalParameterI4uiNV (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramLocalParameterI4uiNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramLocalParameterI4uiNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameterI4uiNV (target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramLocalParameterI4uivNV (GLenum target, GLuint index, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramLocalParameterI4uivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramLocalParameterI4uivNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParameterI4uivNV (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramLocalParametersI4uivNV (GLenum target, GLuint index, GLsizei count, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramLocalParametersI4uivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramLocalParametersI4uivNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramLocalParametersI4uivNV (target, index, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramEnvParameterI4iNV (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramEnvParameterI4iNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramEnvParameterI4iNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameterI4iNV (target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramEnvParameterI4ivNV (GLenum target, GLuint index, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramEnvParameterI4ivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramEnvParameterI4ivNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameterI4ivNV (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramEnvParametersI4ivNV (GLenum target, GLuint index, GLsizei count, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramEnvParametersI4ivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramEnvParametersI4ivNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParametersI4ivNV (target, index, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramEnvParameterI4uiNV (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramEnvParameterI4uiNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramEnvParameterI4uiNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameterI4uiNV (target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramEnvParameterI4uivNV (GLenum target, GLuint index, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramEnvParameterI4uivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramEnvParameterI4uivNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParameterI4uivNV (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramEnvParametersI4uivNV (GLenum target, GLuint index, GLsizei count, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glProgramEnvParametersI4uivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glProgramEnvParametersI4uivNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramEnvParametersI4uivNV (target, index, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramLocalParameterIivNV (GLenum target, GLuint index, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glGetProgramLocalParameterIivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glGetProgramLocalParameterIivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramLocalParameterIivNV (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramLocalParameterIuivNV (GLenum target, GLuint index, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glGetProgramLocalParameterIuivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glGetProgramLocalParameterIuivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramLocalParameterIuivNV (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramEnvParameterIivNV (GLenum target, GLuint index, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glGetProgramEnvParameterIivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glGetProgramEnvParameterIivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramEnvParameterIivNV (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramEnvParameterIuivNV (GLenum target, GLuint index, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program4 - glGetProgramEnvParameterIuivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] && glConfig.m_glGetProgramEnvParameterIuivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramEnvParameterIuivNV (target, index, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramSubroutineParametersuivNV (GLenum target, GLsizei count, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program5 - glProgramSubroutineParametersuivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program5] && glConfig.m_glProgramSubroutineParametersuivNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramSubroutineParametersuivNV (target, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramSubroutineParameteruivNV (GLenum target, GLuint index, GLuint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_program5 - glGetProgramSubroutineParameteruivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_program5] && glConfig.m_glGetProgramSubroutineParameteruivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramSubroutineParameteruivNV (target, index, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex2hNV (GLhalfNV x, GLhalfNV y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertex2hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertex2hNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertex2hNV (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex2hvNV (const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertex2hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertex2hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertex2hvNV (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex3hNV (GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertex3hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertex3hNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertex3hNV (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex3hvNV (const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertex3hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertex3hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertex3hvNV (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex4hNV (GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertex4hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertex4hNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertex4hNV (x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex4hvNV (const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertex4hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertex4hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertex4hvNV (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormal3hNV (GLhalfNV nx, GLhalfNV ny, GLhalfNV nz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glNormal3hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glNormal3hNV)
  {
    prototypeCalled = true;
    glConfig.m_glNormal3hNV (nx, ny, nz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormal3hvNV (const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glNormal3hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glNormal3hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glNormal3hvNV (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor3hNV (GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glColor3hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glColor3hNV)
  {
    prototypeCalled = true;
    glConfig.m_glColor3hNV (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor3hvNV (const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glColor3hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glColor3hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glColor3hvNV (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor4hNV (GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glColor4hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glColor4hNV)
  {
    prototypeCalled = true;
    glConfig.m_glColor4hNV (red, green, blue, alpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor4hvNV (const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glColor4hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glColor4hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glColor4hvNV (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord1hNV (GLhalfNV s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glTexCoord1hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glTexCoord1hNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord1hNV (s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord1hvNV (const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glTexCoord1hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glTexCoord1hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord1hvNV (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2hNV (GLhalfNV s, GLhalfNV t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glTexCoord2hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glTexCoord2hNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2hNV (s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2hvNV (const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glTexCoord2hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glTexCoord2hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2hvNV (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord3hNV (GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glTexCoord3hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glTexCoord3hNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord3hNV (s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord3hvNV (const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glTexCoord3hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glTexCoord3hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord3hvNV (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord4hNV (GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glTexCoord4hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glTexCoord4hNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord4hNV (s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord4hvNV (const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glTexCoord4hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glTexCoord4hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord4hvNV (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1hNV (GLenum target, GLhalfNV s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glMultiTexCoord1hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glMultiTexCoord1hNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1hNV (target, s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1hvNV (GLenum target, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glMultiTexCoord1hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glMultiTexCoord1hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1hvNV (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2hNV (GLenum target, GLhalfNV s, GLhalfNV t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glMultiTexCoord2hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glMultiTexCoord2hNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2hNV (target, s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2hvNV (GLenum target, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glMultiTexCoord2hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glMultiTexCoord2hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2hvNV (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3hNV (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glMultiTexCoord3hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glMultiTexCoord3hNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3hNV (target, s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3hvNV (GLenum target, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glMultiTexCoord3hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glMultiTexCoord3hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3hvNV (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4hNV (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glMultiTexCoord4hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glMultiTexCoord4hNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4hNV (target, s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4hvNV (GLenum target, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glMultiTexCoord4hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glMultiTexCoord4hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4hvNV (target, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1hNV (GLuint index, GLhalfNV x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttrib1hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttrib1hNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1hNV (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1hvNV (GLuint index, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttrib1hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttrib1hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1hvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2hNV (GLuint index, GLhalfNV x, GLhalfNV y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttrib2hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttrib2hNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2hNV (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2hvNV (GLuint index, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttrib2hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttrib2hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2hvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3hNV (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttrib3hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttrib3hNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3hNV (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3hvNV (GLuint index, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttrib3hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttrib3hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3hvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4hNV (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttrib4hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttrib4hNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4hNV (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4hvNV (GLuint index, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttrib4hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttrib4hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4hvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs1hvNV (GLuint index, GLsizei n, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttribs1hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttribs1hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs1hvNV (index, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs2hvNV (GLuint index, GLsizei n, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttribs2hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttribs2hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs2hvNV (index, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs3hvNV (GLuint index, GLsizei n, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttribs3hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttribs3hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs3hvNV (index, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs4hvNV (GLuint index, GLsizei n, const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexAttribs4hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexAttribs4hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs4hvNV (index, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoordhNV (GLhalfNV fog)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glFogCoordhNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glFogCoordhNV)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordhNV (fog);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoordhvNV (const GLhalfNV * fog)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glFogCoordhvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glFogCoordhvNV)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordhvNV (fog);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3hNV (GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glSecondaryColor3hNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glSecondaryColor3hNV)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3hNV (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColor3hvNV (const GLhalfNV * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glSecondaryColor3hvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glSecondaryColor3hvNV)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColor3hvNV (v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexWeighthNV (GLhalfNV weight)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexWeighthNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexWeighthNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexWeighthNV (weight);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexWeighthvNV (const GLhalfNV * weight)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_half_float - glVertexWeighthvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_half_float] && glConfig.m_glVertexWeighthvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexWeighthvNV (weight);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribDivisorNV (GLuint index, GLuint divisor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_instanced_arrays - glVertexAttribDivisorNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_instanced_arrays] && glConfig.m_glVertexAttribDivisorNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribDivisorNV (index, divisor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetInternalformatSampleivNV (GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei count, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_internalformat_sample_query - glGetInternalformatSampleivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_internalformat_sample_query] && glConfig.m_glGetInternalformatSampleivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetInternalformatSampleivNV (target, internalformat, samples, pname, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRenderGpuMaskNV (GLbitfield mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glRenderGpuMaskNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glRenderGpuMaskNV)
  {
    prototypeCalled = true;
    glConfig.m_glRenderGpuMaskNV (mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastBufferSubDataNV (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glMulticastBufferSubDataNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glMulticastBufferSubDataNV)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastBufferSubDataNV (gpuMask, buffer, offset, size, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastCopyBufferSubDataNV (GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glMulticastCopyBufferSubDataNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glMulticastCopyBufferSubDataNV)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastCopyBufferSubDataNV (readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastCopyImageSubDataNV (GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glMulticastCopyImageSubDataNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glMulticastCopyImageSubDataNV)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastCopyImageSubDataNV (srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastBlitFramebufferNV (GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glMulticastBlitFramebufferNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glMulticastBlitFramebufferNV)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastBlitFramebufferNV (srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastFramebufferSampleLocationsfvNV (GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glMulticastFramebufferSampleLocationsfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glMulticastFramebufferSampleLocationsfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastFramebufferSampleLocationsfvNV (gpu, framebuffer, start, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastBarrierNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glMulticastBarrierNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glMulticastBarrierNV)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastBarrierNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastWaitSyncNV (GLuint signalGpu, GLbitfield waitGpuMask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glMulticastWaitSyncNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glMulticastWaitSyncNV)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastWaitSyncNV (signalGpu, waitGpuMask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastGetQueryObjectivNV (GLuint gpu, GLuint id, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glMulticastGetQueryObjectivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glMulticastGetQueryObjectivNV)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastGetQueryObjectivNV (gpu, id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastGetQueryObjectuivNV (GLuint gpu, GLuint id, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glMulticastGetQueryObjectuivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glMulticastGetQueryObjectuivNV)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastGetQueryObjectuivNV (gpu, id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastGetQueryObjecti64vNV (GLuint gpu, GLuint id, GLenum pname, GLint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glMulticastGetQueryObjecti64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glMulticastGetQueryObjecti64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastGetQueryObjecti64vNV (gpu, id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastGetQueryObjectui64vNV (GLuint gpu, GLuint id, GLenum pname, GLuint64 * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_gpu_multicast - glMulticastGetQueryObjectui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] && glConfig.m_glMulticastGetQueryObjectui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastGetQueryObjectui64vNV (gpu, id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUploadGpuMaskNVX (GLbitfield mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_gpu_multicast2 - glUploadGpuMaskNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_gpu_multicast2] && glConfig.m_glUploadGpuMaskNVX)
  {
    prototypeCalled = true;
    glConfig.m_glUploadGpuMaskNVX (mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastViewportArrayvNVX (GLuint gpu, GLuint first, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_gpu_multicast2 - glMulticastViewportArrayvNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_gpu_multicast2] && glConfig.m_glMulticastViewportArrayvNVX)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastViewportArrayvNVX (gpu, first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastViewportPositionWScaleNVX (GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_gpu_multicast2 - glMulticastViewportPositionWScaleNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_gpu_multicast2] && glConfig.m_glMulticastViewportPositionWScaleNVX)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastViewportPositionWScaleNVX (gpu, index, xcoeff, ycoeff);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMulticastScissorArrayvNVX (GLuint gpu, GLuint first, GLsizei count, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_gpu_multicast2 - glMulticastScissorArrayvNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_gpu_multicast2] && glConfig.m_glMulticastScissorArrayvNVX)
  {
    prototypeCalled = true;
    glConfig.m_glMulticastScissorArrayvNVX (gpu, first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glAsyncCopyBufferSubDataNVX (GLsizei waitSemaphoreCount, const GLuint * waitSemaphoreArray, const GLuint64 * fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint * signalSemaphoreArray, const GLuint64 * signalValueArray)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_gpu_multicast2 - glAsyncCopyBufferSubDataNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_gpu_multicast2] && glConfig.m_glAsyncCopyBufferSubDataNVX)
  {
    prototypeCalled = true;
    result = glConfig.m_glAsyncCopyBufferSubDataNVX (waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glAsyncCopyImageSubDataNVX (GLsizei waitSemaphoreCount, const GLuint * waitSemaphoreArray, const GLuint64 * waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint * signalSemaphoreArray, const GLuint64 * signalValueArray)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_gpu_multicast2 - glAsyncCopyImageSubDataNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_gpu_multicast2] && glConfig.m_glAsyncCopyImageSubDataNVX)
  {
    prototypeCalled = true;
    result = glConfig.m_glAsyncCopyImageSubDataNVX (waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glCreateProgressFenceNVX ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_progress_fence - glCreateProgressFenceNVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_progress_fence] && glConfig.m_glCreateProgressFenceNVX)
  {
    prototypeCalled = true;
    result = glConfig.m_glCreateProgressFenceNVX ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSignalSemaphoreui64NVX (GLuint signalGpu, GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_progress_fence - glSignalSemaphoreui64NVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_progress_fence] && glConfig.m_glSignalSemaphoreui64NVX)
  {
    prototypeCalled = true;
    glConfig.m_glSignalSemaphoreui64NVX (signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWaitSemaphoreui64NVX (GLuint waitGpu, GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_progress_fence - glWaitSemaphoreui64NVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_progress_fence] && glConfig.m_glWaitSemaphoreui64NVX)
  {
    prototypeCalled = true;
    glConfig.m_glWaitSemaphoreui64NVX (waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClientWaitSemaphoreui64NVX (GLsizei fenceObjectCount, const GLuint * semaphoreArray, const GLuint64 * fenceValueArray)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NVX_progress_fence - glClientWaitSemaphoreui64NVX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NVX_progress_fence] && glConfig.m_glClientWaitSemaphoreui64NVX)
  {
    prototypeCalled = true;
    glConfig.m_glClientWaitSemaphoreui64NVX (fenceObjectCount, semaphoreArray, fenceValueArray);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMemoryObjectDetachedResourcesuivNV (GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_memory_attachment - glGetMemoryObjectDetachedResourcesuivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_memory_attachment] && glConfig.m_glGetMemoryObjectDetachedResourcesuivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetMemoryObjectDetachedResourcesuivNV (memory, pname, first, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glResetMemoryObjectParameterNV (GLuint memory, GLenum pname)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_memory_attachment - glResetMemoryObjectParameterNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_memory_attachment] && glConfig.m_glResetMemoryObjectParameterNV)
  {
    prototypeCalled = true;
    glConfig.m_glResetMemoryObjectParameterNV (memory, pname);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexAttachMemoryNV (GLenum target, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_memory_attachment - glTexAttachMemoryNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_memory_attachment] && glConfig.m_glTexAttachMemoryNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexAttachMemoryNV (target, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferAttachMemoryNV (GLenum target, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_memory_attachment - glBufferAttachMemoryNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_memory_attachment] && glConfig.m_glBufferAttachMemoryNV)
  {
    prototypeCalled = true;
    glConfig.m_glBufferAttachMemoryNV (target, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureAttachMemoryNV (GLuint texture, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_memory_attachment - glTextureAttachMemoryNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_memory_attachment] && glConfig.m_glTextureAttachMemoryNV)
  {
    prototypeCalled = true;
    glConfig.m_glTextureAttachMemoryNV (texture, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferAttachMemoryNV (GLuint buffer, GLuint memory, GLuint64 offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_memory_attachment - glNamedBufferAttachMemoryNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_memory_attachment] && glConfig.m_glNamedBufferAttachMemoryNV)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferAttachMemoryNV (buffer, memory, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferPageCommitmentMemNV (GLenum target, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_memory_object_sparse - glBufferPageCommitmentMemNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_memory_object_sparse] && glConfig.m_glBufferPageCommitmentMemNV)
  {
    prototypeCalled = true;
    glConfig.m_glBufferPageCommitmentMemNV (target, offset, size, memory, memOffset, commit);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexPageCommitmentMemNV (GLenum target, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_memory_object_sparse - glTexPageCommitmentMemNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_memory_object_sparse] && glConfig.m_glTexPageCommitmentMemNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexPageCommitmentMemNV (target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedBufferPageCommitmentMemNV (GLuint buffer, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_memory_object_sparse - glNamedBufferPageCommitmentMemNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_memory_object_sparse] && glConfig.m_glNamedBufferPageCommitmentMemNV)
  {
    prototypeCalled = true;
    glConfig.m_glNamedBufferPageCommitmentMemNV (buffer, offset, size, memory, memOffset, commit);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexturePageCommitmentMemNV (GLuint texture, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_memory_object_sparse - glTexturePageCommitmentMemNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_memory_object_sparse] && glConfig.m_glTexturePageCommitmentMemNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexturePageCommitmentMemNV (texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawMeshTasksNV (GLuint first, GLuint count)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_mesh_shader - glDrawMeshTasksNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_mesh_shader] && glConfig.m_glDrawMeshTasksNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawMeshTasksNV (first, count);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawMeshTasksIndirectNV (GLintptr indirect)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_mesh_shader - glDrawMeshTasksIndirectNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_mesh_shader] && glConfig.m_glDrawMeshTasksIndirectNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawMeshTasksIndirectNV (indirect);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawMeshTasksIndirectNV (GLintptr indirect, GLsizei drawcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_mesh_shader - glMultiDrawMeshTasksIndirectNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_mesh_shader] && glConfig.m_glMultiDrawMeshTasksIndirectNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawMeshTasksIndirectNV (indirect, drawcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiDrawMeshTasksIndirectCountNV (GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_mesh_shader - glMultiDrawMeshTasksIndirectCountNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_mesh_shader] && glConfig.m_glMultiDrawMeshTasksIndirectCountNV)
  {
    prototypeCalled = true;
    glConfig.m_glMultiDrawMeshTasksIndirectCountNV (indirect, drawcount, maxdrawcount, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix2x3fvNV (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_non_square_matrices - glUniformMatrix2x3fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix2x3fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x3fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix3x2fvNV (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_non_square_matrices - glUniformMatrix3x2fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix3x2fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x2fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix2x4fvNV (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_non_square_matrices - glUniformMatrix2x4fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix2x4fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix2x4fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix4x2fvNV (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_non_square_matrices - glUniformMatrix4x2fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix4x2fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x2fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix3x4fvNV (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_non_square_matrices - glUniformMatrix3x4fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix3x4fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix3x4fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformMatrix4x3fvNV (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_non_square_matrices - glUniformMatrix4x3fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] && glConfig.m_glUniformMatrix4x3fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformMatrix4x3fvNV (location, count, transpose, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenOcclusionQueriesNV (GLsizei n, GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_occlusion_query - glGenOcclusionQueriesNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_occlusion_query] && glConfig.m_glGenOcclusionQueriesNV)
  {
    prototypeCalled = true;
    glConfig.m_glGenOcclusionQueriesNV (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteOcclusionQueriesNV (GLsizei n, const GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_occlusion_query - glDeleteOcclusionQueriesNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_occlusion_query] && glConfig.m_glDeleteOcclusionQueriesNV)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteOcclusionQueriesNV (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsOcclusionQueryNV (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_occlusion_query - glIsOcclusionQueryNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_occlusion_query] && glConfig.m_glIsOcclusionQueryNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsOcclusionQueryNV (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginOcclusionQueryNV (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_occlusion_query - glBeginOcclusionQueryNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_occlusion_query] && glConfig.m_glBeginOcclusionQueryNV)
  {
    prototypeCalled = true;
    glConfig.m_glBeginOcclusionQueryNV (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndOcclusionQueryNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_occlusion_query - glEndOcclusionQueryNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_occlusion_query] && glConfig.m_glEndOcclusionQueryNV)
  {
    prototypeCalled = true;
    glConfig.m_glEndOcclusionQueryNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetOcclusionQueryivNV (GLuint id, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_occlusion_query - glGetOcclusionQueryivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_occlusion_query] && glConfig.m_glGetOcclusionQueryivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetOcclusionQueryivNV (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetOcclusionQueryuivNV (GLuint id, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_occlusion_query - glGetOcclusionQueryuivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_occlusion_query] && glConfig.m_glGetOcclusionQueryuivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetOcclusionQueryuivNV (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramBufferParametersfvNV (GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_parameter_buffer_object - glProgramBufferParametersfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_parameter_buffer_object] && glConfig.m_glProgramBufferParametersfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramBufferParametersfvNV (target, bindingIndex, wordIndex, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramBufferParametersIivNV (GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_parameter_buffer_object - glProgramBufferParametersIivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_parameter_buffer_object] && glConfig.m_glProgramBufferParametersIivNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramBufferParametersIivNV (target, bindingIndex, wordIndex, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramBufferParametersIuivNV (GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_parameter_buffer_object - glProgramBufferParametersIuivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_parameter_buffer_object] && glConfig.m_glProgramBufferParametersIuivNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramBufferParametersIuivNV (target, bindingIndex, wordIndex, count, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGenPathsNV (GLsizei range)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGenPathsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGenPathsNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glGenPathsNV (range);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeletePathsNV (GLuint path, GLsizei range)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glDeletePathsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glDeletePathsNV)
  {
    prototypeCalled = true;
    glConfig.m_glDeletePathsNV (path, range);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsPathNV (GLuint path)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glIsPathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glIsPathNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsPathNV (path);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathCommandsNV (GLuint path, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const void * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathCommandsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathCommandsNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathCommandsNV (path, numCommands, commands, numCoords, coordType, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathCoordsNV (GLuint path, GLsizei numCoords, GLenum coordType, const void * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathCoordsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathCoordsNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathCoordsNV (path, numCoords, coordType, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathSubCommandsNV (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const void * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathSubCommandsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathSubCommandsNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathSubCommandsNV (path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathSubCoordsNV (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathSubCoordsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathSubCoordsNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathSubCoordsNV (path, coordStart, numCoords, coordType, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathStringNV (GLuint path, GLenum format, GLsizei length, const void * pathString)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathStringNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathStringNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathStringNV (path, format, length, pathString);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathGlyphsNV (GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void * charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathGlyphsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathGlyphsNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathGlyphsNV (firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathGlyphRangeNV (GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathGlyphRangeNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathGlyphRangeNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathGlyphRangeNV (firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glWeightPathsNV (GLuint resultPath, GLsizei numPaths, const GLuint * paths, const GLfloat * weights)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glWeightPathsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glWeightPathsNV)
  {
    prototypeCalled = true;
    glConfig.m_glWeightPathsNV (resultPath, numPaths, paths, weights);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyPathNV (GLuint resultPath, GLuint srcPath)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glCopyPathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glCopyPathNV)
  {
    prototypeCalled = true;
    glConfig.m_glCopyPathNV (resultPath, srcPath);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInterpolatePathsNV (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glInterpolatePathsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glInterpolatePathsNV)
  {
    prototypeCalled = true;
    glConfig.m_glInterpolatePathsNV (resultPath, pathA, pathB, weight);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTransformPathNV (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat * transformValues)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glTransformPathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glTransformPathNV)
  {
    prototypeCalled = true;
    glConfig.m_glTransformPathNV (resultPath, srcPath, transformType, transformValues);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathParameterivNV (GLuint path, GLenum pname, const GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathParameterivNV (path, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathParameteriNV (GLuint path, GLenum pname, GLint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathParameteriNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathParameteriNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathParameteriNV (path, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathParameterfvNV (GLuint path, GLenum pname, const GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathParameterfvNV (path, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathParameterfNV (GLuint path, GLenum pname, GLfloat value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathParameterfNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathParameterfNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathParameterfNV (path, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathDashArrayNV (GLuint path, GLsizei dashCount, const GLfloat * dashArray)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathDashArrayNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathDashArrayNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathDashArrayNV (path, dashCount, dashArray);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathStencilFuncNV (GLenum func, GLint ref, GLuint mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathStencilFuncNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathStencilFuncNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathStencilFuncNV (func, ref, mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathStencilDepthOffsetNV (GLfloat factor, GLfloat units)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathStencilDepthOffsetNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathStencilDepthOffsetNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathStencilDepthOffsetNV (factor, units);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilFillPathNV (GLuint path, GLenum fillMode, GLuint mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glStencilFillPathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glStencilFillPathNV)
  {
    prototypeCalled = true;
    glConfig.m_glStencilFillPathNV (path, fillMode, mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilStrokePathNV (GLuint path, GLint reference, GLuint mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glStencilStrokePathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glStencilStrokePathNV)
  {
    prototypeCalled = true;
    glConfig.m_glStencilStrokePathNV (path, reference, mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilFillPathInstancedNV (GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat * transformValues)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glStencilFillPathInstancedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glStencilFillPathInstancedNV)
  {
    prototypeCalled = true;
    glConfig.m_glStencilFillPathInstancedNV (numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilStrokePathInstancedNV (GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat * transformValues)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glStencilStrokePathInstancedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glStencilStrokePathInstancedNV)
  {
    prototypeCalled = true;
    glConfig.m_glStencilStrokePathInstancedNV (numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathCoverDepthFuncNV (GLenum func)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathCoverDepthFuncNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathCoverDepthFuncNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathCoverDepthFuncNV (func);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCoverFillPathNV (GLuint path, GLenum coverMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glCoverFillPathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glCoverFillPathNV)
  {
    prototypeCalled = true;
    glConfig.m_glCoverFillPathNV (path, coverMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCoverStrokePathNV (GLuint path, GLenum coverMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glCoverStrokePathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glCoverStrokePathNV)
  {
    prototypeCalled = true;
    glConfig.m_glCoverStrokePathNV (path, coverMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCoverFillPathInstancedNV (GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glCoverFillPathInstancedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glCoverFillPathInstancedNV)
  {
    prototypeCalled = true;
    glConfig.m_glCoverFillPathInstancedNV (numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCoverStrokePathInstancedNV (GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glCoverStrokePathInstancedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glCoverStrokePathInstancedNV)
  {
    prototypeCalled = true;
    glConfig.m_glCoverStrokePathInstancedNV (numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathParameterivNV (GLuint path, GLenum pname, GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathParameterivNV (path, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathParameterfvNV (GLuint path, GLenum pname, GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathParameterfvNV (path, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathCommandsNV (GLuint path, GLubyte * commands)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathCommandsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathCommandsNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathCommandsNV (path, commands);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathCoordsNV (GLuint path, GLfloat * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathCoordsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathCoordsNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathCoordsNV (path, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathDashArrayNV (GLuint path, GLfloat * dashArray)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathDashArrayNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathDashArrayNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathDashArrayNV (path, dashArray);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathMetricsNV (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLsizei stride, GLfloat * metrics)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathMetricsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathMetricsNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathMetricsNV (metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathMetricRangeNV (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat * metrics)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathMetricRangeNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathMetricRangeNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathMetricRangeNV (metricQueryMask, firstPathName, numPaths, stride, metrics);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathSpacingNV (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat * returnedSpacing)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathSpacingNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathSpacingNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathSpacingNV (pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsPointInFillPathNV (GLuint path, GLuint mask, GLfloat x, GLfloat y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glIsPointInFillPathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glIsPointInFillPathNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsPointInFillPathNV (path, mask, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsPointInStrokePathNV (GLuint path, GLfloat x, GLfloat y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glIsPointInStrokePathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glIsPointInStrokePathNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsPointInStrokePathNV (path, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLfloat _glew_gl_glGetPathLengthNV (GLuint path, GLsizei startSegment, GLsizei numSegments)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLfloat result = ((GLfloat)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathLengthNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathLengthNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetPathLengthNV (path, startSegment, numSegments);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glPointAlongPathNV (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat * x, GLfloat * y, GLfloat * tangentX, GLfloat * tangentY)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPointAlongPathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPointAlongPathNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glPointAlongPathNV (path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixLoad3x2fNV (GLenum matrixMode, const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glMatrixLoad3x2fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixLoad3x2fNV)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoad3x2fNV (matrixMode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixLoad3x3fNV (GLenum matrixMode, const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glMatrixLoad3x3fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixLoad3x3fNV)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoad3x3fNV (matrixMode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixLoadTranspose3x3fNV (GLenum matrixMode, const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glMatrixLoadTranspose3x3fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixLoadTranspose3x3fNV)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixLoadTranspose3x3fNV (matrixMode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixMult3x2fNV (GLenum matrixMode, const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glMatrixMult3x2fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixMult3x2fNV)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixMult3x2fNV (matrixMode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixMult3x3fNV (GLenum matrixMode, const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glMatrixMult3x3fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixMult3x3fNV)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixMult3x3fNV (matrixMode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMatrixMultTranspose3x3fNV (GLenum matrixMode, const GLfloat * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glMatrixMultTranspose3x3fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glMatrixMultTranspose3x3fNV)
  {
    prototypeCalled = true;
    glConfig.m_glMatrixMultTranspose3x3fNV (matrixMode, m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilThenCoverFillPathNV (GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glStencilThenCoverFillPathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glStencilThenCoverFillPathNV)
  {
    prototypeCalled = true;
    glConfig.m_glStencilThenCoverFillPathNV (path, fillMode, mask, coverMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilThenCoverStrokePathNV (GLuint path, GLint reference, GLuint mask, GLenum coverMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glStencilThenCoverStrokePathNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glStencilThenCoverStrokePathNV)
  {
    prototypeCalled = true;
    glConfig.m_glStencilThenCoverStrokePathNV (path, reference, mask, coverMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilThenCoverFillPathInstancedNV (GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glStencilThenCoverFillPathInstancedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glStencilThenCoverFillPathInstancedNV)
  {
    prototypeCalled = true;
    glConfig.m_glStencilThenCoverFillPathInstancedNV (numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStencilThenCoverStrokePathInstancedNV (GLsizei numPaths, GLenum pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glStencilThenCoverStrokePathInstancedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glStencilThenCoverStrokePathInstancedNV)
  {
    prototypeCalled = true;
    glConfig.m_glStencilThenCoverStrokePathInstancedNV (numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glPathGlyphIndexRangeNV (GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint * baseAndCount)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathGlyphIndexRangeNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathGlyphIndexRangeNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glPathGlyphIndexRangeNV (fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glPathGlyphIndexArrayNV (GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathGlyphIndexArrayNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathGlyphIndexArrayNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glPathGlyphIndexArrayNV (firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glPathMemoryGlyphIndexArrayNV (GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void * fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathMemoryGlyphIndexArrayNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathMemoryGlyphIndexArrayNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glPathMemoryGlyphIndexArrayNV (firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramPathFragmentInputGenNV (GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat * coeffs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glProgramPathFragmentInputGenNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glProgramPathFragmentInputGenNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramPathFragmentInputGenNV (program, location, genMode, components, coeffs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramResourcefvNV (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei count, GLsizei * length, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetProgramResourcefvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetProgramResourcefvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramResourcefvNV (program, programInterface, index, propCount, props, count, length, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathColorGenNV (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat * coeffs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathColorGenNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathColorGenNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathColorGenNV (color, genMode, colorFormat, coeffs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathTexGenNV (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat * coeffs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathTexGenNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathTexGenNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathTexGenNV (texCoordSet, genMode, components, coeffs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPathFogGenNV (GLenum genMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glPathFogGenNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glPathFogGenNV)
  {
    prototypeCalled = true;
    glConfig.m_glPathFogGenNV (genMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathColorGenivNV (GLenum color, GLenum pname, GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathColorGenivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathColorGenivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathColorGenivNV (color, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathColorGenfvNV (GLenum color, GLenum pname, GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathColorGenfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathColorGenfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathColorGenfvNV (color, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathTexGenivNV (GLenum texCoordSet, GLenum pname, GLint * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathTexGenivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathTexGenivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathTexGenivNV (texCoordSet, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPathTexGenfvNV (GLenum texCoordSet, GLenum pname, GLfloat * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_path_rendering - glGetPathTexGenfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_path_rendering] && glConfig.m_glGetPathTexGenfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetPathTexGenfvNV (texCoordSet, pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelDataRangeNV (GLenum target, GLsizei length, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_pixel_data_range - glPixelDataRangeNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_pixel_data_range] && glConfig.m_glPixelDataRangeNV)
  {
    prototypeCalled = true;
    glConfig.m_glPixelDataRangeNV (target, length, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFlushPixelDataRangeNV (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_pixel_data_range - glFlushPixelDataRangeNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_pixel_data_range] && glConfig.m_glFlushPixelDataRangeNV)
  {
    prototypeCalled = true;
    glConfig.m_glFlushPixelDataRangeNV (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameteriNV (GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_point_sprite - glPointParameteriNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_point_sprite] && glConfig.m_glPointParameteriNV)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameteriNV (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameterivNV (GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_point_sprite - glPointParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_point_sprite] && glConfig.m_glPointParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterivNV (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPolygonModeNV (GLenum face, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_polygon_mode - glPolygonModeNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_polygon_mode] && glConfig.m_glPolygonModeNV)
  {
    prototypeCalled = true;
    glConfig.m_glPolygonModeNV (face, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPresentFrameKeyedNV (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_present_video - glPresentFrameKeyedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_present_video] && glConfig.m_glPresentFrameKeyedNV)
  {
    prototypeCalled = true;
    glConfig.m_glPresentFrameKeyedNV (video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPresentFrameDualFillNV (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_present_video - glPresentFrameDualFillNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_present_video] && glConfig.m_glPresentFrameDualFillNV)
  {
    prototypeCalled = true;
    glConfig.m_glPresentFrameDualFillNV (video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVideoivNV (GLuint video_slot, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_present_video - glGetVideoivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_present_video] && glConfig.m_glGetVideoivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVideoivNV (video_slot, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVideouivNV (GLuint video_slot, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_present_video - glGetVideouivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_present_video] && glConfig.m_glGetVideouivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVideouivNV (video_slot, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVideoi64vNV (GLuint video_slot, GLenum pname, GLint64EXT * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_present_video - glGetVideoi64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_present_video] && glConfig.m_glGetVideoi64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVideoi64vNV (video_slot, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVideoui64vNV (GLuint video_slot, GLenum pname, GLuint64EXT * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_present_video - glGetVideoui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_present_video] && glConfig.m_glGetVideoui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVideoui64vNV (video_slot, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPrimitiveRestartNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_primitive_restart - glPrimitiveRestartNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_primitive_restart] && glConfig.m_glPrimitiveRestartNV)
  {
    prototypeCalled = true;
    glConfig.m_glPrimitiveRestartNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPrimitiveRestartIndexNV (GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_primitive_restart - glPrimitiveRestartIndexNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_primitive_restart] && glConfig.m_glPrimitiveRestartIndexNV)
  {
    prototypeCalled = true;
    glConfig.m_glPrimitiveRestartIndexNV (index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glQueryResourceNV (GLenum queryType, GLint tagId, GLuint count, GLint * buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_query_resource - glQueryResourceNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_query_resource] && glConfig.m_glQueryResourceNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glQueryResourceNV (queryType, tagId, count, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenQueryResourceTagNV (GLsizei n, GLint * tagIds)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_query_resource_tag - glGenQueryResourceTagNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_query_resource_tag] && glConfig.m_glGenQueryResourceTagNV)
  {
    prototypeCalled = true;
    glConfig.m_glGenQueryResourceTagNV (n, tagIds);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteQueryResourceTagNV (GLsizei n, const GLint * tagIds)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_query_resource_tag - glDeleteQueryResourceTagNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_query_resource_tag] && glConfig.m_glDeleteQueryResourceTagNV)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteQueryResourceTagNV (n, tagIds);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glQueryResourceTagNV (GLint tagId, const GLchar * tagString)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_query_resource_tag - glQueryResourceTagNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_query_resource_tag] && glConfig.m_glQueryResourceTagNV)
  {
    prototypeCalled = true;
    glConfig.m_glQueryResourceTagNV (tagId, tagString);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReadBufferNV (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_read_buffer - glReadBufferNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_read_buffer] && glConfig.m_glReadBufferNV)
  {
    prototypeCalled = true;
    glConfig.m_glReadBufferNV (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCombinerParameterfvNV (GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glCombinerParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glCombinerParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glCombinerParameterfvNV (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCombinerParameterfNV (GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glCombinerParameterfNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glCombinerParameterfNV)
  {
    prototypeCalled = true;
    glConfig.m_glCombinerParameterfNV (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCombinerParameterivNV (GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glCombinerParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glCombinerParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glCombinerParameterivNV (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCombinerParameteriNV (GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glCombinerParameteriNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glCombinerParameteriNV)
  {
    prototypeCalled = true;
    glConfig.m_glCombinerParameteriNV (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCombinerInputNV (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glCombinerInputNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glCombinerInputNV)
  {
    prototypeCalled = true;
    glConfig.m_glCombinerInputNV (stage, portion, variable, input, mapping, componentUsage);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCombinerOutputNV (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glCombinerOutputNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glCombinerOutputNV)
  {
    prototypeCalled = true;
    glConfig.m_glCombinerOutputNV (stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFinalCombinerInputNV (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glFinalCombinerInputNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glFinalCombinerInputNV)
  {
    prototypeCalled = true;
    glConfig.m_glFinalCombinerInputNV (variable, input, mapping, componentUsage);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCombinerInputParameterfvNV (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glGetCombinerInputParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glGetCombinerInputParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetCombinerInputParameterfvNV (stage, portion, variable, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCombinerInputParameterivNV (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glGetCombinerInputParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glGetCombinerInputParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetCombinerInputParameterivNV (stage, portion, variable, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCombinerOutputParameterfvNV (GLenum stage, GLenum portion, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glGetCombinerOutputParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glGetCombinerOutputParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetCombinerOutputParameterfvNV (stage, portion, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCombinerOutputParameterivNV (GLenum stage, GLenum portion, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glGetCombinerOutputParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glGetCombinerOutputParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetCombinerOutputParameterivNV (stage, portion, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFinalCombinerInputParameterfvNV (GLenum variable, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glGetFinalCombinerInputParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glGetFinalCombinerInputParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetFinalCombinerInputParameterfvNV (variable, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFinalCombinerInputParameterivNV (GLenum variable, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners - glGetFinalCombinerInputParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners] && glConfig.m_glGetFinalCombinerInputParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetFinalCombinerInputParameterivNV (variable, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCombinerStageParameterfvNV (GLenum stage, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners2 - glCombinerStageParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners2] && glConfig.m_glCombinerStageParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glCombinerStageParameterfvNV (stage, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetCombinerStageParameterfvNV (GLenum stage, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_register_combiners2 - glGetCombinerStageParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_register_combiners2] && glConfig.m_glGetCombinerStageParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetCombinerStageParameterfvNV (stage, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferSampleLocationsfvNV (GLenum target, GLuint start, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_sample_locations - glFramebufferSampleLocationsfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_sample_locations] && glConfig.m_glFramebufferSampleLocationsfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferSampleLocationsfvNV (target, start, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferSampleLocationsfvNV (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_sample_locations - glNamedFramebufferSampleLocationsfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_sample_locations] && glConfig.m_glNamedFramebufferSampleLocationsfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferSampleLocationsfvNV (framebuffer, start, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glResolveDepthValuesNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_sample_locations - glResolveDepthValuesNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_sample_locations] && glConfig.m_glResolveDepthValuesNV)
  {
    prototypeCalled = true;
    glConfig.m_glResolveDepthValuesNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScissorExclusiveNV (GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_scissor_exclusive - glScissorExclusiveNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_scissor_exclusive] && glConfig.m_glScissorExclusiveNV)
  {
    prototypeCalled = true;
    glConfig.m_glScissorExclusiveNV (x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScissorExclusiveArrayvNV (GLuint first, GLsizei count, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_scissor_exclusive - glScissorExclusiveArrayvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_scissor_exclusive] && glConfig.m_glScissorExclusiveArrayvNV)
  {
    prototypeCalled = true;
    glConfig.m_glScissorExclusiveArrayvNV (first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeBufferResidentNV (GLenum target, GLenum access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glMakeBufferResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glMakeBufferResidentNV)
  {
    prototypeCalled = true;
    glConfig.m_glMakeBufferResidentNV (target, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeBufferNonResidentNV (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glMakeBufferNonResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glMakeBufferNonResidentNV)
  {
    prototypeCalled = true;
    glConfig.m_glMakeBufferNonResidentNV (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsBufferResidentNV (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glIsBufferResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glIsBufferResidentNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsBufferResidentNV (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeNamedBufferResidentNV (GLuint buffer, GLenum access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glMakeNamedBufferResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glMakeNamedBufferResidentNV)
  {
    prototypeCalled = true;
    glConfig.m_glMakeNamedBufferResidentNV (buffer, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMakeNamedBufferNonResidentNV (GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glMakeNamedBufferNonResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glMakeNamedBufferNonResidentNV)
  {
    prototypeCalled = true;
    glConfig.m_glMakeNamedBufferNonResidentNV (buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsNamedBufferResidentNV (GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glIsNamedBufferResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glIsNamedBufferResidentNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsNamedBufferResidentNV (buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetBufferParameterui64vNV (GLenum target, GLenum pname, GLuint64EXT * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glGetBufferParameterui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glGetBufferParameterui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferParameterui64vNV (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetNamedBufferParameterui64vNV (GLuint buffer, GLenum pname, GLuint64EXT * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glGetNamedBufferParameterui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glGetNamedBufferParameterui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetNamedBufferParameterui64vNV (buffer, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetIntegerui64vNV (GLenum value, GLuint64EXT * result)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glGetIntegerui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glGetIntegerui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetIntegerui64vNV (value, result);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformui64NV (GLint location, GLuint64EXT value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glUniformui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glUniformui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformui64NV (location, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glUniformui64vNV (GLint location, GLsizei count, const GLuint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glUniformui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glUniformui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glUniformui64vNV (location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformui64NV (GLuint program, GLint location, GLuint64EXT value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glProgramUniformui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glProgramUniformui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformui64NV (program, location, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramUniformui64vNV (GLuint program, GLint location, GLsizei count, const GLuint64EXT * value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shader_buffer_load - glProgramUniformui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] && glConfig.m_glProgramUniformui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramUniformui64vNV (program, location, count, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindShadingRateImageNV (GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shading_rate_image - glBindShadingRateImageNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shading_rate_image] && glConfig.m_glBindShadingRateImageNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindShadingRateImageNV (texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetShadingRateImagePaletteNV (GLuint viewport, GLuint entry, GLenum * rate)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shading_rate_image - glGetShadingRateImagePaletteNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shading_rate_image] && glConfig.m_glGetShadingRateImagePaletteNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetShadingRateImagePaletteNV (viewport, entry, rate);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetShadingRateSampleLocationivNV (GLenum rate, GLuint samples, GLuint index, GLint * location)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shading_rate_image - glGetShadingRateSampleLocationivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shading_rate_image] && glConfig.m_glGetShadingRateSampleLocationivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetShadingRateSampleLocationivNV (rate, samples, index, location);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShadingRateImageBarrierNV (GLboolean synchronize)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shading_rate_image - glShadingRateImageBarrierNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shading_rate_image] && glConfig.m_glShadingRateImageBarrierNV)
  {
    prototypeCalled = true;
    glConfig.m_glShadingRateImageBarrierNV (synchronize);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShadingRateImagePaletteNV (GLuint viewport, GLuint first, GLsizei count, const GLenum * rates)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shading_rate_image - glShadingRateImagePaletteNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shading_rate_image] && glConfig.m_glShadingRateImagePaletteNV)
  {
    prototypeCalled = true;
    glConfig.m_glShadingRateImagePaletteNV (viewport, first, count, rates);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShadingRateSampleOrderNV (GLenum order)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shading_rate_image - glShadingRateSampleOrderNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shading_rate_image] && glConfig.m_glShadingRateSampleOrderNV)
  {
    prototypeCalled = true;
    glConfig.m_glShadingRateSampleOrderNV (order);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShadingRateSampleOrderCustomNV (GLenum rate, GLuint samples, const GLint * locations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_shading_rate_image - glShadingRateSampleOrderCustomNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_shading_rate_image] && glConfig.m_glShadingRateSampleOrderCustomNV)
  {
    prototypeCalled = true;
    glConfig.m_glShadingRateSampleOrderCustomNV (rate, samples, locations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureBarrierNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_texture_barrier - glTextureBarrierNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_texture_barrier] && glConfig.m_glTextureBarrierNV)
  {
    prototypeCalled = true;
    glConfig.m_glTextureBarrierNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexImage2DMultisampleCoverageNV (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_texture_multisample - glTexImage2DMultisampleCoverageNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_texture_multisample] && glConfig.m_glTexImage2DMultisampleCoverageNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage2DMultisampleCoverageNV (target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexImage3DMultisampleCoverageNV (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_texture_multisample - glTexImage3DMultisampleCoverageNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_texture_multisample] && glConfig.m_glTexImage3DMultisampleCoverageNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage3DMultisampleCoverageNV (target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureImage2DMultisampleNV (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_texture_multisample - glTextureImage2DMultisampleNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_texture_multisample] && glConfig.m_glTextureImage2DMultisampleNV)
  {
    prototypeCalled = true;
    glConfig.m_glTextureImage2DMultisampleNV (texture, target, samples, internalFormat, width, height, fixedSampleLocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureImage3DMultisampleNV (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_texture_multisample - glTextureImage3DMultisampleNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_texture_multisample] && glConfig.m_glTextureImage3DMultisampleNV)
  {
    prototypeCalled = true;
    glConfig.m_glTextureImage3DMultisampleNV (texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureImage2DMultisampleCoverageNV (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_texture_multisample - glTextureImage2DMultisampleCoverageNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_texture_multisample] && glConfig.m_glTextureImage2DMultisampleCoverageNV)
  {
    prototypeCalled = true;
    glConfig.m_glTextureImage2DMultisampleCoverageNV (texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureImage3DMultisampleCoverageNV (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_texture_multisample - glTextureImage3DMultisampleCoverageNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_texture_multisample] && glConfig.m_glTextureImage3DMultisampleCoverageNV)
  {
    prototypeCalled = true;
    glConfig.m_glTextureImage3DMultisampleCoverageNV (texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginTransformFeedbackNV (GLenum primitiveMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glBeginTransformFeedbackNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glBeginTransformFeedbackNV)
  {
    prototypeCalled = true;
    glConfig.m_glBeginTransformFeedbackNV (primitiveMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndTransformFeedbackNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glEndTransformFeedbackNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glEndTransformFeedbackNV)
  {
    prototypeCalled = true;
    glConfig.m_glEndTransformFeedbackNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTransformFeedbackAttribsNV (GLsizei count, const GLint * attribs, GLenum bufferMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glTransformFeedbackAttribsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glTransformFeedbackAttribsNV)
  {
    prototypeCalled = true;
    glConfig.m_glTransformFeedbackAttribsNV (count, attribs, bufferMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBufferRangeNV (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glBindBufferRangeNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glBindBufferRangeNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferRangeNV (target, index, buffer, offset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBufferOffsetNV (GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glBindBufferOffsetNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glBindBufferOffsetNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferOffsetNV (target, index, buffer, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindBufferBaseNV (GLenum target, GLuint index, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glBindBufferBaseNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glBindBufferBaseNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindBufferBaseNV (target, index, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTransformFeedbackVaryingsNV (GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glTransformFeedbackVaryingsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glTransformFeedbackVaryingsNV)
  {
    prototypeCalled = true;
    glConfig.m_glTransformFeedbackVaryingsNV (program, count, locations, bufferMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glActiveVaryingNV (GLuint program, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glActiveVaryingNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glActiveVaryingNV)
  {
    prototypeCalled = true;
    glConfig.m_glActiveVaryingNV (program, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetVaryingLocationNV (GLuint program, const GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glGetVaryingLocationNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glGetVaryingLocationNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetVaryingLocationNV (program, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetActiveVaryingNV (GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glGetActiveVaryingNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glGetActiveVaryingNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetActiveVaryingNV (program, index, bufSize, length, size, type, name);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTransformFeedbackVaryingNV (GLuint program, GLuint index, GLint * location)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glGetTransformFeedbackVaryingNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glGetTransformFeedbackVaryingNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetTransformFeedbackVaryingNV (program, index, location);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTransformFeedbackStreamAttribsNV (GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback - glTransformFeedbackStreamAttribsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] && glConfig.m_glTransformFeedbackStreamAttribsNV)
  {
    prototypeCalled = true;
    glConfig.m_glTransformFeedbackStreamAttribsNV (count, attribs, nbuffers, bufstreams, bufferMode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindTransformFeedbackNV (GLenum target, GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback2 - glBindTransformFeedbackNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glBindTransformFeedbackNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindTransformFeedbackNV (target, id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteTransformFeedbacksNV (GLsizei n, const GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback2 - glDeleteTransformFeedbacksNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glDeleteTransformFeedbacksNV)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteTransformFeedbacksNV (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenTransformFeedbacksNV (GLsizei n, GLuint * ids)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback2 - glGenTransformFeedbacksNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glGenTransformFeedbacksNV)
  {
    prototypeCalled = true;
    glConfig.m_glGenTransformFeedbacksNV (n, ids);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsTransformFeedbackNV (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback2 - glIsTransformFeedbackNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glIsTransformFeedbackNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsTransformFeedbackNV (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPauseTransformFeedbackNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback2 - glPauseTransformFeedbackNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glPauseTransformFeedbackNV)
  {
    prototypeCalled = true;
    glConfig.m_glPauseTransformFeedbackNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glResumeTransformFeedbackNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback2 - glResumeTransformFeedbackNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glResumeTransformFeedbackNV)
  {
    prototypeCalled = true;
    glConfig.m_glResumeTransformFeedbackNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawTransformFeedbackNV (GLenum mode, GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_transform_feedback2 - glDrawTransformFeedbackNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] && glConfig.m_glDrawTransformFeedbackNV)
  {
    prototypeCalled = true;
    glConfig.m_glDrawTransformFeedbackNV (mode, id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVDPAUInitNV (const void * vdpDevice, const void * getProcAddress)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vdpau_interop - glVDPAUInitNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop] && glConfig.m_glVDPAUInitNV)
  {
    prototypeCalled = true;
    glConfig.m_glVDPAUInitNV (vdpDevice, getProcAddress);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVDPAUFiniNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vdpau_interop - glVDPAUFiniNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop] && glConfig.m_glVDPAUFiniNV)
  {
    prototypeCalled = true;
    glConfig.m_glVDPAUFiniNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLvdpauSurfaceNV _glew_gl_glVDPAURegisterVideoSurfaceNV (const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLvdpauSurfaceNV result = ((GLvdpauSurfaceNV)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vdpau_interop - glVDPAURegisterVideoSurfaceNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop] && glConfig.m_glVDPAURegisterVideoSurfaceNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glVDPAURegisterVideoSurfaceNV (vdpSurface, target, numTextureNames, textureNames);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLvdpauSurfaceNV _glew_gl_glVDPAURegisterOutputSurfaceNV (const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLvdpauSurfaceNV result = ((GLvdpauSurfaceNV)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vdpau_interop - glVDPAURegisterOutputSurfaceNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop] && glConfig.m_glVDPAURegisterOutputSurfaceNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glVDPAURegisterOutputSurfaceNV (vdpSurface, target, numTextureNames, textureNames);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glVDPAUIsSurfaceNV (GLvdpauSurfaceNV surface)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vdpau_interop - glVDPAUIsSurfaceNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop] && glConfig.m_glVDPAUIsSurfaceNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glVDPAUIsSurfaceNV (surface);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVDPAUUnregisterSurfaceNV (GLvdpauSurfaceNV surface)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vdpau_interop - glVDPAUUnregisterSurfaceNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop] && glConfig.m_glVDPAUUnregisterSurfaceNV)
  {
    prototypeCalled = true;
    glConfig.m_glVDPAUUnregisterSurfaceNV (surface);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVDPAUGetSurfaceivNV (GLvdpauSurfaceNV surface, GLenum pname, GLsizei count, GLsizei * length, GLint * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vdpau_interop - glVDPAUGetSurfaceivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop] && glConfig.m_glVDPAUGetSurfaceivNV)
  {
    prototypeCalled = true;
    glConfig.m_glVDPAUGetSurfaceivNV (surface, pname, count, length, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVDPAUSurfaceAccessNV (GLvdpauSurfaceNV surface, GLenum access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vdpau_interop - glVDPAUSurfaceAccessNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop] && glConfig.m_glVDPAUSurfaceAccessNV)
  {
    prototypeCalled = true;
    glConfig.m_glVDPAUSurfaceAccessNV (surface, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVDPAUMapSurfacesNV (GLsizei numSurfaces, const GLvdpauSurfaceNV * surfaces)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vdpau_interop - glVDPAUMapSurfacesNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop] && glConfig.m_glVDPAUMapSurfacesNV)
  {
    prototypeCalled = true;
    glConfig.m_glVDPAUMapSurfacesNV (numSurfaces, surfaces);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVDPAUUnmapSurfacesNV (GLsizei numSurface, const GLvdpauSurfaceNV * surfaces)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vdpau_interop - glVDPAUUnmapSurfacesNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop] && glConfig.m_glVDPAUUnmapSurfacesNV)
  {
    prototypeCalled = true;
    glConfig.m_glVDPAUUnmapSurfacesNV (numSurface, surfaces);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLvdpauSurfaceNV _glew_gl_glVDPAURegisterVideoSurfaceWithPictureStructureNV (const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames, GLboolean isFrameStructure)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLvdpauSurfaceNV result = ((GLvdpauSurfaceNV)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vdpau_interop2 - glVDPAURegisterVideoSurfaceWithPictureStructureNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop2] && glConfig.m_glVDPAURegisterVideoSurfaceWithPictureStructureNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glVDPAURegisterVideoSurfaceWithPictureStructureNV (vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFlushVertexArrayRangeNV ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_array_range - glFlushVertexArrayRangeNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_array_range] && glConfig.m_glFlushVertexArrayRangeNV)
  {
    prototypeCalled = true;
    glConfig.m_glFlushVertexArrayRangeNV ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexArrayRangeNV (GLsizei length, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_array_range - glVertexArrayRangeNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_array_range] && glConfig.m_glVertexArrayRangeNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexArrayRangeNV (length, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL1i64NV (GLuint index, GLint64EXT x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL1i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL1i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1i64NV (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL2i64NV (GLuint index, GLint64EXT x, GLint64EXT y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL2i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL2i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2i64NV (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL3i64NV (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL3i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL3i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3i64NV (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL4i64NV (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL4i64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL4i64NV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4i64NV (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL1i64vNV (GLuint index, const GLint64EXT * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL1i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL1i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1i64vNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL2i64vNV (GLuint index, const GLint64EXT * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL2i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL2i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2i64vNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL3i64vNV (GLuint index, const GLint64EXT * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL3i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL3i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3i64vNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL4i64vNV (GLuint index, const GLint64EXT * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL4i64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL4i64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4i64vNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL1ui64NV (GLuint index, GLuint64EXT x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL1ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL1ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1ui64NV (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL2ui64NV (GLuint index, GLuint64EXT x, GLuint64EXT y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL2ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL2ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2ui64NV (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL3ui64NV (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL3ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL3ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3ui64NV (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL4ui64NV (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL4ui64NV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL4ui64NV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4ui64NV (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL1ui64vNV (GLuint index, const GLuint64EXT * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL1ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL1ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL1ui64vNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL2ui64vNV (GLuint index, const GLuint64EXT * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL2ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL2ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL2ui64vNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL3ui64vNV (GLuint index, const GLuint64EXT * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL3ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL3ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL3ui64vNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribL4ui64vNV (GLuint index, const GLuint64EXT * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribL4ui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribL4ui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribL4ui64vNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribLi64vNV (GLuint index, GLenum pname, GLint64EXT * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glGetVertexAttribLi64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glGetVertexAttribLi64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribLi64vNV (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribLui64vNV (GLuint index, GLenum pname, GLuint64EXT * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glGetVertexAttribLui64vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glGetVertexAttribLui64vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribLui64vNV (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribLFormatNV (GLuint index, GLint size, GLenum type, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_attrib_integer_64bit - glVertexAttribLFormatNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] && glConfig.m_glVertexAttribLFormatNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribLFormatNV (index, size, type, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBufferAddressRangeNV (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glBufferAddressRangeNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glBufferAddressRangeNV)
  {
    prototypeCalled = true;
    glConfig.m_glBufferAddressRangeNV (pname, index, address, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexFormatNV (GLint size, GLenum type, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glVertexFormatNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glVertexFormatNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexFormatNV (size, type, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormalFormatNV (GLenum type, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glNormalFormatNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glNormalFormatNV)
  {
    prototypeCalled = true;
    glConfig.m_glNormalFormatNV (type, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorFormatNV (GLint size, GLenum type, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glColorFormatNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glColorFormatNV)
  {
    prototypeCalled = true;
    glConfig.m_glColorFormatNV (size, type, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glIndexFormatNV (GLenum type, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glIndexFormatNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glIndexFormatNV)
  {
    prototypeCalled = true;
    glConfig.m_glIndexFormatNV (type, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoordFormatNV (GLint size, GLenum type, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glTexCoordFormatNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glTexCoordFormatNV)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoordFormatNV (size, type, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEdgeFlagFormatNV (GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glEdgeFlagFormatNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glEdgeFlagFormatNV)
  {
    prototypeCalled = true;
    glConfig.m_glEdgeFlagFormatNV (stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSecondaryColorFormatNV (GLint size, GLenum type, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glSecondaryColorFormatNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glSecondaryColorFormatNV)
  {
    prototypeCalled = true;
    glConfig.m_glSecondaryColorFormatNV (size, type, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogCoordFormatNV (GLenum type, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glFogCoordFormatNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glFogCoordFormatNV)
  {
    prototypeCalled = true;
    glConfig.m_glFogCoordFormatNV (type, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribFormatNV (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glVertexAttribFormatNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glVertexAttribFormatNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribFormatNV (index, size, type, normalized, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribIFormatNV (GLuint index, GLint size, GLenum type, GLsizei stride)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glVertexAttribIFormatNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glVertexAttribIFormatNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribIFormatNV (index, size, type, stride);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetIntegerui64i_vNV (GLenum value, GLuint index, GLuint64EXT * result)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_buffer_unified_memory - glGetIntegerui64i_vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] && glConfig.m_glGetIntegerui64i_vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetIntegerui64i_vNV (value, index, result);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glAreProgramsResidentNV (GLsizei n, const GLuint * programs, GLboolean * residences)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glAreProgramsResidentNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glAreProgramsResidentNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glAreProgramsResidentNV (n, programs, residences);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindProgramNV (GLenum target, GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glBindProgramNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glBindProgramNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindProgramNV (target, id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteProgramsNV (GLsizei n, const GLuint * programs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glDeleteProgramsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glDeleteProgramsNV)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteProgramsNV (n, programs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExecuteProgramNV (GLenum target, GLuint id, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glExecuteProgramNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glExecuteProgramNV)
  {
    prototypeCalled = true;
    glConfig.m_glExecuteProgramNV (target, id, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenProgramsNV (GLsizei n, GLuint * programs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glGenProgramsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGenProgramsNV)
  {
    prototypeCalled = true;
    glConfig.m_glGenProgramsNV (n, programs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramParameterdvNV (GLenum target, GLuint index, GLenum pname, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glGetProgramParameterdvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetProgramParameterdvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramParameterdvNV (target, index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramParameterfvNV (GLenum target, GLuint index, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glGetProgramParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetProgramParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramParameterfvNV (target, index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramivNV (GLuint id, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glGetProgramivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetProgramivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramivNV (id, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramStringNV (GLuint id, GLenum pname, GLubyte * program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glGetProgramStringNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetProgramStringNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramStringNV (id, pname, program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTrackMatrixivNV (GLenum target, GLuint address, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glGetTrackMatrixivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetTrackMatrixivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetTrackMatrixivNV (target, address, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribdvNV (GLuint index, GLenum pname, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glGetVertexAttribdvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetVertexAttribdvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribdvNV (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribfvNV (GLuint index, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glGetVertexAttribfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetVertexAttribfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribfvNV (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribivNV (GLuint index, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glGetVertexAttribivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetVertexAttribivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribivNV (index, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVertexAttribPointervNV (GLuint index, GLenum pname, void ** pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glGetVertexAttribPointervNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glGetVertexAttribPointervNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVertexAttribPointervNV (index, pname, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsProgramNV (GLuint id)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glIsProgramNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glIsProgramNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsProgramNV (id);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLoadProgramNV (GLenum target, GLuint id, GLsizei len, const GLubyte * program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glLoadProgramNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glLoadProgramNV)
  {
    prototypeCalled = true;
    glConfig.m_glLoadProgramNV (target, id, len, program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramParameter4dNV (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glProgramParameter4dNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glProgramParameter4dNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameter4dNV (target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramParameter4dvNV (GLenum target, GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glProgramParameter4dvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glProgramParameter4dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameter4dvNV (target, index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramParameter4fNV (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glProgramParameter4fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glProgramParameter4fNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameter4fNV (target, index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramParameter4fvNV (GLenum target, GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glProgramParameter4fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glProgramParameter4fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameter4fvNV (target, index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramParameters4dvNV (GLenum target, GLuint index, GLsizei count, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glProgramParameters4dvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glProgramParameters4dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameters4dvNV (target, index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramParameters4fvNV (GLenum target, GLuint index, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glProgramParameters4fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glProgramParameters4fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glProgramParameters4fvNV (target, index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRequestResidentProgramsNV (GLsizei n, const GLuint * programs)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glRequestResidentProgramsNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glRequestResidentProgramsNV)
  {
    prototypeCalled = true;
    glConfig.m_glRequestResidentProgramsNV (n, programs);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTrackMatrixNV (GLenum target, GLuint address, GLenum matrix, GLenum transform)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glTrackMatrixNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glTrackMatrixNV)
  {
    prototypeCalled = true;
    glConfig.m_glTrackMatrixNV (target, address, matrix, transform);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribPointerNV (GLuint index, GLint fsize, GLenum type, GLsizei stride, const void * pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribPointerNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribPointerNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribPointerNV (index, fsize, type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1dNV (GLuint index, GLdouble x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib1dNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1dNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1dNV (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1dvNV (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib1dvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1dvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1fNV (GLuint index, GLfloat x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib1fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1fNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fNV (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1fvNV (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib1fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1fvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1sNV (GLuint index, GLshort x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib1sNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1sNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1sNV (index, x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib1svNV (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib1svNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib1svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib1svNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2dNV (GLuint index, GLdouble x, GLdouble y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib2dNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2dNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2dNV (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2dvNV (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib2dvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2dvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2fNV (GLuint index, GLfloat x, GLfloat y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib2fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2fNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fNV (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2fvNV (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib2fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2fvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2sNV (GLuint index, GLshort x, GLshort y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib2sNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2sNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2sNV (index, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib2svNV (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib2svNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib2svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib2svNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3dNV (GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib3dNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3dNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3dNV (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3dvNV (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib3dvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3dvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3fNV (GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib3fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3fNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fNV (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3fvNV (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib3fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3fvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3sNV (GLuint index, GLshort x, GLshort y, GLshort z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib3sNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3sNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3sNV (index, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib3svNV (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib3svNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib3svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib3svNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4dNV (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib4dNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4dNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4dNV (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4dvNV (GLuint index, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib4dvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4dvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4fNV (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib4fNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4fNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fNV (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4fvNV (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib4fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4fvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4sNV (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib4sNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4sNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4sNV (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4svNV (GLuint index, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib4svNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4svNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4ubNV (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib4ubNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4ubNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4ubNV (index, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttrib4ubvNV (GLuint index, const GLubyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttrib4ubvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttrib4ubvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttrib4ubvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs1dvNV (GLuint index, GLsizei count, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs1dvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs1dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs1dvNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs1fvNV (GLuint index, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs1fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs1fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs1fvNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs1svNV (GLuint index, GLsizei count, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs1svNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs1svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs1svNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs2dvNV (GLuint index, GLsizei count, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs2dvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs2dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs2dvNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs2fvNV (GLuint index, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs2fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs2fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs2fvNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs2svNV (GLuint index, GLsizei count, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs2svNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs2svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs2svNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs3dvNV (GLuint index, GLsizei count, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs3dvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs3dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs3dvNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs3fvNV (GLuint index, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs3fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs3fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs3fvNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs3svNV (GLuint index, GLsizei count, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs3svNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs3svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs3svNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs4dvNV (GLuint index, GLsizei count, const GLdouble * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs4dvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs4dvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs4dvNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs4fvNV (GLuint index, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs4fvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs4fvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs4fvNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs4svNV (GLuint index, GLsizei count, const GLshort * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs4svNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs4svNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs4svNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertexAttribs4ubvNV (GLuint index, GLsizei count, const GLubyte * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_vertex_program - glVertexAttribs4ubvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_vertex_program] && glConfig.m_glVertexAttribs4ubvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVertexAttribs4ubvNV (index, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBeginVideoCaptureNV (GLuint video_capture_slot)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glBeginVideoCaptureNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glBeginVideoCaptureNV)
  {
    prototypeCalled = true;
    glConfig.m_glBeginVideoCaptureNV (video_capture_slot);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindVideoCaptureStreamBufferNV (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glBindVideoCaptureStreamBufferNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glBindVideoCaptureStreamBufferNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindVideoCaptureStreamBufferNV (video_capture_slot, stream, frame_region, offset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindVideoCaptureStreamTextureNV (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glBindVideoCaptureStreamTextureNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glBindVideoCaptureStreamTextureNV)
  {
    prototypeCalled = true;
    glConfig.m_glBindVideoCaptureStreamTextureNV (video_capture_slot, stream, frame_region, target, texture);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndVideoCaptureNV (GLuint video_capture_slot)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glEndVideoCaptureNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glEndVideoCaptureNV)
  {
    prototypeCalled = true;
    glConfig.m_glEndVideoCaptureNV (video_capture_slot);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVideoCaptureivNV (GLuint video_capture_slot, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glGetVideoCaptureivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glGetVideoCaptureivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVideoCaptureivNV (video_capture_slot, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVideoCaptureStreamivNV (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glGetVideoCaptureStreamivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glGetVideoCaptureStreamivNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVideoCaptureStreamivNV (video_capture_slot, stream, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVideoCaptureStreamfvNV (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glGetVideoCaptureStreamfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glGetVideoCaptureStreamfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVideoCaptureStreamfvNV (video_capture_slot, stream, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetVideoCaptureStreamdvNV (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glGetVideoCaptureStreamdvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glGetVideoCaptureStreamdvNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetVideoCaptureStreamdvNV (video_capture_slot, stream, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLenum _glew_gl_glVideoCaptureNV (GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLenum result = ((GLenum)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glVideoCaptureNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glVideoCaptureNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glVideoCaptureNV (video_capture_slot, sequence_num, capture_time);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVideoCaptureStreamParameterivNV (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glVideoCaptureStreamParameterivNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glVideoCaptureStreamParameterivNV)
  {
    prototypeCalled = true;
    glConfig.m_glVideoCaptureStreamParameterivNV (video_capture_slot, stream, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVideoCaptureStreamParameterfvNV (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glVideoCaptureStreamParameterfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glVideoCaptureStreamParameterfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVideoCaptureStreamParameterfvNV (video_capture_slot, stream, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVideoCaptureStreamParameterdvNV (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_video_capture - glVideoCaptureStreamParameterdvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_video_capture] && glConfig.m_glVideoCaptureStreamParameterdvNV)
  {
    prototypeCalled = true;
    glConfig.m_glVideoCaptureStreamParameterdvNV (video_capture_slot, stream, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glViewportArrayvNV (GLuint first, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glViewportArrayvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glViewportArrayvNV)
  {
    prototypeCalled = true;
    glConfig.m_glViewportArrayvNV (first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glViewportIndexedfNV (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glViewportIndexedfNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glViewportIndexedfNV)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedfNV (index, x, y, w, h);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glViewportIndexedfvNV (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glViewportIndexedfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glViewportIndexedfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedfvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScissorArrayvNV (GLuint first, GLsizei count, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glScissorArrayvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glScissorArrayvNV)
  {
    prototypeCalled = true;
    glConfig.m_glScissorArrayvNV (first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScissorIndexedNV (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glScissorIndexedNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glScissorIndexedNV)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexedNV (index, left, bottom, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScissorIndexedvNV (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glScissorIndexedvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glScissorIndexedvNV)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexedvNV (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangeArrayfvNV (GLuint first, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glDepthRangeArrayfvNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glDepthRangeArrayfvNV)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangeArrayfvNV (first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangeIndexedfNV (GLuint index, GLfloat n, GLfloat f)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glDepthRangeIndexedfNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glDepthRangeIndexedfNV)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangeIndexedfNV (index, n, f);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFloati_vNV (GLenum target, GLuint index, GLfloat * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glGetFloati_vNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glGetFloati_vNV)
  {
    prototypeCalled = true;
    glConfig.m_glGetFloati_vNV (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableiNV (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glEnableiNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glEnableiNV)
  {
    prototypeCalled = true;
    glConfig.m_glEnableiNV (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableiNV (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glDisableiNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glDisableiNV)
  {
    prototypeCalled = true;
    glConfig.m_glDisableiNV (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsEnablediNV (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_array - glIsEnablediNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_array] && glConfig.m_glIsEnablediNV)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsEnablediNV (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glViewportSwizzleNV (GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_NV_viewport_swizzle - glViewportSwizzleNV
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_NV_viewport_swizzle] && glConfig.m_glViewportSwizzleNV)
  {
    prototypeCalled = true;
    glConfig.m_glViewportSwizzleNV (index, swizzlex, swizzley, swizzlez, swizzlew);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEGLImageTargetTexture2DOES (GLenum target, GLeglImageOES image)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_EGL_image - glEGLImageTargetTexture2DOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_EGL_image] && glConfig.m_glEGLImageTargetTexture2DOES)
  {
    prototypeCalled = true;
    glConfig.m_glEGLImageTargetTexture2DOES (target, image);
  }
  // GL_OES_EGL_image_external - glEGLImageTargetTexture2DOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_EGL_image_external] && glConfig.m_glEGLImageTargetTexture2DOES)
  {
    prototypeCalled = true;
    glConfig.m_glEGLImageTargetTexture2DOES (target, image);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEGLImageTargetRenderbufferStorageOES (GLenum target, GLeglImageOES image)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_EGL_image - glEGLImageTargetRenderbufferStorageOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_EGL_image] && glConfig.m_glEGLImageTargetRenderbufferStorageOES)
  {
    prototypeCalled = true;
    glConfig.m_glEGLImageTargetRenderbufferStorageOES (target, image);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1bOES (GLenum texture, GLbyte s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glMultiTexCoord1bOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glMultiTexCoord1bOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1bOES (texture, s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1bvOES (GLenum texture, const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glMultiTexCoord1bvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glMultiTexCoord1bvOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1bvOES (texture, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2bOES (GLenum texture, GLbyte s, GLbyte t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glMultiTexCoord2bOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glMultiTexCoord2bOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2bOES (texture, s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2bvOES (GLenum texture, const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glMultiTexCoord2bvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glMultiTexCoord2bvOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2bvOES (texture, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3bOES (GLenum texture, GLbyte s, GLbyte t, GLbyte r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glMultiTexCoord3bOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glMultiTexCoord3bOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3bOES (texture, s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3bvOES (GLenum texture, const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glMultiTexCoord3bvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glMultiTexCoord3bvOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3bvOES (texture, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4bOES (GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glMultiTexCoord4bOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glMultiTexCoord4bOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4bOES (texture, s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4bvOES (GLenum texture, const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glMultiTexCoord4bvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glMultiTexCoord4bvOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4bvOES (texture, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord1bOES (GLbyte s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glTexCoord1bOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glTexCoord1bOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord1bOES (s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord1bvOES (const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glTexCoord1bvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glTexCoord1bvOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord1bvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2bOES (GLbyte s, GLbyte t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glTexCoord2bOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glTexCoord2bOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2bOES (s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2bvOES (const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glTexCoord2bvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glTexCoord2bvOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2bvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord3bOES (GLbyte s, GLbyte t, GLbyte r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glTexCoord3bOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glTexCoord3bOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord3bOES (s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord3bvOES (const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glTexCoord3bvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glTexCoord3bvOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord3bvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord4bOES (GLbyte s, GLbyte t, GLbyte r, GLbyte q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glTexCoord4bOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glTexCoord4bOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord4bOES (s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord4bvOES (const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glTexCoord4bvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glTexCoord4bvOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord4bvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex2bOES (GLbyte x, GLbyte y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glVertex2bOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glVertex2bOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex2bOES (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex2bvOES (const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glVertex2bvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glVertex2bvOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex2bvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex3bOES (GLbyte x, GLbyte y, GLbyte z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glVertex3bOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glVertex3bOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex3bOES (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex3bvOES (const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glVertex3bvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glVertex3bvOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex3bvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex4bOES (GLbyte x, GLbyte y, GLbyte z, GLbyte w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glVertex4bOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glVertex4bOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex4bOES (x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex4bvOES (const GLbyte * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_byte_coordinates - glVertex4bvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] && glConfig.m_glVertex4bvOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex4bvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyImageSubDataOES (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_copy_image - glCopyImageSubDataOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_copy_image] && glConfig.m_glCopyImageSubDataOES)
  {
    prototypeCalled = true;
    glConfig.m_glCopyImageSubDataOES (srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableiOES (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_draw_buffers_indexed - glEnableiOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glEnableiOES)
  {
    prototypeCalled = true;
    glConfig.m_glEnableiOES (target, index);
  }
  // GL_OES_viewport_array - glEnableiOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glEnableiOES)
  {
    prototypeCalled = true;
    glConfig.m_glEnableiOES (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableiOES (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_draw_buffers_indexed - glDisableiOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glDisableiOES)
  {
    prototypeCalled = true;
    glConfig.m_glDisableiOES (target, index);
  }
  // GL_OES_viewport_array - glDisableiOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glDisableiOES)
  {
    prototypeCalled = true;
    glConfig.m_glDisableiOES (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationiOES (GLuint buf, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_draw_buffers_indexed - glBlendEquationiOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glBlendEquationiOES)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationiOES (buf, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendEquationSeparateiOES (GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_draw_buffers_indexed - glBlendEquationSeparateiOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glBlendEquationSeparateiOES)
  {
    prototypeCalled = true;
    glConfig.m_glBlendEquationSeparateiOES (buf, modeRGB, modeAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFunciOES (GLuint buf, GLenum src, GLenum dst)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_draw_buffers_indexed - glBlendFunciOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glBlendFunciOES)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFunciOES (buf, src, dst);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendFuncSeparateiOES (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_draw_buffers_indexed - glBlendFuncSeparateiOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glBlendFuncSeparateiOES)
  {
    prototypeCalled = true;
    glConfig.m_glBlendFuncSeparateiOES (buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorMaskiOES (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_draw_buffers_indexed - glColorMaskiOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glColorMaskiOES)
  {
    prototypeCalled = true;
    glConfig.m_glColorMaskiOES (index, r, g, b, a);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsEnablediOES (GLenum target, GLuint index)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_draw_buffers_indexed - glIsEnablediOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] && glConfig.m_glIsEnablediOES)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsEnablediOES (target, index);
  }
  // GL_OES_viewport_array - glIsEnablediOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glIsEnablediOES)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsEnablediOES (target, index);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsBaseVertexOES (GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_draw_elements_base_vertex - glDrawElementsBaseVertexOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_elements_base_vertex] && glConfig.m_glDrawElementsBaseVertexOES)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsBaseVertexOES (mode, count, type, indices, basevertex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawRangeElementsBaseVertexOES (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_draw_elements_base_vertex - glDrawRangeElementsBaseVertexOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_elements_base_vertex] && glConfig.m_glDrawRangeElementsBaseVertexOES)
  {
    prototypeCalled = true;
    glConfig.m_glDrawRangeElementsBaseVertexOES (mode, start, end, count, type, indices, basevertex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawElementsInstancedBaseVertexOES (GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_draw_elements_base_vertex - glDrawElementsInstancedBaseVertexOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_draw_elements_base_vertex] && glConfig.m_glDrawElementsInstancedBaseVertexOES)
  {
    prototypeCalled = true;
    glConfig.m_glDrawElementsInstancedBaseVertexOES (mode, count, type, indices, instancecount, basevertex);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glAlphaFuncxOES (GLenum func, GLfixed ref)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glAlphaFuncxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glAlphaFuncxOES)
  {
    prototypeCalled = true;
    glConfig.m_glAlphaFuncxOES (func, ref);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearColorxOES (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glClearColorxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glClearColorxOES)
  {
    prototypeCalled = true;
    glConfig.m_glClearColorxOES (red, green, blue, alpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearDepthxOES (GLfixed depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glClearDepthxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glClearDepthxOES)
  {
    prototypeCalled = true;
    glConfig.m_glClearDepthxOES (depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClipPlanexOES (GLenum plane, const GLfixed * equation)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glClipPlanexOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glClipPlanexOES)
  {
    prototypeCalled = true;
    glConfig.m_glClipPlanexOES (plane, equation);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor4xOES (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glColor4xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glColor4xOES)
  {
    prototypeCalled = true;
    glConfig.m_glColor4xOES (red, green, blue, alpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangexOES (GLfixed n, GLfixed f)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glDepthRangexOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glDepthRangexOES)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangexOES (n, f);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogxOES (GLenum pname, GLfixed param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glFogxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glFogxOES)
  {
    prototypeCalled = true;
    glConfig.m_glFogxOES (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogxvOES (GLenum pname, const GLfixed * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glFogxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glFogxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glFogxvOES (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFrustumxOES (GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glFrustumxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glFrustumxOES)
  {
    prototypeCalled = true;
    glConfig.m_glFrustumxOES (l, r, b, t, n, f);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetClipPlanexOES (GLenum plane, GLfixed * equation)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetClipPlanexOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetClipPlanexOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetClipPlanexOES (plane, equation);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFixedvOES (GLenum pname, GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetFixedvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetFixedvOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetFixedvOES (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexEnvxvOES (GLenum target, GLenum pname, GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetTexEnvxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetTexEnvxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexEnvxvOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexParameterxvOES (GLenum target, GLenum pname, GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetTexParameterxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetTexParameterxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterxvOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLightModelxOES (GLenum pname, GLfixed param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glLightModelxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glLightModelxOES)
  {
    prototypeCalled = true;
    glConfig.m_glLightModelxOES (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLightModelxvOES (GLenum pname, const GLfixed * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glLightModelxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glLightModelxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glLightModelxvOES (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLightxOES (GLenum light, GLenum pname, GLfixed param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glLightxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glLightxOES)
  {
    prototypeCalled = true;
    glConfig.m_glLightxOES (light, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLightxvOES (GLenum light, GLenum pname, const GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glLightxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glLightxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glLightxvOES (light, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLineWidthxOES (GLfixed width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glLineWidthxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glLineWidthxOES)
  {
    prototypeCalled = true;
    glConfig.m_glLineWidthxOES (width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLoadMatrixxOES (const GLfixed * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glLoadMatrixxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glLoadMatrixxOES)
  {
    prototypeCalled = true;
    glConfig.m_glLoadMatrixxOES (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMaterialxOES (GLenum face, GLenum pname, GLfixed param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMaterialxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMaterialxOES)
  {
    prototypeCalled = true;
    glConfig.m_glMaterialxOES (face, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMaterialxvOES (GLenum face, GLenum pname, const GLfixed * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMaterialxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMaterialxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glMaterialxvOES (face, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultMatrixxOES (const GLfixed * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMultMatrixxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMultMatrixxOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultMatrixxOES (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4xOES (GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMultiTexCoord4xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMultiTexCoord4xOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4xOES (texture, s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormal3xOES (GLfixed nx, GLfixed ny, GLfixed nz)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glNormal3xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glNormal3xOES)
  {
    prototypeCalled = true;
    glConfig.m_glNormal3xOES (nx, ny, nz);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glOrthoxOES (GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glOrthoxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glOrthoxOES)
  {
    prototypeCalled = true;
    glConfig.m_glOrthoxOES (l, r, b, t, n, f);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameterxvOES (GLenum pname, const GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glPointParameterxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glPointParameterxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterxvOES (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointSizexOES (GLfixed size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glPointSizexOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glPointSizexOES)
  {
    prototypeCalled = true;
    glConfig.m_glPointSizexOES (size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPolygonOffsetxOES (GLfixed factor, GLfixed units)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glPolygonOffsetxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glPolygonOffsetxOES)
  {
    prototypeCalled = true;
    glConfig.m_glPolygonOffsetxOES (factor, units);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRotatexOES (GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glRotatexOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glRotatexOES)
  {
    prototypeCalled = true;
    glConfig.m_glRotatexOES (angle, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScalexOES (GLfixed x, GLfixed y, GLfixed z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glScalexOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glScalexOES)
  {
    prototypeCalled = true;
    glConfig.m_glScalexOES (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexEnvxOES (GLenum target, GLenum pname, GLfixed param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexEnvxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexEnvxOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexEnvxOES (target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexEnvxvOES (GLenum target, GLenum pname, const GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexEnvxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexEnvxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexEnvxvOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexParameterxOES (GLenum target, GLenum pname, GLfixed param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexParameterxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexParameterxOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterxOES (target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexParameterxvOES (GLenum target, GLenum pname, const GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexParameterxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexParameterxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterxvOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTranslatexOES (GLfixed x, GLfixed y, GLfixed z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTranslatexOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTranslatexOES)
  {
    prototypeCalled = true;
    glConfig.m_glTranslatexOES (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glAccumxOES (GLenum op, GLfixed value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glAccumxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glAccumxOES)
  {
    prototypeCalled = true;
    glConfig.m_glAccumxOES (op, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBitmapxOES (GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte * bitmap)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glBitmapxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glBitmapxOES)
  {
    prototypeCalled = true;
    glConfig.m_glBitmapxOES (width, height, xorig, yorig, xmove, ymove, bitmap);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBlendColorxOES (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glBlendColorxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glBlendColorxOES)
  {
    prototypeCalled = true;
    glConfig.m_glBlendColorxOES (red, green, blue, alpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearAccumxOES (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glClearAccumxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glClearAccumxOES)
  {
    prototypeCalled = true;
    glConfig.m_glClearAccumxOES (red, green, blue, alpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor3xOES (GLfixed red, GLfixed green, GLfixed blue)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glColor3xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glColor3xOES)
  {
    prototypeCalled = true;
    glConfig.m_glColor3xOES (red, green, blue);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor3xvOES (const GLfixed * components)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glColor3xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glColor3xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glColor3xvOES (components);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor4xvOES (const GLfixed * components)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glColor4xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glColor4xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glColor4xvOES (components);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionParameterxOES (GLenum target, GLenum pname, GLfixed param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glConvolutionParameterxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glConvolutionParameterxOES)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameterxOES (target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glConvolutionParameterxvOES (GLenum target, GLenum pname, const GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glConvolutionParameterxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glConvolutionParameterxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glConvolutionParameterxvOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEvalCoord1xOES (GLfixed u)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glEvalCoord1xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glEvalCoord1xOES)
  {
    prototypeCalled = true;
    glConfig.m_glEvalCoord1xOES (u);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEvalCoord1xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glEvalCoord1xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glEvalCoord1xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glEvalCoord1xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEvalCoord2xOES (GLfixed u, GLfixed v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glEvalCoord2xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glEvalCoord2xOES)
  {
    prototypeCalled = true;
    glConfig.m_glEvalCoord2xOES (u, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEvalCoord2xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glEvalCoord2xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glEvalCoord2xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glEvalCoord2xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFeedbackBufferxOES (GLsizei n, GLenum type, const GLfixed * buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glFeedbackBufferxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glFeedbackBufferxOES)
  {
    prototypeCalled = true;
    glConfig.m_glFeedbackBufferxOES (n, type, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetConvolutionParameterxvOES (GLenum target, GLenum pname, GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetConvolutionParameterxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetConvolutionParameterxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetConvolutionParameterxvOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetHistogramParameterxvOES (GLenum target, GLenum pname, GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetHistogramParameterxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetHistogramParameterxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetHistogramParameterxvOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetLightxOES (GLenum light, GLenum pname, GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetLightxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetLightxOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetLightxOES (light, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMapxvOES (GLenum target, GLenum query, GLfixed * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetMapxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetMapxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetMapxvOES (target, query, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetMaterialxOES (GLenum face, GLenum pname, GLfixed param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetMaterialxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetMaterialxOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetMaterialxOES (face, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPixelMapxv (GLenum map, GLint size, GLfixed * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetPixelMapxv
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetPixelMapxv)
  {
    prototypeCalled = true;
    glConfig.m_glGetPixelMapxv (map, size, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexGenxvOES (GLenum coord, GLenum pname, GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetTexGenxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetTexGenxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexGenxvOES (coord, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexLevelParameterxvOES (GLenum target, GLint level, GLenum pname, GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glGetTexLevelParameterxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glGetTexLevelParameterxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexLevelParameterxvOES (target, level, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glIndexxOES (GLfixed component)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glIndexxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glIndexxOES)
  {
    prototypeCalled = true;
    glConfig.m_glIndexxOES (component);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glIndexxvOES (const GLfixed * component)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glIndexxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glIndexxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glIndexxvOES (component);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLoadTransposeMatrixxOES (const GLfixed * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glLoadTransposeMatrixxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glLoadTransposeMatrixxOES)
  {
    prototypeCalled = true;
    glConfig.m_glLoadTransposeMatrixxOES (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMap1xOES (GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMap1xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMap1xOES)
  {
    prototypeCalled = true;
    glConfig.m_glMap1xOES (target, u1, u2, stride, order, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMap2xOES (GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMap2xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMap2xOES)
  {
    prototypeCalled = true;
    glConfig.m_glMap2xOES (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMapGrid1xOES (GLint n, GLfixed u1, GLfixed u2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMapGrid1xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMapGrid1xOES)
  {
    prototypeCalled = true;
    glConfig.m_glMapGrid1xOES (n, u1, u2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMapGrid2xOES (GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMapGrid2xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMapGrid2xOES)
  {
    prototypeCalled = true;
    glConfig.m_glMapGrid2xOES (n, u1, u2, v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultTransposeMatrixxOES (const GLfixed * m)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMultTransposeMatrixxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMultTransposeMatrixxOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultTransposeMatrixxOES (m);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1xOES (GLenum texture, GLfixed s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMultiTexCoord1xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMultiTexCoord1xOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1xOES (texture, s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord1xvOES (GLenum texture, const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMultiTexCoord1xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMultiTexCoord1xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord1xvOES (texture, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2xOES (GLenum texture, GLfixed s, GLfixed t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMultiTexCoord2xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMultiTexCoord2xOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2xOES (texture, s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord2xvOES (GLenum texture, const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMultiTexCoord2xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMultiTexCoord2xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord2xvOES (texture, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3xOES (GLenum texture, GLfixed s, GLfixed t, GLfixed r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMultiTexCoord3xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMultiTexCoord3xOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3xOES (texture, s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord3xvOES (GLenum texture, const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMultiTexCoord3xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMultiTexCoord3xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord3xvOES (texture, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMultiTexCoord4xvOES (GLenum texture, const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glMultiTexCoord4xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glMultiTexCoord4xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glMultiTexCoord4xvOES (texture, coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormal3xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glNormal3xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glNormal3xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glNormal3xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPassThroughxOES (GLfixed token)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glPassThroughxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glPassThroughxOES)
  {
    prototypeCalled = true;
    glConfig.m_glPassThroughxOES (token);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelMapx (GLenum map, GLint size, const GLfixed * values)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glPixelMapx
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glPixelMapx)
  {
    prototypeCalled = true;
    glConfig.m_glPixelMapx (map, size, values);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelStorex (GLenum pname, GLfixed param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glPixelStorex
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glPixelStorex)
  {
    prototypeCalled = true;
    glConfig.m_glPixelStorex (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelTransferxOES (GLenum pname, GLfixed param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glPixelTransferxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glPixelTransferxOES)
  {
    prototypeCalled = true;
    glConfig.m_glPixelTransferxOES (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelZoomxOES (GLfixed xfactor, GLfixed yfactor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glPixelZoomxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glPixelZoomxOES)
  {
    prototypeCalled = true;
    glConfig.m_glPixelZoomxOES (xfactor, yfactor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPrioritizeTexturesxOES (GLsizei n, const GLuint * textures, const GLfixed * priorities)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glPrioritizeTexturesxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glPrioritizeTexturesxOES)
  {
    prototypeCalled = true;
    glConfig.m_glPrioritizeTexturesxOES (n, textures, priorities);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRasterPos2xOES (GLfixed x, GLfixed y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glRasterPos2xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glRasterPos2xOES)
  {
    prototypeCalled = true;
    glConfig.m_glRasterPos2xOES (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRasterPos2xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glRasterPos2xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glRasterPos2xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glRasterPos2xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRasterPos3xOES (GLfixed x, GLfixed y, GLfixed z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glRasterPos3xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glRasterPos3xOES)
  {
    prototypeCalled = true;
    glConfig.m_glRasterPos3xOES (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRasterPos3xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glRasterPos3xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glRasterPos3xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glRasterPos3xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRasterPos4xOES (GLfixed x, GLfixed y, GLfixed z, GLfixed w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glRasterPos4xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glRasterPos4xOES)
  {
    prototypeCalled = true;
    glConfig.m_glRasterPos4xOES (x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRasterPos4xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glRasterPos4xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glRasterPos4xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glRasterPos4xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRectxOES (GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glRectxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glRectxOES)
  {
    prototypeCalled = true;
    glConfig.m_glRectxOES (x1, y1, x2, y2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glRectxvOES (const GLfixed * v1, const GLfixed * v2)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glRectxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glRectxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glRectxvOES (v1, v2);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord1xOES (GLfixed s)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexCoord1xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexCoord1xOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord1xOES (s);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord1xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexCoord1xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexCoord1xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord1xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2xOES (GLfixed s, GLfixed t)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexCoord2xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexCoord2xOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2xOES (s, t);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexCoord2xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexCoord2xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord3xOES (GLfixed s, GLfixed t, GLfixed r)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexCoord3xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexCoord3xOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord3xOES (s, t, r);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord3xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexCoord3xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexCoord3xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord3xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord4xOES (GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexCoord4xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexCoord4xOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord4xOES (s, t, r, q);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord4xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexCoord4xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexCoord4xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord4xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexGenxOES (GLenum coord, GLenum pname, GLfixed param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexGenxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexGenxOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexGenxOES (coord, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexGenxvOES (GLenum coord, GLenum pname, const GLfixed * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glTexGenxvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glTexGenxvOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexGenxvOES (coord, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex2xOES (GLfixed x)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glVertex2xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glVertex2xOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex2xOES (x);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex2xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glVertex2xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glVertex2xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex2xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex3xOES (GLfixed x, GLfixed y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glVertex3xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glVertex3xOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex3xOES (x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex3xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glVertex3xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glVertex3xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex3xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex4xOES (GLfixed x, GLfixed y, GLfixed z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glVertex4xOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glVertex4xOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex4xOES (x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glVertex4xvOES (const GLfixed * coords)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_fixed_point - glVertex4xvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_fixed_point] && glConfig.m_glVertex4xvOES)
  {
    prototypeCalled = true;
    glConfig.m_glVertex4xvOES (coords);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTextureOES (GLenum target, GLenum attachment, GLuint texture, GLint level)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_geometry_shader - glFramebufferTextureOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_geometry_shader] && glConfig.m_glFramebufferTextureOES)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureOES (target, attachment, texture, level);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetProgramBinaryOES (GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, void * binary)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_get_program_binary - glGetProgramBinaryOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_get_program_binary] && glConfig.m_glGetProgramBinaryOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetProgramBinaryOES (program, bufSize, length, binaryFormat, binary);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glProgramBinaryOES (GLuint program, GLenum binaryFormat, const void * binary, GLint length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_get_program_binary - glProgramBinaryOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_get_program_binary] && glConfig.m_glProgramBinaryOES)
  {
    prototypeCalled = true;
    glConfig.m_glProgramBinaryOES (program, binaryFormat, binary, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void * _glew_gl_glMapBufferOES (GLenum target, GLenum access)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  void * result = ((void *)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_mapbuffer - glMapBufferOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_mapbuffer] && glConfig.m_glMapBufferOES)
  {
    prototypeCalled = true;
    result = glConfig.m_glMapBufferOES (target, access);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glUnmapBufferOES (GLenum target)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_mapbuffer - glUnmapBufferOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_mapbuffer] && glConfig.m_glUnmapBufferOES)
  {
    prototypeCalled = true;
    result = glConfig.m_glUnmapBufferOES (target);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetBufferPointervOES (GLenum target, GLenum pname, void ** params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_mapbuffer - glGetBufferPointervOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_mapbuffer] && glConfig.m_glGetBufferPointervOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetBufferPointervOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPrimitiveBoundingBoxOES (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_primitive_bounding_box - glPrimitiveBoundingBoxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_primitive_bounding_box] && glConfig.m_glPrimitiveBoundingBoxOES)
  {
    prototypeCalled = true;
    glConfig.m_glPrimitiveBoundingBoxOES (minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLbitfield _glew_gl_glQueryMatrixxOES (GLfixed * mantissa, GLint * exponent)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLbitfield result = ((GLbitfield)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_query_matrix - glQueryMatrixxOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_query_matrix] && glConfig.m_glQueryMatrixxOES)
  {
    prototypeCalled = true;
    result = glConfig.m_glQueryMatrixxOES (mantissa, exponent);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glMinSampleShadingOES (GLfloat value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_sample_shading - glMinSampleShadingOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_sample_shading] && glConfig.m_glMinSampleShadingOES)
  {
    prototypeCalled = true;
    glConfig.m_glMinSampleShadingOES (value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClearDepthfOES (GLclampf depth)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_single_precision - glClearDepthfOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_single_precision] && glConfig.m_glClearDepthfOES)
  {
    prototypeCalled = true;
    glConfig.m_glClearDepthfOES (depth);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glClipPlanefOES (GLenum plane, const GLfloat * equation)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_single_precision - glClipPlanefOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_single_precision] && glConfig.m_glClipPlanefOES)
  {
    prototypeCalled = true;
    glConfig.m_glClipPlanefOES (plane, equation);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangefOES (GLclampf n, GLclampf f)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_single_precision - glDepthRangefOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_single_precision] && glConfig.m_glDepthRangefOES)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangefOES (n, f);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFrustumfOES (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_single_precision - glFrustumfOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_single_precision] && glConfig.m_glFrustumfOES)
  {
    prototypeCalled = true;
    glConfig.m_glFrustumfOES (l, r, b, t, n, f);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetClipPlanefOES (GLenum plane, GLfloat * equation)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_single_precision - glGetClipPlanefOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_single_precision] && glConfig.m_glGetClipPlanefOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetClipPlanefOES (plane, equation);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glOrthofOES (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_single_precision - glOrthofOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_single_precision] && glConfig.m_glOrthofOES)
  {
    prototypeCalled = true;
    glConfig.m_glOrthofOES (l, r, b, t, n, f);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPatchParameteriOES (GLenum pname, GLint value)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_tessellation_shader - glPatchParameteriOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_tessellation_shader] && glConfig.m_glPatchParameteriOES)
  {
    prototypeCalled = true;
    glConfig.m_glPatchParameteriOES (pname, value);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexImage3DOES (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_3D - glTexImage3DOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_3D] && glConfig.m_glTexImage3DOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage3DOES (target, level, internalformat, width, height, depth, border, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexSubImage3DOES (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_3D - glTexSubImage3DOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_3D] && glConfig.m_glTexSubImage3DOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexSubImage3DOES (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyTexSubImage3DOES (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_3D - glCopyTexSubImage3DOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_3D] && glConfig.m_glCopyTexSubImage3DOES)
  {
    prototypeCalled = true;
    glConfig.m_glCopyTexSubImage3DOES (target, level, xoffset, yoffset, zoffset, x, y, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexImage3DOES (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_3D - glCompressedTexImage3DOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_3D] && glConfig.m_glCompressedTexImage3DOES)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexImage3DOES (target, level, internalformat, width, height, depth, border, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCompressedTexSubImage3DOES (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_3D - glCompressedTexSubImage3DOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_3D] && glConfig.m_glCompressedTexSubImage3DOES)
  {
    prototypeCalled = true;
    glConfig.m_glCompressedTexSubImage3DOES (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTexture3DOES (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_3D - glFramebufferTexture3DOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_3D] && glConfig.m_glFramebufferTexture3DOES)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTexture3DOES (target, attachment, textarget, texture, level, zoffset);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexParameterIivOES (GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_border_clamp - glTexParameterIivOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glTexParameterIivOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIivOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexParameterIuivOES (GLenum target, GLenum pname, const GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_border_clamp - glTexParameterIuivOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glTexParameterIuivOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexParameterIuivOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexParameterIivOES (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_border_clamp - glGetTexParameterIivOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glGetTexParameterIivOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIivOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexParameterIuivOES (GLenum target, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_border_clamp - glGetTexParameterIuivOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glGetTexParameterIuivOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexParameterIuivOES (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplerParameterIivOES (GLuint sampler, GLenum pname, const GLint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_border_clamp - glSamplerParameterIivOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glSamplerParameterIivOES)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIivOES (sampler, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplerParameterIuivOES (GLuint sampler, GLenum pname, const GLuint * param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_border_clamp - glSamplerParameterIuivOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glSamplerParameterIuivOES)
  {
    prototypeCalled = true;
    glConfig.m_glSamplerParameterIuivOES (sampler, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSamplerParameterIivOES (GLuint sampler, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_border_clamp - glGetSamplerParameterIivOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glGetSamplerParameterIivOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIivOES (sampler, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSamplerParameterIuivOES (GLuint sampler, GLenum pname, GLuint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_border_clamp - glGetSamplerParameterIuivOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] && glConfig.m_glGetSamplerParameterIuivOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetSamplerParameterIuivOES (sampler, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexBufferOES (GLenum target, GLenum internalformat, GLuint buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_buffer - glTexBufferOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_buffer] && glConfig.m_glTexBufferOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferOES (target, internalformat, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexBufferRangeOES (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_buffer - glTexBufferRangeOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_buffer] && glConfig.m_glTexBufferRangeOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexBufferRangeOES (target, internalformat, buffer, offset, size);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexStorage3DMultisampleOES (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_storage_multisample_2d_array - glTexStorage3DMultisampleOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_storage_multisample_2d_array] && glConfig.m_glTexStorage3DMultisampleOES)
  {
    prototypeCalled = true;
    glConfig.m_glTexStorage3DMultisampleOES (target, samples, internalformat, width, height, depth, fixedsamplelocations);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureViewOES (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_texture_view - glTextureViewOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_texture_view] && glConfig.m_glTextureViewOES)
  {
    prototypeCalled = true;
    glConfig.m_glTextureViewOES (texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glBindVertexArrayOES (GLuint array)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_vertex_array_object - glBindVertexArrayOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_vertex_array_object] && glConfig.m_glBindVertexArrayOES)
  {
    prototypeCalled = true;
    glConfig.m_glBindVertexArrayOES (array);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteVertexArraysOES (GLsizei n, const GLuint * arrays)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_vertex_array_object - glDeleteVertexArraysOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_vertex_array_object] && glConfig.m_glDeleteVertexArraysOES)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteVertexArraysOES (n, arrays);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGenVertexArraysOES (GLsizei n, GLuint * arrays)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_vertex_array_object - glGenVertexArraysOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_vertex_array_object] && glConfig.m_glGenVertexArraysOES)
  {
    prototypeCalled = true;
    glConfig.m_glGenVertexArraysOES (n, arrays);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsVertexArrayOES (GLuint array)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_vertex_array_object - glIsVertexArrayOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_vertex_array_object] && glConfig.m_glIsVertexArrayOES)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsVertexArrayOES (array);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glViewportArrayvOES (GLuint first, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_viewport_array - glViewportArrayvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glViewportArrayvOES)
  {
    prototypeCalled = true;
    glConfig.m_glViewportArrayvOES (first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glViewportIndexedfOES (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_viewport_array - glViewportIndexedfOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glViewportIndexedfOES)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedfOES (index, x, y, w, h);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glViewportIndexedfvOES (GLuint index, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_viewport_array - glViewportIndexedfvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glViewportIndexedfvOES)
  {
    prototypeCalled = true;
    glConfig.m_glViewportIndexedfvOES (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScissorArrayvOES (GLuint first, GLsizei count, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_viewport_array - glScissorArrayvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glScissorArrayvOES)
  {
    prototypeCalled = true;
    glConfig.m_glScissorArrayvOES (first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScissorIndexedOES (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_viewport_array - glScissorIndexedOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glScissorIndexedOES)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexedOES (index, left, bottom, width, height);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glScissorIndexedvOES (GLuint index, const GLint * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_viewport_array - glScissorIndexedvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glScissorIndexedvOES)
  {
    prototypeCalled = true;
    glConfig.m_glScissorIndexedvOES (index, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangeArrayfvOES (GLuint first, GLsizei count, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_viewport_array - glDepthRangeArrayfvOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glDepthRangeArrayfvOES)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangeArrayfvOES (first, count, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDepthRangeIndexedfOES (GLuint index, GLfloat n, GLfloat f)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_viewport_array - glDepthRangeIndexedfOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glDepthRangeIndexedfOES)
  {
    prototypeCalled = true;
    glConfig.m_glDepthRangeIndexedfOES (index, n, f);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFloati_vOES (GLenum target, GLuint index, GLfloat * data)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OES_viewport_array - glGetFloati_vOES
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OES_viewport_array] && glConfig.m_glGetFloati_vOES)
  {
    prototypeCalled = true;
    glConfig.m_glGetFloati_vOES (target, index, data);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTextureMultiviewOVR (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OVR_multiview - glFramebufferTextureMultiviewOVR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OVR_multiview] && glConfig.m_glFramebufferTextureMultiviewOVR)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureMultiviewOVR (target, attachment, texture, level, baseViewIndex, numViews);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNamedFramebufferTextureMultiviewOVR (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OVR_multiview - glNamedFramebufferTextureMultiviewOVR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OVR_multiview] && glConfig.m_glNamedFramebufferTextureMultiviewOVR)
  {
    prototypeCalled = true;
    glConfig.m_glNamedFramebufferTextureMultiviewOVR (framebuffer, attachment, texture, level, baseViewIndex, numViews);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferTextureMultisampleMultiviewOVR (GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_OVR_multiview_multisampled_render_to_texture - glFramebufferTextureMultisampleMultiviewOVR
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_OVR_multiview_multisampled_render_to_texture] && glConfig.m_glFramebufferTextureMultisampleMultiviewOVR)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferTextureMultisampleMultiviewOVR (target, attachment, texture, level, samples, baseViewIndex, numViews);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glHintPGI (GLenum target, GLint mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_PGI_misc_hints - glHintPGI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_PGI_misc_hints] && glConfig.m_glHintPGI)
  {
    prototypeCalled = true;
    glConfig.m_glHintPGI (target, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glAlphaFuncQCOM (GLenum func, GLclampf ref)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_alpha_test - glAlphaFuncQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_alpha_test] && glConfig.m_glAlphaFuncQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glAlphaFuncQCOM (func, ref);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetDriverControlsQCOM (GLint * num, GLsizei size, GLuint * driverControls)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_driver_control - glGetDriverControlsQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_driver_control] && glConfig.m_glGetDriverControlsQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glGetDriverControlsQCOM (num, size, driverControls);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetDriverControlStringQCOM (GLuint driverControl, GLsizei bufSize, GLsizei * length, GLchar * driverControlString)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_driver_control - glGetDriverControlStringQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_driver_control] && glConfig.m_glGetDriverControlStringQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glGetDriverControlStringQCOM (driverControl, bufSize, length, driverControlString);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEnableDriverControlQCOM (GLuint driverControl)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_driver_control - glEnableDriverControlQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_driver_control] && glConfig.m_glEnableDriverControlQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glEnableDriverControlQCOM (driverControl);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDisableDriverControlQCOM (GLuint driverControl)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_driver_control - glDisableDriverControlQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_driver_control] && glConfig.m_glDisableDriverControlQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glDisableDriverControlQCOM (driverControl);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtGetTexturesQCOM (GLuint * textures, GLint maxTextures, GLint * numTextures)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get - glExtGetTexturesQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get] && glConfig.m_glExtGetTexturesQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtGetTexturesQCOM (textures, maxTextures, numTextures);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtGetBuffersQCOM (GLuint * buffers, GLint maxBuffers, GLint * numBuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get - glExtGetBuffersQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get] && glConfig.m_glExtGetBuffersQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtGetBuffersQCOM (buffers, maxBuffers, numBuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtGetRenderbuffersQCOM (GLuint * renderbuffers, GLint maxRenderbuffers, GLint * numRenderbuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get - glExtGetRenderbuffersQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get] && glConfig.m_glExtGetRenderbuffersQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtGetRenderbuffersQCOM (renderbuffers, maxRenderbuffers, numRenderbuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtGetFramebuffersQCOM (GLuint * framebuffers, GLint maxFramebuffers, GLint * numFramebuffers)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get - glExtGetFramebuffersQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get] && glConfig.m_glExtGetFramebuffersQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtGetFramebuffersQCOM (framebuffers, maxFramebuffers, numFramebuffers);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtGetTexLevelParameterivQCOM (GLuint texture, GLenum face, GLint level, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get - glExtGetTexLevelParameterivQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get] && glConfig.m_glExtGetTexLevelParameterivQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtGetTexLevelParameterivQCOM (texture, face, level, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtTexObjectStateOverrideiQCOM (GLenum target, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get - glExtTexObjectStateOverrideiQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get] && glConfig.m_glExtTexObjectStateOverrideiQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtTexObjectStateOverrideiQCOM (target, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtGetTexSubImageQCOM (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void * texels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get - glExtGetTexSubImageQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get] && glConfig.m_glExtGetTexSubImageQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtGetTexSubImageQCOM (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtGetBufferPointervQCOM (GLenum target, void ** params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get - glExtGetBufferPointervQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get] && glConfig.m_glExtGetBufferPointervQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtGetBufferPointervQCOM (target, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtGetShadersQCOM (GLuint * shaders, GLint maxShaders, GLint * numShaders)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get2 - glExtGetShadersQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get2] && glConfig.m_glExtGetShadersQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtGetShadersQCOM (shaders, maxShaders, numShaders);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtGetProgramsQCOM (GLuint * programs, GLint maxPrograms, GLint * numPrograms)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get2 - glExtGetProgramsQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get2] && glConfig.m_glExtGetProgramsQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtGetProgramsQCOM (programs, maxPrograms, numPrograms);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glExtIsProgramBinaryQCOM (GLuint program)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get2 - glExtIsProgramBinaryQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get2] && glConfig.m_glExtIsProgramBinaryQCOM)
  {
    prototypeCalled = true;
    result = glConfig.m_glExtIsProgramBinaryQCOM (program);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtGetProgramBinarySourceQCOM (GLuint program, GLenum shadertype, GLchar * source, GLint * length)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_extended_get2 - glExtGetProgramBinarySourceQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_extended_get2] && glConfig.m_glExtGetProgramBinarySourceQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtGetProgramBinarySourceQCOM (program, shadertype, source, length);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferFoveationConfigQCOM (GLuint framebuffer, GLuint numLayers, GLuint focalPointsPerLayer, GLuint requestedFeatures, GLuint * providedFeatures)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_framebuffer_foveated - glFramebufferFoveationConfigQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_framebuffer_foveated] && glConfig.m_glFramebufferFoveationConfigQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferFoveationConfigQCOM (framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, providedFeatures);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferFoveationParametersQCOM (GLuint framebuffer, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_framebuffer_foveated - glFramebufferFoveationParametersQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_framebuffer_foveated] && glConfig.m_glFramebufferFoveationParametersQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferFoveationParametersQCOM (framebuffer, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexEstimateMotionQCOM (GLuint ref, GLuint target, GLuint output)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_motion_estimation - glTexEstimateMotionQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_motion_estimation] && glConfig.m_glTexEstimateMotionQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glTexEstimateMotionQCOM (ref, target, output);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexEstimateMotionRegionsQCOM (GLuint ref, GLuint target, GLuint output, GLuint mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_motion_estimation - glTexEstimateMotionRegionsQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_motion_estimation] && glConfig.m_glTexEstimateMotionRegionsQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glTexEstimateMotionRegionsQCOM (ref, target, output, mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glExtrapolateTex2DQCOM (GLuint src1, GLuint src2, GLuint output, GLfloat scaleFactor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_frame_extrapolation - glExtrapolateTex2DQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_frame_extrapolation] && glConfig.m_glExtrapolateTex2DQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glExtrapolateTex2DQCOM (src1, src2, output, scaleFactor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureFoveationParametersQCOM (GLuint texture, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_texture_foveated - glTextureFoveationParametersQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_texture_foveated] && glConfig.m_glTextureFoveationParametersQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glTextureFoveationParametersQCOM (texture, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFramebufferFetchBarrierQCOM ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_shader_framebuffer_fetch_noncoherent - glFramebufferFetchBarrierQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_shader_framebuffer_fetch_noncoherent] && glConfig.m_glFramebufferFetchBarrierQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glFramebufferFetchBarrierQCOM ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glShadingRateQCOM (GLenum rate)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_shading_rate - glShadingRateQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_shading_rate] && glConfig.m_glShadingRateQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glShadingRateQCOM (rate);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStartTilingQCOM (GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_tiled_rendering - glStartTilingQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_tiled_rendering] && glConfig.m_glStartTilingQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glStartTilingQCOM (x, y, width, height, preserveMask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glEndTilingQCOM (GLbitfield preserveMask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_QCOM_tiled_rendering - glEndTilingQCOM
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_QCOM_tiled_rendering] && glConfig.m_glEndTilingQCOM)
  {
    prototypeCalled = true;
    glConfig.m_glEndTilingQCOM (preserveMask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDetailTexFuncSGIS (GLenum target, GLsizei n, const GLfloat * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_detail_texture - glDetailTexFuncSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_detail_texture] && glConfig.m_glDetailTexFuncSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glDetailTexFuncSGIS (target, n, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetDetailTexFuncSGIS (GLenum target, GLfloat * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_detail_texture - glGetDetailTexFuncSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_detail_texture] && glConfig.m_glGetDetailTexFuncSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glGetDetailTexFuncSGIS (target, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFogFuncSGIS (GLsizei n, const GLfloat * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_fog_function - glFogFuncSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_fog_function] && glConfig.m_glFogFuncSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glFogFuncSGIS (n, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFogFuncSGIS (GLfloat * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_fog_function - glGetFogFuncSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_fog_function] && glConfig.m_glGetFogFuncSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glGetFogFuncSGIS (points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSampleMaskSGIS (GLclampf value, GLboolean invert)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_multisample - glSampleMaskSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_multisample] && glConfig.m_glSampleMaskSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glSampleMaskSGIS (value, invert);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSamplePatternSGIS (GLenum pattern)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_multisample - glSamplePatternSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_multisample] && glConfig.m_glSamplePatternSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glSamplePatternSGIS (pattern);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelTexGenParameteriSGIS (GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_pixel_texture - glPixelTexGenParameteriSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_pixel_texture] && glConfig.m_glPixelTexGenParameteriSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glPixelTexGenParameteriSGIS (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelTexGenParameterivSGIS (GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_pixel_texture - glPixelTexGenParameterivSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_pixel_texture] && glConfig.m_glPixelTexGenParameterivSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glPixelTexGenParameterivSGIS (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelTexGenParameterfSGIS (GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_pixel_texture - glPixelTexGenParameterfSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_pixel_texture] && glConfig.m_glPixelTexGenParameterfSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glPixelTexGenParameterfSGIS (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelTexGenParameterfvSGIS (GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_pixel_texture - glPixelTexGenParameterfvSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_pixel_texture] && glConfig.m_glPixelTexGenParameterfvSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glPixelTexGenParameterfvSGIS (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPixelTexGenParameterivSGIS (GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_pixel_texture - glGetPixelTexGenParameterivSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_pixel_texture] && glConfig.m_glGetPixelTexGenParameterivSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glGetPixelTexGenParameterivSGIS (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetPixelTexGenParameterfvSGIS (GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_pixel_texture - glGetPixelTexGenParameterfvSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_pixel_texture] && glConfig.m_glGetPixelTexGenParameterfvSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glGetPixelTexGenParameterfvSGIS (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameterfSGIS (GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_point_parameters - glPointParameterfSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_point_parameters] && glConfig.m_glPointParameterfSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfSGIS (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPointParameterfvSGIS (GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_point_parameters - glPointParameterfvSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_point_parameters] && glConfig.m_glPointParameterfvSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glPointParameterfvSGIS (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSharpenTexFuncSGIS (GLenum target, GLsizei n, const GLfloat * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_sharpen_texture - glSharpenTexFuncSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_sharpen_texture] && glConfig.m_glSharpenTexFuncSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glSharpenTexFuncSGIS (target, n, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetSharpenTexFuncSGIS (GLenum target, GLfloat * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_sharpen_texture - glGetSharpenTexFuncSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_sharpen_texture] && glConfig.m_glGetSharpenTexFuncSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glGetSharpenTexFuncSGIS (target, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexImage4DSGIS (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_texture4D - glTexImage4DSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_texture4D] && glConfig.m_glTexImage4DSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glTexImage4DSGIS (target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexSubImage4DSGIS (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void * pixels)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_texture4D - glTexSubImage4DSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_texture4D] && glConfig.m_glTexSubImage4DSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glTexSubImage4DSGIS (target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTextureColorMaskSGIS (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_texture_color_mask - glTextureColorMaskSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_texture_color_mask] && glConfig.m_glTextureColorMaskSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glTextureColorMaskSGIS (red, green, blue, alpha);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetTexFilterFuncSGIS (GLenum target, GLenum filter, GLfloat * weights)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_texture_filter4 - glGetTexFilterFuncSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_texture_filter4] && glConfig.m_glGetTexFilterFuncSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glGetTexFilterFuncSGIS (target, filter, weights);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexFilterFuncSGIS (GLenum target, GLenum filter, GLsizei n, const GLfloat * weights)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIS_texture_filter4 - glTexFilterFuncSGIS
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIS_texture_filter4] && glConfig.m_glTexFilterFuncSGIS)
  {
    prototypeCalled = true;
    glConfig.m_glTexFilterFuncSGIS (target, filter, n, weights);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glAsyncMarkerSGIX (GLuint marker)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_async - glAsyncMarkerSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_async] && glConfig.m_glAsyncMarkerSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glAsyncMarkerSGIX (marker);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glFinishAsyncSGIX (GLuint * markerp)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_async - glFinishAsyncSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_async] && glConfig.m_glFinishAsyncSGIX)
  {
    prototypeCalled = true;
    result = glConfig.m_glFinishAsyncSGIX (markerp);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glPollAsyncSGIX (GLuint * markerp)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_async - glPollAsyncSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_async] && glConfig.m_glPollAsyncSGIX)
  {
    prototypeCalled = true;
    result = glConfig.m_glPollAsyncSGIX (markerp);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLuint _glew_gl_glGenAsyncMarkersSGIX (GLsizei range)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLuint result = ((GLuint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_async - glGenAsyncMarkersSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_async] && glConfig.m_glGenAsyncMarkersSGIX)
  {
    prototypeCalled = true;
    result = glConfig.m_glGenAsyncMarkersSGIX (range);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeleteAsyncMarkersSGIX (GLuint marker, GLsizei range)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_async - glDeleteAsyncMarkersSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_async] && glConfig.m_glDeleteAsyncMarkersSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glDeleteAsyncMarkersSGIX (marker, range);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLboolean _glew_gl_glIsAsyncMarkerSGIX (GLuint marker)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLboolean result = ((GLboolean)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_async - glIsAsyncMarkerSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_async] && glConfig.m_glIsAsyncMarkerSGIX)
  {
    prototypeCalled = true;
    result = glConfig.m_glIsAsyncMarkerSGIX (marker);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFlushRasterSGIX ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_flush_raster - glFlushRasterSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_flush_raster] && glConfig.m_glFlushRasterSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFlushRasterSGIX ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentColorMaterialSGIX (GLenum face, GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentColorMaterialSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentColorMaterialSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentColorMaterialSGIX (face, mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentLightfSGIX (GLenum light, GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentLightfSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentLightfSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentLightfSGIX (light, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentLightfvSGIX (GLenum light, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentLightfvSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentLightfvSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentLightfvSGIX (light, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentLightiSGIX (GLenum light, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentLightiSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentLightiSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentLightiSGIX (light, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentLightivSGIX (GLenum light, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentLightivSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentLightivSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentLightivSGIX (light, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentLightModelfSGIX (GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentLightModelfSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentLightModelfSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentLightModelfSGIX (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentLightModelfvSGIX (GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentLightModelfvSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentLightModelfvSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentLightModelfvSGIX (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentLightModeliSGIX (GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentLightModeliSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentLightModeliSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentLightModeliSGIX (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentLightModelivSGIX (GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentLightModelivSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentLightModelivSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentLightModelivSGIX (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentMaterialfSGIX (GLenum face, GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentMaterialfSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentMaterialfSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentMaterialfSGIX (face, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentMaterialfvSGIX (GLenum face, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentMaterialfvSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentMaterialfvSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentMaterialfvSGIX (face, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentMaterialiSGIX (GLenum face, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentMaterialiSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentMaterialiSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentMaterialiSGIX (face, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFragmentMaterialivSGIX (GLenum face, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glFragmentMaterialivSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glFragmentMaterialivSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFragmentMaterialivSGIX (face, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFragmentLightfvSGIX (GLenum light, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glGetFragmentLightfvSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glGetFragmentLightfvSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glGetFragmentLightfvSGIX (light, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFragmentLightivSGIX (GLenum light, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glGetFragmentLightivSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glGetFragmentLightivSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glGetFragmentLightivSGIX (light, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFragmentMaterialfvSGIX (GLenum face, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glGetFragmentMaterialfvSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glGetFragmentMaterialfvSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glGetFragmentMaterialfvSGIX (face, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetFragmentMaterialivSGIX (GLenum face, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glGetFragmentMaterialivSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glGetFragmentMaterialivSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glGetFragmentMaterialivSGIX (face, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLightEnviSGIX (GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_fragment_lighting - glLightEnviSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] && glConfig.m_glLightEnviSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glLightEnviSGIX (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFrameZoomSGIX (GLint factor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_framezoom - glFrameZoomSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_framezoom] && glConfig.m_glFrameZoomSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glFrameZoomSGIX (factor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glIglooInterfaceSGIX (GLenum pname, const void * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_igloo_interface - glIglooInterfaceSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_igloo_interface] && glConfig.m_glIglooInterfaceSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glIglooInterfaceSGIX (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glGetInstrumentsSGIX ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_instruments - glGetInstrumentsSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_instruments] && glConfig.m_glGetInstrumentsSGIX)
  {
    prototypeCalled = true;
    result = glConfig.m_glGetInstrumentsSGIX ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glInstrumentsBufferSGIX (GLsizei size, GLint * buffer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_instruments - glInstrumentsBufferSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_instruments] && glConfig.m_glInstrumentsBufferSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glInstrumentsBufferSGIX (size, buffer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GLint _glew_gl_glPollInstrumentsSGIX (GLint * marker_p)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
  GLint result = ((GLint)0);
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_instruments - glPollInstrumentsSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_instruments] && glConfig.m_glPollInstrumentsSGIX)
  {
    prototypeCalled = true;
    result = glConfig.m_glPollInstrumentsSGIX (marker_p);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReadInstrumentsSGIX (GLint marker)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_instruments - glReadInstrumentsSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_instruments] && glConfig.m_glReadInstrumentsSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glReadInstrumentsSGIX (marker);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStartInstrumentsSGIX ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_instruments - glStartInstrumentsSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_instruments] && glConfig.m_glStartInstrumentsSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glStartInstrumentsSGIX ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glStopInstrumentsSGIX (GLint marker)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_instruments - glStopInstrumentsSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_instruments] && glConfig.m_glStopInstrumentsSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glStopInstrumentsSGIX (marker);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetListParameterfvSGIX (GLuint list, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_list_priority - glGetListParameterfvSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_list_priority] && glConfig.m_glGetListParameterfvSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glGetListParameterfvSGIX (list, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetListParameterivSGIX (GLuint list, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_list_priority - glGetListParameterivSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_list_priority] && glConfig.m_glGetListParameterivSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glGetListParameterivSGIX (list, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glListParameterfSGIX (GLuint list, GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_list_priority - glListParameterfSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_list_priority] && glConfig.m_glListParameterfSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glListParameterfSGIX (list, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glListParameterfvSGIX (GLuint list, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_list_priority - glListParameterfvSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_list_priority] && glConfig.m_glListParameterfvSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glListParameterfvSGIX (list, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glListParameteriSGIX (GLuint list, GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_list_priority - glListParameteriSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_list_priority] && glConfig.m_glListParameteriSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glListParameteriSGIX (list, pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glListParameterivSGIX (GLuint list, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_list_priority - glListParameterivSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_list_priority] && glConfig.m_glListParameterivSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glListParameterivSGIX (list, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glPixelTexGenSGIX (GLenum mode)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_pixel_texture - glPixelTexGenSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_pixel_texture] && glConfig.m_glPixelTexGenSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glPixelTexGenSGIX (mode);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeformationMap3dSGIX (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_polynomial_ffd - glDeformationMap3dSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_polynomial_ffd] && glConfig.m_glDeformationMap3dSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glDeformationMap3dSGIX (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeformationMap3fSGIX (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat * points)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_polynomial_ffd - glDeformationMap3fSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_polynomial_ffd] && glConfig.m_glDeformationMap3fSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glDeformationMap3fSGIX (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDeformSGIX (GLbitfield mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_polynomial_ffd - glDeformSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_polynomial_ffd] && glConfig.m_glDeformSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glDeformSGIX (mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glLoadIdentityDeformationMapSGIX (GLbitfield mask)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_polynomial_ffd - glLoadIdentityDeformationMapSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_polynomial_ffd] && glConfig.m_glLoadIdentityDeformationMapSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glLoadIdentityDeformationMapSGIX (mask);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReferencePlaneSGIX (const GLdouble * equation)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_reference_plane - glReferencePlaneSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_reference_plane] && glConfig.m_glReferencePlaneSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glReferencePlaneSGIX (equation);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSpriteParameterfSGIX (GLenum pname, GLfloat param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_sprite - glSpriteParameterfSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_sprite] && glConfig.m_glSpriteParameterfSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glSpriteParameterfSGIX (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSpriteParameterfvSGIX (GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_sprite - glSpriteParameterfvSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_sprite] && glConfig.m_glSpriteParameterfvSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glSpriteParameterfvSGIX (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSpriteParameteriSGIX (GLenum pname, GLint param)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_sprite - glSpriteParameteriSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_sprite] && glConfig.m_glSpriteParameteriSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glSpriteParameteriSGIX (pname, param);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glSpriteParameterivSGIX (GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_sprite - glSpriteParameterivSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_sprite] && glConfig.m_glSpriteParameterivSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glSpriteParameterivSGIX (pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTagSampleBufferSGIX ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGIX_tag_sample_buffer - glTagSampleBufferSGIX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGIX_tag_sample_buffer] && glConfig.m_glTagSampleBufferSGIX)
  {
    prototypeCalled = true;
    glConfig.m_glTagSampleBufferSGIX ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorTableSGI (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void * table)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGI_color_table - glColorTableSGI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGI_color_table] && glConfig.m_glColorTableSGI)
  {
    prototypeCalled = true;
    glConfig.m_glColorTableSGI (target, internalformat, width, format, type, table);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorTableParameterfvSGI (GLenum target, GLenum pname, const GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGI_color_table - glColorTableParameterfvSGI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGI_color_table] && glConfig.m_glColorTableParameterfvSGI)
  {
    prototypeCalled = true;
    glConfig.m_glColorTableParameterfvSGI (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColorTableParameterivSGI (GLenum target, GLenum pname, const GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGI_color_table - glColorTableParameterivSGI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGI_color_table] && glConfig.m_glColorTableParameterivSGI)
  {
    prototypeCalled = true;
    glConfig.m_glColorTableParameterivSGI (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glCopyColorTableSGI (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGI_color_table - glCopyColorTableSGI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGI_color_table] && glConfig.m_glCopyColorTableSGI)
  {
    prototypeCalled = true;
    glConfig.m_glCopyColorTableSGI (target, internalformat, x, y, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetColorTableSGI (GLenum target, GLenum format, GLenum type, void * table)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGI_color_table - glGetColorTableSGI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGI_color_table] && glConfig.m_glGetColorTableSGI)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTableSGI (target, format, type, table);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetColorTableParameterfvSGI (GLenum target, GLenum pname, GLfloat * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGI_color_table - glGetColorTableParameterfvSGI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGI_color_table] && glConfig.m_glGetColorTableParameterfvSGI)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTableParameterfvSGI (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGetColorTableParameterivSGI (GLenum target, GLenum pname, GLint * params)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SGI_color_table - glGetColorTableParameterivSGI
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SGI_color_table] && glConfig.m_glGetColorTableParameterivSGI)
  {
    prototypeCalled = true;
    glConfig.m_glGetColorTableParameterivSGI (target, pname, params);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glFinishTextureSUNX ()
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUNX_constant_data - glFinishTextureSUNX
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUNX_constant_data] && glConfig.m_glFinishTextureSUNX)
  {
    prototypeCalled = true;
    glConfig.m_glFinishTextureSUNX ();
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGlobalAlphaFactorbSUN (GLbyte factor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_global_alpha - glGlobalAlphaFactorbSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_global_alpha] && glConfig.m_glGlobalAlphaFactorbSUN)
  {
    prototypeCalled = true;
    glConfig.m_glGlobalAlphaFactorbSUN (factor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGlobalAlphaFactorsSUN (GLshort factor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_global_alpha - glGlobalAlphaFactorsSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_global_alpha] && glConfig.m_glGlobalAlphaFactorsSUN)
  {
    prototypeCalled = true;
    glConfig.m_glGlobalAlphaFactorsSUN (factor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGlobalAlphaFactoriSUN (GLint factor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_global_alpha - glGlobalAlphaFactoriSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_global_alpha] && glConfig.m_glGlobalAlphaFactoriSUN)
  {
    prototypeCalled = true;
    glConfig.m_glGlobalAlphaFactoriSUN (factor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGlobalAlphaFactorfSUN (GLfloat factor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_global_alpha - glGlobalAlphaFactorfSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_global_alpha] && glConfig.m_glGlobalAlphaFactorfSUN)
  {
    prototypeCalled = true;
    glConfig.m_glGlobalAlphaFactorfSUN (factor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGlobalAlphaFactordSUN (GLdouble factor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_global_alpha - glGlobalAlphaFactordSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_global_alpha] && glConfig.m_glGlobalAlphaFactordSUN)
  {
    prototypeCalled = true;
    glConfig.m_glGlobalAlphaFactordSUN (factor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGlobalAlphaFactorubSUN (GLubyte factor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_global_alpha - glGlobalAlphaFactorubSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_global_alpha] && glConfig.m_glGlobalAlphaFactorubSUN)
  {
    prototypeCalled = true;
    glConfig.m_glGlobalAlphaFactorubSUN (factor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGlobalAlphaFactorusSUN (GLushort factor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_global_alpha - glGlobalAlphaFactorusSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_global_alpha] && glConfig.m_glGlobalAlphaFactorusSUN)
  {
    prototypeCalled = true;
    glConfig.m_glGlobalAlphaFactorusSUN (factor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glGlobalAlphaFactoruiSUN (GLuint factor)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_global_alpha - glGlobalAlphaFactoruiSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_global_alpha] && glConfig.m_glGlobalAlphaFactoruiSUN)
  {
    prototypeCalled = true;
    glConfig.m_glGlobalAlphaFactoruiSUN (factor);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glDrawMeshArraysSUN (GLenum mode, GLint first, GLsizei count, GLsizei width)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_mesh_array - glDrawMeshArraysSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_mesh_array] && glConfig.m_glDrawMeshArraysSUN)
  {
    prototypeCalled = true;
    glConfig.m_glDrawMeshArraysSUN (mode, first, count, width);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiSUN (GLuint code)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_triangle_list - glReplacementCodeuiSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_triangle_list] && glConfig.m_glReplacementCodeuiSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiSUN (code);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeusSUN (GLushort code)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_triangle_list - glReplacementCodeusSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_triangle_list] && glConfig.m_glReplacementCodeusSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeusSUN (code);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeubSUN (GLubyte code)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_triangle_list - glReplacementCodeubSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_triangle_list] && glConfig.m_glReplacementCodeubSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeubSUN (code);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuivSUN (const GLuint * code)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_triangle_list - glReplacementCodeuivSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_triangle_list] && glConfig.m_glReplacementCodeuivSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuivSUN (code);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeusvSUN (const GLushort * code)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_triangle_list - glReplacementCodeusvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_triangle_list] && glConfig.m_glReplacementCodeusvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeusvSUN (code);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeubvSUN (const GLubyte * code)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_triangle_list - glReplacementCodeubvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_triangle_list] && glConfig.m_glReplacementCodeubvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeubvSUN (code);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodePointerSUN (GLenum type, GLsizei stride, const void ** pointer)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_triangle_list - glReplacementCodePointerSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_triangle_list] && glConfig.m_glReplacementCodePointerSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodePointerSUN (type, stride, pointer);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor4ubVertex2fSUN (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glColor4ubVertex2fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glColor4ubVertex2fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glColor4ubVertex2fSUN (r, g, b, a, x, y);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor4ubVertex2fvSUN (const GLubyte * c, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glColor4ubVertex2fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glColor4ubVertex2fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glColor4ubVertex2fvSUN (c, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor4ubVertex3fSUN (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glColor4ubVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glColor4ubVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glColor4ubVertex3fSUN (r, g, b, a, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor4ubVertex3fvSUN (const GLubyte * c, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glColor4ubVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glColor4ubVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glColor4ubVertex3fvSUN (c, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor3fVertex3fSUN (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glColor3fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glColor3fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glColor3fVertex3fSUN (r, g, b, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor3fVertex3fvSUN (const GLfloat * c, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glColor3fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glColor3fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glColor3fVertex3fvSUN (c, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormal3fVertex3fSUN (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glNormal3fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glNormal3fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glNormal3fVertex3fSUN (nx, ny, nz, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glNormal3fVertex3fvSUN (const GLfloat * n, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glNormal3fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glNormal3fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glNormal3fVertex3fvSUN (n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor4fNormal3fVertex3fSUN (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glColor4fNormal3fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glColor4fNormal3fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glColor4fNormal3fVertex3fSUN (r, g, b, a, nx, ny, nz, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glColor4fNormal3fVertex3fvSUN (const GLfloat * c, const GLfloat * n, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glColor4fNormal3fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glColor4fNormal3fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glColor4fNormal3fVertex3fvSUN (c, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2fVertex3fSUN (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord2fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord2fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2fVertex3fSUN (s, t, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2fVertex3fvSUN (const GLfloat * tc, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord2fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord2fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2fVertex3fvSUN (tc, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord4fVertex4fSUN (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord4fVertex4fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord4fVertex4fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord4fVertex4fSUN (s, t, p, q, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord4fVertex4fvSUN (const GLfloat * tc, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord4fVertex4fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord4fVertex4fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord4fVertex4fvSUN (tc, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2fColor4ubVertex3fSUN (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord2fColor4ubVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord2fColor4ubVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2fColor4ubVertex3fSUN (s, t, r, g, b, a, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2fColor4ubVertex3fvSUN (const GLfloat * tc, const GLubyte * c, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord2fColor4ubVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord2fColor4ubVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2fColor4ubVertex3fvSUN (tc, c, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2fColor3fVertex3fSUN (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord2fColor3fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord2fColor3fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2fColor3fVertex3fSUN (s, t, r, g, b, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2fColor3fVertex3fvSUN (const GLfloat * tc, const GLfloat * c, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord2fColor3fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord2fColor3fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2fColor3fVertex3fvSUN (tc, c, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2fNormal3fVertex3fSUN (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord2fNormal3fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord2fNormal3fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2fNormal3fVertex3fSUN (s, t, nx, ny, nz, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2fNormal3fVertex3fvSUN (const GLfloat * tc, const GLfloat * n, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord2fNormal3fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord2fNormal3fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2fNormal3fVertex3fvSUN (tc, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2fColor4fNormal3fVertex3fSUN (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord2fColor4fNormal3fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord2fColor4fNormal3fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2fColor4fNormal3fVertex3fSUN (s, t, r, g, b, a, nx, ny, nz, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord2fColor4fNormal3fVertex3fvSUN (const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord2fColor4fNormal3fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord2fColor4fNormal3fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord2fColor4fNormal3fVertex3fvSUN (tc, c, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord4fColor4fNormal3fVertex4fSUN (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord4fColor4fNormal3fVertex4fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord4fColor4fNormal3fVertex4fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord4fColor4fNormal3fVertex4fSUN (s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glTexCoord4fColor4fNormal3fVertex4fvSUN (const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glTexCoord4fColor4fNormal3fVertex4fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glTexCoord4fColor4fNormal3fVertex4fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glTexCoord4fColor4fNormal3fVertex4fvSUN (tc, c, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiVertex3fSUN (GLuint rc, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiVertex3fSUN (rc, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiVertex3fvSUN (const GLuint * rc, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiVertex3fvSUN (rc, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiColor4ubVertex3fSUN (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiColor4ubVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiColor4ubVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiColor4ubVertex3fSUN (rc, r, g, b, a, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiColor4ubVertex3fvSUN (const GLuint * rc, const GLubyte * c, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiColor4ubVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiColor4ubVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiColor4ubVertex3fvSUN (rc, c, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiColor3fVertex3fSUN (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiColor3fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiColor3fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiColor3fVertex3fSUN (rc, r, g, b, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiColor3fVertex3fvSUN (const GLuint * rc, const GLfloat * c, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiColor3fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiColor3fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiColor3fVertex3fvSUN (rc, c, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiNormal3fVertex3fSUN (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiNormal3fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiNormal3fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiNormal3fVertex3fSUN (rc, nx, ny, nz, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiNormal3fVertex3fvSUN (const GLuint * rc, const GLfloat * n, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiNormal3fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiNormal3fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiNormal3fVertex3fvSUN (rc, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiColor4fNormal3fVertex3fSUN (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiColor4fNormal3fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiColor4fNormal3fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiColor4fNormal3fVertex3fSUN (rc, r, g, b, a, nx, ny, nz, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiColor4fNormal3fVertex3fvSUN (const GLuint * rc, const GLfloat * c, const GLfloat * n, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiColor4fNormal3fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiColor4fNormal3fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiColor4fNormal3fVertex3fvSUN (rc, c, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiTexCoord2fVertex3fSUN (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiTexCoord2fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiTexCoord2fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiTexCoord2fVertex3fSUN (rc, s, t, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiTexCoord2fVertex3fvSUN (const GLuint * rc, const GLfloat * tc, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiTexCoord2fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiTexCoord2fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiTexCoord2fVertex3fvSUN (rc, tc, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN (rc, s, t, nx, ny, nz, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN (const GLuint * rc, const GLfloat * tc, const GLfloat * n, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN (rc, tc, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN (rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void _glew_gl_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN (const GLuint * rc, const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v)
{
  bool prototypeCalled = false;
  const glew::gl::DeviceConfig &glConfig = glew::gl::GetConfig ();
#if GLEW_GL_PRE_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
  // GL_SUN_vertex - glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN
  if (!prototypeCalled && glConfig.m_featureSupported [GLEW_GL_SUN_vertex] && glConfig.m_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN)
  {
    prototypeCalled = true;
    glConfig.m_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN (rc, tc, c, n, v);
  }
  GLEW_ASSERT (prototypeCalled);
#if GLEW_GL_POST_ERROR_CHECK
  GLEW_ASSERT (glGetError () == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool glew::IsSupported (GLEW_GL_FeatureSet feature)
{
  return glew::gl::IsSupported (feature);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool glew::gl::s_initialised = false;

glew::gl::DeviceConfig glew::gl::s_deviceConfig;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void glew::gl::Initialise ()
{
  memset (&s_deviceConfig, 0, sizeof (s_deviceConfig));

  //
  // Determine current driver's feature reporting.
  //

  const unsigned char *glVersion = glGetString (GL_VERSION);

  if (!glVersion)
  {
    glVersion = (const unsigned char*) ""; // Protect against some drivers will happily pass back NULL.
  }

  const size_t glVersionLen = strlen ((const char *) glVersion);

  if (glVersionLen)
  {
    unsigned int major = 0, minor = 0;

#if _WIN32
  #define strncasecmp _strnicmp
#endif

    const bool openGlEsSupported = (strncasecmp ((const char *) glVersion, "OpenGL ES", 9) == 0);

    const char *divisor = strchr ((const char *) glVersion, '.');

    if (divisor)
    {
      major = (*(char *) (divisor - 1)) - '0';
      minor = (*(char *) (divisor + 1)) - '0';
    }

    if (openGlEsSupported)
    {
      s_deviceConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0] = ((major >= 2));
      s_deviceConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0] = ((major >= 3));
      s_deviceConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1] = ((major >= 3) && (minor >= 1));
      s_deviceConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2] = ((major >= 3) && (minor >= 2));
    }
    else
    {
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_1_0] = ((major >= 1));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_1_1] = ((major >= 1) && (minor >= 1));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_1_2] = ((major >= 1) && (minor >= 2));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_1_3] = ((major >= 1) && (minor >= 3));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_1_4] = ((major >= 1) && (minor >= 4));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_1_5] = ((major >= 1) && (minor >= 5));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_2_0] = ((major >= 2));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_2_1] = ((major >= 2) && (minor >= 1));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_3_0] = ((major >= 3));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_3_1] = ((major >= 3) && (minor >= 1));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_3_2] = ((major >= 3) && (minor >= 2));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_3_3] = ((major >= 3) && (minor >= 3));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_0] = ((major >= 4));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_1] = ((major >= 4) && (minor >= 1));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_2] = ((major >= 4) && (minor >= 2));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_3] = ((major >= 4) && (minor >= 3));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_4] = ((major >= 4) && (minor >= 4));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_5] = ((major >= 4) && (minor >= 5));
      s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_6] = ((major >= 4) && (minor >= 6));
    }
  }

  //
  // Evaluate extension support.
  //

  std::unordered_set <std::string> supportedExtensions;

  const unsigned char *glExtensions = (const unsigned char*) glGetString (GL_EXTENSIONS);

  if (!glExtensions)
  {
    glExtensions = (const unsigned char*) ""; // Protect against some drivers will happily pass back NULL.
  }

  const size_t glExtensionsLen = strlen ((const char *) glExtensions);

  if (glExtensionsLen)
  {
    unsigned char *thisExtStart = (unsigned char *) glExtensions;

    unsigned char *thisExtEnd = NULL;

    char thisExtBuffer [128];

    memset (thisExtBuffer, 0, sizeof (thisExtBuffer));

    do
    {
      const char * seperator = strchr ((const char *) thisExtStart, ' ');

      if (seperator)
      {
        const size_t len = (((uintptr_t) seperator - (uintptr_t) thisExtStart) / sizeof (unsigned char));

      #if _WIN32
        strncpy_s (thisExtBuffer, 128, (const char *)thisExtStart, len);
      #else
        strncpy (thisExtBuffer, (const char *)thisExtStart, len);
      #endif

        thisExtBuffer [GLEW_MIN (len, 127)] = '\0';

        thisExtEnd = (unsigned char *) seperator + 1; // skip tab character
      }
      else
      {
        const size_t len = strlen ((const char *) thisExtStart);

      #if _WIN32
        strncpy_s (thisExtBuffer, 128, (const char *)thisExtStart, len);
      #else
        strncpy (thisExtBuffer, (const char *)thisExtStart, len);
      #endif

        thisExtBuffer [GLEW_MIN (len + 1, 127)] = '\0';

        thisExtEnd = NULL;
      }

      std::string thisExt (thisExtBuffer);

      if (supportedExtensions.find (thisExt) == supportedExtensions.end ())
      {
        supportedExtensions.insert (thisExt);
      }

      thisExtStart = thisExtEnd;
    }
    while ((thisExtStart && *thisExtStart != '\0') && (thisExtEnd && *thisExtEnd != '\0'));
  }

  s_deviceConfig.m_featureSupported [GLEW_GL_3DFX_multisample] = (supportedExtensions.find ("GL_3DFX_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_3DFX_tbuffer] = (supportedExtensions.find ("GL_3DFX_tbuffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_3DFX_texture_compression_FXT1] = (supportedExtensions.find ("GL_3DFX_texture_compression_FXT1") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_blend_minmax_factor] = (supportedExtensions.find ("GL_AMD_blend_minmax_factor") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_compressed_3DC_texture] = (supportedExtensions.find ("GL_AMD_compressed_3DC_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_compressed_ATC_texture] = (supportedExtensions.find ("GL_AMD_compressed_ATC_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_conservative_depth] = (supportedExtensions.find ("GL_AMD_conservative_depth") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_debug_output] = (supportedExtensions.find ("GL_AMD_debug_output") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_depth_clamp_separate] = (supportedExtensions.find ("GL_AMD_depth_clamp_separate") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_draw_buffers_blend] = (supportedExtensions.find ("GL_AMD_draw_buffers_blend") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_framebuffer_multisample_advanced] = (supportedExtensions.find ("GL_AMD_framebuffer_multisample_advanced") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_framebuffer_sample_positions] = (supportedExtensions.find ("GL_AMD_framebuffer_sample_positions") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_gcn_shader] = (supportedExtensions.find ("GL_AMD_gcn_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_half_float] = (supportedExtensions.find ("GL_AMD_gpu_shader_half_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int16] = (supportedExtensions.find ("GL_AMD_gpu_shader_int16") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64] = (supportedExtensions.find ("GL_AMD_gpu_shader_int64") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_interleaved_elements] = (supportedExtensions.find ("GL_AMD_interleaved_elements") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_multi_draw_indirect] = (supportedExtensions.find ("GL_AMD_multi_draw_indirect") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_name_gen_delete] = (supportedExtensions.find ("GL_AMD_name_gen_delete") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_occlusion_query_event] = (supportedExtensions.find ("GL_AMD_occlusion_query_event") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor] = (supportedExtensions.find ("GL_AMD_performance_monitor") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_pinned_memory] = (supportedExtensions.find ("GL_AMD_pinned_memory") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_program_binary_Z400] = (supportedExtensions.find ("GL_AMD_program_binary_Z400") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_query_buffer_object] = (supportedExtensions.find ("GL_AMD_query_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_sample_positions] = (supportedExtensions.find ("GL_AMD_sample_positions") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_seamless_cubemap_per_texture] = (supportedExtensions.find ("GL_AMD_seamless_cubemap_per_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_shader_atomic_counter_ops] = (supportedExtensions.find ("GL_AMD_shader_atomic_counter_ops") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_shader_ballot] = (supportedExtensions.find ("GL_AMD_shader_ballot") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_shader_gpu_shader_half_float_fetch] = (supportedExtensions.find ("GL_AMD_shader_gpu_shader_half_float_fetch") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_shader_image_load_store_lod] = (supportedExtensions.find ("GL_AMD_shader_image_load_store_lod") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_shader_stencil_export] = (supportedExtensions.find ("GL_AMD_shader_stencil_export") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_shader_trinary_minmax] = (supportedExtensions.find ("GL_AMD_shader_trinary_minmax") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_shader_explicit_vertex_parameter] = (supportedExtensions.find ("GL_AMD_shader_explicit_vertex_parameter") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_sparse_texture] = (supportedExtensions.find ("GL_AMD_sparse_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_stencil_operation_extended] = (supportedExtensions.find ("GL_AMD_stencil_operation_extended") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_texture_gather_bias_lod] = (supportedExtensions.find ("GL_AMD_texture_gather_bias_lod") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_texture_texture4] = (supportedExtensions.find ("GL_AMD_texture_texture4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_transform_feedback3_lines_triangles] = (supportedExtensions.find ("GL_AMD_transform_feedback3_lines_triangles") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_transform_feedback4] = (supportedExtensions.find ("GL_AMD_transform_feedback4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_vertex_shader_layer] = (supportedExtensions.find ("GL_AMD_vertex_shader_layer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_vertex_shader_tessellator] = (supportedExtensions.find ("GL_AMD_vertex_shader_tessellator") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_AMD_vertex_shader_viewport_index] = (supportedExtensions.find ("GL_AMD_vertex_shader_viewport_index") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ANDROID_extension_pack_es31a] = (supportedExtensions.find ("GL_ANDROID_extension_pack_es31a") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_depth_texture] = (supportedExtensions.find ("GL_ANGLE_depth_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_framebuffer_blit] = (supportedExtensions.find ("GL_ANGLE_framebuffer_blit") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_framebuffer_multisample] = (supportedExtensions.find ("GL_ANGLE_framebuffer_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_instanced_arrays] = (supportedExtensions.find ("GL_ANGLE_instanced_arrays") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_pack_reverse_row_order] = (supportedExtensions.find ("GL_ANGLE_pack_reverse_row_order") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_program_binary] = (supportedExtensions.find ("GL_ANGLE_program_binary") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_texture_compression_dxt3] = (supportedExtensions.find ("GL_ANGLE_texture_compression_dxt3") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_texture_compression_dxt5] = (supportedExtensions.find ("GL_ANGLE_texture_compression_dxt5") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_texture_usage] = (supportedExtensions.find ("GL_ANGLE_texture_usage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_translated_shader_source] = (supportedExtensions.find ("GL_ANGLE_translated_shader_source") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_aux_depth_stencil] = (supportedExtensions.find ("GL_APPLE_aux_depth_stencil") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_client_storage] = (supportedExtensions.find ("GL_APPLE_client_storage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_clip_distance] = (supportedExtensions.find ("GL_APPLE_clip_distance") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_color_buffer_packed_float] = (supportedExtensions.find ("GL_APPLE_color_buffer_packed_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_copy_texture_levels] = (supportedExtensions.find ("GL_APPLE_copy_texture_levels") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_element_array] = (supportedExtensions.find ("GL_APPLE_element_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_fence] = (supportedExtensions.find ("GL_APPLE_fence") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_float_pixels] = (supportedExtensions.find ("GL_APPLE_float_pixels") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_flush_buffer_range] = (supportedExtensions.find ("GL_APPLE_flush_buffer_range") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_framebuffer_multisample] = (supportedExtensions.find ("GL_APPLE_framebuffer_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_object_purgeable] = (supportedExtensions.find ("GL_APPLE_object_purgeable") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_rgb_422] = (supportedExtensions.find ("GL_APPLE_rgb_422") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_row_bytes] = (supportedExtensions.find ("GL_APPLE_row_bytes") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_specular_vector] = (supportedExtensions.find ("GL_APPLE_specular_vector") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_sync] = (supportedExtensions.find ("GL_APPLE_sync") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_texture_format_BGRA8888] = (supportedExtensions.find ("GL_APPLE_texture_format_BGRA8888") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_texture_max_level] = (supportedExtensions.find ("GL_APPLE_texture_max_level") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_texture_packed_float] = (supportedExtensions.find ("GL_APPLE_texture_packed_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_texture_range] = (supportedExtensions.find ("GL_APPLE_texture_range") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_transform_hint] = (supportedExtensions.find ("GL_APPLE_transform_hint") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_object] = (supportedExtensions.find ("GL_APPLE_vertex_array_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_range] = (supportedExtensions.find ("GL_APPLE_vertex_array_range") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_vertex_program_evaluators] = (supportedExtensions.find ("GL_APPLE_vertex_program_evaluators") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_ycbcr_422] = (supportedExtensions.find ("GL_APPLE_ycbcr_422") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_ES2_compatibility] = (supportedExtensions.find ("GL_ARB_ES2_compatibility") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_ES3_1_compatibility] = (supportedExtensions.find ("GL_ARB_ES3_1_compatibility") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_ES3_2_compatibility] = (supportedExtensions.find ("GL_ARB_ES3_2_compatibility") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_ES3_compatibility] = (supportedExtensions.find ("GL_ARB_ES3_compatibility") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_arrays_of_arrays] = (supportedExtensions.find ("GL_ARB_arrays_of_arrays") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_base_instance] = (supportedExtensions.find ("GL_ARB_base_instance") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture] = (supportedExtensions.find ("GL_ARB_bindless_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_blend_func_extended] = (supportedExtensions.find ("GL_ARB_blend_func_extended") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_buffer_storage] = (supportedExtensions.find ("GL_ARB_buffer_storage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_cl_event] = (supportedExtensions.find ("GL_ARB_cl_event") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_clear_buffer_object] = (supportedExtensions.find ("GL_ARB_clear_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_clear_texture] = (supportedExtensions.find ("GL_ARB_clear_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_clip_control] = (supportedExtensions.find ("GL_ARB_clip_control") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_color_buffer_float] = (supportedExtensions.find ("GL_ARB_color_buffer_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_compatibility] = (supportedExtensions.find ("GL_ARB_compatibility") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_compressed_texture_pixel_storage] = (supportedExtensions.find ("GL_ARB_compressed_texture_pixel_storage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_compute_shader] = (supportedExtensions.find ("GL_ARB_compute_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_compute_variable_group_size] = (supportedExtensions.find ("GL_ARB_compute_variable_group_size") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_conditional_render_inverted] = (supportedExtensions.find ("GL_ARB_conditional_render_inverted") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_conservative_depth] = (supportedExtensions.find ("GL_ARB_conservative_depth") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_copy_buffer] = (supportedExtensions.find ("GL_ARB_copy_buffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_copy_image] = (supportedExtensions.find ("GL_ARB_copy_image") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_cull_distance] = (supportedExtensions.find ("GL_ARB_cull_distance") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_debug_output] = (supportedExtensions.find ("GL_ARB_debug_output") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_depth_buffer_float] = (supportedExtensions.find ("GL_ARB_depth_buffer_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_depth_clamp] = (supportedExtensions.find ("GL_ARB_depth_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_depth_texture] = (supportedExtensions.find ("GL_ARB_depth_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_derivative_control] = (supportedExtensions.find ("GL_ARB_derivative_control") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access] = (supportedExtensions.find ("GL_ARB_direct_state_access") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_draw_buffers] = (supportedExtensions.find ("GL_ARB_draw_buffers") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_draw_buffers_blend] = (supportedExtensions.find ("GL_ARB_draw_buffers_blend") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_draw_elements_base_vertex] = (supportedExtensions.find ("GL_ARB_draw_elements_base_vertex") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_draw_indirect] = (supportedExtensions.find ("GL_ARB_draw_indirect") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_draw_instanced] = (supportedExtensions.find ("GL_ARB_draw_instanced") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_enhanced_layouts] = (supportedExtensions.find ("GL_ARB_enhanced_layouts") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_explicit_attrib_location] = (supportedExtensions.find ("GL_ARB_explicit_attrib_location") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_explicit_uniform_location] = (supportedExtensions.find ("GL_ARB_explicit_uniform_location") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_fragment_coord_conventions] = (supportedExtensions.find ("GL_ARB_fragment_coord_conventions") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_fragment_layer_viewport] = (supportedExtensions.find ("GL_ARB_fragment_layer_viewport") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_fragment_program] = (supportedExtensions.find ("GL_ARB_fragment_program") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_fragment_program_shadow] = (supportedExtensions.find ("GL_ARB_fragment_program_shadow") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_fragment_shader] = (supportedExtensions.find ("GL_ARB_fragment_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_fragment_shader_interlock] = (supportedExtensions.find ("GL_ARB_fragment_shader_interlock") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_no_attachments] = (supportedExtensions.find ("GL_ARB_framebuffer_no_attachments") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object] = (supportedExtensions.find ("GL_ARB_framebuffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_sRGB] = (supportedExtensions.find ("GL_ARB_framebuffer_sRGB") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_geometry_shader4] = (supportedExtensions.find ("GL_ARB_geometry_shader4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_get_program_binary] = (supportedExtensions.find ("GL_ARB_get_program_binary") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_get_texture_sub_image] = (supportedExtensions.find ("GL_ARB_get_texture_sub_image") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_gl_spirv] = (supportedExtensions.find ("GL_ARB_gl_spirv") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader5] = (supportedExtensions.find ("GL_ARB_gpu_shader5") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64] = (supportedExtensions.find ("GL_ARB_gpu_shader_fp64") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64] = (supportedExtensions.find ("GL_ARB_gpu_shader_int64") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_half_float_pixel] = (supportedExtensions.find ("GL_ARB_half_float_pixel") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_half_float_vertex] = (supportedExtensions.find ("GL_ARB_half_float_vertex") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_imaging] = (supportedExtensions.find ("GL_ARB_imaging") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_indirect_parameters] = (supportedExtensions.find ("GL_ARB_indirect_parameters") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_instanced_arrays] = (supportedExtensions.find ("GL_ARB_instanced_arrays") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_internalformat_query] = (supportedExtensions.find ("GL_ARB_internalformat_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_internalformat_query2] = (supportedExtensions.find ("GL_ARB_internalformat_query2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_invalidate_subdata] = (supportedExtensions.find ("GL_ARB_invalidate_subdata") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_map_buffer_alignment] = (supportedExtensions.find ("GL_ARB_map_buffer_alignment") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_map_buffer_range] = (supportedExtensions.find ("GL_ARB_map_buffer_range") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_matrix_palette] = (supportedExtensions.find ("GL_ARB_matrix_palette") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_multi_bind] = (supportedExtensions.find ("GL_ARB_multi_bind") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_multi_draw_indirect] = (supportedExtensions.find ("GL_ARB_multi_draw_indirect") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_multisample] = (supportedExtensions.find ("GL_ARB_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_multitexture] = (supportedExtensions.find ("GL_ARB_multitexture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query] = (supportedExtensions.find ("GL_ARB_occlusion_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query2] = (supportedExtensions.find ("GL_ARB_occlusion_query2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_parallel_shader_compile] = (supportedExtensions.find ("GL_ARB_parallel_shader_compile") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_pipeline_statistics_query] = (supportedExtensions.find ("GL_ARB_pipeline_statistics_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_pixel_buffer_object] = (supportedExtensions.find ("GL_ARB_pixel_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_point_parameters] = (supportedExtensions.find ("GL_ARB_point_parameters") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_point_sprite] = (supportedExtensions.find ("GL_ARB_point_sprite") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_polygon_offset_clamp] = (supportedExtensions.find ("GL_ARB_polygon_offset_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_post_depth_coverage] = (supportedExtensions.find ("GL_ARB_post_depth_coverage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_program_interface_query] = (supportedExtensions.find ("GL_ARB_program_interface_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_provoking_vertex] = (supportedExtensions.find ("GL_ARB_provoking_vertex") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_query_buffer_object] = (supportedExtensions.find ("GL_ARB_query_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_robust_buffer_access_behavior] = (supportedExtensions.find ("GL_ARB_robust_buffer_access_behavior") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_robustness] = (supportedExtensions.find ("GL_ARB_robustness") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_robustness_isolation] = (supportedExtensions.find ("GL_ARB_robustness_isolation") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sample_locations] = (supportedExtensions.find ("GL_ARB_sample_locations") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sample_shading] = (supportedExtensions.find ("GL_ARB_sample_shading") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects] = (supportedExtensions.find ("GL_ARB_sampler_objects") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_seamless_cube_map] = (supportedExtensions.find ("GL_ARB_seamless_cube_map") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_seamless_cubemap_per_texture] = (supportedExtensions.find ("GL_ARB_seamless_cubemap_per_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects] = (supportedExtensions.find ("GL_ARB_separate_shader_objects") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_atomic_counter_ops] = (supportedExtensions.find ("GL_ARB_shader_atomic_counter_ops") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_atomic_counters] = (supportedExtensions.find ("GL_ARB_shader_atomic_counters") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_ballot] = (supportedExtensions.find ("GL_ARB_shader_ballot") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_bit_encoding] = (supportedExtensions.find ("GL_ARB_shader_bit_encoding") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_clock] = (supportedExtensions.find ("GL_ARB_shader_clock") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_draw_parameters] = (supportedExtensions.find ("GL_ARB_shader_draw_parameters") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_group_vote] = (supportedExtensions.find ("GL_ARB_shader_group_vote") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_image_load_store] = (supportedExtensions.find ("GL_ARB_shader_image_load_store") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_image_size] = (supportedExtensions.find ("GL_ARB_shader_image_size") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_objects] = (supportedExtensions.find ("GL_ARB_shader_objects") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_precision] = (supportedExtensions.find ("GL_ARB_shader_precision") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_stencil_export] = (supportedExtensions.find ("GL_ARB_shader_stencil_export") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_storage_buffer_object] = (supportedExtensions.find ("GL_ARB_shader_storage_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_subroutine] = (supportedExtensions.find ("GL_ARB_shader_subroutine") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_texture_image_samples] = (supportedExtensions.find ("GL_ARB_shader_texture_image_samples") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_texture_lod] = (supportedExtensions.find ("GL_ARB_shader_texture_lod") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_viewport_layer_array] = (supportedExtensions.find ("GL_ARB_shader_viewport_layer_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shading_language_100] = (supportedExtensions.find ("GL_ARB_shading_language_100") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shading_language_420pack] = (supportedExtensions.find ("GL_ARB_shading_language_420pack") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shading_language_include] = (supportedExtensions.find ("GL_ARB_shading_language_include") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shading_language_packing] = (supportedExtensions.find ("GL_ARB_shading_language_packing") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shadow] = (supportedExtensions.find ("GL_ARB_shadow") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shadow_ambient] = (supportedExtensions.find ("GL_ARB_shadow_ambient") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sparse_buffer] = (supportedExtensions.find ("GL_ARB_sparse_buffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sparse_texture] = (supportedExtensions.find ("GL_ARB_sparse_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sparse_texture2] = (supportedExtensions.find ("GL_ARB_sparse_texture2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sparse_texture_clamp] = (supportedExtensions.find ("GL_ARB_sparse_texture_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_spirv_extensions] = (supportedExtensions.find ("GL_ARB_spirv_extensions") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_stencil_texturing] = (supportedExtensions.find ("GL_ARB_stencil_texturing") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sync] = (supportedExtensions.find ("GL_ARB_sync") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_tessellation_shader] = (supportedExtensions.find ("GL_ARB_tessellation_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_barrier] = (supportedExtensions.find ("GL_ARB_texture_barrier") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_border_clamp] = (supportedExtensions.find ("GL_ARB_texture_border_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_buffer_object] = (supportedExtensions.find ("GL_ARB_texture_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_buffer_object_rgb32] = (supportedExtensions.find ("GL_ARB_texture_buffer_object_rgb32") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_buffer_range] = (supportedExtensions.find ("GL_ARB_texture_buffer_range") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_compression] = (supportedExtensions.find ("GL_ARB_texture_compression") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_compression_bptc] = (supportedExtensions.find ("GL_ARB_texture_compression_bptc") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_compression_rgtc] = (supportedExtensions.find ("GL_ARB_texture_compression_rgtc") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_cube_map] = (supportedExtensions.find ("GL_ARB_texture_cube_map") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_cube_map_array] = (supportedExtensions.find ("GL_ARB_texture_cube_map_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_env_add] = (supportedExtensions.find ("GL_ARB_texture_env_add") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_env_combine] = (supportedExtensions.find ("GL_ARB_texture_env_combine") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_env_crossbar] = (supportedExtensions.find ("GL_ARB_texture_env_crossbar") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_env_dot3] = (supportedExtensions.find ("GL_ARB_texture_env_dot3") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_filter_anisotropic] = (supportedExtensions.find ("GL_ARB_texture_filter_anisotropic") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_filter_minmax] = (supportedExtensions.find ("GL_ARB_texture_filter_minmax") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_float] = (supportedExtensions.find ("GL_ARB_texture_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_gather] = (supportedExtensions.find ("GL_ARB_texture_gather") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_mirror_clamp_to_edge] = (supportedExtensions.find ("GL_ARB_texture_mirror_clamp_to_edge") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_mirrored_repeat] = (supportedExtensions.find ("GL_ARB_texture_mirrored_repeat") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_multisample] = (supportedExtensions.find ("GL_ARB_texture_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_non_power_of_two] = (supportedExtensions.find ("GL_ARB_texture_non_power_of_two") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_query_levels] = (supportedExtensions.find ("GL_ARB_texture_query_levels") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_query_lod] = (supportedExtensions.find ("GL_ARB_texture_query_lod") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_rectangle] = (supportedExtensions.find ("GL_ARB_texture_rectangle") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_rg] = (supportedExtensions.find ("GL_ARB_texture_rg") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_rgb10_a2ui] = (supportedExtensions.find ("GL_ARB_texture_rgb10_a2ui") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_stencil8] = (supportedExtensions.find ("GL_ARB_texture_stencil8") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_storage] = (supportedExtensions.find ("GL_ARB_texture_storage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_storage_multisample] = (supportedExtensions.find ("GL_ARB_texture_storage_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_swizzle] = (supportedExtensions.find ("GL_ARB_texture_swizzle") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_view] = (supportedExtensions.find ("GL_ARB_texture_view") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_timer_query] = (supportedExtensions.find ("GL_ARB_timer_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback2] = (supportedExtensions.find ("GL_ARB_transform_feedback2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback3] = (supportedExtensions.find ("GL_ARB_transform_feedback3") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback_instanced] = (supportedExtensions.find ("GL_ARB_transform_feedback_instanced") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback_overflow_query] = (supportedExtensions.find ("GL_ARB_transform_feedback_overflow_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_transpose_matrix] = (supportedExtensions.find ("GL_ARB_transpose_matrix") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object] = (supportedExtensions.find ("GL_ARB_uniform_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_array_bgra] = (supportedExtensions.find ("GL_ARB_vertex_array_bgra") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_array_object] = (supportedExtensions.find ("GL_ARB_vertex_array_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit] = (supportedExtensions.find ("GL_ARB_vertex_attrib_64bit") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_binding] = (supportedExtensions.find ("GL_ARB_vertex_attrib_binding") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend] = (supportedExtensions.find ("GL_ARB_vertex_blend") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object] = (supportedExtensions.find ("GL_ARB_vertex_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_program] = (supportedExtensions.find ("GL_ARB_vertex_program") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader] = (supportedExtensions.find ("GL_ARB_vertex_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_10f_11f_11f_rev] = (supportedExtensions.find ("GL_ARB_vertex_type_10f_11f_11f_rev") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev] = (supportedExtensions.find ("GL_ARB_vertex_type_2_10_10_10_rev") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_viewport_array] = (supportedExtensions.find ("GL_ARB_viewport_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARB_window_pos] = (supportedExtensions.find ("GL_ARB_window_pos") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARM_mali_program_binary] = (supportedExtensions.find ("GL_ARM_mali_program_binary") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARM_mali_shader_binary] = (supportedExtensions.find ("GL_ARM_mali_shader_binary") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARM_rgba8] = (supportedExtensions.find ("GL_ARM_rgba8") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARM_shader_core_properties] = (supportedExtensions.find ("GL_ARM_shader_core_properties") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARM_shader_framebuffer_fetch] = (supportedExtensions.find ("GL_ARM_shader_framebuffer_fetch") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARM_shader_framebuffer_fetch_depth_stencil] = (supportedExtensions.find ("GL_ARM_shader_framebuffer_fetch_depth_stencil") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ARM_texture_unnormalized_coordinates] = (supportedExtensions.find ("GL_ARM_texture_unnormalized_coordinates") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_draw_buffers] = (supportedExtensions.find ("GL_ATI_draw_buffers") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_element_array] = (supportedExtensions.find ("GL_ATI_element_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_envmap_bumpmap] = (supportedExtensions.find ("GL_ATI_envmap_bumpmap") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader] = (supportedExtensions.find ("GL_ATI_fragment_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_map_object_buffer] = (supportedExtensions.find ("GL_ATI_map_object_buffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_meminfo] = (supportedExtensions.find ("GL_ATI_meminfo") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_pixel_format_float] = (supportedExtensions.find ("GL_ATI_pixel_format_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_pn_triangles] = (supportedExtensions.find ("GL_ATI_pn_triangles") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_separate_stencil] = (supportedExtensions.find ("GL_ATI_separate_stencil") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_text_fragment_shader] = (supportedExtensions.find ("GL_ATI_text_fragment_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_texture_env_combine3] = (supportedExtensions.find ("GL_ATI_texture_env_combine3") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_texture_float] = (supportedExtensions.find ("GL_ATI_texture_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_texture_mirror_once] = (supportedExtensions.find ("GL_ATI_texture_mirror_once") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object] = (supportedExtensions.find ("GL_ATI_vertex_array_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_vertex_attrib_array_object] = (supportedExtensions.find ("GL_ATI_vertex_attrib_array_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams] = (supportedExtensions.find ("GL_ATI_vertex_streams") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_DMP_program_binary] = (supportedExtensions.find ("GL_DMP_program_binary") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_DMP_shader_binary] = (supportedExtensions.find ("GL_DMP_shader_binary") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_422_pixels] = (supportedExtensions.find ("GL_EXT_422_pixels") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_EGL_image_array] = (supportedExtensions.find ("GL_EXT_EGL_image_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_EGL_image_storage] = (supportedExtensions.find ("GL_EXT_EGL_image_storage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_EGL_image_storage_compression] = (supportedExtensions.find ("GL_EXT_EGL_image_storage_compression") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_EGL_sync] = (supportedExtensions.find ("GL_EXT_EGL_sync") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_YUV_target] = (supportedExtensions.find ("GL_EXT_YUV_target") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_abgr] = (supportedExtensions.find ("GL_EXT_abgr") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_base_instance] = (supportedExtensions.find ("GL_EXT_base_instance") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_bgra] = (supportedExtensions.find ("GL_EXT_bgra") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_bindable_uniform] = (supportedExtensions.find ("GL_EXT_bindable_uniform") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_color] = (supportedExtensions.find ("GL_EXT_blend_color") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_equation_separate] = (supportedExtensions.find ("GL_EXT_blend_equation_separate") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_func_extended] = (supportedExtensions.find ("GL_EXT_blend_func_extended") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_func_separate] = (supportedExtensions.find ("GL_EXT_blend_func_separate") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_logic_op] = (supportedExtensions.find ("GL_EXT_blend_logic_op") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_minmax] = (supportedExtensions.find ("GL_EXT_blend_minmax") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_subtract] = (supportedExtensions.find ("GL_EXT_blend_subtract") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_buffer_storage] = (supportedExtensions.find ("GL_EXT_buffer_storage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_clear_texture] = (supportedExtensions.find ("GL_EXT_clear_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_clip_control] = (supportedExtensions.find ("GL_EXT_clip_control") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_clip_cull_distance] = (supportedExtensions.find ("GL_EXT_clip_cull_distance") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_clip_volume_hint] = (supportedExtensions.find ("GL_EXT_clip_volume_hint") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_cmyka] = (supportedExtensions.find ("GL_EXT_cmyka") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_color_buffer_float] = (supportedExtensions.find ("GL_EXT_color_buffer_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_color_buffer_half_float] = (supportedExtensions.find ("GL_EXT_color_buffer_half_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_color_subtable] = (supportedExtensions.find ("GL_EXT_color_subtable") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_compiled_vertex_array] = (supportedExtensions.find ("GL_EXT_compiled_vertex_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_conservative_depth] = (supportedExtensions.find ("GL_EXT_conservative_depth") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_convolution] = (supportedExtensions.find ("GL_EXT_convolution") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame] = (supportedExtensions.find ("GL_EXT_coordinate_frame") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_copy_image] = (supportedExtensions.find ("GL_EXT_copy_image") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_copy_texture] = (supportedExtensions.find ("GL_EXT_copy_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_cull_vertex] = (supportedExtensions.find ("GL_EXT_cull_vertex") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_debug_label] = (supportedExtensions.find ("GL_EXT_debug_label") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_debug_marker] = (supportedExtensions.find ("GL_EXT_debug_marker") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_depth_bounds_test] = (supportedExtensions.find ("GL_EXT_depth_bounds_test") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_depth_clamp] = (supportedExtensions.find ("GL_EXT_depth_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access] = (supportedExtensions.find ("GL_EXT_direct_state_access") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_discard_framebuffer] = (supportedExtensions.find ("GL_EXT_discard_framebuffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query] = (supportedExtensions.find ("GL_EXT_disjoint_timer_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers] = (supportedExtensions.find ("GL_EXT_draw_buffers") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers2] = (supportedExtensions.find ("GL_EXT_draw_buffers2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed] = (supportedExtensions.find ("GL_EXT_draw_buffers_indexed") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_elements_base_vertex] = (supportedExtensions.find ("GL_EXT_draw_elements_base_vertex") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_instanced] = (supportedExtensions.find ("GL_EXT_draw_instanced") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_range_elements] = (supportedExtensions.find ("GL_EXT_draw_range_elements") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_transform_feedback] = (supportedExtensions.find ("GL_EXT_draw_transform_feedback") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_external_buffer] = (supportedExtensions.find ("GL_EXT_external_buffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_float_blend] = (supportedExtensions.find ("GL_EXT_float_blend") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_fog_coord] = (supportedExtensions.find ("GL_EXT_fog_coord") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_fragment_shading_rate] = (supportedExtensions.find ("GL_EXT_fragment_shading_rate") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_blit] = (supportedExtensions.find ("GL_EXT_framebuffer_blit") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_blit_layers] = (supportedExtensions.find ("GL_EXT_framebuffer_blit_layers") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_multisample] = (supportedExtensions.find ("GL_EXT_framebuffer_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_multisample_blit_scaled] = (supportedExtensions.find ("GL_EXT_framebuffer_multisample_blit_scaled") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object] = (supportedExtensions.find ("GL_EXT_framebuffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_sRGB] = (supportedExtensions.find ("GL_EXT_framebuffer_sRGB") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_geometry_point_size] = (supportedExtensions.find ("GL_EXT_geometry_point_size") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_geometry_shader] = (supportedExtensions.find ("GL_EXT_geometry_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_geometry_shader4] = (supportedExtensions.find ("GL_EXT_geometry_shader4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_gpu_program_parameters] = (supportedExtensions.find ("GL_EXT_gpu_program_parameters") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4] = (supportedExtensions.find ("GL_EXT_gpu_shader4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader5] = (supportedExtensions.find ("GL_EXT_gpu_shader5") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_histogram] = (supportedExtensions.find ("GL_EXT_histogram") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_index_array_formats] = (supportedExtensions.find ("GL_EXT_index_array_formats") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_index_func] = (supportedExtensions.find ("GL_EXT_index_func") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_index_material] = (supportedExtensions.find ("GL_EXT_index_material") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_index_texture] = (supportedExtensions.find ("GL_EXT_index_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_instanced_arrays] = (supportedExtensions.find ("GL_EXT_instanced_arrays") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_light_texture] = (supportedExtensions.find ("GL_EXT_light_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_map_buffer_range] = (supportedExtensions.find ("GL_EXT_map_buffer_range") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_memory_object] = (supportedExtensions.find ("GL_EXT_memory_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_memory_object_fd] = (supportedExtensions.find ("GL_EXT_memory_object_fd") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_memory_object_win32] = (supportedExtensions.find ("GL_EXT_memory_object_win32") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_misc_attribute] = (supportedExtensions.find ("GL_EXT_misc_attribute") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multi_draw_arrays] = (supportedExtensions.find ("GL_EXT_multi_draw_arrays") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multi_draw_indirect] = (supportedExtensions.find ("GL_EXT_multi_draw_indirect") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multisample] = (supportedExtensions.find ("GL_EXT_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multisampled_compatibility] = (supportedExtensions.find ("GL_EXT_multisampled_compatibility") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multisampled_render_to_texture] = (supportedExtensions.find ("GL_EXT_multisampled_render_to_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multisampled_render_to_texture2] = (supportedExtensions.find ("GL_EXT_multisampled_render_to_texture2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multiview_draw_buffers] = (supportedExtensions.find ("GL_EXT_multiview_draw_buffers") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multiview_tessellation_geometry_shader] = (supportedExtensions.find ("GL_EXT_multiview_tessellation_geometry_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multiview_texture_multisample] = (supportedExtensions.find ("GL_EXT_multiview_texture_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multiview_timer_query] = (supportedExtensions.find ("GL_EXT_multiview_timer_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_occlusion_query_boolean] = (supportedExtensions.find ("GL_EXT_occlusion_query_boolean") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_packed_depth_stencil] = (supportedExtensions.find ("GL_EXT_packed_depth_stencil") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_packed_float] = (supportedExtensions.find ("GL_EXT_packed_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_packed_pixels] = (supportedExtensions.find ("GL_EXT_packed_pixels") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_paletted_texture] = (supportedExtensions.find ("GL_EXT_paletted_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_pixel_buffer_object] = (supportedExtensions.find ("GL_EXT_pixel_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_pixel_transform] = (supportedExtensions.find ("GL_EXT_pixel_transform") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_pixel_transform_color_table] = (supportedExtensions.find ("GL_EXT_pixel_transform_color_table") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_point_parameters] = (supportedExtensions.find ("GL_EXT_point_parameters") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_polygon_offset] = (supportedExtensions.find ("GL_EXT_polygon_offset") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_polygon_offset_clamp] = (supportedExtensions.find ("GL_EXT_polygon_offset_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_post_depth_coverage] = (supportedExtensions.find ("GL_EXT_post_depth_coverage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_primitive_bounding_box] = (supportedExtensions.find ("GL_EXT_primitive_bounding_box") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_protected_textures] = (supportedExtensions.find ("GL_EXT_protected_textures") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_provoking_vertex] = (supportedExtensions.find ("GL_EXT_provoking_vertex") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_pvrtc_sRGB] = (supportedExtensions.find ("GL_EXT_pvrtc_sRGB") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_raster_multisample] = (supportedExtensions.find ("GL_EXT_raster_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_read_format_bgra] = (supportedExtensions.find ("GL_EXT_read_format_bgra") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_render_snorm] = (supportedExtensions.find ("GL_EXT_render_snorm") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_rescale_normal] = (supportedExtensions.find ("GL_EXT_rescale_normal") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_robustness] = (supportedExtensions.find ("GL_EXT_robustness") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_semaphore] = (supportedExtensions.find ("GL_EXT_semaphore") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_semaphore_fd] = (supportedExtensions.find ("GL_EXT_semaphore_fd") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_semaphore_win32] = (supportedExtensions.find ("GL_EXT_semaphore_win32") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_sRGB] = (supportedExtensions.find ("GL_EXT_sRGB") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_sRGB_write_control] = (supportedExtensions.find ("GL_EXT_sRGB_write_control") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_secondary_color] = (supportedExtensions.find ("GL_EXT_secondary_color") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_separate_depth_stencil] = (supportedExtensions.find ("GL_EXT_separate_depth_stencil") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects] = (supportedExtensions.find ("GL_EXT_separate_shader_objects") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_separate_specular_color] = (supportedExtensions.find ("GL_EXT_separate_specular_color") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_framebuffer_fetch] = (supportedExtensions.find ("GL_EXT_shader_framebuffer_fetch") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_framebuffer_fetch_non_coherent] = (supportedExtensions.find ("GL_EXT_shader_framebuffer_fetch_non_coherent") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_group_vote] = (supportedExtensions.find ("GL_EXT_shader_group_vote") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_image_load_formatted] = (supportedExtensions.find ("GL_EXT_shader_image_load_formatted") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_image_load_store] = (supportedExtensions.find ("GL_EXT_shader_image_load_store") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_implicit_conversions] = (supportedExtensions.find ("GL_EXT_shader_implicit_conversions") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_integer_mix] = (supportedExtensions.find ("GL_EXT_shader_integer_mix") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_io_blocks] = (supportedExtensions.find ("GL_EXT_shader_io_blocks") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_non_constant_global_initializers] = (supportedExtensions.find ("GL_EXT_shader_non_constant_global_initializers") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_pixel_local_storage] = (supportedExtensions.find ("GL_EXT_shader_pixel_local_storage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_pixel_local_storage2] = (supportedExtensions.find ("GL_EXT_shader_pixel_local_storage2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_samples_identical] = (supportedExtensions.find ("GL_EXT_shader_samples_identical") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_texture_lod] = (supportedExtensions.find ("GL_EXT_shader_texture_lod") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shadow_funcs] = (supportedExtensions.find ("GL_EXT_shadow_funcs") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shadow_samplers] = (supportedExtensions.find ("GL_EXT_shadow_samplers") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shared_texture_palette] = (supportedExtensions.find ("GL_EXT_shared_texture_palette") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_sparse_texture] = (supportedExtensions.find ("GL_EXT_sparse_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_sparse_texture2] = (supportedExtensions.find ("GL_EXT_sparse_texture2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_stencil_clear_tag] = (supportedExtensions.find ("GL_EXT_stencil_clear_tag") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_stencil_two_side] = (supportedExtensions.find ("GL_EXT_stencil_two_side") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_stencil_wrap] = (supportedExtensions.find ("GL_EXT_stencil_wrap") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_subtexture] = (supportedExtensions.find ("GL_EXT_subtexture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_tessellation_point_size] = (supportedExtensions.find ("GL_EXT_tessellation_point_size") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_tessellation_shader] = (supportedExtensions.find ("GL_EXT_tessellation_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture] = (supportedExtensions.find ("GL_EXT_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture3D] = (supportedExtensions.find ("GL_EXT_texture3D") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_array] = (supportedExtensions.find ("GL_EXT_texture_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp] = (supportedExtensions.find ("GL_EXT_texture_border_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_buffer] = (supportedExtensions.find ("GL_EXT_texture_buffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_buffer_object] = (supportedExtensions.find ("GL_EXT_texture_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_compression_astc_decode_mode] = (supportedExtensions.find ("GL_EXT_texture_compression_astc_decode_mode") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_compression_bptc] = (supportedExtensions.find ("GL_EXT_texture_compression_bptc") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_compression_dxt1] = (supportedExtensions.find ("GL_EXT_texture_compression_dxt1") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_compression_latc] = (supportedExtensions.find ("GL_EXT_texture_compression_latc") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_compression_rgtc] = (supportedExtensions.find ("GL_EXT_texture_compression_rgtc") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_compression_s3tc] = (supportedExtensions.find ("GL_EXT_texture_compression_s3tc") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_compression_s3tc_srgb] = (supportedExtensions.find ("GL_EXT_texture_compression_s3tc_srgb") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_cube_map] = (supportedExtensions.find ("GL_EXT_texture_cube_map") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_cube_map_array] = (supportedExtensions.find ("GL_EXT_texture_cube_map_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_env_add] = (supportedExtensions.find ("GL_EXT_texture_env_add") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_env_combine] = (supportedExtensions.find ("GL_EXT_texture_env_combine") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_env_dot3] = (supportedExtensions.find ("GL_EXT_texture_env_dot3") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_filter_anisotropic] = (supportedExtensions.find ("GL_EXT_texture_filter_anisotropic") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_filter_minmax] = (supportedExtensions.find ("GL_EXT_texture_filter_minmax") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_format_BGRA8888] = (supportedExtensions.find ("GL_EXT_texture_format_BGRA8888") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_format_sRGB_override] = (supportedExtensions.find ("GL_EXT_texture_format_sRGB_override") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_integer] = (supportedExtensions.find ("GL_EXT_texture_integer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_lod_bias] = (supportedExtensions.find ("GL_EXT_texture_lod_bias") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_mirror_clamp] = (supportedExtensions.find ("GL_EXT_texture_mirror_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_mirror_clamp_to_edge] = (supportedExtensions.find ("GL_EXT_texture_mirror_clamp_to_edge") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_norm16] = (supportedExtensions.find ("GL_EXT_texture_norm16") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_object] = (supportedExtensions.find ("GL_EXT_texture_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_perturb_normal] = (supportedExtensions.find ("GL_EXT_texture_perturb_normal") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_query_lod] = (supportedExtensions.find ("GL_EXT_texture_query_lod") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_rg] = (supportedExtensions.find ("GL_EXT_texture_rg") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_sRGB] = (supportedExtensions.find ("GL_EXT_texture_sRGB") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_sRGB_R8] = (supportedExtensions.find ("GL_EXT_texture_sRGB_R8") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_sRGB_RG8] = (supportedExtensions.find ("GL_EXT_texture_sRGB_RG8") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_sRGB_decode] = (supportedExtensions.find ("GL_EXT_texture_sRGB_decode") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_shadow_lod] = (supportedExtensions.find ("GL_EXT_texture_shadow_lod") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_shared_exponent] = (supportedExtensions.find ("GL_EXT_texture_shared_exponent") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_snorm] = (supportedExtensions.find ("GL_EXT_texture_snorm") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_storage] = (supportedExtensions.find ("GL_EXT_texture_storage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_storage_compression] = (supportedExtensions.find ("GL_EXT_texture_storage_compression") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_swizzle] = (supportedExtensions.find ("GL_EXT_texture_swizzle") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_type_2_10_10_10_REV] = (supportedExtensions.find ("GL_EXT_texture_type_2_10_10_10_REV") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_view] = (supportedExtensions.find ("GL_EXT_texture_view") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_timeline_semaphore] = (supportedExtensions.find ("GL_NV_timeline_semaphore") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_timer_query] = (supportedExtensions.find ("GL_EXT_timer_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback] = (supportedExtensions.find ("GL_EXT_transform_feedback") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_unpack_subimage] = (supportedExtensions.find ("GL_EXT_unpack_subimage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_vertex_array] = (supportedExtensions.find ("GL_EXT_vertex_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_vertex_array_bgra] = (supportedExtensions.find ("GL_EXT_vertex_array_bgra") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit] = (supportedExtensions.find ("GL_EXT_vertex_attrib_64bit") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader] = (supportedExtensions.find ("GL_EXT_vertex_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_vertex_weighting] = (supportedExtensions.find ("GL_EXT_vertex_weighting") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_win32_keyed_mutex] = (supportedExtensions.find ("GL_EXT_win32_keyed_mutex") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_window_rectangles] = (supportedExtensions.find ("GL_EXT_window_rectangles") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_EXT_x11_sync_object] = (supportedExtensions.find ("GL_EXT_x11_sync_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_FJ_shader_binary_GCCSO] = (supportedExtensions.find ("GL_FJ_shader_binary_GCCSO") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_GREMEDY_frame_terminator] = (supportedExtensions.find ("GL_GREMEDY_frame_terminator") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_GREMEDY_string_marker] = (supportedExtensions.find ("GL_GREMEDY_string_marker") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_HP_convolution_border_modes] = (supportedExtensions.find ("GL_HP_convolution_border_modes") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_HP_image_transform] = (supportedExtensions.find ("GL_HP_image_transform") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_HP_occlusion_test] = (supportedExtensions.find ("GL_HP_occlusion_test") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_HP_texture_lighting] = (supportedExtensions.find ("GL_HP_texture_lighting") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IBM_cull_vertex] = (supportedExtensions.find ("GL_IBM_cull_vertex") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IBM_multimode_draw_arrays] = (supportedExtensions.find ("GL_IBM_multimode_draw_arrays") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IBM_rasterpos_clip] = (supportedExtensions.find ("GL_IBM_rasterpos_clip") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IBM_static_data] = (supportedExtensions.find ("GL_IBM_static_data") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IBM_texture_mirrored_repeat] = (supportedExtensions.find ("GL_IBM_texture_mirrored_repeat") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IBM_vertex_array_lists] = (supportedExtensions.find ("GL_IBM_vertex_array_lists") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IMG_bindless_texture] = (supportedExtensions.find ("GL_IMG_bindless_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IMG_framebuffer_downsample] = (supportedExtensions.find ("GL_IMG_framebuffer_downsample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IMG_multisampled_render_to_texture] = (supportedExtensions.find ("GL_IMG_multisampled_render_to_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IMG_program_binary] = (supportedExtensions.find ("GL_IMG_program_binary") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IMG_read_format] = (supportedExtensions.find ("GL_IMG_read_format") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IMG_shader_binary] = (supportedExtensions.find ("GL_IMG_shader_binary") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IMG_texture_compression_pvrtc] = (supportedExtensions.find ("GL_IMG_texture_compression_pvrtc") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IMG_texture_compression_pvrtc2] = (supportedExtensions.find ("GL_IMG_texture_compression_pvrtc2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_IMG_texture_filter_cubic] = (supportedExtensions.find ("GL_IMG_texture_filter_cubic") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_INGR_blend_func_separate] = (supportedExtensions.find ("GL_INGR_blend_func_separate") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_INGR_color_clamp] = (supportedExtensions.find ("GL_INGR_color_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_INGR_interlace_read] = (supportedExtensions.find ("GL_INGR_interlace_read") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_INTEL_conservative_rasterization] = (supportedExtensions.find ("GL_INTEL_conservative_rasterization") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_INTEL_fragment_shader_ordering] = (supportedExtensions.find ("GL_INTEL_fragment_shader_ordering") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_INTEL_framebuffer_CMAA] = (supportedExtensions.find ("GL_INTEL_framebuffer_CMAA") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_INTEL_map_texture] = (supportedExtensions.find ("GL_INTEL_map_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_INTEL_blackhole_render] = (supportedExtensions.find ("GL_INTEL_blackhole_render") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_INTEL_parallel_arrays] = (supportedExtensions.find ("GL_INTEL_parallel_arrays") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_INTEL_performance_query] = (supportedExtensions.find ("GL_INTEL_performance_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_blend_equation_advanced] = (supportedExtensions.find ("GL_KHR_blend_equation_advanced") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_blend_equation_advanced_coherent] = (supportedExtensions.find ("GL_KHR_blend_equation_advanced_coherent") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_context_flush_control] = (supportedExtensions.find ("GL_KHR_context_flush_control") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_debug] = (supportedExtensions.find ("GL_KHR_debug") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_no_error] = (supportedExtensions.find ("GL_KHR_no_error") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_robust_buffer_access_behavior] = (supportedExtensions.find ("GL_KHR_robust_buffer_access_behavior") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_robustness] = (supportedExtensions.find ("GL_KHR_robustness") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_shader_subgroup] = (supportedExtensions.find ("GL_KHR_shader_subgroup") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_texture_compression_astc_hdr] = (supportedExtensions.find ("GL_KHR_texture_compression_astc_hdr") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_texture_compression_astc_ldr] = (supportedExtensions.find ("GL_KHR_texture_compression_astc_ldr") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_texture_compression_astc_sliced_3d] = (supportedExtensions.find ("GL_KHR_texture_compression_astc_sliced_3d") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_KHR_parallel_shader_compile] = (supportedExtensions.find ("GL_KHR_parallel_shader_compile") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESAX_texture_stack] = (supportedExtensions.find ("GL_MESAX_texture_stack") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_bgra] = (supportedExtensions.find ("GL_MESA_bgra") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_framebuffer_flip_x] = (supportedExtensions.find ("GL_MESA_framebuffer_flip_x") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_framebuffer_flip_y] = (supportedExtensions.find ("GL_MESA_framebuffer_flip_y") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_framebuffer_swap_xy] = (supportedExtensions.find ("GL_MESA_framebuffer_swap_xy") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_pack_invert] = (supportedExtensions.find ("GL_MESA_pack_invert") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_program_binary_formats] = (supportedExtensions.find ("GL_MESA_program_binary_formats") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_resize_buffers] = (supportedExtensions.find ("GL_MESA_resize_buffers") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects] = (supportedExtensions.find ("GL_MESA_sampler_objects") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_shader_integer_functions] = (supportedExtensions.find ("GL_MESA_shader_integer_functions") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_texture_const_bandwidth] = (supportedExtensions.find ("GL_MESA_texture_const_bandwidth") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_tile_raster_order] = (supportedExtensions.find ("GL_MESA_tile_raster_order") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_window_pos] = (supportedExtensions.find ("GL_MESA_window_pos") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_MESA_ycbcr_texture] = (supportedExtensions.find ("GL_MESA_ycbcr_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NVX_blend_equation_advanced_multi_draw_buffers] = (supportedExtensions.find ("GL_NVX_blend_equation_advanced_multi_draw_buffers") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NVX_conditional_render] = (supportedExtensions.find ("GL_NVX_conditional_render") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NVX_gpu_memory_info] = (supportedExtensions.find ("GL_NVX_gpu_memory_info") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NVX_linked_gpu_multicast] = (supportedExtensions.find ("GL_NVX_linked_gpu_multicast") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_alpha_to_coverage_dither_control] = (supportedExtensions.find ("GL_NV_alpha_to_coverage_dither_control") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_bindless_multi_draw_indirect] = (supportedExtensions.find ("GL_NV_bindless_multi_draw_indirect") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_bindless_multi_draw_indirect_count] = (supportedExtensions.find ("GL_NV_bindless_multi_draw_indirect_count") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_bindless_texture] = (supportedExtensions.find ("GL_NV_bindless_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_blend_equation_advanced] = (supportedExtensions.find ("GL_NV_blend_equation_advanced") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_blend_equation_advanced_coherent] = (supportedExtensions.find ("GL_NV_blend_equation_advanced_coherent") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_blend_minmax_factor] = (supportedExtensions.find ("GL_NV_blend_minmax_factor") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_blend_square] = (supportedExtensions.find ("GL_NV_blend_square") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_clip_space_w_scaling] = (supportedExtensions.find ("GL_NV_clip_space_w_scaling") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_command_list] = (supportedExtensions.find ("GL_NV_command_list") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_compute_program5] = (supportedExtensions.find ("GL_NV_compute_program5") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_compute_shader_derivatives] = (supportedExtensions.find ("GL_NV_compute_shader_derivatives") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_conditional_render] = (supportedExtensions.find ("GL_NV_conditional_render") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_conservative_raster] = (supportedExtensions.find ("GL_NV_conservative_raster") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_conservative_raster_dilate] = (supportedExtensions.find ("GL_NV_conservative_raster_dilate") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_conservative_raster_pre_snap] = (supportedExtensions.find ("GL_NV_conservative_raster_pre_snap") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_conservative_raster_pre_snap_triangles] = (supportedExtensions.find ("GL_NV_conservative_raster_pre_snap_triangles") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_conservative_raster_underestimation] = (supportedExtensions.find ("GL_NV_conservative_raster_underestimation") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_copy_buffer] = (supportedExtensions.find ("GL_NV_copy_buffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_copy_depth_to_color] = (supportedExtensions.find ("GL_NV_copy_depth_to_color") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_copy_image] = (supportedExtensions.find ("GL_NV_copy_image") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_coverage_sample] = (supportedExtensions.find ("GL_NV_coverage_sample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_deep_texture3D] = (supportedExtensions.find ("GL_NV_deep_texture3D") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_depth_buffer_float] = (supportedExtensions.find ("GL_NV_depth_buffer_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_depth_clamp] = (supportedExtensions.find ("GL_NV_depth_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_depth_nonlinear] = (supportedExtensions.find ("GL_NV_depth_nonlinear") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_draw_buffers] = (supportedExtensions.find ("GL_NV_draw_buffers") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_draw_instanced] = (supportedExtensions.find ("GL_NV_draw_instanced") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_draw_texture] = (supportedExtensions.find ("GL_NV_draw_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_draw_vulkan_image] = (supportedExtensions.find ("GL_NV_draw_vulkan_image") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_evaluators] = (supportedExtensions.find ("GL_NV_evaluators") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_explicit_attrib_location] = (supportedExtensions.find ("GL_NV_explicit_attrib_location") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_explicit_multisample] = (supportedExtensions.find ("GL_NV_explicit_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_fbo_color_attachments] = (supportedExtensions.find ("GL_NV_fbo_color_attachments") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_fence] = (supportedExtensions.find ("GL_NV_fence") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_fill_rectangle] = (supportedExtensions.find ("GL_NV_fill_rectangle") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_float_buffer] = (supportedExtensions.find ("GL_NV_float_buffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_fog_distance] = (supportedExtensions.find ("GL_NV_fog_distance") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_fragment_coverage_to_color] = (supportedExtensions.find ("GL_NV_fragment_coverage_to_color") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_fragment_program] = (supportedExtensions.find ("GL_NV_fragment_program") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_fragment_program2] = (supportedExtensions.find ("GL_NV_fragment_program2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_fragment_program4] = (supportedExtensions.find ("GL_NV_fragment_program4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_fragment_program_option] = (supportedExtensions.find ("GL_NV_fragment_program_option") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_fragment_shader_barycentric] = (supportedExtensions.find ("GL_NV_fragment_shader_barycentric") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_fragment_shader_interlock] = (supportedExtensions.find ("GL_NV_fragment_shader_interlock") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_framebuffer_blit] = (supportedExtensions.find ("GL_NV_framebuffer_blit") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_framebuffer_mixed_samples] = (supportedExtensions.find ("GL_NV_framebuffer_mixed_samples") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_framebuffer_multisample] = (supportedExtensions.find ("GL_NV_framebuffer_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_framebuffer_multisample_coverage] = (supportedExtensions.find ("GL_NV_framebuffer_multisample_coverage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_generate_mipmap_sRGB] = (supportedExtensions.find ("GL_NV_generate_mipmap_sRGB") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_geometry_program4] = (supportedExtensions.find ("GL_NV_geometry_program4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_geometry_shader4] = (supportedExtensions.find ("GL_NV_geometry_shader4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_geometry_shader_passthrough] = (supportedExtensions.find ("GL_NV_geometry_shader_passthrough") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_gpu_program4] = (supportedExtensions.find ("GL_NV_gpu_program4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_gpu_program5] = (supportedExtensions.find ("GL_NV_gpu_program5") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_gpu_program5_mem_extended] = (supportedExtensions.find ("GL_NV_gpu_program5_mem_extended") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5] = (supportedExtensions.find ("GL_NV_gpu_shader5") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_half_float] = (supportedExtensions.find ("GL_NV_half_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_image_formats] = (supportedExtensions.find ("GL_NV_image_formats") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_instanced_arrays] = (supportedExtensions.find ("GL_NV_instanced_arrays") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_internalformat_sample_query] = (supportedExtensions.find ("GL_NV_internalformat_sample_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_light_max_exponent] = (supportedExtensions.find ("GL_NV_light_max_exponent") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast] = (supportedExtensions.find ("GL_NV_gpu_multicast") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NVX_gpu_multicast2] = (supportedExtensions.find ("GL_NVX_gpu_multicast2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NVX_progress_fence] = (supportedExtensions.find ("GL_NVX_progress_fence") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_memory_attachment] = (supportedExtensions.find ("GL_NV_memory_attachment") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_memory_object_sparse] = (supportedExtensions.find ("GL_NV_memory_object_sparse") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_mesh_shader] = (supportedExtensions.find ("GL_NV_mesh_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_multisample_coverage] = (supportedExtensions.find ("GL_NV_multisample_coverage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_multisample_filter_hint] = (supportedExtensions.find ("GL_NV_multisample_filter_hint") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices] = (supportedExtensions.find ("GL_NV_non_square_matrices") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_occlusion_query] = (supportedExtensions.find ("GL_NV_occlusion_query") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_packed_depth_stencil] = (supportedExtensions.find ("GL_NV_packed_depth_stencil") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_parameter_buffer_object] = (supportedExtensions.find ("GL_NV_parameter_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_parameter_buffer_object2] = (supportedExtensions.find ("GL_NV_parameter_buffer_object2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_path_rendering] = (supportedExtensions.find ("GL_NV_path_rendering") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_path_rendering_shared_edge] = (supportedExtensions.find ("GL_NV_path_rendering_shared_edge") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_pixel_data_range] = (supportedExtensions.find ("GL_NV_pixel_data_range") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_pixel_buffer_object] = (supportedExtensions.find ("GL_NV_pixel_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_point_sprite] = (supportedExtensions.find ("GL_NV_point_sprite") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_polygon_mode] = (supportedExtensions.find ("GL_NV_polygon_mode") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_present_video] = (supportedExtensions.find ("GL_NV_present_video") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_primitive_restart] = (supportedExtensions.find ("GL_NV_primitive_restart") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_primitive_shading_rate] = (supportedExtensions.find ("GL_NV_primitive_shading_rate") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_query_resource] = (supportedExtensions.find ("GL_NV_query_resource") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_query_resource_tag] = (supportedExtensions.find ("GL_NV_query_resource_tag") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_read_buffer] = (supportedExtensions.find ("GL_NV_read_buffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_read_buffer_front] = (supportedExtensions.find ("GL_NV_read_buffer_front") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_read_depth] = (supportedExtensions.find ("GL_NV_read_depth") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_read_depth_stencil] = (supportedExtensions.find ("GL_NV_read_depth_stencil") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_read_stencil] = (supportedExtensions.find ("GL_NV_read_stencil") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_register_combiners] = (supportedExtensions.find ("GL_NV_register_combiners") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_register_combiners2] = (supportedExtensions.find ("GL_NV_register_combiners2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_representative_fragment_test] = (supportedExtensions.find ("GL_NV_representative_fragment_test") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_robustness_video_memory_purge] = (supportedExtensions.find ("GL_NV_robustness_video_memory_purge") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_sRGB_formats] = (supportedExtensions.find ("GL_NV_sRGB_formats") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_sample_locations] = (supportedExtensions.find ("GL_NV_sample_locations") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_sample_mask_override_coverage] = (supportedExtensions.find ("GL_NV_sample_mask_override_coverage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_scissor_exclusive] = (supportedExtensions.find ("GL_NV_scissor_exclusive") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_atomic_counters] = (supportedExtensions.find ("GL_NV_shader_atomic_counters") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_atomic_float] = (supportedExtensions.find ("GL_NV_shader_atomic_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_atomic_float64] = (supportedExtensions.find ("GL_NV_shader_atomic_float64") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_atomic_fp16_vector] = (supportedExtensions.find ("GL_NV_shader_atomic_fp16_vector") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_atomic_int64] = (supportedExtensions.find ("GL_NV_shader_atomic_int64") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load] = (supportedExtensions.find ("GL_NV_shader_buffer_load") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_store] = (supportedExtensions.find ("GL_NV_shader_buffer_store") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_noperspective_interpolation] = (supportedExtensions.find ("GL_NV_shader_noperspective_interpolation") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_storage_buffer_object] = (supportedExtensions.find ("GL_NV_shader_storage_buffer_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_subgroup_partitioned] = (supportedExtensions.find ("GL_NV_shader_subgroup_partitioned") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_texture_footprint] = (supportedExtensions.find ("GL_NV_shader_texture_footprint") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_thread_group] = (supportedExtensions.find ("GL_NV_shader_thread_group") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_thread_shuffle] = (supportedExtensions.find ("GL_NV_shader_thread_shuffle") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shading_rate_image] = (supportedExtensions.find ("GL_NV_shading_rate_image") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shadow_samplers_array] = (supportedExtensions.find ("GL_NV_shadow_samplers_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_shadow_samplers_cube] = (supportedExtensions.find ("GL_NV_shadow_samplers_cube") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_stereo_view_rendering] = (supportedExtensions.find ("GL_NV_stereo_view_rendering") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_tessellation_program5] = (supportedExtensions.find ("GL_NV_tessellation_program5") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texgen_emboss] = (supportedExtensions.find ("GL_NV_texgen_emboss") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texgen_reflection] = (supportedExtensions.find ("GL_NV_texgen_reflection") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_barrier] = (supportedExtensions.find ("GL_NV_texture_barrier") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_border_clamp] = (supportedExtensions.find ("GL_NV_texture_border_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_compression_s3tc_update] = (supportedExtensions.find ("GL_NV_texture_compression_s3tc_update") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_compression_vtc] = (supportedExtensions.find ("GL_NV_texture_compression_vtc") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_env_combine4] = (supportedExtensions.find ("GL_NV_texture_env_combine4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_expand_normal] = (supportedExtensions.find ("GL_NV_texture_expand_normal") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_multisample] = (supportedExtensions.find ("GL_NV_texture_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_npot_2D_mipmap] = (supportedExtensions.find ("GL_NV_texture_npot_2D_mipmap") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_rectangle] = (supportedExtensions.find ("GL_NV_texture_rectangle") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_rectangle_compressed] = (supportedExtensions.find ("GL_NV_texture_rectangle_compressed") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_shader] = (supportedExtensions.find ("GL_NV_texture_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_shader2] = (supportedExtensions.find ("GL_NV_texture_shader2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_shader3] = (supportedExtensions.find ("GL_NV_texture_shader3") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_transform_feedback] = (supportedExtensions.find ("GL_NV_transform_feedback") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2] = (supportedExtensions.find ("GL_NV_transform_feedback2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_uniform_buffer_std430_layout] = (supportedExtensions.find ("GL_NV_uniform_buffer_std430_layout") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_uniform_buffer_unified_memory] = (supportedExtensions.find ("GL_NV_uniform_buffer_unified_memory") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop] = (supportedExtensions.find ("GL_NV_vdpau_interop") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop2] = (supportedExtensions.find ("GL_NV_vdpau_interop2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_array_range] = (supportedExtensions.find ("GL_NV_vertex_array_range") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_array_range2] = (supportedExtensions.find ("GL_NV_vertex_array_range2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit] = (supportedExtensions.find ("GL_NV_vertex_attrib_integer_64bit") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory] = (supportedExtensions.find ("GL_NV_vertex_buffer_unified_memory") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_program] = (supportedExtensions.find ("GL_NV_vertex_program") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_program1_1] = (supportedExtensions.find ("GL_NV_vertex_program1_1") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_program2] = (supportedExtensions.find ("GL_NV_vertex_program2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_program2_option] = (supportedExtensions.find ("GL_NV_vertex_program2_option") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_program3] = (supportedExtensions.find ("GL_NV_vertex_program3") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_program4] = (supportedExtensions.find ("GL_NV_vertex_program4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_video_capture] = (supportedExtensions.find ("GL_NV_video_capture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_viewport_array] = (supportedExtensions.find ("GL_NV_viewport_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_viewport_array2] = (supportedExtensions.find ("GL_NV_viewport_array2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_viewport_swizzle] = (supportedExtensions.find ("GL_NV_viewport_swizzle") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_NV_pack_subimage] = (supportedExtensions.find ("GL_NV_pack_subimage") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_EGL_image] = (supportedExtensions.find ("GL_OES_EGL_image") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_EGL_image_external] = (supportedExtensions.find ("GL_OES_EGL_image_external") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_EGL_image_external_essl3] = (supportedExtensions.find ("GL_OES_EGL_image_external_essl3") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates] = (supportedExtensions.find ("GL_OES_byte_coordinates") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_compressed_ETC1_RGB8_sub_texture] = (supportedExtensions.find ("GL_OES_compressed_ETC1_RGB8_sub_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_compressed_ETC1_RGB8_texture] = (supportedExtensions.find ("GL_OES_compressed_ETC1_RGB8_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_compressed_paletted_texture] = (supportedExtensions.find ("GL_OES_compressed_paletted_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_copy_image] = (supportedExtensions.find ("GL_OES_copy_image") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_depth24] = (supportedExtensions.find ("GL_OES_depth24") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_depth32] = (supportedExtensions.find ("GL_OES_depth32") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_depth_texture] = (supportedExtensions.find ("GL_OES_depth_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed] = (supportedExtensions.find ("GL_OES_draw_buffers_indexed") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_draw_elements_base_vertex] = (supportedExtensions.find ("GL_OES_draw_elements_base_vertex") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_element_index_uint] = (supportedExtensions.find ("GL_OES_element_index_uint") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_fbo_render_mipmap] = (supportedExtensions.find ("GL_OES_fbo_render_mipmap") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_fixed_point] = (supportedExtensions.find ("GL_OES_fixed_point") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_fragment_precision_high] = (supportedExtensions.find ("GL_OES_fragment_precision_high") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_geometry_point_size] = (supportedExtensions.find ("GL_OES_geometry_point_size") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_geometry_shader] = (supportedExtensions.find ("GL_OES_geometry_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_get_program_binary] = (supportedExtensions.find ("GL_OES_get_program_binary") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_gpu_shader5] = (supportedExtensions.find ("GL_OES_gpu_shader5") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_mapbuffer] = (supportedExtensions.find ("GL_OES_mapbuffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_packed_depth_stencil] = (supportedExtensions.find ("GL_OES_packed_depth_stencil") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_primitive_bounding_box] = (supportedExtensions.find ("GL_OES_primitive_bounding_box") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_query_matrix] = (supportedExtensions.find ("GL_OES_query_matrix") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_read_format] = (supportedExtensions.find ("GL_OES_read_format") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_required_internalformat] = (supportedExtensions.find ("GL_OES_required_internalformat") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_rgb8_rgba8] = (supportedExtensions.find ("GL_OES_rgb8_rgba8") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_sample_shading] = (supportedExtensions.find ("GL_OES_sample_shading") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_sample_variables] = (supportedExtensions.find ("GL_OES_sample_variables") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_shader_image_atomic] = (supportedExtensions.find ("GL_OES_shader_image_atomic") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_shader_io_blocks] = (supportedExtensions.find ("GL_OES_shader_io_blocks") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_shader_multisample_interpolation] = (supportedExtensions.find ("GL_OES_shader_multisample_interpolation") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_single_precision] = (supportedExtensions.find ("GL_OES_single_precision") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_standard_derivatives] = (supportedExtensions.find ("GL_OES_standard_derivatives") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_stencil1] = (supportedExtensions.find ("GL_OES_stencil1") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_stencil4] = (supportedExtensions.find ("GL_OES_stencil4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_surfaceless_context] = (supportedExtensions.find ("GL_OES_surfaceless_context") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_tessellation_point_size] = (supportedExtensions.find ("GL_OES_tessellation_point_size") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_tessellation_shader] = (supportedExtensions.find ("GL_OES_tessellation_shader") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_3D] = (supportedExtensions.find ("GL_OES_texture_3D") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp] = (supportedExtensions.find ("GL_OES_texture_border_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_buffer] = (supportedExtensions.find ("GL_OES_texture_buffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_compression_astc] = (supportedExtensions.find ("GL_OES_texture_compression_astc") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_cube_map_array] = (supportedExtensions.find ("GL_OES_texture_cube_map_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_float] = (supportedExtensions.find ("GL_OES_texture_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_float_linear] = (supportedExtensions.find ("GL_OES_texture_float_linear") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_half_float] = (supportedExtensions.find ("GL_OES_texture_half_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_half_float_linear] = (supportedExtensions.find ("GL_OES_texture_half_float_linear") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_npot] = (supportedExtensions.find ("GL_OES_texture_npot") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_stencil8] = (supportedExtensions.find ("GL_OES_texture_stencil8") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_storage_multisample_2d_array] = (supportedExtensions.find ("GL_OES_texture_storage_multisample_2d_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_view] = (supportedExtensions.find ("GL_OES_texture_view") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_vertex_array_object] = (supportedExtensions.find ("GL_OES_vertex_array_object") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_vertex_half_float] = (supportedExtensions.find ("GL_OES_vertex_half_float") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_vertex_type_10_10_10_2] = (supportedExtensions.find ("GL_OES_vertex_type_10_10_10_2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OES_viewport_array] = (supportedExtensions.find ("GL_OES_viewport_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OML_interlace] = (supportedExtensions.find ("GL_OML_interlace") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OML_resample] = (supportedExtensions.find ("GL_OML_resample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OML_subsample] = (supportedExtensions.find ("GL_OML_subsample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OVR_multiview] = (supportedExtensions.find ("GL_OVR_multiview") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OVR_multiview2] = (supportedExtensions.find ("GL_OVR_multiview2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_OVR_multiview_multisampled_render_to_texture] = (supportedExtensions.find ("GL_OVR_multiview_multisampled_render_to_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_PGI_misc_hints] = (supportedExtensions.find ("GL_PGI_misc_hints") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_PGI_vertex_hints] = (supportedExtensions.find ("GL_PGI_vertex_hints") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_alpha_test] = (supportedExtensions.find ("GL_QCOM_alpha_test") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_binning_control] = (supportedExtensions.find ("GL_QCOM_binning_control") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_driver_control] = (supportedExtensions.find ("GL_QCOM_driver_control") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_extended_get] = (supportedExtensions.find ("GL_QCOM_extended_get") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_extended_get2] = (supportedExtensions.find ("GL_QCOM_extended_get2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_framebuffer_foveated] = (supportedExtensions.find ("GL_QCOM_framebuffer_foveated") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_motion_estimation] = (supportedExtensions.find ("GL_QCOM_motion_estimation") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_frame_extrapolation] = (supportedExtensions.find ("GL_QCOM_frame_extrapolation") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_render_shared_exponent] = (supportedExtensions.find ("GL_QCOM_render_shared_exponent") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_render_sRGB_R8_RG8] = (supportedExtensions.find ("GL_QCOM_render_sRGB_R8_RG8") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_texture_foveated] = (supportedExtensions.find ("GL_QCOM_texture_foveated") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_texture_foveated2] = (supportedExtensions.find ("GL_QCOM_texture_foveated2") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_texture_foveated_subsampled_layout] = (supportedExtensions.find ("GL_QCOM_texture_foveated_subsampled_layout") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_ycbcr_degamma] = (supportedExtensions.find ("GL_QCOM_ycbcr_degamma") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_texture_lod_bias] = (supportedExtensions.find ("GL_QCOM_texture_lod_bias") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_perfmon_global_mode] = (supportedExtensions.find ("GL_QCOM_perfmon_global_mode") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_shader_framebuffer_fetch_noncoherent] = (supportedExtensions.find ("GL_QCOM_shader_framebuffer_fetch_noncoherent") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_shader_framebuffer_fetch_rate] = (supportedExtensions.find ("GL_QCOM_shader_framebuffer_fetch_rate") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_shading_rate] = (supportedExtensions.find ("GL_QCOM_shading_rate") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_tiled_rendering] = (supportedExtensions.find ("GL_QCOM_tiled_rendering") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_writeonly_rendering] = (supportedExtensions.find ("GL_QCOM_writeonly_rendering") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_YUV_texture_gather] = (supportedExtensions.find ("GL_QCOM_YUV_texture_gather") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_REND_screen_coordinates] = (supportedExtensions.find ("GL_REND_screen_coordinates") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_S3_s3tc] = (supportedExtensions.find ("GL_S3_s3tc") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_detail_texture] = (supportedExtensions.find ("GL_SGIS_detail_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_fog_function] = (supportedExtensions.find ("GL_SGIS_fog_function") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_generate_mipmap] = (supportedExtensions.find ("GL_SGIS_generate_mipmap") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_multisample] = (supportedExtensions.find ("GL_SGIS_multisample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_pixel_texture] = (supportedExtensions.find ("GL_SGIS_pixel_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_point_line_texgen] = (supportedExtensions.find ("GL_SGIS_point_line_texgen") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_point_parameters] = (supportedExtensions.find ("GL_SGIS_point_parameters") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_sharpen_texture] = (supportedExtensions.find ("GL_SGIS_sharpen_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_texture4D] = (supportedExtensions.find ("GL_SGIS_texture4D") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_texture_border_clamp] = (supportedExtensions.find ("GL_SGIS_texture_border_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_texture_color_mask] = (supportedExtensions.find ("GL_SGIS_texture_color_mask") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_texture_edge_clamp] = (supportedExtensions.find ("GL_SGIS_texture_edge_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_texture_filter4] = (supportedExtensions.find ("GL_SGIS_texture_filter4") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_texture_lod] = (supportedExtensions.find ("GL_SGIS_texture_lod") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_texture_select] = (supportedExtensions.find ("GL_SGIS_texture_select") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_async] = (supportedExtensions.find ("GL_SGIX_async") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_async_histogram] = (supportedExtensions.find ("GL_SGIX_async_histogram") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_async_pixel] = (supportedExtensions.find ("GL_SGIX_async_pixel") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_blend_alpha_minmax] = (supportedExtensions.find ("GL_SGIX_blend_alpha_minmax") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_calligraphic_fragment] = (supportedExtensions.find ("GL_SGIX_calligraphic_fragment") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_clipmap] = (supportedExtensions.find ("GL_SGIX_clipmap") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_convolution_accuracy] = (supportedExtensions.find ("GL_SGIX_convolution_accuracy") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_depth_pass_instrument] = (supportedExtensions.find ("GL_SGIX_depth_pass_instrument") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_depth_texture] = (supportedExtensions.find ("GL_SGIX_depth_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_flush_raster] = (supportedExtensions.find ("GL_SGIX_flush_raster") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_fog_offset] = (supportedExtensions.find ("GL_SGIX_fog_offset") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting] = (supportedExtensions.find ("GL_SGIX_fragment_lighting") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_framezoom] = (supportedExtensions.find ("GL_SGIX_framezoom") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_igloo_interface] = (supportedExtensions.find ("GL_SGIX_igloo_interface") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_instruments] = (supportedExtensions.find ("GL_SGIX_instruments") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_interlace] = (supportedExtensions.find ("GL_SGIX_interlace") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_ir_instrument1] = (supportedExtensions.find ("GL_SGIX_ir_instrument1") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_list_priority] = (supportedExtensions.find ("GL_SGIX_list_priority") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_pixel_texture] = (supportedExtensions.find ("GL_SGIX_pixel_texture") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_pixel_tiles] = (supportedExtensions.find ("GL_SGIX_pixel_tiles") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_polynomial_ffd] = (supportedExtensions.find ("GL_SGIX_polynomial_ffd") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_reference_plane] = (supportedExtensions.find ("GL_SGIX_reference_plane") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_resample] = (supportedExtensions.find ("GL_SGIX_resample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_scalebias_hint] = (supportedExtensions.find ("GL_SGIX_scalebias_hint") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_shadow] = (supportedExtensions.find ("GL_SGIX_shadow") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_shadow_ambient] = (supportedExtensions.find ("GL_SGIX_shadow_ambient") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_sprite] = (supportedExtensions.find ("GL_SGIX_sprite") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_subsample] = (supportedExtensions.find ("GL_SGIX_subsample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_tag_sample_buffer] = (supportedExtensions.find ("GL_SGIX_tag_sample_buffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_texture_add_env] = (supportedExtensions.find ("GL_SGIX_texture_add_env") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_texture_coordinate_clamp] = (supportedExtensions.find ("GL_SGIX_texture_coordinate_clamp") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_texture_lod_bias] = (supportedExtensions.find ("GL_SGIX_texture_lod_bias") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_texture_multi_buffer] = (supportedExtensions.find ("GL_SGIX_texture_multi_buffer") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_texture_scale_bias] = (supportedExtensions.find ("GL_SGIX_texture_scale_bias") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_vertex_preclip] = (supportedExtensions.find ("GL_SGIX_vertex_preclip") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_ycrcb] = (supportedExtensions.find ("GL_SGIX_ycrcb") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_ycrcb_subsample] = (supportedExtensions.find ("GL_SGIX_ycrcb_subsample") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_ycrcba] = (supportedExtensions.find ("GL_SGIX_ycrcba") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGI_color_matrix] = (supportedExtensions.find ("GL_SGI_color_matrix") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGI_color_table] = (supportedExtensions.find ("GL_SGI_color_table") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SGI_texture_color_table] = (supportedExtensions.find ("GL_SGI_texture_color_table") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SUNX_constant_data] = (supportedExtensions.find ("GL_SUNX_constant_data") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SUN_convolution_border_modes] = (supportedExtensions.find ("GL_SUN_convolution_border_modes") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SUN_global_alpha] = (supportedExtensions.find ("GL_SUN_global_alpha") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SUN_mesh_array] = (supportedExtensions.find ("GL_SUN_mesh_array") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SUN_slice_accum] = (supportedExtensions.find ("GL_SUN_slice_accum") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SUN_triangle_list] = (supportedExtensions.find ("GL_SUN_triangle_list") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_SUN_vertex] = (supportedExtensions.find ("GL_SUN_vertex") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_VIV_shader_binary] = (supportedExtensions.find ("GL_VIV_shader_binary") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_WIN_phong_shading] = (supportedExtensions.find ("GL_WIN_phong_shading") != supportedExtensions.end ());
  s_deviceConfig.m_featureSupported [GLEW_GL_WIN_specular_fog] = (supportedExtensions.find ("GL_WIN_specular_fog") != supportedExtensions.end ());

  // GL_VERSION_1_1
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_1_1])
  {
    s_deviceConfig.m_glDrawArrays = (PFNGLDRAWARRAYSPROC) glewGetProcAddress ("glDrawArrays");
    s_deviceConfig.m_glDrawElements = (PFNGLDRAWELEMENTSPROC) glewGetProcAddress ("glDrawElements");
    s_deviceConfig.m_glGetPointerv = (PFNGLGETPOINTERVPROC) glewGetProcAddress ("glGetPointerv");
    s_deviceConfig.m_glPolygonOffset = (PFNGLPOLYGONOFFSETPROC) glewGetProcAddress ("glPolygonOffset");
    s_deviceConfig.m_glCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC) glewGetProcAddress ("glCopyTexImage1D");
    s_deviceConfig.m_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC) glewGetProcAddress ("glCopyTexImage2D");
    s_deviceConfig.m_glCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC) glewGetProcAddress ("glCopyTexSubImage1D");
    s_deviceConfig.m_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC) glewGetProcAddress ("glCopyTexSubImage2D");
    s_deviceConfig.m_glTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC) glewGetProcAddress ("glTexSubImage1D");
    s_deviceConfig.m_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC) glewGetProcAddress ("glTexSubImage2D");
    s_deviceConfig.m_glBindTexture = (PFNGLBINDTEXTUREPROC) glewGetProcAddress ("glBindTexture");
    s_deviceConfig.m_glDeleteTextures = (PFNGLDELETETEXTURESPROC) glewGetProcAddress ("glDeleteTextures");
    s_deviceConfig.m_glGenTextures = (PFNGLGENTEXTURESPROC) glewGetProcAddress ("glGenTextures");
    s_deviceConfig.m_glIsTexture = (PFNGLISTEXTUREPROC) glewGetProcAddress ("glIsTexture");
    s_deviceConfig.m_glArrayElement = (PFNGLARRAYELEMENTPROC) glewGetProcAddress ("glArrayElement");
    s_deviceConfig.m_glColorPointer = (PFNGLCOLORPOINTERPROC) glewGetProcAddress ("glColorPointer");
    s_deviceConfig.m_glDisableClientState = (PFNGLDISABLECLIENTSTATEPROC) glewGetProcAddress ("glDisableClientState");
    s_deviceConfig.m_glEdgeFlagPointer = (PFNGLEDGEFLAGPOINTERPROC) glewGetProcAddress ("glEdgeFlagPointer");
    s_deviceConfig.m_glEnableClientState = (PFNGLENABLECLIENTSTATEPROC) glewGetProcAddress ("glEnableClientState");
    s_deviceConfig.m_glIndexPointer = (PFNGLINDEXPOINTERPROC) glewGetProcAddress ("glIndexPointer");
    s_deviceConfig.m_glInterleavedArrays = (PFNGLINTERLEAVEDARRAYSPROC) glewGetProcAddress ("glInterleavedArrays");
    s_deviceConfig.m_glNormalPointer = (PFNGLNORMALPOINTERPROC) glewGetProcAddress ("glNormalPointer");
    s_deviceConfig.m_glTexCoordPointer = (PFNGLTEXCOORDPOINTERPROC) glewGetProcAddress ("glTexCoordPointer");
    s_deviceConfig.m_glVertexPointer = (PFNGLVERTEXPOINTERPROC) glewGetProcAddress ("glVertexPointer");
    s_deviceConfig.m_glAreTexturesResident = (PFNGLARETEXTURESRESIDENTPROC) glewGetProcAddress ("glAreTexturesResident");
    s_deviceConfig.m_glPrioritizeTextures = (PFNGLPRIORITIZETEXTURESPROC) glewGetProcAddress ("glPrioritizeTextures");
    s_deviceConfig.m_glIndexub = (PFNGLINDEXUBPROC) glewGetProcAddress ("glIndexub");
    s_deviceConfig.m_glIndexubv = (PFNGLINDEXUBVPROC) glewGetProcAddress ("glIndexubv");
    s_deviceConfig.m_glPopClientAttrib = (PFNGLPOPCLIENTATTRIBPROC) glewGetProcAddress ("glPopClientAttrib");
    s_deviceConfig.m_glPushClientAttrib = (PFNGLPUSHCLIENTATTRIBPROC) glewGetProcAddress ("glPushClientAttrib");
  }

  // GL_VERSION_1_2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_1_2])
  {
    s_deviceConfig.m_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC) glewGetProcAddress ("glDrawRangeElements");
    s_deviceConfig.m_glTexImage3D = (PFNGLTEXIMAGE3DPROC) glewGetProcAddress ("glTexImage3D");
    s_deviceConfig.m_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC) glewGetProcAddress ("glTexSubImage3D");
    s_deviceConfig.m_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC) glewGetProcAddress ("glCopyTexSubImage3D");
  }

  // GL_VERSION_1_3
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_1_3])
  {
    s_deviceConfig.m_glActiveTexture = (PFNGLACTIVETEXTUREPROC) glewGetProcAddress ("glActiveTexture");
    s_deviceConfig.m_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC) glewGetProcAddress ("glSampleCoverage");
    s_deviceConfig.m_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC) glewGetProcAddress ("glCompressedTexImage3D");
    s_deviceConfig.m_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC) glewGetProcAddress ("glCompressedTexImage2D");
    s_deviceConfig.m_glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC) glewGetProcAddress ("glCompressedTexImage1D");
    s_deviceConfig.m_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) glewGetProcAddress ("glCompressedTexSubImage3D");
    s_deviceConfig.m_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) glewGetProcAddress ("glCompressedTexSubImage2D");
    s_deviceConfig.m_glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) glewGetProcAddress ("glCompressedTexSubImage1D");
    s_deviceConfig.m_glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC) glewGetProcAddress ("glGetCompressedTexImage");
    s_deviceConfig.m_glClientActiveTexture = (PFNGLCLIENTACTIVETEXTUREPROC) glewGetProcAddress ("glClientActiveTexture");
    s_deviceConfig.m_glMultiTexCoord1d = (PFNGLMULTITEXCOORD1DPROC) glewGetProcAddress ("glMultiTexCoord1d");
    s_deviceConfig.m_glMultiTexCoord1dv = (PFNGLMULTITEXCOORD1DVPROC) glewGetProcAddress ("glMultiTexCoord1dv");
    s_deviceConfig.m_glMultiTexCoord1f = (PFNGLMULTITEXCOORD1FPROC) glewGetProcAddress ("glMultiTexCoord1f");
    s_deviceConfig.m_glMultiTexCoord1fv = (PFNGLMULTITEXCOORD1FVPROC) glewGetProcAddress ("glMultiTexCoord1fv");
    s_deviceConfig.m_glMultiTexCoord1i = (PFNGLMULTITEXCOORD1IPROC) glewGetProcAddress ("glMultiTexCoord1i");
    s_deviceConfig.m_glMultiTexCoord1iv = (PFNGLMULTITEXCOORD1IVPROC) glewGetProcAddress ("glMultiTexCoord1iv");
    s_deviceConfig.m_glMultiTexCoord1s = (PFNGLMULTITEXCOORD1SPROC) glewGetProcAddress ("glMultiTexCoord1s");
    s_deviceConfig.m_glMultiTexCoord1sv = (PFNGLMULTITEXCOORD1SVPROC) glewGetProcAddress ("glMultiTexCoord1sv");
    s_deviceConfig.m_glMultiTexCoord2d = (PFNGLMULTITEXCOORD2DPROC) glewGetProcAddress ("glMultiTexCoord2d");
    s_deviceConfig.m_glMultiTexCoord2dv = (PFNGLMULTITEXCOORD2DVPROC) glewGetProcAddress ("glMultiTexCoord2dv");
    s_deviceConfig.m_glMultiTexCoord2f = (PFNGLMULTITEXCOORD2FPROC) glewGetProcAddress ("glMultiTexCoord2f");
    s_deviceConfig.m_glMultiTexCoord2fv = (PFNGLMULTITEXCOORD2FVPROC) glewGetProcAddress ("glMultiTexCoord2fv");
    s_deviceConfig.m_glMultiTexCoord2i = (PFNGLMULTITEXCOORD2IPROC) glewGetProcAddress ("glMultiTexCoord2i");
    s_deviceConfig.m_glMultiTexCoord2iv = (PFNGLMULTITEXCOORD2IVPROC) glewGetProcAddress ("glMultiTexCoord2iv");
    s_deviceConfig.m_glMultiTexCoord2s = (PFNGLMULTITEXCOORD2SPROC) glewGetProcAddress ("glMultiTexCoord2s");
    s_deviceConfig.m_glMultiTexCoord2sv = (PFNGLMULTITEXCOORD2SVPROC) glewGetProcAddress ("glMultiTexCoord2sv");
    s_deviceConfig.m_glMultiTexCoord3d = (PFNGLMULTITEXCOORD3DPROC) glewGetProcAddress ("glMultiTexCoord3d");
    s_deviceConfig.m_glMultiTexCoord3dv = (PFNGLMULTITEXCOORD3DVPROC) glewGetProcAddress ("glMultiTexCoord3dv");
    s_deviceConfig.m_glMultiTexCoord3f = (PFNGLMULTITEXCOORD3FPROC) glewGetProcAddress ("glMultiTexCoord3f");
    s_deviceConfig.m_glMultiTexCoord3fv = (PFNGLMULTITEXCOORD3FVPROC) glewGetProcAddress ("glMultiTexCoord3fv");
    s_deviceConfig.m_glMultiTexCoord3i = (PFNGLMULTITEXCOORD3IPROC) glewGetProcAddress ("glMultiTexCoord3i");
    s_deviceConfig.m_glMultiTexCoord3iv = (PFNGLMULTITEXCOORD3IVPROC) glewGetProcAddress ("glMultiTexCoord3iv");
    s_deviceConfig.m_glMultiTexCoord3s = (PFNGLMULTITEXCOORD3SPROC) glewGetProcAddress ("glMultiTexCoord3s");
    s_deviceConfig.m_glMultiTexCoord3sv = (PFNGLMULTITEXCOORD3SVPROC) glewGetProcAddress ("glMultiTexCoord3sv");
    s_deviceConfig.m_glMultiTexCoord4d = (PFNGLMULTITEXCOORD4DPROC) glewGetProcAddress ("glMultiTexCoord4d");
    s_deviceConfig.m_glMultiTexCoord4dv = (PFNGLMULTITEXCOORD4DVPROC) glewGetProcAddress ("glMultiTexCoord4dv");
    s_deviceConfig.m_glMultiTexCoord4f = (PFNGLMULTITEXCOORD4FPROC) glewGetProcAddress ("glMultiTexCoord4f");
    s_deviceConfig.m_glMultiTexCoord4fv = (PFNGLMULTITEXCOORD4FVPROC) glewGetProcAddress ("glMultiTexCoord4fv");
    s_deviceConfig.m_glMultiTexCoord4i = (PFNGLMULTITEXCOORD4IPROC) glewGetProcAddress ("glMultiTexCoord4i");
    s_deviceConfig.m_glMultiTexCoord4iv = (PFNGLMULTITEXCOORD4IVPROC) glewGetProcAddress ("glMultiTexCoord4iv");
    s_deviceConfig.m_glMultiTexCoord4s = (PFNGLMULTITEXCOORD4SPROC) glewGetProcAddress ("glMultiTexCoord4s");
    s_deviceConfig.m_glMultiTexCoord4sv = (PFNGLMULTITEXCOORD4SVPROC) glewGetProcAddress ("glMultiTexCoord4sv");
    s_deviceConfig.m_glLoadTransposeMatrixf = (PFNGLLOADTRANSPOSEMATRIXFPROC) glewGetProcAddress ("glLoadTransposeMatrixf");
    s_deviceConfig.m_glLoadTransposeMatrixd = (PFNGLLOADTRANSPOSEMATRIXDPROC) glewGetProcAddress ("glLoadTransposeMatrixd");
    s_deviceConfig.m_glMultTransposeMatrixf = (PFNGLMULTTRANSPOSEMATRIXFPROC) glewGetProcAddress ("glMultTransposeMatrixf");
    s_deviceConfig.m_glMultTransposeMatrixd = (PFNGLMULTTRANSPOSEMATRIXDPROC) glewGetProcAddress ("glMultTransposeMatrixd");
  }

  // GL_VERSION_1_4
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_1_4])
  {
    s_deviceConfig.m_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC) glewGetProcAddress ("glBlendFuncSeparate");
    s_deviceConfig.m_glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC) glewGetProcAddress ("glMultiDrawArrays");
    s_deviceConfig.m_glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC) glewGetProcAddress ("glMultiDrawElements");
    s_deviceConfig.m_glPointParameterf = (PFNGLPOINTPARAMETERFPROC) glewGetProcAddress ("glPointParameterf");
    s_deviceConfig.m_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC) glewGetProcAddress ("glPointParameterfv");
    s_deviceConfig.m_glPointParameteri = (PFNGLPOINTPARAMETERIPROC) glewGetProcAddress ("glPointParameteri");
    s_deviceConfig.m_glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC) glewGetProcAddress ("glPointParameteriv");
    s_deviceConfig.m_glFogCoordf = (PFNGLFOGCOORDFPROC) glewGetProcAddress ("glFogCoordf");
    s_deviceConfig.m_glFogCoordfv = (PFNGLFOGCOORDFVPROC) glewGetProcAddress ("glFogCoordfv");
    s_deviceConfig.m_glFogCoordd = (PFNGLFOGCOORDDPROC) glewGetProcAddress ("glFogCoordd");
    s_deviceConfig.m_glFogCoorddv = (PFNGLFOGCOORDDVPROC) glewGetProcAddress ("glFogCoorddv");
    s_deviceConfig.m_glFogCoordPointer = (PFNGLFOGCOORDPOINTERPROC) glewGetProcAddress ("glFogCoordPointer");
    s_deviceConfig.m_glSecondaryColor3b = (PFNGLSECONDARYCOLOR3BPROC) glewGetProcAddress ("glSecondaryColor3b");
    s_deviceConfig.m_glSecondaryColor3bv = (PFNGLSECONDARYCOLOR3BVPROC) glewGetProcAddress ("glSecondaryColor3bv");
    s_deviceConfig.m_glSecondaryColor3d = (PFNGLSECONDARYCOLOR3DPROC) glewGetProcAddress ("glSecondaryColor3d");
    s_deviceConfig.m_glSecondaryColor3dv = (PFNGLSECONDARYCOLOR3DVPROC) glewGetProcAddress ("glSecondaryColor3dv");
    s_deviceConfig.m_glSecondaryColor3f = (PFNGLSECONDARYCOLOR3FPROC) glewGetProcAddress ("glSecondaryColor3f");
    s_deviceConfig.m_glSecondaryColor3fv = (PFNGLSECONDARYCOLOR3FVPROC) glewGetProcAddress ("glSecondaryColor3fv");
    s_deviceConfig.m_glSecondaryColor3i = (PFNGLSECONDARYCOLOR3IPROC) glewGetProcAddress ("glSecondaryColor3i");
    s_deviceConfig.m_glSecondaryColor3iv = (PFNGLSECONDARYCOLOR3IVPROC) glewGetProcAddress ("glSecondaryColor3iv");
    s_deviceConfig.m_glSecondaryColor3s = (PFNGLSECONDARYCOLOR3SPROC) glewGetProcAddress ("glSecondaryColor3s");
    s_deviceConfig.m_glSecondaryColor3sv = (PFNGLSECONDARYCOLOR3SVPROC) glewGetProcAddress ("glSecondaryColor3sv");
    s_deviceConfig.m_glSecondaryColor3ub = (PFNGLSECONDARYCOLOR3UBPROC) glewGetProcAddress ("glSecondaryColor3ub");
    s_deviceConfig.m_glSecondaryColor3ubv = (PFNGLSECONDARYCOLOR3UBVPROC) glewGetProcAddress ("glSecondaryColor3ubv");
    s_deviceConfig.m_glSecondaryColor3ui = (PFNGLSECONDARYCOLOR3UIPROC) glewGetProcAddress ("glSecondaryColor3ui");
    s_deviceConfig.m_glSecondaryColor3uiv = (PFNGLSECONDARYCOLOR3UIVPROC) glewGetProcAddress ("glSecondaryColor3uiv");
    s_deviceConfig.m_glSecondaryColor3us = (PFNGLSECONDARYCOLOR3USPROC) glewGetProcAddress ("glSecondaryColor3us");
    s_deviceConfig.m_glSecondaryColor3usv = (PFNGLSECONDARYCOLOR3USVPROC) glewGetProcAddress ("glSecondaryColor3usv");
    s_deviceConfig.m_glSecondaryColorPointer = (PFNGLSECONDARYCOLORPOINTERPROC) glewGetProcAddress ("glSecondaryColorPointer");
    s_deviceConfig.m_glWindowPos2d = (PFNGLWINDOWPOS2DPROC) glewGetProcAddress ("glWindowPos2d");
    s_deviceConfig.m_glWindowPos2dv = (PFNGLWINDOWPOS2DVPROC) glewGetProcAddress ("glWindowPos2dv");
    s_deviceConfig.m_glWindowPos2f = (PFNGLWINDOWPOS2FPROC) glewGetProcAddress ("glWindowPos2f");
    s_deviceConfig.m_glWindowPos2fv = (PFNGLWINDOWPOS2FVPROC) glewGetProcAddress ("glWindowPos2fv");
    s_deviceConfig.m_glWindowPos2i = (PFNGLWINDOWPOS2IPROC) glewGetProcAddress ("glWindowPos2i");
    s_deviceConfig.m_glWindowPos2iv = (PFNGLWINDOWPOS2IVPROC) glewGetProcAddress ("glWindowPos2iv");
    s_deviceConfig.m_glWindowPos2s = (PFNGLWINDOWPOS2SPROC) glewGetProcAddress ("glWindowPos2s");
    s_deviceConfig.m_glWindowPos2sv = (PFNGLWINDOWPOS2SVPROC) glewGetProcAddress ("glWindowPos2sv");
    s_deviceConfig.m_glWindowPos3d = (PFNGLWINDOWPOS3DPROC) glewGetProcAddress ("glWindowPos3d");
    s_deviceConfig.m_glWindowPos3dv = (PFNGLWINDOWPOS3DVPROC) glewGetProcAddress ("glWindowPos3dv");
    s_deviceConfig.m_glWindowPos3f = (PFNGLWINDOWPOS3FPROC) glewGetProcAddress ("glWindowPos3f");
    s_deviceConfig.m_glWindowPos3fv = (PFNGLWINDOWPOS3FVPROC) glewGetProcAddress ("glWindowPos3fv");
    s_deviceConfig.m_glWindowPos3i = (PFNGLWINDOWPOS3IPROC) glewGetProcAddress ("glWindowPos3i");
    s_deviceConfig.m_glWindowPos3iv = (PFNGLWINDOWPOS3IVPROC) glewGetProcAddress ("glWindowPos3iv");
    s_deviceConfig.m_glWindowPos3s = (PFNGLWINDOWPOS3SPROC) glewGetProcAddress ("glWindowPos3s");
    s_deviceConfig.m_glWindowPos3sv = (PFNGLWINDOWPOS3SVPROC) glewGetProcAddress ("glWindowPos3sv");
    s_deviceConfig.m_glBlendColor = (PFNGLBLENDCOLORPROC) glewGetProcAddress ("glBlendColor");
    s_deviceConfig.m_glBlendEquation = (PFNGLBLENDEQUATIONPROC) glewGetProcAddress ("glBlendEquation");
  }

  // GL_VERSION_1_5
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_1_5])
  {
    s_deviceConfig.m_glGenQueries = (PFNGLGENQUERIESPROC) glewGetProcAddress ("glGenQueries");
    s_deviceConfig.m_glDeleteQueries = (PFNGLDELETEQUERIESPROC) glewGetProcAddress ("glDeleteQueries");
    s_deviceConfig.m_glIsQuery = (PFNGLISQUERYPROC) glewGetProcAddress ("glIsQuery");
    s_deviceConfig.m_glBeginQuery = (PFNGLBEGINQUERYPROC) glewGetProcAddress ("glBeginQuery");
    s_deviceConfig.m_glEndQuery = (PFNGLENDQUERYPROC) glewGetProcAddress ("glEndQuery");
    s_deviceConfig.m_glGetQueryiv = (PFNGLGETQUERYIVPROC) glewGetProcAddress ("glGetQueryiv");
    s_deviceConfig.m_glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC) glewGetProcAddress ("glGetQueryObjectiv");
    s_deviceConfig.m_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC) glewGetProcAddress ("glGetQueryObjectuiv");
    s_deviceConfig.m_glBindBuffer = (PFNGLBINDBUFFERPROC) glewGetProcAddress ("glBindBuffer");
    s_deviceConfig.m_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC) glewGetProcAddress ("glDeleteBuffers");
    s_deviceConfig.m_glGenBuffers = (PFNGLGENBUFFERSPROC) glewGetProcAddress ("glGenBuffers");
    s_deviceConfig.m_glIsBuffer = (PFNGLISBUFFERPROC) glewGetProcAddress ("glIsBuffer");
    s_deviceConfig.m_glBufferData = (PFNGLBUFFERDATAPROC) glewGetProcAddress ("glBufferData");
    s_deviceConfig.m_glBufferSubData = (PFNGLBUFFERSUBDATAPROC) glewGetProcAddress ("glBufferSubData");
    s_deviceConfig.m_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC) glewGetProcAddress ("glGetBufferSubData");
    s_deviceConfig.m_glMapBuffer = (PFNGLMAPBUFFERPROC) glewGetProcAddress ("glMapBuffer");
    s_deviceConfig.m_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC) glewGetProcAddress ("glUnmapBuffer");
    s_deviceConfig.m_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetBufferParameteriv");
    s_deviceConfig.m_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC) glewGetProcAddress ("glGetBufferPointerv");
  }

  // GL_VERSION_2_0
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_2_0])
  {
    s_deviceConfig.m_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC) glewGetProcAddress ("glBlendEquationSeparate");
    s_deviceConfig.m_glDrawBuffers = (PFNGLDRAWBUFFERSPROC) glewGetProcAddress ("glDrawBuffers");
    s_deviceConfig.m_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC) glewGetProcAddress ("glStencilOpSeparate");
    s_deviceConfig.m_glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC) glewGetProcAddress ("glStencilFuncSeparate");
    s_deviceConfig.m_glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC) glewGetProcAddress ("glStencilMaskSeparate");
    s_deviceConfig.m_glAttachShader = (PFNGLATTACHSHADERPROC) glewGetProcAddress ("glAttachShader");
    s_deviceConfig.m_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC) glewGetProcAddress ("glBindAttribLocation");
    s_deviceConfig.m_glCompileShader = (PFNGLCOMPILESHADERPROC) glewGetProcAddress ("glCompileShader");
    s_deviceConfig.m_glCreateProgram = (PFNGLCREATEPROGRAMPROC) glewGetProcAddress ("glCreateProgram");
    s_deviceConfig.m_glCreateShader = (PFNGLCREATESHADERPROC) glewGetProcAddress ("glCreateShader");
    s_deviceConfig.m_glDeleteProgram = (PFNGLDELETEPROGRAMPROC) glewGetProcAddress ("glDeleteProgram");
    s_deviceConfig.m_glDeleteShader = (PFNGLDELETESHADERPROC) glewGetProcAddress ("glDeleteShader");
    s_deviceConfig.m_glDetachShader = (PFNGLDETACHSHADERPROC) glewGetProcAddress ("glDetachShader");
    s_deviceConfig.m_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC) glewGetProcAddress ("glDisableVertexAttribArray");
    s_deviceConfig.m_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC) glewGetProcAddress ("glEnableVertexAttribArray");
    s_deviceConfig.m_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC) glewGetProcAddress ("glGetActiveAttrib");
    s_deviceConfig.m_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC) glewGetProcAddress ("glGetActiveUniform");
    s_deviceConfig.m_glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC) glewGetProcAddress ("glGetAttachedShaders");
    s_deviceConfig.m_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC) glewGetProcAddress ("glGetAttribLocation");
    s_deviceConfig.m_glGetProgramiv = (PFNGLGETPROGRAMIVPROC) glewGetProcAddress ("glGetProgramiv");
    s_deviceConfig.m_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC) glewGetProcAddress ("glGetProgramInfoLog");
    s_deviceConfig.m_glGetShaderiv = (PFNGLGETSHADERIVPROC) glewGetProcAddress ("glGetShaderiv");
    s_deviceConfig.m_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC) glewGetProcAddress ("glGetShaderInfoLog");
    s_deviceConfig.m_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC) glewGetProcAddress ("glGetShaderSource");
    s_deviceConfig.m_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC) glewGetProcAddress ("glGetUniformLocation");
    s_deviceConfig.m_glGetUniformfv = (PFNGLGETUNIFORMFVPROC) glewGetProcAddress ("glGetUniformfv");
    s_deviceConfig.m_glGetUniformiv = (PFNGLGETUNIFORMIVPROC) glewGetProcAddress ("glGetUniformiv");
    s_deviceConfig.m_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC) glewGetProcAddress ("glGetVertexAttribdv");
    s_deviceConfig.m_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC) glewGetProcAddress ("glGetVertexAttribfv");
    s_deviceConfig.m_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC) glewGetProcAddress ("glGetVertexAttribiv");
    s_deviceConfig.m_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC) glewGetProcAddress ("glGetVertexAttribPointerv");
    s_deviceConfig.m_glIsProgram = (PFNGLISPROGRAMPROC) glewGetProcAddress ("glIsProgram");
    s_deviceConfig.m_glIsShader = (PFNGLISSHADERPROC) glewGetProcAddress ("glIsShader");
    s_deviceConfig.m_glLinkProgram = (PFNGLLINKPROGRAMPROC) glewGetProcAddress ("glLinkProgram");
    s_deviceConfig.m_glShaderSource = (PFNGLSHADERSOURCEPROC) glewGetProcAddress ("glShaderSource");
    s_deviceConfig.m_glUseProgram = (PFNGLUSEPROGRAMPROC) glewGetProcAddress ("glUseProgram");
    s_deviceConfig.m_glUniform1f = (PFNGLUNIFORM1FPROC) glewGetProcAddress ("glUniform1f");
    s_deviceConfig.m_glUniform2f = (PFNGLUNIFORM2FPROC) glewGetProcAddress ("glUniform2f");
    s_deviceConfig.m_glUniform3f = (PFNGLUNIFORM3FPROC) glewGetProcAddress ("glUniform3f");
    s_deviceConfig.m_glUniform4f = (PFNGLUNIFORM4FPROC) glewGetProcAddress ("glUniform4f");
    s_deviceConfig.m_glUniform1i = (PFNGLUNIFORM1IPROC) glewGetProcAddress ("glUniform1i");
    s_deviceConfig.m_glUniform2i = (PFNGLUNIFORM2IPROC) glewGetProcAddress ("glUniform2i");
    s_deviceConfig.m_glUniform3i = (PFNGLUNIFORM3IPROC) glewGetProcAddress ("glUniform3i");
    s_deviceConfig.m_glUniform4i = (PFNGLUNIFORM4IPROC) glewGetProcAddress ("glUniform4i");
    s_deviceConfig.m_glUniform1fv = (PFNGLUNIFORM1FVPROC) glewGetProcAddress ("glUniform1fv");
    s_deviceConfig.m_glUniform2fv = (PFNGLUNIFORM2FVPROC) glewGetProcAddress ("glUniform2fv");
    s_deviceConfig.m_glUniform3fv = (PFNGLUNIFORM3FVPROC) glewGetProcAddress ("glUniform3fv");
    s_deviceConfig.m_glUniform4fv = (PFNGLUNIFORM4FVPROC) glewGetProcAddress ("glUniform4fv");
    s_deviceConfig.m_glUniform1iv = (PFNGLUNIFORM1IVPROC) glewGetProcAddress ("glUniform1iv");
    s_deviceConfig.m_glUniform2iv = (PFNGLUNIFORM2IVPROC) glewGetProcAddress ("glUniform2iv");
    s_deviceConfig.m_glUniform3iv = (PFNGLUNIFORM3IVPROC) glewGetProcAddress ("glUniform3iv");
    s_deviceConfig.m_glUniform4iv = (PFNGLUNIFORM4IVPROC) glewGetProcAddress ("glUniform4iv");
    s_deviceConfig.m_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC) glewGetProcAddress ("glUniformMatrix2fv");
    s_deviceConfig.m_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC) glewGetProcAddress ("glUniformMatrix3fv");
    s_deviceConfig.m_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC) glewGetProcAddress ("glUniformMatrix4fv");
    s_deviceConfig.m_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC) glewGetProcAddress ("glValidateProgram");
    s_deviceConfig.m_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC) glewGetProcAddress ("glVertexAttrib1d");
    s_deviceConfig.m_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC) glewGetProcAddress ("glVertexAttrib1dv");
    s_deviceConfig.m_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC) glewGetProcAddress ("glVertexAttrib1f");
    s_deviceConfig.m_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC) glewGetProcAddress ("glVertexAttrib1fv");
    s_deviceConfig.m_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC) glewGetProcAddress ("glVertexAttrib1s");
    s_deviceConfig.m_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC) glewGetProcAddress ("glVertexAttrib1sv");
    s_deviceConfig.m_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC) glewGetProcAddress ("glVertexAttrib2d");
    s_deviceConfig.m_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC) glewGetProcAddress ("glVertexAttrib2dv");
    s_deviceConfig.m_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC) glewGetProcAddress ("glVertexAttrib2f");
    s_deviceConfig.m_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC) glewGetProcAddress ("glVertexAttrib2fv");
    s_deviceConfig.m_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC) glewGetProcAddress ("glVertexAttrib2s");
    s_deviceConfig.m_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC) glewGetProcAddress ("glVertexAttrib2sv");
    s_deviceConfig.m_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC) glewGetProcAddress ("glVertexAttrib3d");
    s_deviceConfig.m_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC) glewGetProcAddress ("glVertexAttrib3dv");
    s_deviceConfig.m_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC) glewGetProcAddress ("glVertexAttrib3f");
    s_deviceConfig.m_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC) glewGetProcAddress ("glVertexAttrib3fv");
    s_deviceConfig.m_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC) glewGetProcAddress ("glVertexAttrib3s");
    s_deviceConfig.m_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC) glewGetProcAddress ("glVertexAttrib3sv");
    s_deviceConfig.m_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC) glewGetProcAddress ("glVertexAttrib4Nbv");
    s_deviceConfig.m_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC) glewGetProcAddress ("glVertexAttrib4Niv");
    s_deviceConfig.m_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC) glewGetProcAddress ("glVertexAttrib4Nsv");
    s_deviceConfig.m_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC) glewGetProcAddress ("glVertexAttrib4Nub");
    s_deviceConfig.m_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC) glewGetProcAddress ("glVertexAttrib4Nubv");
    s_deviceConfig.m_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC) glewGetProcAddress ("glVertexAttrib4Nuiv");
    s_deviceConfig.m_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC) glewGetProcAddress ("glVertexAttrib4Nusv");
    s_deviceConfig.m_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC) glewGetProcAddress ("glVertexAttrib4bv");
    s_deviceConfig.m_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC) glewGetProcAddress ("glVertexAttrib4d");
    s_deviceConfig.m_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC) glewGetProcAddress ("glVertexAttrib4dv");
    s_deviceConfig.m_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC) glewGetProcAddress ("glVertexAttrib4f");
    s_deviceConfig.m_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC) glewGetProcAddress ("glVertexAttrib4fv");
    s_deviceConfig.m_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC) glewGetProcAddress ("glVertexAttrib4iv");
    s_deviceConfig.m_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC) glewGetProcAddress ("glVertexAttrib4s");
    s_deviceConfig.m_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC) glewGetProcAddress ("glVertexAttrib4sv");
    s_deviceConfig.m_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC) glewGetProcAddress ("glVertexAttrib4ubv");
    s_deviceConfig.m_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC) glewGetProcAddress ("glVertexAttrib4uiv");
    s_deviceConfig.m_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC) glewGetProcAddress ("glVertexAttrib4usv");
    s_deviceConfig.m_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC) glewGetProcAddress ("glVertexAttribPointer");
  }

  // GL_VERSION_2_1
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_2_1])
  {
    s_deviceConfig.m_glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC) glewGetProcAddress ("glUniformMatrix2x3fv");
    s_deviceConfig.m_glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC) glewGetProcAddress ("glUniformMatrix3x2fv");
    s_deviceConfig.m_glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC) glewGetProcAddress ("glUniformMatrix2x4fv");
    s_deviceConfig.m_glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC) glewGetProcAddress ("glUniformMatrix4x2fv");
    s_deviceConfig.m_glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC) glewGetProcAddress ("glUniformMatrix3x4fv");
    s_deviceConfig.m_glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC) glewGetProcAddress ("glUniformMatrix4x3fv");
  }

  // GL_VERSION_3_0
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_3_0])
  {
    s_deviceConfig.m_glColorMaski = (PFNGLCOLORMASKIPROC) glewGetProcAddress ("glColorMaski");
    s_deviceConfig.m_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC) glewGetProcAddress ("glGetBooleani_v");
    s_deviceConfig.m_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) glewGetProcAddress ("glGetIntegeri_v");
    s_deviceConfig.m_glEnablei = (PFNGLENABLEIPROC) glewGetProcAddress ("glEnablei");
    s_deviceConfig.m_glDisablei = (PFNGLDISABLEIPROC) glewGetProcAddress ("glDisablei");
    s_deviceConfig.m_glIsEnabledi = (PFNGLISENABLEDIPROC) glewGetProcAddress ("glIsEnabledi");
    s_deviceConfig.m_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glBeginTransformFeedback");
    s_deviceConfig.m_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glEndTransformFeedback");
    s_deviceConfig.m_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) glewGetProcAddress ("glBindBufferRange");
    s_deviceConfig.m_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) glewGetProcAddress ("glBindBufferBase");
    s_deviceConfig.m_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC) glewGetProcAddress ("glTransformFeedbackVaryings");
    s_deviceConfig.m_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) glewGetProcAddress ("glGetTransformFeedbackVarying");
    s_deviceConfig.m_glClampColor = (PFNGLCLAMPCOLORPROC) glewGetProcAddress ("glClampColor");
    s_deviceConfig.m_glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC) glewGetProcAddress ("glBeginConditionalRender");
    s_deviceConfig.m_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC) glewGetProcAddress ("glEndConditionalRender");
    s_deviceConfig.m_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC) glewGetProcAddress ("glVertexAttribIPointer");
    s_deviceConfig.m_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC) glewGetProcAddress ("glGetVertexAttribIiv");
    s_deviceConfig.m_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC) glewGetProcAddress ("glGetVertexAttribIuiv");
    s_deviceConfig.m_glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC) glewGetProcAddress ("glVertexAttribI1i");
    s_deviceConfig.m_glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC) glewGetProcAddress ("glVertexAttribI2i");
    s_deviceConfig.m_glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC) glewGetProcAddress ("glVertexAttribI3i");
    s_deviceConfig.m_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC) glewGetProcAddress ("glVertexAttribI4i");
    s_deviceConfig.m_glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC) glewGetProcAddress ("glVertexAttribI1ui");
    s_deviceConfig.m_glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC) glewGetProcAddress ("glVertexAttribI2ui");
    s_deviceConfig.m_glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC) glewGetProcAddress ("glVertexAttribI3ui");
    s_deviceConfig.m_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC) glewGetProcAddress ("glVertexAttribI4ui");
    s_deviceConfig.m_glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC) glewGetProcAddress ("glVertexAttribI1iv");
    s_deviceConfig.m_glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC) glewGetProcAddress ("glVertexAttribI2iv");
    s_deviceConfig.m_glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC) glewGetProcAddress ("glVertexAttribI3iv");
    s_deviceConfig.m_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC) glewGetProcAddress ("glVertexAttribI4iv");
    s_deviceConfig.m_glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC) glewGetProcAddress ("glVertexAttribI1uiv");
    s_deviceConfig.m_glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC) glewGetProcAddress ("glVertexAttribI2uiv");
    s_deviceConfig.m_glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC) glewGetProcAddress ("glVertexAttribI3uiv");
    s_deviceConfig.m_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC) glewGetProcAddress ("glVertexAttribI4uiv");
    s_deviceConfig.m_glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC) glewGetProcAddress ("glVertexAttribI4bv");
    s_deviceConfig.m_glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC) glewGetProcAddress ("glVertexAttribI4sv");
    s_deviceConfig.m_glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC) glewGetProcAddress ("glVertexAttribI4ubv");
    s_deviceConfig.m_glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC) glewGetProcAddress ("glVertexAttribI4usv");
    s_deviceConfig.m_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC) glewGetProcAddress ("glGetUniformuiv");
    s_deviceConfig.m_glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC) glewGetProcAddress ("glBindFragDataLocation");
    s_deviceConfig.m_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC) glewGetProcAddress ("glGetFragDataLocation");
    s_deviceConfig.m_glUniform1ui = (PFNGLUNIFORM1UIPROC) glewGetProcAddress ("glUniform1ui");
    s_deviceConfig.m_glUniform2ui = (PFNGLUNIFORM2UIPROC) glewGetProcAddress ("glUniform2ui");
    s_deviceConfig.m_glUniform3ui = (PFNGLUNIFORM3UIPROC) glewGetProcAddress ("glUniform3ui");
    s_deviceConfig.m_glUniform4ui = (PFNGLUNIFORM4UIPROC) glewGetProcAddress ("glUniform4ui");
    s_deviceConfig.m_glUniform1uiv = (PFNGLUNIFORM1UIVPROC) glewGetProcAddress ("glUniform1uiv");
    s_deviceConfig.m_glUniform2uiv = (PFNGLUNIFORM2UIVPROC) glewGetProcAddress ("glUniform2uiv");
    s_deviceConfig.m_glUniform3uiv = (PFNGLUNIFORM3UIVPROC) glewGetProcAddress ("glUniform3uiv");
    s_deviceConfig.m_glUniform4uiv = (PFNGLUNIFORM4UIVPROC) glewGetProcAddress ("glUniform4uiv");
    s_deviceConfig.m_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC) glewGetProcAddress ("glTexParameterIiv");
    s_deviceConfig.m_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC) glewGetProcAddress ("glTexParameterIuiv");
    s_deviceConfig.m_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC) glewGetProcAddress ("glGetTexParameterIiv");
    s_deviceConfig.m_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC) glewGetProcAddress ("glGetTexParameterIuiv");
    s_deviceConfig.m_glClearBufferiv = (PFNGLCLEARBUFFERIVPROC) glewGetProcAddress ("glClearBufferiv");
    s_deviceConfig.m_glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC) glewGetProcAddress ("glClearBufferuiv");
    s_deviceConfig.m_glClearBufferfv = (PFNGLCLEARBUFFERFVPROC) glewGetProcAddress ("glClearBufferfv");
    s_deviceConfig.m_glClearBufferfi = (PFNGLCLEARBUFFERFIPROC) glewGetProcAddress ("glClearBufferfi");
    s_deviceConfig.m_glGetStringi = (PFNGLGETSTRINGIPROC) glewGetProcAddress ("glGetStringi");
    s_deviceConfig.m_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC) glewGetProcAddress ("glIsRenderbuffer");
    s_deviceConfig.m_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC) glewGetProcAddress ("glBindRenderbuffer");
    s_deviceConfig.m_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC) glewGetProcAddress ("glDeleteRenderbuffers");
    s_deviceConfig.m_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC) glewGetProcAddress ("glGenRenderbuffers");
    s_deviceConfig.m_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC) glewGetProcAddress ("glRenderbufferStorage");
    s_deviceConfig.m_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetRenderbufferParameteriv");
    s_deviceConfig.m_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC) glewGetProcAddress ("glIsFramebuffer");
    s_deviceConfig.m_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC) glewGetProcAddress ("glBindFramebuffer");
    s_deviceConfig.m_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC) glewGetProcAddress ("glDeleteFramebuffers");
    s_deviceConfig.m_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC) glewGetProcAddress ("glGenFramebuffers");
    s_deviceConfig.m_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC) glewGetProcAddress ("glCheckFramebufferStatus");
    s_deviceConfig.m_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC) glewGetProcAddress ("glFramebufferTexture1D");
    s_deviceConfig.m_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC) glewGetProcAddress ("glFramebufferTexture2D");
    s_deviceConfig.m_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC) glewGetProcAddress ("glFramebufferTexture3D");
    s_deviceConfig.m_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC) glewGetProcAddress ("glFramebufferRenderbuffer");
    s_deviceConfig.m_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) glewGetProcAddress ("glGetFramebufferAttachmentParameteriv");
    s_deviceConfig.m_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC) glewGetProcAddress ("glGenerateMipmap");
    s_deviceConfig.m_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC) glewGetProcAddress ("glBlitFramebuffer");
    s_deviceConfig.m_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) glewGetProcAddress ("glRenderbufferStorageMultisample");
    s_deviceConfig.m_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC) glewGetProcAddress ("glFramebufferTextureLayer");
    s_deviceConfig.m_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC) glewGetProcAddress ("glMapBufferRange");
    s_deviceConfig.m_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC) glewGetProcAddress ("glFlushMappedBufferRange");
    s_deviceConfig.m_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC) glewGetProcAddress ("glBindVertexArray");
    s_deviceConfig.m_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC) glewGetProcAddress ("glDeleteVertexArrays");
    s_deviceConfig.m_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC) glewGetProcAddress ("glGenVertexArrays");
    s_deviceConfig.m_glIsVertexArray = (PFNGLISVERTEXARRAYPROC) glewGetProcAddress ("glIsVertexArray");
  }

  // GL_VERSION_3_1
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_3_1])
  {
    s_deviceConfig.m_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC) glewGetProcAddress ("glDrawArraysInstanced");
    s_deviceConfig.m_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC) glewGetProcAddress ("glDrawElementsInstanced");
    s_deviceConfig.m_glTexBuffer = (PFNGLTEXBUFFERPROC) glewGetProcAddress ("glTexBuffer");
    s_deviceConfig.m_glPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC) glewGetProcAddress ("glPrimitiveRestartIndex");
    s_deviceConfig.m_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC) glewGetProcAddress ("glCopyBufferSubData");
    s_deviceConfig.m_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC) glewGetProcAddress ("glGetUniformIndices");
    s_deviceConfig.m_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC) glewGetProcAddress ("glGetActiveUniformsiv");
    s_deviceConfig.m_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC) glewGetProcAddress ("glGetActiveUniformName");
    s_deviceConfig.m_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC) glewGetProcAddress ("glGetUniformBlockIndex");
    s_deviceConfig.m_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC) glewGetProcAddress ("glGetActiveUniformBlockiv");
    s_deviceConfig.m_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) glewGetProcAddress ("glGetActiveUniformBlockName");
    s_deviceConfig.m_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC) glewGetProcAddress ("glUniformBlockBinding");
    s_deviceConfig.m_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) glewGetProcAddress ("glBindBufferRange");
    s_deviceConfig.m_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) glewGetProcAddress ("glBindBufferBase");
    s_deviceConfig.m_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) glewGetProcAddress ("glGetIntegeri_v");
  }

  // GL_VERSION_3_2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_3_2])
  {
    s_deviceConfig.m_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC) glewGetProcAddress ("glDrawElementsBaseVertex");
    s_deviceConfig.m_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) glewGetProcAddress ("glDrawRangeElementsBaseVertex");
    s_deviceConfig.m_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) glewGetProcAddress ("glDrawElementsInstancedBaseVertex");
    s_deviceConfig.m_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) glewGetProcAddress ("glMultiDrawElementsBaseVertex");
    s_deviceConfig.m_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC) glewGetProcAddress ("glProvokingVertex");
    s_deviceConfig.m_glFenceSync = (PFNGLFENCESYNCPROC) glewGetProcAddress ("glFenceSync");
    s_deviceConfig.m_glIsSync = (PFNGLISSYNCPROC) glewGetProcAddress ("glIsSync");
    s_deviceConfig.m_glDeleteSync = (PFNGLDELETESYNCPROC) glewGetProcAddress ("glDeleteSync");
    s_deviceConfig.m_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC) glewGetProcAddress ("glClientWaitSync");
    s_deviceConfig.m_glWaitSync = (PFNGLWAITSYNCPROC) glewGetProcAddress ("glWaitSync");
    s_deviceConfig.m_glGetInteger64v = (PFNGLGETINTEGER64VPROC) glewGetProcAddress ("glGetInteger64v");
    s_deviceConfig.m_glGetSynciv = (PFNGLGETSYNCIVPROC) glewGetProcAddress ("glGetSynciv");
    s_deviceConfig.m_glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC) glewGetProcAddress ("glGetInteger64i_v");
    s_deviceConfig.m_glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC) glewGetProcAddress ("glGetBufferParameteri64v");
    s_deviceConfig.m_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC) glewGetProcAddress ("glFramebufferTexture");
    s_deviceConfig.m_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC) glewGetProcAddress ("glTexImage2DMultisample");
    s_deviceConfig.m_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC) glewGetProcAddress ("glTexImage3DMultisample");
    s_deviceConfig.m_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC) glewGetProcAddress ("glGetMultisamplefv");
    s_deviceConfig.m_glSampleMaski = (PFNGLSAMPLEMASKIPROC) glewGetProcAddress ("glSampleMaski");
  }

  // GL_VERSION_3_3
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_3_3])
  {
    s_deviceConfig.m_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) glewGetProcAddress ("glBindFragDataLocationIndexed");
    s_deviceConfig.m_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC) glewGetProcAddress ("glGetFragDataIndex");
    s_deviceConfig.m_glGenSamplers = (PFNGLGENSAMPLERSPROC) glewGetProcAddress ("glGenSamplers");
    s_deviceConfig.m_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC) glewGetProcAddress ("glDeleteSamplers");
    s_deviceConfig.m_glIsSampler = (PFNGLISSAMPLERPROC) glewGetProcAddress ("glIsSampler");
    s_deviceConfig.m_glBindSampler = (PFNGLBINDSAMPLERPROC) glewGetProcAddress ("glBindSampler");
    s_deviceConfig.m_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC) glewGetProcAddress ("glSamplerParameteri");
    s_deviceConfig.m_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC) glewGetProcAddress ("glSamplerParameteriv");
    s_deviceConfig.m_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC) glewGetProcAddress ("glSamplerParameterf");
    s_deviceConfig.m_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC) glewGetProcAddress ("glSamplerParameterfv");
    s_deviceConfig.m_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC) glewGetProcAddress ("glSamplerParameterIiv");
    s_deviceConfig.m_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC) glewGetProcAddress ("glSamplerParameterIuiv");
    s_deviceConfig.m_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC) glewGetProcAddress ("glGetSamplerParameteriv");
    s_deviceConfig.m_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC) glewGetProcAddress ("glGetSamplerParameterIiv");
    s_deviceConfig.m_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC) glewGetProcAddress ("glGetSamplerParameterfv");
    s_deviceConfig.m_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC) glewGetProcAddress ("glGetSamplerParameterIuiv");
    s_deviceConfig.m_glQueryCounter = (PFNGLQUERYCOUNTERPROC) glewGetProcAddress ("glQueryCounter");
    s_deviceConfig.m_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC) glewGetProcAddress ("glGetQueryObjecti64v");
    s_deviceConfig.m_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC) glewGetProcAddress ("glGetQueryObjectui64v");
    s_deviceConfig.m_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC) glewGetProcAddress ("glVertexAttribDivisor");
    s_deviceConfig.m_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC) glewGetProcAddress ("glVertexAttribP1ui");
    s_deviceConfig.m_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC) glewGetProcAddress ("glVertexAttribP1uiv");
    s_deviceConfig.m_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC) glewGetProcAddress ("glVertexAttribP2ui");
    s_deviceConfig.m_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC) glewGetProcAddress ("glVertexAttribP2uiv");
    s_deviceConfig.m_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC) glewGetProcAddress ("glVertexAttribP3ui");
    s_deviceConfig.m_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC) glewGetProcAddress ("glVertexAttribP3uiv");
    s_deviceConfig.m_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC) glewGetProcAddress ("glVertexAttribP4ui");
    s_deviceConfig.m_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC) glewGetProcAddress ("glVertexAttribP4uiv");
    s_deviceConfig.m_glVertexP2ui = (PFNGLVERTEXP2UIPROC) glewGetProcAddress ("glVertexP2ui");
    s_deviceConfig.m_glVertexP2uiv = (PFNGLVERTEXP2UIVPROC) glewGetProcAddress ("glVertexP2uiv");
    s_deviceConfig.m_glVertexP3ui = (PFNGLVERTEXP3UIPROC) glewGetProcAddress ("glVertexP3ui");
    s_deviceConfig.m_glVertexP3uiv = (PFNGLVERTEXP3UIVPROC) glewGetProcAddress ("glVertexP3uiv");
    s_deviceConfig.m_glVertexP4ui = (PFNGLVERTEXP4UIPROC) glewGetProcAddress ("glVertexP4ui");
    s_deviceConfig.m_glVertexP4uiv = (PFNGLVERTEXP4UIVPROC) glewGetProcAddress ("glVertexP4uiv");
    s_deviceConfig.m_glTexCoordP1ui = (PFNGLTEXCOORDP1UIPROC) glewGetProcAddress ("glTexCoordP1ui");
    s_deviceConfig.m_glTexCoordP1uiv = (PFNGLTEXCOORDP1UIVPROC) glewGetProcAddress ("glTexCoordP1uiv");
    s_deviceConfig.m_glTexCoordP2ui = (PFNGLTEXCOORDP2UIPROC) glewGetProcAddress ("glTexCoordP2ui");
    s_deviceConfig.m_glTexCoordP2uiv = (PFNGLTEXCOORDP2UIVPROC) glewGetProcAddress ("glTexCoordP2uiv");
    s_deviceConfig.m_glTexCoordP3ui = (PFNGLTEXCOORDP3UIPROC) glewGetProcAddress ("glTexCoordP3ui");
    s_deviceConfig.m_glTexCoordP3uiv = (PFNGLTEXCOORDP3UIVPROC) glewGetProcAddress ("glTexCoordP3uiv");
    s_deviceConfig.m_glTexCoordP4ui = (PFNGLTEXCOORDP4UIPROC) glewGetProcAddress ("glTexCoordP4ui");
    s_deviceConfig.m_glTexCoordP4uiv = (PFNGLTEXCOORDP4UIVPROC) glewGetProcAddress ("glTexCoordP4uiv");
    s_deviceConfig.m_glMultiTexCoordP1ui = (PFNGLMULTITEXCOORDP1UIPROC) glewGetProcAddress ("glMultiTexCoordP1ui");
    s_deviceConfig.m_glMultiTexCoordP1uiv = (PFNGLMULTITEXCOORDP1UIVPROC) glewGetProcAddress ("glMultiTexCoordP1uiv");
    s_deviceConfig.m_glMultiTexCoordP2ui = (PFNGLMULTITEXCOORDP2UIPROC) glewGetProcAddress ("glMultiTexCoordP2ui");
    s_deviceConfig.m_glMultiTexCoordP2uiv = (PFNGLMULTITEXCOORDP2UIVPROC) glewGetProcAddress ("glMultiTexCoordP2uiv");
    s_deviceConfig.m_glMultiTexCoordP3ui = (PFNGLMULTITEXCOORDP3UIPROC) glewGetProcAddress ("glMultiTexCoordP3ui");
    s_deviceConfig.m_glMultiTexCoordP3uiv = (PFNGLMULTITEXCOORDP3UIVPROC) glewGetProcAddress ("glMultiTexCoordP3uiv");
    s_deviceConfig.m_glMultiTexCoordP4ui = (PFNGLMULTITEXCOORDP4UIPROC) glewGetProcAddress ("glMultiTexCoordP4ui");
    s_deviceConfig.m_glMultiTexCoordP4uiv = (PFNGLMULTITEXCOORDP4UIVPROC) glewGetProcAddress ("glMultiTexCoordP4uiv");
    s_deviceConfig.m_glNormalP3ui = (PFNGLNORMALP3UIPROC) glewGetProcAddress ("glNormalP3ui");
    s_deviceConfig.m_glNormalP3uiv = (PFNGLNORMALP3UIVPROC) glewGetProcAddress ("glNormalP3uiv");
    s_deviceConfig.m_glColorP3ui = (PFNGLCOLORP3UIPROC) glewGetProcAddress ("glColorP3ui");
    s_deviceConfig.m_glColorP3uiv = (PFNGLCOLORP3UIVPROC) glewGetProcAddress ("glColorP3uiv");
    s_deviceConfig.m_glColorP4ui = (PFNGLCOLORP4UIPROC) glewGetProcAddress ("glColorP4ui");
    s_deviceConfig.m_glColorP4uiv = (PFNGLCOLORP4UIVPROC) glewGetProcAddress ("glColorP4uiv");
    s_deviceConfig.m_glSecondaryColorP3ui = (PFNGLSECONDARYCOLORP3UIPROC) glewGetProcAddress ("glSecondaryColorP3ui");
    s_deviceConfig.m_glSecondaryColorP3uiv = (PFNGLSECONDARYCOLORP3UIVPROC) glewGetProcAddress ("glSecondaryColorP3uiv");
  }

  // GL_VERSION_4_0
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_0])
  {
    s_deviceConfig.m_glMinSampleShading = (PFNGLMINSAMPLESHADINGPROC) glewGetProcAddress ("glMinSampleShading");
    s_deviceConfig.m_glBlendEquationi = (PFNGLBLENDEQUATIONIPROC) glewGetProcAddress ("glBlendEquationi");
    s_deviceConfig.m_glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC) glewGetProcAddress ("glBlendEquationSeparatei");
    s_deviceConfig.m_glBlendFunci = (PFNGLBLENDFUNCIPROC) glewGetProcAddress ("glBlendFunci");
    s_deviceConfig.m_glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC) glewGetProcAddress ("glBlendFuncSeparatei");
    s_deviceConfig.m_glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC) glewGetProcAddress ("glDrawArraysIndirect");
    s_deviceConfig.m_glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC) glewGetProcAddress ("glDrawElementsIndirect");
    s_deviceConfig.m_glUniform1d = (PFNGLUNIFORM1DPROC) glewGetProcAddress ("glUniform1d");
    s_deviceConfig.m_glUniform2d = (PFNGLUNIFORM2DPROC) glewGetProcAddress ("glUniform2d");
    s_deviceConfig.m_glUniform3d = (PFNGLUNIFORM3DPROC) glewGetProcAddress ("glUniform3d");
    s_deviceConfig.m_glUniform4d = (PFNGLUNIFORM4DPROC) glewGetProcAddress ("glUniform4d");
    s_deviceConfig.m_glUniform1dv = (PFNGLUNIFORM1DVPROC) glewGetProcAddress ("glUniform1dv");
    s_deviceConfig.m_glUniform2dv = (PFNGLUNIFORM2DVPROC) glewGetProcAddress ("glUniform2dv");
    s_deviceConfig.m_glUniform3dv = (PFNGLUNIFORM3DVPROC) glewGetProcAddress ("glUniform3dv");
    s_deviceConfig.m_glUniform4dv = (PFNGLUNIFORM4DVPROC) glewGetProcAddress ("glUniform4dv");
    s_deviceConfig.m_glUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC) glewGetProcAddress ("glUniformMatrix2dv");
    s_deviceConfig.m_glUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC) glewGetProcAddress ("glUniformMatrix3dv");
    s_deviceConfig.m_glUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC) glewGetProcAddress ("glUniformMatrix4dv");
    s_deviceConfig.m_glUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC) glewGetProcAddress ("glUniformMatrix2x3dv");
    s_deviceConfig.m_glUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC) glewGetProcAddress ("glUniformMatrix2x4dv");
    s_deviceConfig.m_glUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC) glewGetProcAddress ("glUniformMatrix3x2dv");
    s_deviceConfig.m_glUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC) glewGetProcAddress ("glUniformMatrix3x4dv");
    s_deviceConfig.m_glUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC) glewGetProcAddress ("glUniformMatrix4x2dv");
    s_deviceConfig.m_glUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC) glewGetProcAddress ("glUniformMatrix4x3dv");
    s_deviceConfig.m_glGetUniformdv = (PFNGLGETUNIFORMDVPROC) glewGetProcAddress ("glGetUniformdv");
    s_deviceConfig.m_glGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) glewGetProcAddress ("glGetSubroutineUniformLocation");
    s_deviceConfig.m_glGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC) glewGetProcAddress ("glGetSubroutineIndex");
    s_deviceConfig.m_glGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) glewGetProcAddress ("glGetActiveSubroutineUniformiv");
    s_deviceConfig.m_glGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) glewGetProcAddress ("glGetActiveSubroutineUniformName");
    s_deviceConfig.m_glGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC) glewGetProcAddress ("glGetActiveSubroutineName");
    s_deviceConfig.m_glUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC) glewGetProcAddress ("glUniformSubroutinesuiv");
    s_deviceConfig.m_glGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC) glewGetProcAddress ("glGetUniformSubroutineuiv");
    s_deviceConfig.m_glGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC) glewGetProcAddress ("glGetProgramStageiv");
    s_deviceConfig.m_glPatchParameteri = (PFNGLPATCHPARAMETERIPROC) glewGetProcAddress ("glPatchParameteri");
    s_deviceConfig.m_glPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC) glewGetProcAddress ("glPatchParameterfv");
    s_deviceConfig.m_glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glBindTransformFeedback");
    s_deviceConfig.m_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC) glewGetProcAddress ("glDeleteTransformFeedbacks");
    s_deviceConfig.m_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC) glewGetProcAddress ("glGenTransformFeedbacks");
    s_deviceConfig.m_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glIsTransformFeedback");
    s_deviceConfig.m_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC) glewGetProcAddress ("glPauseTransformFeedback");
    s_deviceConfig.m_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC) glewGetProcAddress ("glResumeTransformFeedback");
    s_deviceConfig.m_glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glDrawTransformFeedback");
    s_deviceConfig.m_glDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) glewGetProcAddress ("glDrawTransformFeedbackStream");
    s_deviceConfig.m_glBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC) glewGetProcAddress ("glBeginQueryIndexed");
    s_deviceConfig.m_glEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC) glewGetProcAddress ("glEndQueryIndexed");
    s_deviceConfig.m_glGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC) glewGetProcAddress ("glGetQueryIndexediv");
  }

  // GL_VERSION_4_1
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_1])
  {
    s_deviceConfig.m_glReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC) glewGetProcAddress ("glReleaseShaderCompiler");
    s_deviceConfig.m_glShaderBinary = (PFNGLSHADERBINARYPROC) glewGetProcAddress ("glShaderBinary");
    s_deviceConfig.m_glGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC) glewGetProcAddress ("glGetShaderPrecisionFormat");
    s_deviceConfig.m_glDepthRangef = (PFNGLDEPTHRANGEFPROC) glewGetProcAddress ("glDepthRangef");
    s_deviceConfig.m_glClearDepthf = (PFNGLCLEARDEPTHFPROC) glewGetProcAddress ("glClearDepthf");
    s_deviceConfig.m_glGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC) glewGetProcAddress ("glGetProgramBinary");
    s_deviceConfig.m_glProgramBinary = (PFNGLPROGRAMBINARYPROC) glewGetProcAddress ("glProgramBinary");
    s_deviceConfig.m_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC) glewGetProcAddress ("glProgramParameteri");
    s_deviceConfig.m_glUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC) glewGetProcAddress ("glUseProgramStages");
    s_deviceConfig.m_glActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC) glewGetProcAddress ("glActiveShaderProgram");
    s_deviceConfig.m_glCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC) glewGetProcAddress ("glCreateShaderProgramv");
    s_deviceConfig.m_glBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC) glewGetProcAddress ("glBindProgramPipeline");
    s_deviceConfig.m_glDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC) glewGetProcAddress ("glDeleteProgramPipelines");
    s_deviceConfig.m_glGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC) glewGetProcAddress ("glGenProgramPipelines");
    s_deviceConfig.m_glIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC) glewGetProcAddress ("glIsProgramPipeline");
    s_deviceConfig.m_glGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC) glewGetProcAddress ("glGetProgramPipelineiv");
    s_deviceConfig.m_glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC) glewGetProcAddress ("glProgramUniform1i");
    s_deviceConfig.m_glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC) glewGetProcAddress ("glProgramUniform1iv");
    s_deviceConfig.m_glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC) glewGetProcAddress ("glProgramUniform1f");
    s_deviceConfig.m_glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC) glewGetProcAddress ("glProgramUniform1fv");
    s_deviceConfig.m_glProgramUniform1d = (PFNGLPROGRAMUNIFORM1DPROC) glewGetProcAddress ("glProgramUniform1d");
    s_deviceConfig.m_glProgramUniform1dv = (PFNGLPROGRAMUNIFORM1DVPROC) glewGetProcAddress ("glProgramUniform1dv");
    s_deviceConfig.m_glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC) glewGetProcAddress ("glProgramUniform1ui");
    s_deviceConfig.m_glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC) glewGetProcAddress ("glProgramUniform1uiv");
    s_deviceConfig.m_glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC) glewGetProcAddress ("glProgramUniform2i");
    s_deviceConfig.m_glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC) glewGetProcAddress ("glProgramUniform2iv");
    s_deviceConfig.m_glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC) glewGetProcAddress ("glProgramUniform2f");
    s_deviceConfig.m_glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC) glewGetProcAddress ("glProgramUniform2fv");
    s_deviceConfig.m_glProgramUniform2d = (PFNGLPROGRAMUNIFORM2DPROC) glewGetProcAddress ("glProgramUniform2d");
    s_deviceConfig.m_glProgramUniform2dv = (PFNGLPROGRAMUNIFORM2DVPROC) glewGetProcAddress ("glProgramUniform2dv");
    s_deviceConfig.m_glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC) glewGetProcAddress ("glProgramUniform2ui");
    s_deviceConfig.m_glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC) glewGetProcAddress ("glProgramUniform2uiv");
    s_deviceConfig.m_glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC) glewGetProcAddress ("glProgramUniform3i");
    s_deviceConfig.m_glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC) glewGetProcAddress ("glProgramUniform3iv");
    s_deviceConfig.m_glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC) glewGetProcAddress ("glProgramUniform3f");
    s_deviceConfig.m_glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC) glewGetProcAddress ("glProgramUniform3fv");
    s_deviceConfig.m_glProgramUniform3d = (PFNGLPROGRAMUNIFORM3DPROC) glewGetProcAddress ("glProgramUniform3d");
    s_deviceConfig.m_glProgramUniform3dv = (PFNGLPROGRAMUNIFORM3DVPROC) glewGetProcAddress ("glProgramUniform3dv");
    s_deviceConfig.m_glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC) glewGetProcAddress ("glProgramUniform3ui");
    s_deviceConfig.m_glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC) glewGetProcAddress ("glProgramUniform3uiv");
    s_deviceConfig.m_glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC) glewGetProcAddress ("glProgramUniform4i");
    s_deviceConfig.m_glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC) glewGetProcAddress ("glProgramUniform4iv");
    s_deviceConfig.m_glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC) glewGetProcAddress ("glProgramUniform4f");
    s_deviceConfig.m_glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC) glewGetProcAddress ("glProgramUniform4fv");
    s_deviceConfig.m_glProgramUniform4d = (PFNGLPROGRAMUNIFORM4DPROC) glewGetProcAddress ("glProgramUniform4d");
    s_deviceConfig.m_glProgramUniform4dv = (PFNGLPROGRAMUNIFORM4DVPROC) glewGetProcAddress ("glProgramUniform4dv");
    s_deviceConfig.m_glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC) glewGetProcAddress ("glProgramUniform4ui");
    s_deviceConfig.m_glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC) glewGetProcAddress ("glProgramUniform4uiv");
    s_deviceConfig.m_glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC) glewGetProcAddress ("glProgramUniformMatrix2fv");
    s_deviceConfig.m_glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC) glewGetProcAddress ("glProgramUniformMatrix3fv");
    s_deviceConfig.m_glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC) glewGetProcAddress ("glProgramUniformMatrix4fv");
    s_deviceConfig.m_glProgramUniformMatrix2dv = (PFNGLPROGRAMUNIFORMMATRIX2DVPROC) glewGetProcAddress ("glProgramUniformMatrix2dv");
    s_deviceConfig.m_glProgramUniformMatrix3dv = (PFNGLPROGRAMUNIFORMMATRIX3DVPROC) glewGetProcAddress ("glProgramUniformMatrix3dv");
    s_deviceConfig.m_glProgramUniformMatrix4dv = (PFNGLPROGRAMUNIFORMMATRIX4DVPROC) glewGetProcAddress ("glProgramUniformMatrix4dv");
    s_deviceConfig.m_glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) glewGetProcAddress ("glProgramUniformMatrix2x3fv");
    s_deviceConfig.m_glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) glewGetProcAddress ("glProgramUniformMatrix3x2fv");
    s_deviceConfig.m_glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) glewGetProcAddress ("glProgramUniformMatrix2x4fv");
    s_deviceConfig.m_glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) glewGetProcAddress ("glProgramUniformMatrix4x2fv");
    s_deviceConfig.m_glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) glewGetProcAddress ("glProgramUniformMatrix3x4fv");
    s_deviceConfig.m_glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) glewGetProcAddress ("glProgramUniformMatrix4x3fv");
    s_deviceConfig.m_glProgramUniformMatrix2x3dv = (PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) glewGetProcAddress ("glProgramUniformMatrix2x3dv");
    s_deviceConfig.m_glProgramUniformMatrix3x2dv = (PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) glewGetProcAddress ("glProgramUniformMatrix3x2dv");
    s_deviceConfig.m_glProgramUniformMatrix2x4dv = (PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) glewGetProcAddress ("glProgramUniformMatrix2x4dv");
    s_deviceConfig.m_glProgramUniformMatrix4x2dv = (PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) glewGetProcAddress ("glProgramUniformMatrix4x2dv");
    s_deviceConfig.m_glProgramUniformMatrix3x4dv = (PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) glewGetProcAddress ("glProgramUniformMatrix3x4dv");
    s_deviceConfig.m_glProgramUniformMatrix4x3dv = (PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) glewGetProcAddress ("glProgramUniformMatrix4x3dv");
    s_deviceConfig.m_glValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC) glewGetProcAddress ("glValidateProgramPipeline");
    s_deviceConfig.m_glGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC) glewGetProcAddress ("glGetProgramPipelineInfoLog");
    s_deviceConfig.m_glVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC) glewGetProcAddress ("glVertexAttribL1d");
    s_deviceConfig.m_glVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC) glewGetProcAddress ("glVertexAttribL2d");
    s_deviceConfig.m_glVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC) glewGetProcAddress ("glVertexAttribL3d");
    s_deviceConfig.m_glVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC) glewGetProcAddress ("glVertexAttribL4d");
    s_deviceConfig.m_glVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC) glewGetProcAddress ("glVertexAttribL1dv");
    s_deviceConfig.m_glVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC) glewGetProcAddress ("glVertexAttribL2dv");
    s_deviceConfig.m_glVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC) glewGetProcAddress ("glVertexAttribL3dv");
    s_deviceConfig.m_glVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC) glewGetProcAddress ("glVertexAttribL4dv");
    s_deviceConfig.m_glVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC) glewGetProcAddress ("glVertexAttribLPointer");
    s_deviceConfig.m_glGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC) glewGetProcAddress ("glGetVertexAttribLdv");
    s_deviceConfig.m_glViewportArrayv = (PFNGLVIEWPORTARRAYVPROC) glewGetProcAddress ("glViewportArrayv");
    s_deviceConfig.m_glViewportIndexedf = (PFNGLVIEWPORTINDEXEDFPROC) glewGetProcAddress ("glViewportIndexedf");
    s_deviceConfig.m_glViewportIndexedfv = (PFNGLVIEWPORTINDEXEDFVPROC) glewGetProcAddress ("glViewportIndexedfv");
    s_deviceConfig.m_glScissorArrayv = (PFNGLSCISSORARRAYVPROC) glewGetProcAddress ("glScissorArrayv");
    s_deviceConfig.m_glScissorIndexed = (PFNGLSCISSORINDEXEDPROC) glewGetProcAddress ("glScissorIndexed");
    s_deviceConfig.m_glScissorIndexedv = (PFNGLSCISSORINDEXEDVPROC) glewGetProcAddress ("glScissorIndexedv");
    s_deviceConfig.m_glDepthRangeArrayv = (PFNGLDEPTHRANGEARRAYVPROC) glewGetProcAddress ("glDepthRangeArrayv");
    s_deviceConfig.m_glDepthRangeIndexed = (PFNGLDEPTHRANGEINDEXEDPROC) glewGetProcAddress ("glDepthRangeIndexed");
    s_deviceConfig.m_glGetFloati_v = (PFNGLGETFLOATI_VPROC) glewGetProcAddress ("glGetFloati_v");
    s_deviceConfig.m_glGetDoublei_v = (PFNGLGETDOUBLEI_VPROC) glewGetProcAddress ("glGetDoublei_v");
  }

  // GL_VERSION_4_2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_2])
  {
    s_deviceConfig.m_glDrawArraysInstancedBaseInstance = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) glewGetProcAddress ("glDrawArraysInstancedBaseInstance");
    s_deviceConfig.m_glDrawElementsInstancedBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) glewGetProcAddress ("glDrawElementsInstancedBaseInstance");
    s_deviceConfig.m_glDrawElementsInstancedBaseVertexBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) glewGetProcAddress ("glDrawElementsInstancedBaseVertexBaseInstance");
    s_deviceConfig.m_glGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC) glewGetProcAddress ("glGetInternalformativ");
    s_deviceConfig.m_glGetActiveAtomicCounterBufferiv = (PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) glewGetProcAddress ("glGetActiveAtomicCounterBufferiv");
    s_deviceConfig.m_glBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC) glewGetProcAddress ("glBindImageTexture");
    s_deviceConfig.m_glMemoryBarrier = (PFNGLMEMORYBARRIERPROC) glewGetProcAddress ("glMemoryBarrier");
    s_deviceConfig.m_glTexStorage1D = (PFNGLTEXSTORAGE1DPROC) glewGetProcAddress ("glTexStorage1D");
    s_deviceConfig.m_glTexStorage2D = (PFNGLTEXSTORAGE2DPROC) glewGetProcAddress ("glTexStorage2D");
    s_deviceConfig.m_glTexStorage3D = (PFNGLTEXSTORAGE3DPROC) glewGetProcAddress ("glTexStorage3D");
    s_deviceConfig.m_glDrawTransformFeedbackInstanced = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) glewGetProcAddress ("glDrawTransformFeedbackInstanced");
    s_deviceConfig.m_glDrawTransformFeedbackStreamInstanced = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) glewGetProcAddress ("glDrawTransformFeedbackStreamInstanced");
  }

  // GL_VERSION_4_3
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_3])
  {
    s_deviceConfig.m_glClearBufferData = (PFNGLCLEARBUFFERDATAPROC) glewGetProcAddress ("glClearBufferData");
    s_deviceConfig.m_glClearBufferSubData = (PFNGLCLEARBUFFERSUBDATAPROC) glewGetProcAddress ("glClearBufferSubData");
    s_deviceConfig.m_glDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC) glewGetProcAddress ("glDispatchCompute");
    s_deviceConfig.m_glDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC) glewGetProcAddress ("glDispatchComputeIndirect");
    s_deviceConfig.m_glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC) glewGetProcAddress ("glCopyImageSubData");
    s_deviceConfig.m_glFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC) glewGetProcAddress ("glFramebufferParameteri");
    s_deviceConfig.m_glGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetFramebufferParameteriv");
    s_deviceConfig.m_glGetInternalformati64v = (PFNGLGETINTERNALFORMATI64VPROC) glewGetProcAddress ("glGetInternalformati64v");
    s_deviceConfig.m_glInvalidateTexSubImage = (PFNGLINVALIDATETEXSUBIMAGEPROC) glewGetProcAddress ("glInvalidateTexSubImage");
    s_deviceConfig.m_glInvalidateTexImage = (PFNGLINVALIDATETEXIMAGEPROC) glewGetProcAddress ("glInvalidateTexImage");
    s_deviceConfig.m_glInvalidateBufferSubData = (PFNGLINVALIDATEBUFFERSUBDATAPROC) glewGetProcAddress ("glInvalidateBufferSubData");
    s_deviceConfig.m_glInvalidateBufferData = (PFNGLINVALIDATEBUFFERDATAPROC) glewGetProcAddress ("glInvalidateBufferData");
    s_deviceConfig.m_glInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC) glewGetProcAddress ("glInvalidateFramebuffer");
    s_deviceConfig.m_glInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC) glewGetProcAddress ("glInvalidateSubFramebuffer");
    s_deviceConfig.m_glMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC) glewGetProcAddress ("glMultiDrawArraysIndirect");
    s_deviceConfig.m_glMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC) glewGetProcAddress ("glMultiDrawElementsIndirect");
    s_deviceConfig.m_glGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC) glewGetProcAddress ("glGetProgramInterfaceiv");
    s_deviceConfig.m_glGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC) glewGetProcAddress ("glGetProgramResourceIndex");
    s_deviceConfig.m_glGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC) glewGetProcAddress ("glGetProgramResourceName");
    s_deviceConfig.m_glGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC) glewGetProcAddress ("glGetProgramResourceiv");
    s_deviceConfig.m_glGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC) glewGetProcAddress ("glGetProgramResourceLocation");
    s_deviceConfig.m_glGetProgramResourceLocationIndex = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) glewGetProcAddress ("glGetProgramResourceLocationIndex");
    s_deviceConfig.m_glShaderStorageBlockBinding = (PFNGLSHADERSTORAGEBLOCKBINDINGPROC) glewGetProcAddress ("glShaderStorageBlockBinding");
    s_deviceConfig.m_glTexBufferRange = (PFNGLTEXBUFFERRANGEPROC) glewGetProcAddress ("glTexBufferRange");
    s_deviceConfig.m_glTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC) glewGetProcAddress ("glTexStorage2DMultisample");
    s_deviceConfig.m_glTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC) glewGetProcAddress ("glTexStorage3DMultisample");
    s_deviceConfig.m_glTextureView = (PFNGLTEXTUREVIEWPROC) glewGetProcAddress ("glTextureView");
    s_deviceConfig.m_glBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC) glewGetProcAddress ("glBindVertexBuffer");
    s_deviceConfig.m_glVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC) glewGetProcAddress ("glVertexAttribFormat");
    s_deviceConfig.m_glVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC) glewGetProcAddress ("glVertexAttribIFormat");
    s_deviceConfig.m_glVertexAttribLFormat = (PFNGLVERTEXATTRIBLFORMATPROC) glewGetProcAddress ("glVertexAttribLFormat");
    s_deviceConfig.m_glVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC) glewGetProcAddress ("glVertexAttribBinding");
    s_deviceConfig.m_glVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC) glewGetProcAddress ("glVertexBindingDivisor");
    s_deviceConfig.m_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC) glewGetProcAddress ("glDebugMessageControl");
    s_deviceConfig.m_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC) glewGetProcAddress ("glDebugMessageInsert");
    s_deviceConfig.m_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC) glewGetProcAddress ("glDebugMessageCallback");
    s_deviceConfig.m_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC) glewGetProcAddress ("glGetDebugMessageLog");
    s_deviceConfig.m_glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC) glewGetProcAddress ("glPushDebugGroup");
    s_deviceConfig.m_glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC) glewGetProcAddress ("glPopDebugGroup");
    s_deviceConfig.m_glObjectLabel = (PFNGLOBJECTLABELPROC) glewGetProcAddress ("glObjectLabel");
    s_deviceConfig.m_glGetObjectLabel = (PFNGLGETOBJECTLABELPROC) glewGetProcAddress ("glGetObjectLabel");
    s_deviceConfig.m_glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC) glewGetProcAddress ("glObjectPtrLabel");
    s_deviceConfig.m_glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC) glewGetProcAddress ("glGetObjectPtrLabel");
    s_deviceConfig.m_glGetPointerv = (PFNGLGETPOINTERVPROC) glewGetProcAddress ("glGetPointerv");
  }

  // GL_VERSION_4_4
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_4])
  {
    s_deviceConfig.m_glBufferStorage = (PFNGLBUFFERSTORAGEPROC) glewGetProcAddress ("glBufferStorage");
    s_deviceConfig.m_glClearTexImage = (PFNGLCLEARTEXIMAGEPROC) glewGetProcAddress ("glClearTexImage");
    s_deviceConfig.m_glClearTexSubImage = (PFNGLCLEARTEXSUBIMAGEPROC) glewGetProcAddress ("glClearTexSubImage");
    s_deviceConfig.m_glBindBuffersBase = (PFNGLBINDBUFFERSBASEPROC) glewGetProcAddress ("glBindBuffersBase");
    s_deviceConfig.m_glBindBuffersRange = (PFNGLBINDBUFFERSRANGEPROC) glewGetProcAddress ("glBindBuffersRange");
    s_deviceConfig.m_glBindTextures = (PFNGLBINDTEXTURESPROC) glewGetProcAddress ("glBindTextures");
    s_deviceConfig.m_glBindSamplers = (PFNGLBINDSAMPLERSPROC) glewGetProcAddress ("glBindSamplers");
    s_deviceConfig.m_glBindImageTextures = (PFNGLBINDIMAGETEXTURESPROC) glewGetProcAddress ("glBindImageTextures");
    s_deviceConfig.m_glBindVertexBuffers = (PFNGLBINDVERTEXBUFFERSPROC) glewGetProcAddress ("glBindVertexBuffers");
  }

  // GL_VERSION_4_5
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_5])
  {
    s_deviceConfig.m_glClipControl = (PFNGLCLIPCONTROLPROC) glewGetProcAddress ("glClipControl");
    s_deviceConfig.m_glCreateTransformFeedbacks = (PFNGLCREATETRANSFORMFEEDBACKSPROC) glewGetProcAddress ("glCreateTransformFeedbacks");
    s_deviceConfig.m_glTransformFeedbackBufferBase = (PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) glewGetProcAddress ("glTransformFeedbackBufferBase");
    s_deviceConfig.m_glTransformFeedbackBufferRange = (PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) glewGetProcAddress ("glTransformFeedbackBufferRange");
    s_deviceConfig.m_glGetTransformFeedbackiv = (PFNGLGETTRANSFORMFEEDBACKIVPROC) glewGetProcAddress ("glGetTransformFeedbackiv");
    s_deviceConfig.m_glGetTransformFeedbacki_v = (PFNGLGETTRANSFORMFEEDBACKI_VPROC) glewGetProcAddress ("glGetTransformFeedbacki_v");
    s_deviceConfig.m_glGetTransformFeedbacki64_v = (PFNGLGETTRANSFORMFEEDBACKI64_VPROC) glewGetProcAddress ("glGetTransformFeedbacki64_v");
    s_deviceConfig.m_glCreateBuffers = (PFNGLCREATEBUFFERSPROC) glewGetProcAddress ("glCreateBuffers");
    s_deviceConfig.m_glNamedBufferStorage = (PFNGLNAMEDBUFFERSTORAGEPROC) glewGetProcAddress ("glNamedBufferStorage");
    s_deviceConfig.m_glNamedBufferData = (PFNGLNAMEDBUFFERDATAPROC) glewGetProcAddress ("glNamedBufferData");
    s_deviceConfig.m_glNamedBufferSubData = (PFNGLNAMEDBUFFERSUBDATAPROC) glewGetProcAddress ("glNamedBufferSubData");
    s_deviceConfig.m_glCopyNamedBufferSubData = (PFNGLCOPYNAMEDBUFFERSUBDATAPROC) glewGetProcAddress ("glCopyNamedBufferSubData");
    s_deviceConfig.m_glClearNamedBufferData = (PFNGLCLEARNAMEDBUFFERDATAPROC) glewGetProcAddress ("glClearNamedBufferData");
    s_deviceConfig.m_glClearNamedBufferSubData = (PFNGLCLEARNAMEDBUFFERSUBDATAPROC) glewGetProcAddress ("glClearNamedBufferSubData");
    s_deviceConfig.m_glMapNamedBuffer = (PFNGLMAPNAMEDBUFFERPROC) glewGetProcAddress ("glMapNamedBuffer");
    s_deviceConfig.m_glMapNamedBufferRange = (PFNGLMAPNAMEDBUFFERRANGEPROC) glewGetProcAddress ("glMapNamedBufferRange");
    s_deviceConfig.m_glUnmapNamedBuffer = (PFNGLUNMAPNAMEDBUFFERPROC) glewGetProcAddress ("glUnmapNamedBuffer");
    s_deviceConfig.m_glFlushMappedNamedBufferRange = (PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) glewGetProcAddress ("glFlushMappedNamedBufferRange");
    s_deviceConfig.m_glGetNamedBufferParameteriv = (PFNGLGETNAMEDBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetNamedBufferParameteriv");
    s_deviceConfig.m_glGetNamedBufferParameteri64v = (PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) glewGetProcAddress ("glGetNamedBufferParameteri64v");
    s_deviceConfig.m_glGetNamedBufferPointerv = (PFNGLGETNAMEDBUFFERPOINTERVPROC) glewGetProcAddress ("glGetNamedBufferPointerv");
    s_deviceConfig.m_glGetNamedBufferSubData = (PFNGLGETNAMEDBUFFERSUBDATAPROC) glewGetProcAddress ("glGetNamedBufferSubData");
    s_deviceConfig.m_glCreateFramebuffers = (PFNGLCREATEFRAMEBUFFERSPROC) glewGetProcAddress ("glCreateFramebuffers");
    s_deviceConfig.m_glNamedFramebufferRenderbuffer = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) glewGetProcAddress ("glNamedFramebufferRenderbuffer");
    s_deviceConfig.m_glNamedFramebufferParameteri = (PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) glewGetProcAddress ("glNamedFramebufferParameteri");
    s_deviceConfig.m_glNamedFramebufferTexture = (PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) glewGetProcAddress ("glNamedFramebufferTexture");
    s_deviceConfig.m_glNamedFramebufferTextureLayer = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) glewGetProcAddress ("glNamedFramebufferTextureLayer");
    s_deviceConfig.m_glNamedFramebufferDrawBuffer = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) glewGetProcAddress ("glNamedFramebufferDrawBuffer");
    s_deviceConfig.m_glNamedFramebufferDrawBuffers = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) glewGetProcAddress ("glNamedFramebufferDrawBuffers");
    s_deviceConfig.m_glNamedFramebufferReadBuffer = (PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) glewGetProcAddress ("glNamedFramebufferReadBuffer");
    s_deviceConfig.m_glInvalidateNamedFramebufferData = (PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) glewGetProcAddress ("glInvalidateNamedFramebufferData");
    s_deviceConfig.m_glInvalidateNamedFramebufferSubData = (PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) glewGetProcAddress ("glInvalidateNamedFramebufferSubData");
    s_deviceConfig.m_glClearNamedFramebufferiv = (PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) glewGetProcAddress ("glClearNamedFramebufferiv");
    s_deviceConfig.m_glClearNamedFramebufferuiv = (PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) glewGetProcAddress ("glClearNamedFramebufferuiv");
    s_deviceConfig.m_glClearNamedFramebufferfv = (PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) glewGetProcAddress ("glClearNamedFramebufferfv");
    s_deviceConfig.m_glClearNamedFramebufferfi = (PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) glewGetProcAddress ("glClearNamedFramebufferfi");
    s_deviceConfig.m_glBlitNamedFramebuffer = (PFNGLBLITNAMEDFRAMEBUFFERPROC) glewGetProcAddress ("glBlitNamedFramebuffer");
    s_deviceConfig.m_glCheckNamedFramebufferStatus = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) glewGetProcAddress ("glCheckNamedFramebufferStatus");
    s_deviceConfig.m_glGetNamedFramebufferParameteriv = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetNamedFramebufferParameteriv");
    s_deviceConfig.m_glGetNamedFramebufferAttachmentParameteriv = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) glewGetProcAddress ("glGetNamedFramebufferAttachmentParameteriv");
    s_deviceConfig.m_glCreateRenderbuffers = (PFNGLCREATERENDERBUFFERSPROC) glewGetProcAddress ("glCreateRenderbuffers");
    s_deviceConfig.m_glNamedRenderbufferStorage = (PFNGLNAMEDRENDERBUFFERSTORAGEPROC) glewGetProcAddress ("glNamedRenderbufferStorage");
    s_deviceConfig.m_glNamedRenderbufferStorageMultisample = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) glewGetProcAddress ("glNamedRenderbufferStorageMultisample");
    s_deviceConfig.m_glGetNamedRenderbufferParameteriv = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetNamedRenderbufferParameteriv");
    s_deviceConfig.m_glCreateTextures = (PFNGLCREATETEXTURESPROC) glewGetProcAddress ("glCreateTextures");
    s_deviceConfig.m_glTextureBuffer = (PFNGLTEXTUREBUFFERPROC) glewGetProcAddress ("glTextureBuffer");
    s_deviceConfig.m_glTextureBufferRange = (PFNGLTEXTUREBUFFERRANGEPROC) glewGetProcAddress ("glTextureBufferRange");
    s_deviceConfig.m_glTextureStorage1D = (PFNGLTEXTURESTORAGE1DPROC) glewGetProcAddress ("glTextureStorage1D");
    s_deviceConfig.m_glTextureStorage2D = (PFNGLTEXTURESTORAGE2DPROC) glewGetProcAddress ("glTextureStorage2D");
    s_deviceConfig.m_glTextureStorage3D = (PFNGLTEXTURESTORAGE3DPROC) glewGetProcAddress ("glTextureStorage3D");
    s_deviceConfig.m_glTextureStorage2DMultisample = (PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) glewGetProcAddress ("glTextureStorage2DMultisample");
    s_deviceConfig.m_glTextureStorage3DMultisample = (PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) glewGetProcAddress ("glTextureStorage3DMultisample");
    s_deviceConfig.m_glTextureSubImage1D = (PFNGLTEXTURESUBIMAGE1DPROC) glewGetProcAddress ("glTextureSubImage1D");
    s_deviceConfig.m_glTextureSubImage2D = (PFNGLTEXTURESUBIMAGE2DPROC) glewGetProcAddress ("glTextureSubImage2D");
    s_deviceConfig.m_glTextureSubImage3D = (PFNGLTEXTURESUBIMAGE3DPROC) glewGetProcAddress ("glTextureSubImage3D");
    s_deviceConfig.m_glCompressedTextureSubImage1D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) glewGetProcAddress ("glCompressedTextureSubImage1D");
    s_deviceConfig.m_glCompressedTextureSubImage2D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) glewGetProcAddress ("glCompressedTextureSubImage2D");
    s_deviceConfig.m_glCompressedTextureSubImage3D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) glewGetProcAddress ("glCompressedTextureSubImage3D");
    s_deviceConfig.m_glCopyTextureSubImage1D = (PFNGLCOPYTEXTURESUBIMAGE1DPROC) glewGetProcAddress ("glCopyTextureSubImage1D");
    s_deviceConfig.m_glCopyTextureSubImage2D = (PFNGLCOPYTEXTURESUBIMAGE2DPROC) glewGetProcAddress ("glCopyTextureSubImage2D");
    s_deviceConfig.m_glCopyTextureSubImage3D = (PFNGLCOPYTEXTURESUBIMAGE3DPROC) glewGetProcAddress ("glCopyTextureSubImage3D");
    s_deviceConfig.m_glTextureParameterf = (PFNGLTEXTUREPARAMETERFPROC) glewGetProcAddress ("glTextureParameterf");
    s_deviceConfig.m_glTextureParameterfv = (PFNGLTEXTUREPARAMETERFVPROC) glewGetProcAddress ("glTextureParameterfv");
    s_deviceConfig.m_glTextureParameteri = (PFNGLTEXTUREPARAMETERIPROC) glewGetProcAddress ("glTextureParameteri");
    s_deviceConfig.m_glTextureParameterIiv = (PFNGLTEXTUREPARAMETERIIVPROC) glewGetProcAddress ("glTextureParameterIiv");
    s_deviceConfig.m_glTextureParameterIuiv = (PFNGLTEXTUREPARAMETERIUIVPROC) glewGetProcAddress ("glTextureParameterIuiv");
    s_deviceConfig.m_glTextureParameteriv = (PFNGLTEXTUREPARAMETERIVPROC) glewGetProcAddress ("glTextureParameteriv");
    s_deviceConfig.m_glGenerateTextureMipmap = (PFNGLGENERATETEXTUREMIPMAPPROC) glewGetProcAddress ("glGenerateTextureMipmap");
    s_deviceConfig.m_glBindTextureUnit = (PFNGLBINDTEXTUREUNITPROC) glewGetProcAddress ("glBindTextureUnit");
    s_deviceConfig.m_glGetTextureImage = (PFNGLGETTEXTUREIMAGEPROC) glewGetProcAddress ("glGetTextureImage");
    s_deviceConfig.m_glGetCompressedTextureImage = (PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) glewGetProcAddress ("glGetCompressedTextureImage");
    s_deviceConfig.m_glGetTextureLevelParameterfv = (PFNGLGETTEXTURELEVELPARAMETERFVPROC) glewGetProcAddress ("glGetTextureLevelParameterfv");
    s_deviceConfig.m_glGetTextureLevelParameteriv = (PFNGLGETTEXTURELEVELPARAMETERIVPROC) glewGetProcAddress ("glGetTextureLevelParameteriv");
    s_deviceConfig.m_glGetTextureParameterfv = (PFNGLGETTEXTUREPARAMETERFVPROC) glewGetProcAddress ("glGetTextureParameterfv");
    s_deviceConfig.m_glGetTextureParameterIiv = (PFNGLGETTEXTUREPARAMETERIIVPROC) glewGetProcAddress ("glGetTextureParameterIiv");
    s_deviceConfig.m_glGetTextureParameterIuiv = (PFNGLGETTEXTUREPARAMETERIUIVPROC) glewGetProcAddress ("glGetTextureParameterIuiv");
    s_deviceConfig.m_glGetTextureParameteriv = (PFNGLGETTEXTUREPARAMETERIVPROC) glewGetProcAddress ("glGetTextureParameteriv");
    s_deviceConfig.m_glCreateVertexArrays = (PFNGLCREATEVERTEXARRAYSPROC) glewGetProcAddress ("glCreateVertexArrays");
    s_deviceConfig.m_glDisableVertexArrayAttrib = (PFNGLDISABLEVERTEXARRAYATTRIBPROC) glewGetProcAddress ("glDisableVertexArrayAttrib");
    s_deviceConfig.m_glEnableVertexArrayAttrib = (PFNGLENABLEVERTEXARRAYATTRIBPROC) glewGetProcAddress ("glEnableVertexArrayAttrib");
    s_deviceConfig.m_glVertexArrayElementBuffer = (PFNGLVERTEXARRAYELEMENTBUFFERPROC) glewGetProcAddress ("glVertexArrayElementBuffer");
    s_deviceConfig.m_glVertexArrayVertexBuffer = (PFNGLVERTEXARRAYVERTEXBUFFERPROC) glewGetProcAddress ("glVertexArrayVertexBuffer");
    s_deviceConfig.m_glVertexArrayVertexBuffers = (PFNGLVERTEXARRAYVERTEXBUFFERSPROC) glewGetProcAddress ("glVertexArrayVertexBuffers");
    s_deviceConfig.m_glVertexArrayAttribBinding = (PFNGLVERTEXARRAYATTRIBBINDINGPROC) glewGetProcAddress ("glVertexArrayAttribBinding");
    s_deviceConfig.m_glVertexArrayAttribFormat = (PFNGLVERTEXARRAYATTRIBFORMATPROC) glewGetProcAddress ("glVertexArrayAttribFormat");
    s_deviceConfig.m_glVertexArrayAttribIFormat = (PFNGLVERTEXARRAYATTRIBIFORMATPROC) glewGetProcAddress ("glVertexArrayAttribIFormat");
    s_deviceConfig.m_glVertexArrayAttribLFormat = (PFNGLVERTEXARRAYATTRIBLFORMATPROC) glewGetProcAddress ("glVertexArrayAttribLFormat");
    s_deviceConfig.m_glVertexArrayBindingDivisor = (PFNGLVERTEXARRAYBINDINGDIVISORPROC) glewGetProcAddress ("glVertexArrayBindingDivisor");
    s_deviceConfig.m_glGetVertexArrayiv = (PFNGLGETVERTEXARRAYIVPROC) glewGetProcAddress ("glGetVertexArrayiv");
    s_deviceConfig.m_glGetVertexArrayIndexediv = (PFNGLGETVERTEXARRAYINDEXEDIVPROC) glewGetProcAddress ("glGetVertexArrayIndexediv");
    s_deviceConfig.m_glGetVertexArrayIndexed64iv = (PFNGLGETVERTEXARRAYINDEXED64IVPROC) glewGetProcAddress ("glGetVertexArrayIndexed64iv");
    s_deviceConfig.m_glCreateSamplers = (PFNGLCREATESAMPLERSPROC) glewGetProcAddress ("glCreateSamplers");
    s_deviceConfig.m_glCreateProgramPipelines = (PFNGLCREATEPROGRAMPIPELINESPROC) glewGetProcAddress ("glCreateProgramPipelines");
    s_deviceConfig.m_glCreateQueries = (PFNGLCREATEQUERIESPROC) glewGetProcAddress ("glCreateQueries");
    s_deviceConfig.m_glGetQueryBufferObjecti64v = (PFNGLGETQUERYBUFFEROBJECTI64VPROC) glewGetProcAddress ("glGetQueryBufferObjecti64v");
    s_deviceConfig.m_glGetQueryBufferObjectiv = (PFNGLGETQUERYBUFFEROBJECTIVPROC) glewGetProcAddress ("glGetQueryBufferObjectiv");
    s_deviceConfig.m_glGetQueryBufferObjectui64v = (PFNGLGETQUERYBUFFEROBJECTUI64VPROC) glewGetProcAddress ("glGetQueryBufferObjectui64v");
    s_deviceConfig.m_glGetQueryBufferObjectuiv = (PFNGLGETQUERYBUFFEROBJECTUIVPROC) glewGetProcAddress ("glGetQueryBufferObjectuiv");
    s_deviceConfig.m_glMemoryBarrierByRegion = (PFNGLMEMORYBARRIERBYREGIONPROC) glewGetProcAddress ("glMemoryBarrierByRegion");
    s_deviceConfig.m_glGetTextureSubImage = (PFNGLGETTEXTURESUBIMAGEPROC) glewGetProcAddress ("glGetTextureSubImage");
    s_deviceConfig.m_glGetCompressedTextureSubImage = (PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) glewGetProcAddress ("glGetCompressedTextureSubImage");
    s_deviceConfig.m_glGetGraphicsResetStatus = (PFNGLGETGRAPHICSRESETSTATUSPROC) glewGetProcAddress ("glGetGraphicsResetStatus");
    s_deviceConfig.m_glGetnCompressedTexImage = (PFNGLGETNCOMPRESSEDTEXIMAGEPROC) glewGetProcAddress ("glGetnCompressedTexImage");
    s_deviceConfig.m_glGetnTexImage = (PFNGLGETNTEXIMAGEPROC) glewGetProcAddress ("glGetnTexImage");
    s_deviceConfig.m_glGetnUniformdv = (PFNGLGETNUNIFORMDVPROC) glewGetProcAddress ("glGetnUniformdv");
    s_deviceConfig.m_glGetnUniformfv = (PFNGLGETNUNIFORMFVPROC) glewGetProcAddress ("glGetnUniformfv");
    s_deviceConfig.m_glGetnUniformiv = (PFNGLGETNUNIFORMIVPROC) glewGetProcAddress ("glGetnUniformiv");
    s_deviceConfig.m_glGetnUniformuiv = (PFNGLGETNUNIFORMUIVPROC) glewGetProcAddress ("glGetnUniformuiv");
    s_deviceConfig.m_glReadnPixels = (PFNGLREADNPIXELSPROC) glewGetProcAddress ("glReadnPixels");
    s_deviceConfig.m_glGetnMapdv = (PFNGLGETNMAPDVPROC) glewGetProcAddress ("glGetnMapdv");
    s_deviceConfig.m_glGetnMapfv = (PFNGLGETNMAPFVPROC) glewGetProcAddress ("glGetnMapfv");
    s_deviceConfig.m_glGetnMapiv = (PFNGLGETNMAPIVPROC) glewGetProcAddress ("glGetnMapiv");
    s_deviceConfig.m_glGetnPixelMapfv = (PFNGLGETNPIXELMAPFVPROC) glewGetProcAddress ("glGetnPixelMapfv");
    s_deviceConfig.m_glGetnPixelMapuiv = (PFNGLGETNPIXELMAPUIVPROC) glewGetProcAddress ("glGetnPixelMapuiv");
    s_deviceConfig.m_glGetnPixelMapusv = (PFNGLGETNPIXELMAPUSVPROC) glewGetProcAddress ("glGetnPixelMapusv");
    s_deviceConfig.m_glGetnPolygonStipple = (PFNGLGETNPOLYGONSTIPPLEPROC) glewGetProcAddress ("glGetnPolygonStipple");
    s_deviceConfig.m_glGetnColorTable = (PFNGLGETNCOLORTABLEPROC) glewGetProcAddress ("glGetnColorTable");
    s_deviceConfig.m_glGetnConvolutionFilter = (PFNGLGETNCONVOLUTIONFILTERPROC) glewGetProcAddress ("glGetnConvolutionFilter");
    s_deviceConfig.m_glGetnSeparableFilter = (PFNGLGETNSEPARABLEFILTERPROC) glewGetProcAddress ("glGetnSeparableFilter");
    s_deviceConfig.m_glGetnHistogram = (PFNGLGETNHISTOGRAMPROC) glewGetProcAddress ("glGetnHistogram");
    s_deviceConfig.m_glGetnMinmax = (PFNGLGETNMINMAXPROC) glewGetProcAddress ("glGetnMinmax");
    s_deviceConfig.m_glTextureBarrier = (PFNGLTEXTUREBARRIERPROC) glewGetProcAddress ("glTextureBarrier");
  }

  // GL_VERSION_4_6
  if (s_deviceConfig.m_featureSupported [GLEW_GL_VERSION_4_6])
  {
    s_deviceConfig.m_glSpecializeShader = (PFNGLSPECIALIZESHADERPROC) glewGetProcAddress ("glSpecializeShader");
    s_deviceConfig.m_glMultiDrawArraysIndirectCount = (PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC) glewGetProcAddress ("glMultiDrawArraysIndirectCount");
    s_deviceConfig.m_glMultiDrawElementsIndirectCount = (PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC) glewGetProcAddress ("glMultiDrawElementsIndirectCount");
    s_deviceConfig.m_glPolygonOffsetClamp = (PFNGLPOLYGONOFFSETCLAMPPROC) glewGetProcAddress ("glPolygonOffsetClamp");
  }

  // GL_ES_VERSION_2_0
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ES_VERSION_2_0])
  {
    s_deviceConfig.m_glActiveTexture = (PFNGLACTIVETEXTUREPROC) glewGetProcAddress ("glActiveTexture");
    s_deviceConfig.m_glAttachShader = (PFNGLATTACHSHADERPROC) glewGetProcAddress ("glAttachShader");
    s_deviceConfig.m_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC) glewGetProcAddress ("glBindAttribLocation");
    s_deviceConfig.m_glBindBuffer = (PFNGLBINDBUFFERPROC) glewGetProcAddress ("glBindBuffer");
    s_deviceConfig.m_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC) glewGetProcAddress ("glBindFramebuffer");
    s_deviceConfig.m_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC) glewGetProcAddress ("glBindRenderbuffer");
    s_deviceConfig.m_glBindTexture = (PFNGLBINDTEXTUREPROC) glewGetProcAddress ("glBindTexture");
    s_deviceConfig.m_glBlendColor = (PFNGLBLENDCOLORPROC) glewGetProcAddress ("glBlendColor");
    s_deviceConfig.m_glBlendEquation = (PFNGLBLENDEQUATIONPROC) glewGetProcAddress ("glBlendEquation");
    s_deviceConfig.m_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC) glewGetProcAddress ("glBlendEquationSeparate");
    s_deviceConfig.m_glBlendFunc = (PFNGLBLENDFUNCPROC) glewGetProcAddress ("glBlendFunc");
    s_deviceConfig.m_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC) glewGetProcAddress ("glBlendFuncSeparate");
    s_deviceConfig.m_glBufferData = (PFNGLBUFFERDATAPROC) glewGetProcAddress ("glBufferData");
    s_deviceConfig.m_glBufferSubData = (PFNGLBUFFERSUBDATAPROC) glewGetProcAddress ("glBufferSubData");
    s_deviceConfig.m_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC) glewGetProcAddress ("glCheckFramebufferStatus");
    s_deviceConfig.m_glClear = (PFNGLCLEARPROC) glewGetProcAddress ("glClear");
    s_deviceConfig.m_glClearColor = (PFNGLCLEARCOLORPROC) glewGetProcAddress ("glClearColor");
    s_deviceConfig.m_glClearDepthf = (PFNGLCLEARDEPTHFPROC) glewGetProcAddress ("glClearDepthf");
    s_deviceConfig.m_glClearStencil = (PFNGLCLEARSTENCILPROC) glewGetProcAddress ("glClearStencil");
    s_deviceConfig.m_glColorMask = (PFNGLCOLORMASKPROC) glewGetProcAddress ("glColorMask");
    s_deviceConfig.m_glCompileShader = (PFNGLCOMPILESHADERPROC) glewGetProcAddress ("glCompileShader");
    s_deviceConfig.m_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC) glewGetProcAddress ("glCompressedTexImage2D");
    s_deviceConfig.m_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) glewGetProcAddress ("glCompressedTexSubImage2D");
    s_deviceConfig.m_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC) glewGetProcAddress ("glCopyTexImage2D");
    s_deviceConfig.m_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC) glewGetProcAddress ("glCopyTexSubImage2D");
    s_deviceConfig.m_glCreateProgram = (PFNGLCREATEPROGRAMPROC) glewGetProcAddress ("glCreateProgram");
    s_deviceConfig.m_glCreateShader = (PFNGLCREATESHADERPROC) glewGetProcAddress ("glCreateShader");
    s_deviceConfig.m_glCullFace = (PFNGLCULLFACEPROC) glewGetProcAddress ("glCullFace");
    s_deviceConfig.m_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC) glewGetProcAddress ("glDeleteBuffers");
    s_deviceConfig.m_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC) glewGetProcAddress ("glDeleteFramebuffers");
    s_deviceConfig.m_glDeleteProgram = (PFNGLDELETEPROGRAMPROC) glewGetProcAddress ("glDeleteProgram");
    s_deviceConfig.m_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC) glewGetProcAddress ("glDeleteRenderbuffers");
    s_deviceConfig.m_glDeleteShader = (PFNGLDELETESHADERPROC) glewGetProcAddress ("glDeleteShader");
    s_deviceConfig.m_glDeleteTextures = (PFNGLDELETETEXTURESPROC) glewGetProcAddress ("glDeleteTextures");
    s_deviceConfig.m_glDepthFunc = (PFNGLDEPTHFUNCPROC) glewGetProcAddress ("glDepthFunc");
    s_deviceConfig.m_glDepthMask = (PFNGLDEPTHMASKPROC) glewGetProcAddress ("glDepthMask");
    s_deviceConfig.m_glDepthRangef = (PFNGLDEPTHRANGEFPROC) glewGetProcAddress ("glDepthRangef");
    s_deviceConfig.m_glDetachShader = (PFNGLDETACHSHADERPROC) glewGetProcAddress ("glDetachShader");
    s_deviceConfig.m_glDisable = (PFNGLDISABLEPROC) glewGetProcAddress ("glDisable");
    s_deviceConfig.m_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC) glewGetProcAddress ("glDisableVertexAttribArray");
    s_deviceConfig.m_glDrawArrays = (PFNGLDRAWARRAYSPROC) glewGetProcAddress ("glDrawArrays");
    s_deviceConfig.m_glDrawElements = (PFNGLDRAWELEMENTSPROC) glewGetProcAddress ("glDrawElements");
    s_deviceConfig.m_glEnable = (PFNGLENABLEPROC) glewGetProcAddress ("glEnable");
    s_deviceConfig.m_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC) glewGetProcAddress ("glEnableVertexAttribArray");
    s_deviceConfig.m_glFinish = (PFNGLFINISHPROC) glewGetProcAddress ("glFinish");
    s_deviceConfig.m_glFlush = (PFNGLFLUSHPROC) glewGetProcAddress ("glFlush");
    s_deviceConfig.m_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC) glewGetProcAddress ("glFramebufferRenderbuffer");
    s_deviceConfig.m_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC) glewGetProcAddress ("glFramebufferTexture2D");
    s_deviceConfig.m_glFrontFace = (PFNGLFRONTFACEPROC) glewGetProcAddress ("glFrontFace");
    s_deviceConfig.m_glGenBuffers = (PFNGLGENBUFFERSPROC) glewGetProcAddress ("glGenBuffers");
    s_deviceConfig.m_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC) glewGetProcAddress ("glGenerateMipmap");
    s_deviceConfig.m_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC) glewGetProcAddress ("glGenFramebuffers");
    s_deviceConfig.m_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC) glewGetProcAddress ("glGenRenderbuffers");
    s_deviceConfig.m_glGenTextures = (PFNGLGENTEXTURESPROC) glewGetProcAddress ("glGenTextures");
    s_deviceConfig.m_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC) glewGetProcAddress ("glGetActiveAttrib");
    s_deviceConfig.m_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC) glewGetProcAddress ("glGetActiveUniform");
    s_deviceConfig.m_glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC) glewGetProcAddress ("glGetAttachedShaders");
    s_deviceConfig.m_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC) glewGetProcAddress ("glGetAttribLocation");
    s_deviceConfig.m_glGetBooleanv = (PFNGLGETBOOLEANVPROC) glewGetProcAddress ("glGetBooleanv");
    s_deviceConfig.m_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetBufferParameteriv");
    s_deviceConfig.m_glGetError = (PFNGLGETERRORPROC) glewGetProcAddress ("glGetError");
    s_deviceConfig.m_glGetFloatv = (PFNGLGETFLOATVPROC) glewGetProcAddress ("glGetFloatv");
    s_deviceConfig.m_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) glewGetProcAddress ("glGetFramebufferAttachmentParameteriv");
    s_deviceConfig.m_glGetIntegerv = (PFNGLGETINTEGERVPROC) glewGetProcAddress ("glGetIntegerv");
    s_deviceConfig.m_glGetProgramiv = (PFNGLGETPROGRAMIVPROC) glewGetProcAddress ("glGetProgramiv");
    s_deviceConfig.m_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC) glewGetProcAddress ("glGetProgramInfoLog");
    s_deviceConfig.m_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetRenderbufferParameteriv");
    s_deviceConfig.m_glGetShaderiv = (PFNGLGETSHADERIVPROC) glewGetProcAddress ("glGetShaderiv");
    s_deviceConfig.m_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC) glewGetProcAddress ("glGetShaderInfoLog");
    s_deviceConfig.m_glGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC) glewGetProcAddress ("glGetShaderPrecisionFormat");
    s_deviceConfig.m_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC) glewGetProcAddress ("glGetShaderSource");
    s_deviceConfig.m_glGetString = (PFNGLGETSTRINGPROC) glewGetProcAddress ("glGetString");
    s_deviceConfig.m_glGetTexParameterfv = (PFNGLGETTEXPARAMETERFVPROC) glewGetProcAddress ("glGetTexParameterfv");
    s_deviceConfig.m_glGetTexParameteriv = (PFNGLGETTEXPARAMETERIVPROC) glewGetProcAddress ("glGetTexParameteriv");
    s_deviceConfig.m_glGetUniformfv = (PFNGLGETUNIFORMFVPROC) glewGetProcAddress ("glGetUniformfv");
    s_deviceConfig.m_glGetUniformiv = (PFNGLGETUNIFORMIVPROC) glewGetProcAddress ("glGetUniformiv");
    s_deviceConfig.m_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC) glewGetProcAddress ("glGetUniformLocation");
    s_deviceConfig.m_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC) glewGetProcAddress ("glGetVertexAttribfv");
    s_deviceConfig.m_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC) glewGetProcAddress ("glGetVertexAttribiv");
    s_deviceConfig.m_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC) glewGetProcAddress ("glGetVertexAttribPointerv");
    s_deviceConfig.m_glHint = (PFNGLHINTPROC) glewGetProcAddress ("glHint");
    s_deviceConfig.m_glIsBuffer = (PFNGLISBUFFERPROC) glewGetProcAddress ("glIsBuffer");
    s_deviceConfig.m_glIsEnabled = (PFNGLISENABLEDPROC) glewGetProcAddress ("glIsEnabled");
    s_deviceConfig.m_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC) glewGetProcAddress ("glIsFramebuffer");
    s_deviceConfig.m_glIsProgram = (PFNGLISPROGRAMPROC) glewGetProcAddress ("glIsProgram");
    s_deviceConfig.m_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC) glewGetProcAddress ("glIsRenderbuffer");
    s_deviceConfig.m_glIsShader = (PFNGLISSHADERPROC) glewGetProcAddress ("glIsShader");
    s_deviceConfig.m_glIsTexture = (PFNGLISTEXTUREPROC) glewGetProcAddress ("glIsTexture");
    s_deviceConfig.m_glLineWidth = (PFNGLLINEWIDTHPROC) glewGetProcAddress ("glLineWidth");
    s_deviceConfig.m_glLinkProgram = (PFNGLLINKPROGRAMPROC) glewGetProcAddress ("glLinkProgram");
    s_deviceConfig.m_glPixelStorei = (PFNGLPIXELSTOREIPROC) glewGetProcAddress ("glPixelStorei");
    s_deviceConfig.m_glPolygonOffset = (PFNGLPOLYGONOFFSETPROC) glewGetProcAddress ("glPolygonOffset");
    s_deviceConfig.m_glReadPixels = (PFNGLREADPIXELSPROC) glewGetProcAddress ("glReadPixels");
    s_deviceConfig.m_glReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC) glewGetProcAddress ("glReleaseShaderCompiler");
    s_deviceConfig.m_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC) glewGetProcAddress ("glRenderbufferStorage");
    s_deviceConfig.m_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC) glewGetProcAddress ("glSampleCoverage");
    s_deviceConfig.m_glScissor = (PFNGLSCISSORPROC) glewGetProcAddress ("glScissor");
    s_deviceConfig.m_glShaderBinary = (PFNGLSHADERBINARYPROC) glewGetProcAddress ("glShaderBinary");
    s_deviceConfig.m_glShaderSource = (PFNGLSHADERSOURCEPROC) glewGetProcAddress ("glShaderSource");
    s_deviceConfig.m_glStencilFunc = (PFNGLSTENCILFUNCPROC) glewGetProcAddress ("glStencilFunc");
    s_deviceConfig.m_glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC) glewGetProcAddress ("glStencilFuncSeparate");
    s_deviceConfig.m_glStencilMask = (PFNGLSTENCILMASKPROC) glewGetProcAddress ("glStencilMask");
    s_deviceConfig.m_glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC) glewGetProcAddress ("glStencilMaskSeparate");
    s_deviceConfig.m_glStencilOp = (PFNGLSTENCILOPPROC) glewGetProcAddress ("glStencilOp");
    s_deviceConfig.m_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC) glewGetProcAddress ("glStencilOpSeparate");
    s_deviceConfig.m_glTexImage2D = (PFNGLTEXIMAGE2DPROC) glewGetProcAddress ("glTexImage2D");
    s_deviceConfig.m_glTexParameterf = (PFNGLTEXPARAMETERFPROC) glewGetProcAddress ("glTexParameterf");
    s_deviceConfig.m_glTexParameterfv = (PFNGLTEXPARAMETERFVPROC) glewGetProcAddress ("glTexParameterfv");
    s_deviceConfig.m_glTexParameteri = (PFNGLTEXPARAMETERIPROC) glewGetProcAddress ("glTexParameteri");
    s_deviceConfig.m_glTexParameteriv = (PFNGLTEXPARAMETERIVPROC) glewGetProcAddress ("glTexParameteriv");
    s_deviceConfig.m_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC) glewGetProcAddress ("glTexSubImage2D");
    s_deviceConfig.m_glUniform1f = (PFNGLUNIFORM1FPROC) glewGetProcAddress ("glUniform1f");
    s_deviceConfig.m_glUniform1fv = (PFNGLUNIFORM1FVPROC) glewGetProcAddress ("glUniform1fv");
    s_deviceConfig.m_glUniform1i = (PFNGLUNIFORM1IPROC) glewGetProcAddress ("glUniform1i");
    s_deviceConfig.m_glUniform1iv = (PFNGLUNIFORM1IVPROC) glewGetProcAddress ("glUniform1iv");
    s_deviceConfig.m_glUniform2f = (PFNGLUNIFORM2FPROC) glewGetProcAddress ("glUniform2f");
    s_deviceConfig.m_glUniform2fv = (PFNGLUNIFORM2FVPROC) glewGetProcAddress ("glUniform2fv");
    s_deviceConfig.m_glUniform2i = (PFNGLUNIFORM2IPROC) glewGetProcAddress ("glUniform2i");
    s_deviceConfig.m_glUniform2iv = (PFNGLUNIFORM2IVPROC) glewGetProcAddress ("glUniform2iv");
    s_deviceConfig.m_glUniform3f = (PFNGLUNIFORM3FPROC) glewGetProcAddress ("glUniform3f");
    s_deviceConfig.m_glUniform3fv = (PFNGLUNIFORM3FVPROC) glewGetProcAddress ("glUniform3fv");
    s_deviceConfig.m_glUniform3i = (PFNGLUNIFORM3IPROC) glewGetProcAddress ("glUniform3i");
    s_deviceConfig.m_glUniform3iv = (PFNGLUNIFORM3IVPROC) glewGetProcAddress ("glUniform3iv");
    s_deviceConfig.m_glUniform4f = (PFNGLUNIFORM4FPROC) glewGetProcAddress ("glUniform4f");
    s_deviceConfig.m_glUniform4fv = (PFNGLUNIFORM4FVPROC) glewGetProcAddress ("glUniform4fv");
    s_deviceConfig.m_glUniform4i = (PFNGLUNIFORM4IPROC) glewGetProcAddress ("glUniform4i");
    s_deviceConfig.m_glUniform4iv = (PFNGLUNIFORM4IVPROC) glewGetProcAddress ("glUniform4iv");
    s_deviceConfig.m_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC) glewGetProcAddress ("glUniformMatrix2fv");
    s_deviceConfig.m_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC) glewGetProcAddress ("glUniformMatrix3fv");
    s_deviceConfig.m_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC) glewGetProcAddress ("glUniformMatrix4fv");
    s_deviceConfig.m_glUseProgram = (PFNGLUSEPROGRAMPROC) glewGetProcAddress ("glUseProgram");
    s_deviceConfig.m_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC) glewGetProcAddress ("glValidateProgram");
    s_deviceConfig.m_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC) glewGetProcAddress ("glVertexAttrib1f");
    s_deviceConfig.m_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC) glewGetProcAddress ("glVertexAttrib1fv");
    s_deviceConfig.m_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC) glewGetProcAddress ("glVertexAttrib2f");
    s_deviceConfig.m_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC) glewGetProcAddress ("glVertexAttrib2fv");
    s_deviceConfig.m_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC) glewGetProcAddress ("glVertexAttrib3f");
    s_deviceConfig.m_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC) glewGetProcAddress ("glVertexAttrib3fv");
    s_deviceConfig.m_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC) glewGetProcAddress ("glVertexAttrib4f");
    s_deviceConfig.m_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC) glewGetProcAddress ("glVertexAttrib4fv");
    s_deviceConfig.m_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC) glewGetProcAddress ("glVertexAttribPointer");
    s_deviceConfig.m_glViewport = (PFNGLVIEWPORTPROC) glewGetProcAddress ("glViewport");
  }

  // GL_ES_VERSION_3_0
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_0])
  {
    s_deviceConfig.m_glReadBuffer = (PFNGLREADBUFFERPROC) glewGetProcAddress ("glReadBuffer");
    s_deviceConfig.m_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC) glewGetProcAddress ("glDrawRangeElements");
    s_deviceConfig.m_glTexImage3D = (PFNGLTEXIMAGE3DPROC) glewGetProcAddress ("glTexImage3D");
    s_deviceConfig.m_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC) glewGetProcAddress ("glTexSubImage3D");
    s_deviceConfig.m_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC) glewGetProcAddress ("glCopyTexSubImage3D");
    s_deviceConfig.m_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC) glewGetProcAddress ("glCompressedTexImage3D");
    s_deviceConfig.m_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) glewGetProcAddress ("glCompressedTexSubImage3D");
    s_deviceConfig.m_glGenQueries = (PFNGLGENQUERIESPROC) glewGetProcAddress ("glGenQueries");
    s_deviceConfig.m_glDeleteQueries = (PFNGLDELETEQUERIESPROC) glewGetProcAddress ("glDeleteQueries");
    s_deviceConfig.m_glIsQuery = (PFNGLISQUERYPROC) glewGetProcAddress ("glIsQuery");
    s_deviceConfig.m_glBeginQuery = (PFNGLBEGINQUERYPROC) glewGetProcAddress ("glBeginQuery");
    s_deviceConfig.m_glEndQuery = (PFNGLENDQUERYPROC) glewGetProcAddress ("glEndQuery");
    s_deviceConfig.m_glGetQueryiv = (PFNGLGETQUERYIVPROC) glewGetProcAddress ("glGetQueryiv");
    s_deviceConfig.m_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC) glewGetProcAddress ("glGetQueryObjectuiv");
    s_deviceConfig.m_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC) glewGetProcAddress ("glUnmapBuffer");
    s_deviceConfig.m_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC) glewGetProcAddress ("glGetBufferPointerv");
    s_deviceConfig.m_glDrawBuffers = (PFNGLDRAWBUFFERSPROC) glewGetProcAddress ("glDrawBuffers");
    s_deviceConfig.m_glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC) glewGetProcAddress ("glUniformMatrix2x3fv");
    s_deviceConfig.m_glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC) glewGetProcAddress ("glUniformMatrix3x2fv");
    s_deviceConfig.m_glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC) glewGetProcAddress ("glUniformMatrix2x4fv");
    s_deviceConfig.m_glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC) glewGetProcAddress ("glUniformMatrix4x2fv");
    s_deviceConfig.m_glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC) glewGetProcAddress ("glUniformMatrix3x4fv");
    s_deviceConfig.m_glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC) glewGetProcAddress ("glUniformMatrix4x3fv");
    s_deviceConfig.m_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC) glewGetProcAddress ("glBlitFramebuffer");
    s_deviceConfig.m_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) glewGetProcAddress ("glRenderbufferStorageMultisample");
    s_deviceConfig.m_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC) glewGetProcAddress ("glFramebufferTextureLayer");
    s_deviceConfig.m_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC) glewGetProcAddress ("glMapBufferRange");
    s_deviceConfig.m_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC) glewGetProcAddress ("glFlushMappedBufferRange");
    s_deviceConfig.m_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC) glewGetProcAddress ("glBindVertexArray");
    s_deviceConfig.m_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC) glewGetProcAddress ("glDeleteVertexArrays");
    s_deviceConfig.m_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC) glewGetProcAddress ("glGenVertexArrays");
    s_deviceConfig.m_glIsVertexArray = (PFNGLISVERTEXARRAYPROC) glewGetProcAddress ("glIsVertexArray");
    s_deviceConfig.m_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) glewGetProcAddress ("glGetIntegeri_v");
    s_deviceConfig.m_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glBeginTransformFeedback");
    s_deviceConfig.m_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glEndTransformFeedback");
    s_deviceConfig.m_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) glewGetProcAddress ("glBindBufferRange");
    s_deviceConfig.m_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) glewGetProcAddress ("glBindBufferBase");
    s_deviceConfig.m_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC) glewGetProcAddress ("glTransformFeedbackVaryings");
    s_deviceConfig.m_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) glewGetProcAddress ("glGetTransformFeedbackVarying");
    s_deviceConfig.m_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC) glewGetProcAddress ("glVertexAttribIPointer");
    s_deviceConfig.m_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC) glewGetProcAddress ("glGetVertexAttribIiv");
    s_deviceConfig.m_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC) glewGetProcAddress ("glGetVertexAttribIuiv");
    s_deviceConfig.m_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC) glewGetProcAddress ("glVertexAttribI4i");
    s_deviceConfig.m_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC) glewGetProcAddress ("glVertexAttribI4ui");
    s_deviceConfig.m_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC) glewGetProcAddress ("glVertexAttribI4iv");
    s_deviceConfig.m_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC) glewGetProcAddress ("glVertexAttribI4uiv");
    s_deviceConfig.m_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC) glewGetProcAddress ("glGetUniformuiv");
    s_deviceConfig.m_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC) glewGetProcAddress ("glGetFragDataLocation");
    s_deviceConfig.m_glUniform1ui = (PFNGLUNIFORM1UIPROC) glewGetProcAddress ("glUniform1ui");
    s_deviceConfig.m_glUniform2ui = (PFNGLUNIFORM2UIPROC) glewGetProcAddress ("glUniform2ui");
    s_deviceConfig.m_glUniform3ui = (PFNGLUNIFORM3UIPROC) glewGetProcAddress ("glUniform3ui");
    s_deviceConfig.m_glUniform4ui = (PFNGLUNIFORM4UIPROC) glewGetProcAddress ("glUniform4ui");
    s_deviceConfig.m_glUniform1uiv = (PFNGLUNIFORM1UIVPROC) glewGetProcAddress ("glUniform1uiv");
    s_deviceConfig.m_glUniform2uiv = (PFNGLUNIFORM2UIVPROC) glewGetProcAddress ("glUniform2uiv");
    s_deviceConfig.m_glUniform3uiv = (PFNGLUNIFORM3UIVPROC) glewGetProcAddress ("glUniform3uiv");
    s_deviceConfig.m_glUniform4uiv = (PFNGLUNIFORM4UIVPROC) glewGetProcAddress ("glUniform4uiv");
    s_deviceConfig.m_glClearBufferiv = (PFNGLCLEARBUFFERIVPROC) glewGetProcAddress ("glClearBufferiv");
    s_deviceConfig.m_glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC) glewGetProcAddress ("glClearBufferuiv");
    s_deviceConfig.m_glClearBufferfv = (PFNGLCLEARBUFFERFVPROC) glewGetProcAddress ("glClearBufferfv");
    s_deviceConfig.m_glClearBufferfi = (PFNGLCLEARBUFFERFIPROC) glewGetProcAddress ("glClearBufferfi");
    s_deviceConfig.m_glGetStringi = (PFNGLGETSTRINGIPROC) glewGetProcAddress ("glGetStringi");
    s_deviceConfig.m_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC) glewGetProcAddress ("glCopyBufferSubData");
    s_deviceConfig.m_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC) glewGetProcAddress ("glGetUniformIndices");
    s_deviceConfig.m_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC) glewGetProcAddress ("glGetActiveUniformsiv");
    s_deviceConfig.m_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC) glewGetProcAddress ("glGetUniformBlockIndex");
    s_deviceConfig.m_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC) glewGetProcAddress ("glGetActiveUniformBlockiv");
    s_deviceConfig.m_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) glewGetProcAddress ("glGetActiveUniformBlockName");
    s_deviceConfig.m_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC) glewGetProcAddress ("glUniformBlockBinding");
    s_deviceConfig.m_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC) glewGetProcAddress ("glDrawArraysInstanced");
    s_deviceConfig.m_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC) glewGetProcAddress ("glDrawElementsInstanced");
    s_deviceConfig.m_glFenceSync = (PFNGLFENCESYNCPROC) glewGetProcAddress ("glFenceSync");
    s_deviceConfig.m_glIsSync = (PFNGLISSYNCPROC) glewGetProcAddress ("glIsSync");
    s_deviceConfig.m_glDeleteSync = (PFNGLDELETESYNCPROC) glewGetProcAddress ("glDeleteSync");
    s_deviceConfig.m_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC) glewGetProcAddress ("glClientWaitSync");
    s_deviceConfig.m_glWaitSync = (PFNGLWAITSYNCPROC) glewGetProcAddress ("glWaitSync");
    s_deviceConfig.m_glGetInteger64v = (PFNGLGETINTEGER64VPROC) glewGetProcAddress ("glGetInteger64v");
    s_deviceConfig.m_glGetSynciv = (PFNGLGETSYNCIVPROC) glewGetProcAddress ("glGetSynciv");
    s_deviceConfig.m_glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC) glewGetProcAddress ("glGetInteger64i_v");
    s_deviceConfig.m_glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC) glewGetProcAddress ("glGetBufferParameteri64v");
    s_deviceConfig.m_glGenSamplers = (PFNGLGENSAMPLERSPROC) glewGetProcAddress ("glGenSamplers");
    s_deviceConfig.m_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC) glewGetProcAddress ("glDeleteSamplers");
    s_deviceConfig.m_glIsSampler = (PFNGLISSAMPLERPROC) glewGetProcAddress ("glIsSampler");
    s_deviceConfig.m_glBindSampler = (PFNGLBINDSAMPLERPROC) glewGetProcAddress ("glBindSampler");
    s_deviceConfig.m_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC) glewGetProcAddress ("glSamplerParameteri");
    s_deviceConfig.m_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC) glewGetProcAddress ("glSamplerParameteriv");
    s_deviceConfig.m_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC) glewGetProcAddress ("glSamplerParameterf");
    s_deviceConfig.m_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC) glewGetProcAddress ("glSamplerParameterfv");
    s_deviceConfig.m_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC) glewGetProcAddress ("glGetSamplerParameteriv");
    s_deviceConfig.m_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC) glewGetProcAddress ("glGetSamplerParameterfv");
    s_deviceConfig.m_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC) glewGetProcAddress ("glVertexAttribDivisor");
    s_deviceConfig.m_glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glBindTransformFeedback");
    s_deviceConfig.m_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC) glewGetProcAddress ("glDeleteTransformFeedbacks");
    s_deviceConfig.m_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC) glewGetProcAddress ("glGenTransformFeedbacks");
    s_deviceConfig.m_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glIsTransformFeedback");
    s_deviceConfig.m_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC) glewGetProcAddress ("glPauseTransformFeedback");
    s_deviceConfig.m_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC) glewGetProcAddress ("glResumeTransformFeedback");
    s_deviceConfig.m_glGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC) glewGetProcAddress ("glGetProgramBinary");
    s_deviceConfig.m_glProgramBinary = (PFNGLPROGRAMBINARYPROC) glewGetProcAddress ("glProgramBinary");
    s_deviceConfig.m_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC) glewGetProcAddress ("glProgramParameteri");
    s_deviceConfig.m_glInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC) glewGetProcAddress ("glInvalidateFramebuffer");
    s_deviceConfig.m_glInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC) glewGetProcAddress ("glInvalidateSubFramebuffer");
    s_deviceConfig.m_glTexStorage2D = (PFNGLTEXSTORAGE2DPROC) glewGetProcAddress ("glTexStorage2D");
    s_deviceConfig.m_glTexStorage3D = (PFNGLTEXSTORAGE3DPROC) glewGetProcAddress ("glTexStorage3D");
    s_deviceConfig.m_glGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC) glewGetProcAddress ("glGetInternalformativ");
  }

  // GL_ES_VERSION_3_1
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_1])
  {
    s_deviceConfig.m_glDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC) glewGetProcAddress ("glDispatchCompute");
    s_deviceConfig.m_glDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC) glewGetProcAddress ("glDispatchComputeIndirect");
    s_deviceConfig.m_glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC) glewGetProcAddress ("glDrawArraysIndirect");
    s_deviceConfig.m_glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC) glewGetProcAddress ("glDrawElementsIndirect");
    s_deviceConfig.m_glFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC) glewGetProcAddress ("glFramebufferParameteri");
    s_deviceConfig.m_glGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetFramebufferParameteriv");
    s_deviceConfig.m_glGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC) glewGetProcAddress ("glGetProgramInterfaceiv");
    s_deviceConfig.m_glGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC) glewGetProcAddress ("glGetProgramResourceIndex");
    s_deviceConfig.m_glGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC) glewGetProcAddress ("glGetProgramResourceName");
    s_deviceConfig.m_glGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC) glewGetProcAddress ("glGetProgramResourceiv");
    s_deviceConfig.m_glGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC) glewGetProcAddress ("glGetProgramResourceLocation");
    s_deviceConfig.m_glUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC) glewGetProcAddress ("glUseProgramStages");
    s_deviceConfig.m_glActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC) glewGetProcAddress ("glActiveShaderProgram");
    s_deviceConfig.m_glCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC) glewGetProcAddress ("glCreateShaderProgramv");
    s_deviceConfig.m_glBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC) glewGetProcAddress ("glBindProgramPipeline");
    s_deviceConfig.m_glDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC) glewGetProcAddress ("glDeleteProgramPipelines");
    s_deviceConfig.m_glGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC) glewGetProcAddress ("glGenProgramPipelines");
    s_deviceConfig.m_glIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC) glewGetProcAddress ("glIsProgramPipeline");
    s_deviceConfig.m_glGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC) glewGetProcAddress ("glGetProgramPipelineiv");
    s_deviceConfig.m_glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC) glewGetProcAddress ("glProgramUniform1i");
    s_deviceConfig.m_glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC) glewGetProcAddress ("glProgramUniform2i");
    s_deviceConfig.m_glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC) glewGetProcAddress ("glProgramUniform3i");
    s_deviceConfig.m_glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC) glewGetProcAddress ("glProgramUniform4i");
    s_deviceConfig.m_glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC) glewGetProcAddress ("glProgramUniform1ui");
    s_deviceConfig.m_glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC) glewGetProcAddress ("glProgramUniform2ui");
    s_deviceConfig.m_glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC) glewGetProcAddress ("glProgramUniform3ui");
    s_deviceConfig.m_glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC) glewGetProcAddress ("glProgramUniform4ui");
    s_deviceConfig.m_glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC) glewGetProcAddress ("glProgramUniform1f");
    s_deviceConfig.m_glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC) glewGetProcAddress ("glProgramUniform2f");
    s_deviceConfig.m_glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC) glewGetProcAddress ("glProgramUniform3f");
    s_deviceConfig.m_glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC) glewGetProcAddress ("glProgramUniform4f");
    s_deviceConfig.m_glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC) glewGetProcAddress ("glProgramUniform1iv");
    s_deviceConfig.m_glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC) glewGetProcAddress ("glProgramUniform2iv");
    s_deviceConfig.m_glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC) glewGetProcAddress ("glProgramUniform3iv");
    s_deviceConfig.m_glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC) glewGetProcAddress ("glProgramUniform4iv");
    s_deviceConfig.m_glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC) glewGetProcAddress ("glProgramUniform1uiv");
    s_deviceConfig.m_glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC) glewGetProcAddress ("glProgramUniform2uiv");
    s_deviceConfig.m_glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC) glewGetProcAddress ("glProgramUniform3uiv");
    s_deviceConfig.m_glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC) glewGetProcAddress ("glProgramUniform4uiv");
    s_deviceConfig.m_glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC) glewGetProcAddress ("glProgramUniform1fv");
    s_deviceConfig.m_glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC) glewGetProcAddress ("glProgramUniform2fv");
    s_deviceConfig.m_glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC) glewGetProcAddress ("glProgramUniform3fv");
    s_deviceConfig.m_glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC) glewGetProcAddress ("glProgramUniform4fv");
    s_deviceConfig.m_glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC) glewGetProcAddress ("glProgramUniformMatrix2fv");
    s_deviceConfig.m_glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC) glewGetProcAddress ("glProgramUniformMatrix3fv");
    s_deviceConfig.m_glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC) glewGetProcAddress ("glProgramUniformMatrix4fv");
    s_deviceConfig.m_glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) glewGetProcAddress ("glProgramUniformMatrix2x3fv");
    s_deviceConfig.m_glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) glewGetProcAddress ("glProgramUniformMatrix3x2fv");
    s_deviceConfig.m_glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) glewGetProcAddress ("glProgramUniformMatrix2x4fv");
    s_deviceConfig.m_glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) glewGetProcAddress ("glProgramUniformMatrix4x2fv");
    s_deviceConfig.m_glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) glewGetProcAddress ("glProgramUniformMatrix3x4fv");
    s_deviceConfig.m_glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) glewGetProcAddress ("glProgramUniformMatrix4x3fv");
    s_deviceConfig.m_glValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC) glewGetProcAddress ("glValidateProgramPipeline");
    s_deviceConfig.m_glGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC) glewGetProcAddress ("glGetProgramPipelineInfoLog");
    s_deviceConfig.m_glBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC) glewGetProcAddress ("glBindImageTexture");
    s_deviceConfig.m_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC) glewGetProcAddress ("glGetBooleani_v");
    s_deviceConfig.m_glMemoryBarrier = (PFNGLMEMORYBARRIERPROC) glewGetProcAddress ("glMemoryBarrier");
    s_deviceConfig.m_glMemoryBarrierByRegion = (PFNGLMEMORYBARRIERBYREGIONPROC) glewGetProcAddress ("glMemoryBarrierByRegion");
    s_deviceConfig.m_glTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC) glewGetProcAddress ("glTexStorage2DMultisample");
    s_deviceConfig.m_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC) glewGetProcAddress ("glGetMultisamplefv");
    s_deviceConfig.m_glSampleMaski = (PFNGLSAMPLEMASKIPROC) glewGetProcAddress ("glSampleMaski");
    s_deviceConfig.m_glGetTexLevelParameteriv = (PFNGLGETTEXLEVELPARAMETERIVPROC) glewGetProcAddress ("glGetTexLevelParameteriv");
    s_deviceConfig.m_glGetTexLevelParameterfv = (PFNGLGETTEXLEVELPARAMETERFVPROC) glewGetProcAddress ("glGetTexLevelParameterfv");
    s_deviceConfig.m_glBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC) glewGetProcAddress ("glBindVertexBuffer");
    s_deviceConfig.m_glVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC) glewGetProcAddress ("glVertexAttribFormat");
    s_deviceConfig.m_glVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC) glewGetProcAddress ("glVertexAttribIFormat");
    s_deviceConfig.m_glVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC) glewGetProcAddress ("glVertexAttribBinding");
    s_deviceConfig.m_glVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC) glewGetProcAddress ("glVertexBindingDivisor");
  }

  // GL_ES_VERSION_3_2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ES_VERSION_3_2])
  {
    s_deviceConfig.m_glBlendBarrier = (PFNGLBLENDBARRIERPROC) glewGetProcAddress ("glBlendBarrier");
    s_deviceConfig.m_glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC) glewGetProcAddress ("glCopyImageSubData");
    s_deviceConfig.m_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC) glewGetProcAddress ("glDebugMessageControl");
    s_deviceConfig.m_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC) glewGetProcAddress ("glDebugMessageInsert");
    s_deviceConfig.m_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC) glewGetProcAddress ("glDebugMessageCallback");
    s_deviceConfig.m_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC) glewGetProcAddress ("glGetDebugMessageLog");
    s_deviceConfig.m_glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC) glewGetProcAddress ("glPushDebugGroup");
    s_deviceConfig.m_glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC) glewGetProcAddress ("glPopDebugGroup");
    s_deviceConfig.m_glObjectLabel = (PFNGLOBJECTLABELPROC) glewGetProcAddress ("glObjectLabel");
    s_deviceConfig.m_glGetObjectLabel = (PFNGLGETOBJECTLABELPROC) glewGetProcAddress ("glGetObjectLabel");
    s_deviceConfig.m_glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC) glewGetProcAddress ("glObjectPtrLabel");
    s_deviceConfig.m_glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC) glewGetProcAddress ("glGetObjectPtrLabel");
    s_deviceConfig.m_glGetPointerv = (PFNGLGETPOINTERVPROC) glewGetProcAddress ("glGetPointerv");
    s_deviceConfig.m_glEnablei = (PFNGLENABLEIPROC) glewGetProcAddress ("glEnablei");
    s_deviceConfig.m_glDisablei = (PFNGLDISABLEIPROC) glewGetProcAddress ("glDisablei");
    s_deviceConfig.m_glBlendEquationi = (PFNGLBLENDEQUATIONIPROC) glewGetProcAddress ("glBlendEquationi");
    s_deviceConfig.m_glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC) glewGetProcAddress ("glBlendEquationSeparatei");
    s_deviceConfig.m_glBlendFunci = (PFNGLBLENDFUNCIPROC) glewGetProcAddress ("glBlendFunci");
    s_deviceConfig.m_glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC) glewGetProcAddress ("glBlendFuncSeparatei");
    s_deviceConfig.m_glColorMaski = (PFNGLCOLORMASKIPROC) glewGetProcAddress ("glColorMaski");
    s_deviceConfig.m_glIsEnabledi = (PFNGLISENABLEDIPROC) glewGetProcAddress ("glIsEnabledi");
    s_deviceConfig.m_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC) glewGetProcAddress ("glDrawElementsBaseVertex");
    s_deviceConfig.m_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) glewGetProcAddress ("glDrawRangeElementsBaseVertex");
    s_deviceConfig.m_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) glewGetProcAddress ("glDrawElementsInstancedBaseVertex");
    s_deviceConfig.m_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC) glewGetProcAddress ("glFramebufferTexture");
    s_deviceConfig.m_glPrimitiveBoundingBox = (PFNGLPRIMITIVEBOUNDINGBOXPROC) glewGetProcAddress ("glPrimitiveBoundingBox");
    s_deviceConfig.m_glGetGraphicsResetStatus = (PFNGLGETGRAPHICSRESETSTATUSPROC) glewGetProcAddress ("glGetGraphicsResetStatus");
    s_deviceConfig.m_glReadnPixels = (PFNGLREADNPIXELSPROC) glewGetProcAddress ("glReadnPixels");
    s_deviceConfig.m_glGetnUniformfv = (PFNGLGETNUNIFORMFVPROC) glewGetProcAddress ("glGetnUniformfv");
    s_deviceConfig.m_glGetnUniformiv = (PFNGLGETNUNIFORMIVPROC) glewGetProcAddress ("glGetnUniformiv");
    s_deviceConfig.m_glGetnUniformuiv = (PFNGLGETNUNIFORMUIVPROC) glewGetProcAddress ("glGetnUniformuiv");
    s_deviceConfig.m_glMinSampleShading = (PFNGLMINSAMPLESHADINGPROC) glewGetProcAddress ("glMinSampleShading");
    s_deviceConfig.m_glPatchParameteri = (PFNGLPATCHPARAMETERIPROC) glewGetProcAddress ("glPatchParameteri");
    s_deviceConfig.m_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC) glewGetProcAddress ("glTexParameterIiv");
    s_deviceConfig.m_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC) glewGetProcAddress ("glTexParameterIuiv");
    s_deviceConfig.m_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC) glewGetProcAddress ("glGetTexParameterIiv");
    s_deviceConfig.m_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC) glewGetProcAddress ("glGetTexParameterIuiv");
    s_deviceConfig.m_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC) glewGetProcAddress ("glSamplerParameterIiv");
    s_deviceConfig.m_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC) glewGetProcAddress ("glSamplerParameterIuiv");
    s_deviceConfig.m_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC) glewGetProcAddress ("glGetSamplerParameterIiv");
    s_deviceConfig.m_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC) glewGetProcAddress ("glGetSamplerParameterIuiv");
    s_deviceConfig.m_glTexBuffer = (PFNGLTEXBUFFERPROC) glewGetProcAddress ("glTexBuffer");
    s_deviceConfig.m_glTexBufferRange = (PFNGLTEXBUFFERRANGEPROC) glewGetProcAddress ("glTexBufferRange");
    s_deviceConfig.m_glTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC) glewGetProcAddress ("glTexStorage3DMultisample");
  }

  // GL_3DFX_tbuffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_3DFX_tbuffer])
  {
    s_deviceConfig.m_glTbufferMask3DFX = (PFNGLTBUFFERMASK3DFXPROC) glewGetProcAddress ("glTbufferMask3DFX");
  }

  // GL_AMD_debug_output
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_debug_output])
  {
    s_deviceConfig.m_glDebugMessageEnableAMD = (PFNGLDEBUGMESSAGEENABLEAMDPROC) glewGetProcAddress ("glDebugMessageEnableAMD");
    s_deviceConfig.m_glDebugMessageInsertAMD = (PFNGLDEBUGMESSAGEINSERTAMDPROC) glewGetProcAddress ("glDebugMessageInsertAMD");
    s_deviceConfig.m_glDebugMessageCallbackAMD = (PFNGLDEBUGMESSAGECALLBACKAMDPROC) glewGetProcAddress ("glDebugMessageCallbackAMD");
    s_deviceConfig.m_glGetDebugMessageLogAMD = (PFNGLGETDEBUGMESSAGELOGAMDPROC) glewGetProcAddress ("glGetDebugMessageLogAMD");
  }

  // GL_AMD_draw_buffers_blend
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_draw_buffers_blend])
  {
    s_deviceConfig.m_glBlendFuncIndexedAMD = (PFNGLBLENDFUNCINDEXEDAMDPROC) glewGetProcAddress ("glBlendFuncIndexedAMD");
    s_deviceConfig.m_glBlendFuncSeparateIndexedAMD = (PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) glewGetProcAddress ("glBlendFuncSeparateIndexedAMD");
    s_deviceConfig.m_glBlendEquationIndexedAMD = (PFNGLBLENDEQUATIONINDEXEDAMDPROC) glewGetProcAddress ("glBlendEquationIndexedAMD");
    s_deviceConfig.m_glBlendEquationSeparateIndexedAMD = (PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) glewGetProcAddress ("glBlendEquationSeparateIndexedAMD");
  }

  // GL_AMD_framebuffer_multisample_advanced
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_framebuffer_multisample_advanced])
  {
    s_deviceConfig.m_glRenderbufferStorageMultisampleAdvancedAMD = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC) glewGetProcAddress ("glRenderbufferStorageMultisampleAdvancedAMD");
    s_deviceConfig.m_glNamedRenderbufferStorageMultisampleAdvancedAMD = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC) glewGetProcAddress ("glNamedRenderbufferStorageMultisampleAdvancedAMD");
  }

  // GL_AMD_framebuffer_sample_positions
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_framebuffer_sample_positions])
  {
    s_deviceConfig.m_glFramebufferSamplePositionsfvAMD = (PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) glewGetProcAddress ("glFramebufferSamplePositionsfvAMD");
    s_deviceConfig.m_glNamedFramebufferSamplePositionsfvAMD = (PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) glewGetProcAddress ("glNamedFramebufferSamplePositionsfvAMD");
    s_deviceConfig.m_glGetFramebufferParameterfvAMD = (PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC) glewGetProcAddress ("glGetFramebufferParameterfvAMD");
    s_deviceConfig.m_glGetNamedFramebufferParameterfvAMD = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC) glewGetProcAddress ("glGetNamedFramebufferParameterfvAMD");
  }

  // GL_AMD_gpu_shader_int64
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_gpu_shader_int64])
  {
    s_deviceConfig.m_glUniform1i64NV = (PFNGLUNIFORM1I64NVPROC) glewGetProcAddress ("glUniform1i64NV");
    s_deviceConfig.m_glUniform2i64NV = (PFNGLUNIFORM2I64NVPROC) glewGetProcAddress ("glUniform2i64NV");
    s_deviceConfig.m_glUniform3i64NV = (PFNGLUNIFORM3I64NVPROC) glewGetProcAddress ("glUniform3i64NV");
    s_deviceConfig.m_glUniform4i64NV = (PFNGLUNIFORM4I64NVPROC) glewGetProcAddress ("glUniform4i64NV");
    s_deviceConfig.m_glUniform1i64vNV = (PFNGLUNIFORM1I64VNVPROC) glewGetProcAddress ("glUniform1i64vNV");
    s_deviceConfig.m_glUniform2i64vNV = (PFNGLUNIFORM2I64VNVPROC) glewGetProcAddress ("glUniform2i64vNV");
    s_deviceConfig.m_glUniform3i64vNV = (PFNGLUNIFORM3I64VNVPROC) glewGetProcAddress ("glUniform3i64vNV");
    s_deviceConfig.m_glUniform4i64vNV = (PFNGLUNIFORM4I64VNVPROC) glewGetProcAddress ("glUniform4i64vNV");
    s_deviceConfig.m_glUniform1ui64NV = (PFNGLUNIFORM1UI64NVPROC) glewGetProcAddress ("glUniform1ui64NV");
    s_deviceConfig.m_glUniform2ui64NV = (PFNGLUNIFORM2UI64NVPROC) glewGetProcAddress ("glUniform2ui64NV");
    s_deviceConfig.m_glUniform3ui64NV = (PFNGLUNIFORM3UI64NVPROC) glewGetProcAddress ("glUniform3ui64NV");
    s_deviceConfig.m_glUniform4ui64NV = (PFNGLUNIFORM4UI64NVPROC) glewGetProcAddress ("glUniform4ui64NV");
    s_deviceConfig.m_glUniform1ui64vNV = (PFNGLUNIFORM1UI64VNVPROC) glewGetProcAddress ("glUniform1ui64vNV");
    s_deviceConfig.m_glUniform2ui64vNV = (PFNGLUNIFORM2UI64VNVPROC) glewGetProcAddress ("glUniform2ui64vNV");
    s_deviceConfig.m_glUniform3ui64vNV = (PFNGLUNIFORM3UI64VNVPROC) glewGetProcAddress ("glUniform3ui64vNV");
    s_deviceConfig.m_glUniform4ui64vNV = (PFNGLUNIFORM4UI64VNVPROC) glewGetProcAddress ("glUniform4ui64vNV");
    s_deviceConfig.m_glGetUniformi64vNV = (PFNGLGETUNIFORMI64VNVPROC) glewGetProcAddress ("glGetUniformi64vNV");
    s_deviceConfig.m_glGetUniformui64vNV = (PFNGLGETUNIFORMUI64VNVPROC) glewGetProcAddress ("glGetUniformui64vNV");
    s_deviceConfig.m_glProgramUniform1i64NV = (PFNGLPROGRAMUNIFORM1I64NVPROC) glewGetProcAddress ("glProgramUniform1i64NV");
    s_deviceConfig.m_glProgramUniform2i64NV = (PFNGLPROGRAMUNIFORM2I64NVPROC) glewGetProcAddress ("glProgramUniform2i64NV");
    s_deviceConfig.m_glProgramUniform3i64NV = (PFNGLPROGRAMUNIFORM3I64NVPROC) glewGetProcAddress ("glProgramUniform3i64NV");
    s_deviceConfig.m_glProgramUniform4i64NV = (PFNGLPROGRAMUNIFORM4I64NVPROC) glewGetProcAddress ("glProgramUniform4i64NV");
    s_deviceConfig.m_glProgramUniform1i64vNV = (PFNGLPROGRAMUNIFORM1I64VNVPROC) glewGetProcAddress ("glProgramUniform1i64vNV");
    s_deviceConfig.m_glProgramUniform2i64vNV = (PFNGLPROGRAMUNIFORM2I64VNVPROC) glewGetProcAddress ("glProgramUniform2i64vNV");
    s_deviceConfig.m_glProgramUniform3i64vNV = (PFNGLPROGRAMUNIFORM3I64VNVPROC) glewGetProcAddress ("glProgramUniform3i64vNV");
    s_deviceConfig.m_glProgramUniform4i64vNV = (PFNGLPROGRAMUNIFORM4I64VNVPROC) glewGetProcAddress ("glProgramUniform4i64vNV");
    s_deviceConfig.m_glProgramUniform1ui64NV = (PFNGLPROGRAMUNIFORM1UI64NVPROC) glewGetProcAddress ("glProgramUniform1ui64NV");
    s_deviceConfig.m_glProgramUniform2ui64NV = (PFNGLPROGRAMUNIFORM2UI64NVPROC) glewGetProcAddress ("glProgramUniform2ui64NV");
    s_deviceConfig.m_glProgramUniform3ui64NV = (PFNGLPROGRAMUNIFORM3UI64NVPROC) glewGetProcAddress ("glProgramUniform3ui64NV");
    s_deviceConfig.m_glProgramUniform4ui64NV = (PFNGLPROGRAMUNIFORM4UI64NVPROC) glewGetProcAddress ("glProgramUniform4ui64NV");
    s_deviceConfig.m_glProgramUniform1ui64vNV = (PFNGLPROGRAMUNIFORM1UI64VNVPROC) glewGetProcAddress ("glProgramUniform1ui64vNV");
    s_deviceConfig.m_glProgramUniform2ui64vNV = (PFNGLPROGRAMUNIFORM2UI64VNVPROC) glewGetProcAddress ("glProgramUniform2ui64vNV");
    s_deviceConfig.m_glProgramUniform3ui64vNV = (PFNGLPROGRAMUNIFORM3UI64VNVPROC) glewGetProcAddress ("glProgramUniform3ui64vNV");
    s_deviceConfig.m_glProgramUniform4ui64vNV = (PFNGLPROGRAMUNIFORM4UI64VNVPROC) glewGetProcAddress ("glProgramUniform4ui64vNV");
  }

  // GL_AMD_interleaved_elements
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_interleaved_elements])
  {
    s_deviceConfig.m_glVertexAttribParameteriAMD = (PFNGLVERTEXATTRIBPARAMETERIAMDPROC) glewGetProcAddress ("glVertexAttribParameteriAMD");
  }

  // GL_AMD_multi_draw_indirect
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_multi_draw_indirect])
  {
    s_deviceConfig.m_glMultiDrawArraysIndirectAMD = (PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) glewGetProcAddress ("glMultiDrawArraysIndirectAMD");
    s_deviceConfig.m_glMultiDrawElementsIndirectAMD = (PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) glewGetProcAddress ("glMultiDrawElementsIndirectAMD");
  }

  // GL_AMD_name_gen_delete
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_name_gen_delete])
  {
    s_deviceConfig.m_glGenNamesAMD = (PFNGLGENNAMESAMDPROC) glewGetProcAddress ("glGenNamesAMD");
    s_deviceConfig.m_glDeleteNamesAMD = (PFNGLDELETENAMESAMDPROC) glewGetProcAddress ("glDeleteNamesAMD");
    s_deviceConfig.m_glIsNameAMD = (PFNGLISNAMEAMDPROC) glewGetProcAddress ("glIsNameAMD");
  }

  // GL_AMD_occlusion_query_event
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_occlusion_query_event])
  {
    s_deviceConfig.m_glQueryObjectParameteruiAMD = (PFNGLQUERYOBJECTPARAMETERUIAMDPROC) glewGetProcAddress ("glQueryObjectParameteruiAMD");
  }

  // GL_AMD_performance_monitor
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_performance_monitor])
  {
    s_deviceConfig.m_glGetPerfMonitorGroupsAMD = (PFNGLGETPERFMONITORGROUPSAMDPROC) glewGetProcAddress ("glGetPerfMonitorGroupsAMD");
    s_deviceConfig.m_glGetPerfMonitorCountersAMD = (PFNGLGETPERFMONITORCOUNTERSAMDPROC) glewGetProcAddress ("glGetPerfMonitorCountersAMD");
    s_deviceConfig.m_glGetPerfMonitorGroupStringAMD = (PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) glewGetProcAddress ("glGetPerfMonitorGroupStringAMD");
    s_deviceConfig.m_glGetPerfMonitorCounterStringAMD = (PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) glewGetProcAddress ("glGetPerfMonitorCounterStringAMD");
    s_deviceConfig.m_glGetPerfMonitorCounterInfoAMD = (PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) glewGetProcAddress ("glGetPerfMonitorCounterInfoAMD");
    s_deviceConfig.m_glGenPerfMonitorsAMD = (PFNGLGENPERFMONITORSAMDPROC) glewGetProcAddress ("glGenPerfMonitorsAMD");
    s_deviceConfig.m_glDeletePerfMonitorsAMD = (PFNGLDELETEPERFMONITORSAMDPROC) glewGetProcAddress ("glDeletePerfMonitorsAMD");
    s_deviceConfig.m_glSelectPerfMonitorCountersAMD = (PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) glewGetProcAddress ("glSelectPerfMonitorCountersAMD");
    s_deviceConfig.m_glBeginPerfMonitorAMD = (PFNGLBEGINPERFMONITORAMDPROC) glewGetProcAddress ("glBeginPerfMonitorAMD");
    s_deviceConfig.m_glEndPerfMonitorAMD = (PFNGLENDPERFMONITORAMDPROC) glewGetProcAddress ("glEndPerfMonitorAMD");
    s_deviceConfig.m_glGetPerfMonitorCounterDataAMD = (PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) glewGetProcAddress ("glGetPerfMonitorCounterDataAMD");
  }

  // GL_AMD_sample_positions
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_sample_positions])
  {
    s_deviceConfig.m_glSetMultisamplefvAMD = (PFNGLSETMULTISAMPLEFVAMDPROC) glewGetProcAddress ("glSetMultisamplefvAMD");
  }

  // GL_AMD_sparse_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_sparse_texture])
  {
    s_deviceConfig.m_glTexStorageSparseAMD = (PFNGLTEXSTORAGESPARSEAMDPROC) glewGetProcAddress ("glTexStorageSparseAMD");
    s_deviceConfig.m_glTextureStorageSparseAMD = (PFNGLTEXTURESTORAGESPARSEAMDPROC) glewGetProcAddress ("glTextureStorageSparseAMD");
  }

  // GL_AMD_stencil_operation_extended
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_stencil_operation_extended])
  {
    s_deviceConfig.m_glStencilOpValueAMD = (PFNGLSTENCILOPVALUEAMDPROC) glewGetProcAddress ("glStencilOpValueAMD");
  }

  // GL_AMD_vertex_shader_tessellator
  if (s_deviceConfig.m_featureSupported [GLEW_GL_AMD_vertex_shader_tessellator])
  {
    s_deviceConfig.m_glTessellationFactorAMD = (PFNGLTESSELLATIONFACTORAMDPROC) glewGetProcAddress ("glTessellationFactorAMD");
    s_deviceConfig.m_glTessellationModeAMD = (PFNGLTESSELLATIONMODEAMDPROC) glewGetProcAddress ("glTessellationModeAMD");
  }

  // GL_ANGLE_framebuffer_blit
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_framebuffer_blit])
  {
    s_deviceConfig.m_glBlitFramebufferANGLE = (PFNGLBLITFRAMEBUFFERANGLEPROC) glewGetProcAddress ("glBlitFramebufferANGLE");
  }

  // GL_ANGLE_framebuffer_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_framebuffer_multisample])
  {
    s_deviceConfig.m_glRenderbufferStorageMultisampleANGLE = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC) glewGetProcAddress ("glRenderbufferStorageMultisampleANGLE");
  }

  // GL_ANGLE_instanced_arrays
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_instanced_arrays])
  {
    s_deviceConfig.m_glDrawArraysInstancedANGLE = (PFNGLDRAWARRAYSINSTANCEDANGLEPROC) glewGetProcAddress ("glDrawArraysInstancedANGLE");
    s_deviceConfig.m_glDrawElementsInstancedANGLE = (PFNGLDRAWELEMENTSINSTANCEDANGLEPROC) glewGetProcAddress ("glDrawElementsInstancedANGLE");
    s_deviceConfig.m_glVertexAttribDivisorANGLE = (PFNGLVERTEXATTRIBDIVISORANGLEPROC) glewGetProcAddress ("glVertexAttribDivisorANGLE");
  }

  // GL_ANGLE_translated_shader_source
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ANGLE_translated_shader_source])
  {
    s_deviceConfig.m_glGetTranslatedShaderSourceANGLE = (PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC) glewGetProcAddress ("glGetTranslatedShaderSourceANGLE");
  }

  // GL_APPLE_copy_texture_levels
  if (s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_copy_texture_levels])
  {
    s_deviceConfig.m_glCopyTextureLevelsAPPLE = (PFNGLCOPYTEXTURELEVELSAPPLEPROC) glewGetProcAddress ("glCopyTextureLevelsAPPLE");
  }

  // GL_APPLE_element_array
  if (s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_element_array])
  {
    s_deviceConfig.m_glElementPointerAPPLE = (PFNGLELEMENTPOINTERAPPLEPROC) glewGetProcAddress ("glElementPointerAPPLE");
    s_deviceConfig.m_glDrawElementArrayAPPLE = (PFNGLDRAWELEMENTARRAYAPPLEPROC) glewGetProcAddress ("glDrawElementArrayAPPLE");
    s_deviceConfig.m_glDrawRangeElementArrayAPPLE = (PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) glewGetProcAddress ("glDrawRangeElementArrayAPPLE");
    s_deviceConfig.m_glMultiDrawElementArrayAPPLE = (PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) glewGetProcAddress ("glMultiDrawElementArrayAPPLE");
    s_deviceConfig.m_glMultiDrawRangeElementArrayAPPLE = (PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) glewGetProcAddress ("glMultiDrawRangeElementArrayAPPLE");
  }

  // GL_APPLE_fence
  if (s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_fence])
  {
    s_deviceConfig.m_glGenFencesAPPLE = (PFNGLGENFENCESAPPLEPROC) glewGetProcAddress ("glGenFencesAPPLE");
    s_deviceConfig.m_glDeleteFencesAPPLE = (PFNGLDELETEFENCESAPPLEPROC) glewGetProcAddress ("glDeleteFencesAPPLE");
    s_deviceConfig.m_glSetFenceAPPLE = (PFNGLSETFENCEAPPLEPROC) glewGetProcAddress ("glSetFenceAPPLE");
    s_deviceConfig.m_glIsFenceAPPLE = (PFNGLISFENCEAPPLEPROC) glewGetProcAddress ("glIsFenceAPPLE");
    s_deviceConfig.m_glTestFenceAPPLE = (PFNGLTESTFENCEAPPLEPROC) glewGetProcAddress ("glTestFenceAPPLE");
    s_deviceConfig.m_glFinishFenceAPPLE = (PFNGLFINISHFENCEAPPLEPROC) glewGetProcAddress ("glFinishFenceAPPLE");
    s_deviceConfig.m_glTestObjectAPPLE = (PFNGLTESTOBJECTAPPLEPROC) glewGetProcAddress ("glTestObjectAPPLE");
    s_deviceConfig.m_glFinishObjectAPPLE = (PFNGLFINISHOBJECTAPPLEPROC) glewGetProcAddress ("glFinishObjectAPPLE");
  }

  // GL_APPLE_flush_buffer_range
  if (s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_flush_buffer_range])
  {
    s_deviceConfig.m_glBufferParameteriAPPLE = (PFNGLBUFFERPARAMETERIAPPLEPROC) glewGetProcAddress ("glBufferParameteriAPPLE");
    s_deviceConfig.m_glFlushMappedBufferRangeAPPLE = (PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) glewGetProcAddress ("glFlushMappedBufferRangeAPPLE");
  }

  // GL_APPLE_framebuffer_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_framebuffer_multisample])
  {
    s_deviceConfig.m_glRenderbufferStorageMultisampleAPPLE = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEAPPLEPROC) glewGetProcAddress ("glRenderbufferStorageMultisampleAPPLE");
    s_deviceConfig.m_glResolveMultisampleFramebufferAPPLE = (PFNGLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLEPROC) glewGetProcAddress ("glResolveMultisampleFramebufferAPPLE");
  }

  // GL_APPLE_object_purgeable
  if (s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_object_purgeable])
  {
    s_deviceConfig.m_glObjectPurgeableAPPLE = (PFNGLOBJECTPURGEABLEAPPLEPROC) glewGetProcAddress ("glObjectPurgeableAPPLE");
    s_deviceConfig.m_glObjectUnpurgeableAPPLE = (PFNGLOBJECTUNPURGEABLEAPPLEPROC) glewGetProcAddress ("glObjectUnpurgeableAPPLE");
    s_deviceConfig.m_glGetObjectParameterivAPPLE = (PFNGLGETOBJECTPARAMETERIVAPPLEPROC) glewGetProcAddress ("glGetObjectParameterivAPPLE");
  }

  // GL_APPLE_sync
  if (s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_sync])
  {
    s_deviceConfig.m_glFenceSyncAPPLE = (PFNGLFENCESYNCAPPLEPROC) glewGetProcAddress ("glFenceSyncAPPLE");
    s_deviceConfig.m_glIsSyncAPPLE = (PFNGLISSYNCAPPLEPROC) glewGetProcAddress ("glIsSyncAPPLE");
    s_deviceConfig.m_glDeleteSyncAPPLE = (PFNGLDELETESYNCAPPLEPROC) glewGetProcAddress ("glDeleteSyncAPPLE");
    s_deviceConfig.m_glClientWaitSyncAPPLE = (PFNGLCLIENTWAITSYNCAPPLEPROC) glewGetProcAddress ("glClientWaitSyncAPPLE");
    s_deviceConfig.m_glWaitSyncAPPLE = (PFNGLWAITSYNCAPPLEPROC) glewGetProcAddress ("glWaitSyncAPPLE");
    s_deviceConfig.m_glGetInteger64vAPPLE = (PFNGLGETINTEGER64VAPPLEPROC) glewGetProcAddress ("glGetInteger64vAPPLE");
    s_deviceConfig.m_glGetSyncivAPPLE = (PFNGLGETSYNCIVAPPLEPROC) glewGetProcAddress ("glGetSyncivAPPLE");
  }

  // GL_APPLE_texture_range
  if (s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_texture_range])
  {
    s_deviceConfig.m_glTextureRangeAPPLE = (PFNGLTEXTURERANGEAPPLEPROC) glewGetProcAddress ("glTextureRangeAPPLE");
    s_deviceConfig.m_glGetTexParameterPointervAPPLE = (PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) glewGetProcAddress ("glGetTexParameterPointervAPPLE");
  }

  // GL_APPLE_vertex_array_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_object])
  {
    s_deviceConfig.m_glBindVertexArrayAPPLE = (PFNGLBINDVERTEXARRAYAPPLEPROC) glewGetProcAddress ("glBindVertexArrayAPPLE");
    s_deviceConfig.m_glDeleteVertexArraysAPPLE = (PFNGLDELETEVERTEXARRAYSAPPLEPROC) glewGetProcAddress ("glDeleteVertexArraysAPPLE");
    s_deviceConfig.m_glGenVertexArraysAPPLE = (PFNGLGENVERTEXARRAYSAPPLEPROC) glewGetProcAddress ("glGenVertexArraysAPPLE");
    s_deviceConfig.m_glIsVertexArrayAPPLE = (PFNGLISVERTEXARRAYAPPLEPROC) glewGetProcAddress ("glIsVertexArrayAPPLE");
  }

  // GL_APPLE_vertex_array_range
  if (s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_vertex_array_range])
  {
    s_deviceConfig.m_glVertexArrayRangeAPPLE = (PFNGLVERTEXARRAYRANGEAPPLEPROC) glewGetProcAddress ("glVertexArrayRangeAPPLE");
    s_deviceConfig.m_glFlushVertexArrayRangeAPPLE = (PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) glewGetProcAddress ("glFlushVertexArrayRangeAPPLE");
    s_deviceConfig.m_glVertexArrayParameteriAPPLE = (PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) glewGetProcAddress ("glVertexArrayParameteriAPPLE");
  }

  // GL_APPLE_vertex_program_evaluators
  if (s_deviceConfig.m_featureSupported [GLEW_GL_APPLE_vertex_program_evaluators])
  {
    s_deviceConfig.m_glEnableVertexAttribAPPLE = (PFNGLENABLEVERTEXATTRIBAPPLEPROC) glewGetProcAddress ("glEnableVertexAttribAPPLE");
    s_deviceConfig.m_glDisableVertexAttribAPPLE = (PFNGLDISABLEVERTEXATTRIBAPPLEPROC) glewGetProcAddress ("glDisableVertexAttribAPPLE");
    s_deviceConfig.m_glIsVertexAttribEnabledAPPLE = (PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) glewGetProcAddress ("glIsVertexAttribEnabledAPPLE");
    s_deviceConfig.m_glMapVertexAttrib1dAPPLE = (PFNGLMAPVERTEXATTRIB1DAPPLEPROC) glewGetProcAddress ("glMapVertexAttrib1dAPPLE");
    s_deviceConfig.m_glMapVertexAttrib1fAPPLE = (PFNGLMAPVERTEXATTRIB1FAPPLEPROC) glewGetProcAddress ("glMapVertexAttrib1fAPPLE");
    s_deviceConfig.m_glMapVertexAttrib2dAPPLE = (PFNGLMAPVERTEXATTRIB2DAPPLEPROC) glewGetProcAddress ("glMapVertexAttrib2dAPPLE");
    s_deviceConfig.m_glMapVertexAttrib2fAPPLE = (PFNGLMAPVERTEXATTRIB2FAPPLEPROC) glewGetProcAddress ("glMapVertexAttrib2fAPPLE");
  }

  // GL_ARB_ES2_compatibility
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_ES2_compatibility])
  {
    s_deviceConfig.m_glReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC) glewGetProcAddress ("glReleaseShaderCompiler");
    s_deviceConfig.m_glShaderBinary = (PFNGLSHADERBINARYPROC) glewGetProcAddress ("glShaderBinary");
    s_deviceConfig.m_glGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC) glewGetProcAddress ("glGetShaderPrecisionFormat");
    s_deviceConfig.m_glDepthRangef = (PFNGLDEPTHRANGEFPROC) glewGetProcAddress ("glDepthRangef");
    s_deviceConfig.m_glClearDepthf = (PFNGLCLEARDEPTHFPROC) glewGetProcAddress ("glClearDepthf");
  }

  // GL_ARB_ES3_1_compatibility
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_ES3_1_compatibility])
  {
    s_deviceConfig.m_glMemoryBarrierByRegion = (PFNGLMEMORYBARRIERBYREGIONPROC) glewGetProcAddress ("glMemoryBarrierByRegion");
  }

  // GL_ARB_ES3_2_compatibility
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_ES3_2_compatibility])
  {
    s_deviceConfig.m_glPrimitiveBoundingBoxARB = (PFNGLPRIMITIVEBOUNDINGBOXARBPROC) glewGetProcAddress ("glPrimitiveBoundingBoxARB");
  }

  // GL_ARB_base_instance
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_base_instance])
  {
    s_deviceConfig.m_glDrawArraysInstancedBaseInstance = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) glewGetProcAddress ("glDrawArraysInstancedBaseInstance");
    s_deviceConfig.m_glDrawElementsInstancedBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) glewGetProcAddress ("glDrawElementsInstancedBaseInstance");
    s_deviceConfig.m_glDrawElementsInstancedBaseVertexBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) glewGetProcAddress ("glDrawElementsInstancedBaseVertexBaseInstance");
  }

  // GL_ARB_bindless_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_bindless_texture])
  {
    s_deviceConfig.m_glGetTextureHandleARB = (PFNGLGETTEXTUREHANDLEARBPROC) glewGetProcAddress ("glGetTextureHandleARB");
    s_deviceConfig.m_glGetTextureSamplerHandleARB = (PFNGLGETTEXTURESAMPLERHANDLEARBPROC) glewGetProcAddress ("glGetTextureSamplerHandleARB");
    s_deviceConfig.m_glMakeTextureHandleResidentARB = (PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) glewGetProcAddress ("glMakeTextureHandleResidentARB");
    s_deviceConfig.m_glMakeTextureHandleNonResidentARB = (PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) glewGetProcAddress ("glMakeTextureHandleNonResidentARB");
    s_deviceConfig.m_glGetImageHandleARB = (PFNGLGETIMAGEHANDLEARBPROC) glewGetProcAddress ("glGetImageHandleARB");
    s_deviceConfig.m_glMakeImageHandleResidentARB = (PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) glewGetProcAddress ("glMakeImageHandleResidentARB");
    s_deviceConfig.m_glMakeImageHandleNonResidentARB = (PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) glewGetProcAddress ("glMakeImageHandleNonResidentARB");
    s_deviceConfig.m_glUniformHandleui64ARB = (PFNGLUNIFORMHANDLEUI64ARBPROC) glewGetProcAddress ("glUniformHandleui64ARB");
    s_deviceConfig.m_glUniformHandleui64vARB = (PFNGLUNIFORMHANDLEUI64VARBPROC) glewGetProcAddress ("glUniformHandleui64vARB");
    s_deviceConfig.m_glProgramUniformHandleui64ARB = (PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) glewGetProcAddress ("glProgramUniformHandleui64ARB");
    s_deviceConfig.m_glProgramUniformHandleui64vARB = (PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) glewGetProcAddress ("glProgramUniformHandleui64vARB");
    s_deviceConfig.m_glIsTextureHandleResidentARB = (PFNGLISTEXTUREHANDLERESIDENTARBPROC) glewGetProcAddress ("glIsTextureHandleResidentARB");
    s_deviceConfig.m_glIsImageHandleResidentARB = (PFNGLISIMAGEHANDLERESIDENTARBPROC) glewGetProcAddress ("glIsImageHandleResidentARB");
    s_deviceConfig.m_glVertexAttribL1ui64ARB = (PFNGLVERTEXATTRIBL1UI64ARBPROC) glewGetProcAddress ("glVertexAttribL1ui64ARB");
    s_deviceConfig.m_glVertexAttribL1ui64vARB = (PFNGLVERTEXATTRIBL1UI64VARBPROC) glewGetProcAddress ("glVertexAttribL1ui64vARB");
    s_deviceConfig.m_glGetVertexAttribLui64vARB = (PFNGLGETVERTEXATTRIBLUI64VARBPROC) glewGetProcAddress ("glGetVertexAttribLui64vARB");
  }

  // GL_ARB_blend_func_extended
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_blend_func_extended])
  {
    s_deviceConfig.m_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) glewGetProcAddress ("glBindFragDataLocationIndexed");
    s_deviceConfig.m_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC) glewGetProcAddress ("glGetFragDataIndex");
  }

  // GL_ARB_buffer_storage
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_buffer_storage])
  {
    s_deviceConfig.m_glBufferStorage = (PFNGLBUFFERSTORAGEPROC) glewGetProcAddress ("glBufferStorage");
  }

  // GL_ARB_cl_event
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_cl_event])
  {
    s_deviceConfig.m_glCreateSyncFromCLeventARB = (PFNGLCREATESYNCFROMCLEVENTARBPROC) glewGetProcAddress ("glCreateSyncFromCLeventARB");
  }

  // GL_ARB_clear_buffer_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_clear_buffer_object])
  {
    s_deviceConfig.m_glClearBufferData = (PFNGLCLEARBUFFERDATAPROC) glewGetProcAddress ("glClearBufferData");
    s_deviceConfig.m_glClearBufferSubData = (PFNGLCLEARBUFFERSUBDATAPROC) glewGetProcAddress ("glClearBufferSubData");
  }

  // GL_ARB_clear_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_clear_texture])
  {
    s_deviceConfig.m_glClearTexImage = (PFNGLCLEARTEXIMAGEPROC) glewGetProcAddress ("glClearTexImage");
    s_deviceConfig.m_glClearTexSubImage = (PFNGLCLEARTEXSUBIMAGEPROC) glewGetProcAddress ("glClearTexSubImage");
  }

  // GL_ARB_clip_control
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_clip_control])
  {
    s_deviceConfig.m_glClipControl = (PFNGLCLIPCONTROLPROC) glewGetProcAddress ("glClipControl");
  }

  // GL_ARB_color_buffer_float
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_color_buffer_float])
  {
    s_deviceConfig.m_glClampColorARB = (PFNGLCLAMPCOLORARBPROC) glewGetProcAddress ("glClampColorARB");
  }

  // GL_ARB_compute_shader
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_compute_shader])
  {
    s_deviceConfig.m_glDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC) glewGetProcAddress ("glDispatchCompute");
    s_deviceConfig.m_glDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC) glewGetProcAddress ("glDispatchComputeIndirect");
  }

  // GL_ARB_compute_variable_group_size
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_compute_variable_group_size])
  {
    s_deviceConfig.m_glDispatchComputeGroupSizeARB = (PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) glewGetProcAddress ("glDispatchComputeGroupSizeARB");
  }

  // GL_ARB_copy_buffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_copy_buffer])
  {
    s_deviceConfig.m_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC) glewGetProcAddress ("glCopyBufferSubData");
  }

  // GL_ARB_copy_image
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_copy_image])
  {
    s_deviceConfig.m_glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC) glewGetProcAddress ("glCopyImageSubData");
  }

  // GL_ARB_debug_output
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_debug_output])
  {
    s_deviceConfig.m_glDebugMessageControlARB = (PFNGLDEBUGMESSAGECONTROLARBPROC) glewGetProcAddress ("glDebugMessageControlARB");
    s_deviceConfig.m_glDebugMessageInsertARB = (PFNGLDEBUGMESSAGEINSERTARBPROC) glewGetProcAddress ("glDebugMessageInsertARB");
    s_deviceConfig.m_glDebugMessageCallbackARB = (PFNGLDEBUGMESSAGECALLBACKARBPROC) glewGetProcAddress ("glDebugMessageCallbackARB");
    s_deviceConfig.m_glGetDebugMessageLogARB = (PFNGLGETDEBUGMESSAGELOGARBPROC) glewGetProcAddress ("glGetDebugMessageLogARB");
  }

  // GL_ARB_direct_state_access
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_direct_state_access])
  {
    s_deviceConfig.m_glCreateTransformFeedbacks = (PFNGLCREATETRANSFORMFEEDBACKSPROC) glewGetProcAddress ("glCreateTransformFeedbacks");
    s_deviceConfig.m_glTransformFeedbackBufferBase = (PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) glewGetProcAddress ("glTransformFeedbackBufferBase");
    s_deviceConfig.m_glTransformFeedbackBufferRange = (PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) glewGetProcAddress ("glTransformFeedbackBufferRange");
    s_deviceConfig.m_glGetTransformFeedbackiv = (PFNGLGETTRANSFORMFEEDBACKIVPROC) glewGetProcAddress ("glGetTransformFeedbackiv");
    s_deviceConfig.m_glGetTransformFeedbacki_v = (PFNGLGETTRANSFORMFEEDBACKI_VPROC) glewGetProcAddress ("glGetTransformFeedbacki_v");
    s_deviceConfig.m_glGetTransformFeedbacki64_v = (PFNGLGETTRANSFORMFEEDBACKI64_VPROC) glewGetProcAddress ("glGetTransformFeedbacki64_v");
    s_deviceConfig.m_glCreateBuffers = (PFNGLCREATEBUFFERSPROC) glewGetProcAddress ("glCreateBuffers");
    s_deviceConfig.m_glNamedBufferStorage = (PFNGLNAMEDBUFFERSTORAGEPROC) glewGetProcAddress ("glNamedBufferStorage");
    s_deviceConfig.m_glNamedBufferData = (PFNGLNAMEDBUFFERDATAPROC) glewGetProcAddress ("glNamedBufferData");
    s_deviceConfig.m_glNamedBufferSubData = (PFNGLNAMEDBUFFERSUBDATAPROC) glewGetProcAddress ("glNamedBufferSubData");
    s_deviceConfig.m_glCopyNamedBufferSubData = (PFNGLCOPYNAMEDBUFFERSUBDATAPROC) glewGetProcAddress ("glCopyNamedBufferSubData");
    s_deviceConfig.m_glClearNamedBufferData = (PFNGLCLEARNAMEDBUFFERDATAPROC) glewGetProcAddress ("glClearNamedBufferData");
    s_deviceConfig.m_glClearNamedBufferSubData = (PFNGLCLEARNAMEDBUFFERSUBDATAPROC) glewGetProcAddress ("glClearNamedBufferSubData");
    s_deviceConfig.m_glMapNamedBuffer = (PFNGLMAPNAMEDBUFFERPROC) glewGetProcAddress ("glMapNamedBuffer");
    s_deviceConfig.m_glMapNamedBufferRange = (PFNGLMAPNAMEDBUFFERRANGEPROC) glewGetProcAddress ("glMapNamedBufferRange");
    s_deviceConfig.m_glUnmapNamedBuffer = (PFNGLUNMAPNAMEDBUFFERPROC) glewGetProcAddress ("glUnmapNamedBuffer");
    s_deviceConfig.m_glFlushMappedNamedBufferRange = (PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) glewGetProcAddress ("glFlushMappedNamedBufferRange");
    s_deviceConfig.m_glGetNamedBufferParameteriv = (PFNGLGETNAMEDBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetNamedBufferParameteriv");
    s_deviceConfig.m_glGetNamedBufferParameteri64v = (PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) glewGetProcAddress ("glGetNamedBufferParameteri64v");
    s_deviceConfig.m_glGetNamedBufferPointerv = (PFNGLGETNAMEDBUFFERPOINTERVPROC) glewGetProcAddress ("glGetNamedBufferPointerv");
    s_deviceConfig.m_glGetNamedBufferSubData = (PFNGLGETNAMEDBUFFERSUBDATAPROC) glewGetProcAddress ("glGetNamedBufferSubData");
    s_deviceConfig.m_glCreateFramebuffers = (PFNGLCREATEFRAMEBUFFERSPROC) glewGetProcAddress ("glCreateFramebuffers");
    s_deviceConfig.m_glNamedFramebufferRenderbuffer = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) glewGetProcAddress ("glNamedFramebufferRenderbuffer");
    s_deviceConfig.m_glNamedFramebufferParameteri = (PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) glewGetProcAddress ("glNamedFramebufferParameteri");
    s_deviceConfig.m_glNamedFramebufferTexture = (PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) glewGetProcAddress ("glNamedFramebufferTexture");
    s_deviceConfig.m_glNamedFramebufferTextureLayer = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) glewGetProcAddress ("glNamedFramebufferTextureLayer");
    s_deviceConfig.m_glNamedFramebufferDrawBuffer = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) glewGetProcAddress ("glNamedFramebufferDrawBuffer");
    s_deviceConfig.m_glNamedFramebufferDrawBuffers = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) glewGetProcAddress ("glNamedFramebufferDrawBuffers");
    s_deviceConfig.m_glNamedFramebufferReadBuffer = (PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) glewGetProcAddress ("glNamedFramebufferReadBuffer");
    s_deviceConfig.m_glInvalidateNamedFramebufferData = (PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) glewGetProcAddress ("glInvalidateNamedFramebufferData");
    s_deviceConfig.m_glInvalidateNamedFramebufferSubData = (PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) glewGetProcAddress ("glInvalidateNamedFramebufferSubData");
    s_deviceConfig.m_glClearNamedFramebufferiv = (PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) glewGetProcAddress ("glClearNamedFramebufferiv");
    s_deviceConfig.m_glClearNamedFramebufferuiv = (PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) glewGetProcAddress ("glClearNamedFramebufferuiv");
    s_deviceConfig.m_glClearNamedFramebufferfv = (PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) glewGetProcAddress ("glClearNamedFramebufferfv");
    s_deviceConfig.m_glClearNamedFramebufferfi = (PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) glewGetProcAddress ("glClearNamedFramebufferfi");
    s_deviceConfig.m_glBlitNamedFramebuffer = (PFNGLBLITNAMEDFRAMEBUFFERPROC) glewGetProcAddress ("glBlitNamedFramebuffer");
    s_deviceConfig.m_glCheckNamedFramebufferStatus = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) glewGetProcAddress ("glCheckNamedFramebufferStatus");
    s_deviceConfig.m_glGetNamedFramebufferParameteriv = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetNamedFramebufferParameteriv");
    s_deviceConfig.m_glGetNamedFramebufferAttachmentParameteriv = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) glewGetProcAddress ("glGetNamedFramebufferAttachmentParameteriv");
    s_deviceConfig.m_glCreateRenderbuffers = (PFNGLCREATERENDERBUFFERSPROC) glewGetProcAddress ("glCreateRenderbuffers");
    s_deviceConfig.m_glNamedRenderbufferStorage = (PFNGLNAMEDRENDERBUFFERSTORAGEPROC) glewGetProcAddress ("glNamedRenderbufferStorage");
    s_deviceConfig.m_glNamedRenderbufferStorageMultisample = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) glewGetProcAddress ("glNamedRenderbufferStorageMultisample");
    s_deviceConfig.m_glGetNamedRenderbufferParameteriv = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetNamedRenderbufferParameteriv");
    s_deviceConfig.m_glCreateTextures = (PFNGLCREATETEXTURESPROC) glewGetProcAddress ("glCreateTextures");
    s_deviceConfig.m_glTextureBuffer = (PFNGLTEXTUREBUFFERPROC) glewGetProcAddress ("glTextureBuffer");
    s_deviceConfig.m_glTextureBufferRange = (PFNGLTEXTUREBUFFERRANGEPROC) glewGetProcAddress ("glTextureBufferRange");
    s_deviceConfig.m_glTextureStorage1D = (PFNGLTEXTURESTORAGE1DPROC) glewGetProcAddress ("glTextureStorage1D");
    s_deviceConfig.m_glTextureStorage2D = (PFNGLTEXTURESTORAGE2DPROC) glewGetProcAddress ("glTextureStorage2D");
    s_deviceConfig.m_glTextureStorage3D = (PFNGLTEXTURESTORAGE3DPROC) glewGetProcAddress ("glTextureStorage3D");
    s_deviceConfig.m_glTextureStorage2DMultisample = (PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) glewGetProcAddress ("glTextureStorage2DMultisample");
    s_deviceConfig.m_glTextureStorage3DMultisample = (PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) glewGetProcAddress ("glTextureStorage3DMultisample");
    s_deviceConfig.m_glTextureSubImage1D = (PFNGLTEXTURESUBIMAGE1DPROC) glewGetProcAddress ("glTextureSubImage1D");
    s_deviceConfig.m_glTextureSubImage2D = (PFNGLTEXTURESUBIMAGE2DPROC) glewGetProcAddress ("glTextureSubImage2D");
    s_deviceConfig.m_glTextureSubImage3D = (PFNGLTEXTURESUBIMAGE3DPROC) glewGetProcAddress ("glTextureSubImage3D");
    s_deviceConfig.m_glCompressedTextureSubImage1D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) glewGetProcAddress ("glCompressedTextureSubImage1D");
    s_deviceConfig.m_glCompressedTextureSubImage2D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) glewGetProcAddress ("glCompressedTextureSubImage2D");
    s_deviceConfig.m_glCompressedTextureSubImage3D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) glewGetProcAddress ("glCompressedTextureSubImage3D");
    s_deviceConfig.m_glCopyTextureSubImage1D = (PFNGLCOPYTEXTURESUBIMAGE1DPROC) glewGetProcAddress ("glCopyTextureSubImage1D");
    s_deviceConfig.m_glCopyTextureSubImage2D = (PFNGLCOPYTEXTURESUBIMAGE2DPROC) glewGetProcAddress ("glCopyTextureSubImage2D");
    s_deviceConfig.m_glCopyTextureSubImage3D = (PFNGLCOPYTEXTURESUBIMAGE3DPROC) glewGetProcAddress ("glCopyTextureSubImage3D");
    s_deviceConfig.m_glTextureParameterf = (PFNGLTEXTUREPARAMETERFPROC) glewGetProcAddress ("glTextureParameterf");
    s_deviceConfig.m_glTextureParameterfv = (PFNGLTEXTUREPARAMETERFVPROC) glewGetProcAddress ("glTextureParameterfv");
    s_deviceConfig.m_glTextureParameteri = (PFNGLTEXTUREPARAMETERIPROC) glewGetProcAddress ("glTextureParameteri");
    s_deviceConfig.m_glTextureParameterIiv = (PFNGLTEXTUREPARAMETERIIVPROC) glewGetProcAddress ("glTextureParameterIiv");
    s_deviceConfig.m_glTextureParameterIuiv = (PFNGLTEXTUREPARAMETERIUIVPROC) glewGetProcAddress ("glTextureParameterIuiv");
    s_deviceConfig.m_glTextureParameteriv = (PFNGLTEXTUREPARAMETERIVPROC) glewGetProcAddress ("glTextureParameteriv");
    s_deviceConfig.m_glGenerateTextureMipmap = (PFNGLGENERATETEXTUREMIPMAPPROC) glewGetProcAddress ("glGenerateTextureMipmap");
    s_deviceConfig.m_glBindTextureUnit = (PFNGLBINDTEXTUREUNITPROC) glewGetProcAddress ("glBindTextureUnit");
    s_deviceConfig.m_glGetTextureImage = (PFNGLGETTEXTUREIMAGEPROC) glewGetProcAddress ("glGetTextureImage");
    s_deviceConfig.m_glGetCompressedTextureImage = (PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) glewGetProcAddress ("glGetCompressedTextureImage");
    s_deviceConfig.m_glGetTextureLevelParameterfv = (PFNGLGETTEXTURELEVELPARAMETERFVPROC) glewGetProcAddress ("glGetTextureLevelParameterfv");
    s_deviceConfig.m_glGetTextureLevelParameteriv = (PFNGLGETTEXTURELEVELPARAMETERIVPROC) glewGetProcAddress ("glGetTextureLevelParameteriv");
    s_deviceConfig.m_glGetTextureParameterfv = (PFNGLGETTEXTUREPARAMETERFVPROC) glewGetProcAddress ("glGetTextureParameterfv");
    s_deviceConfig.m_glGetTextureParameterIiv = (PFNGLGETTEXTUREPARAMETERIIVPROC) glewGetProcAddress ("glGetTextureParameterIiv");
    s_deviceConfig.m_glGetTextureParameterIuiv = (PFNGLGETTEXTUREPARAMETERIUIVPROC) glewGetProcAddress ("glGetTextureParameterIuiv");
    s_deviceConfig.m_glGetTextureParameteriv = (PFNGLGETTEXTUREPARAMETERIVPROC) glewGetProcAddress ("glGetTextureParameteriv");
    s_deviceConfig.m_glCreateVertexArrays = (PFNGLCREATEVERTEXARRAYSPROC) glewGetProcAddress ("glCreateVertexArrays");
    s_deviceConfig.m_glDisableVertexArrayAttrib = (PFNGLDISABLEVERTEXARRAYATTRIBPROC) glewGetProcAddress ("glDisableVertexArrayAttrib");
    s_deviceConfig.m_glEnableVertexArrayAttrib = (PFNGLENABLEVERTEXARRAYATTRIBPROC) glewGetProcAddress ("glEnableVertexArrayAttrib");
    s_deviceConfig.m_glVertexArrayElementBuffer = (PFNGLVERTEXARRAYELEMENTBUFFERPROC) glewGetProcAddress ("glVertexArrayElementBuffer");
    s_deviceConfig.m_glVertexArrayVertexBuffer = (PFNGLVERTEXARRAYVERTEXBUFFERPROC) glewGetProcAddress ("glVertexArrayVertexBuffer");
    s_deviceConfig.m_glVertexArrayVertexBuffers = (PFNGLVERTEXARRAYVERTEXBUFFERSPROC) glewGetProcAddress ("glVertexArrayVertexBuffers");
    s_deviceConfig.m_glVertexArrayAttribBinding = (PFNGLVERTEXARRAYATTRIBBINDINGPROC) glewGetProcAddress ("glVertexArrayAttribBinding");
    s_deviceConfig.m_glVertexArrayAttribFormat = (PFNGLVERTEXARRAYATTRIBFORMATPROC) glewGetProcAddress ("glVertexArrayAttribFormat");
    s_deviceConfig.m_glVertexArrayAttribIFormat = (PFNGLVERTEXARRAYATTRIBIFORMATPROC) glewGetProcAddress ("glVertexArrayAttribIFormat");
    s_deviceConfig.m_glVertexArrayAttribLFormat = (PFNGLVERTEXARRAYATTRIBLFORMATPROC) glewGetProcAddress ("glVertexArrayAttribLFormat");
    s_deviceConfig.m_glVertexArrayBindingDivisor = (PFNGLVERTEXARRAYBINDINGDIVISORPROC) glewGetProcAddress ("glVertexArrayBindingDivisor");
    s_deviceConfig.m_glGetVertexArrayiv = (PFNGLGETVERTEXARRAYIVPROC) glewGetProcAddress ("glGetVertexArrayiv");
    s_deviceConfig.m_glGetVertexArrayIndexediv = (PFNGLGETVERTEXARRAYINDEXEDIVPROC) glewGetProcAddress ("glGetVertexArrayIndexediv");
    s_deviceConfig.m_glGetVertexArrayIndexed64iv = (PFNGLGETVERTEXARRAYINDEXED64IVPROC) glewGetProcAddress ("glGetVertexArrayIndexed64iv");
    s_deviceConfig.m_glCreateSamplers = (PFNGLCREATESAMPLERSPROC) glewGetProcAddress ("glCreateSamplers");
    s_deviceConfig.m_glCreateProgramPipelines = (PFNGLCREATEPROGRAMPIPELINESPROC) glewGetProcAddress ("glCreateProgramPipelines");
    s_deviceConfig.m_glCreateQueries = (PFNGLCREATEQUERIESPROC) glewGetProcAddress ("glCreateQueries");
    s_deviceConfig.m_glGetQueryBufferObjecti64v = (PFNGLGETQUERYBUFFEROBJECTI64VPROC) glewGetProcAddress ("glGetQueryBufferObjecti64v");
    s_deviceConfig.m_glGetQueryBufferObjectiv = (PFNGLGETQUERYBUFFEROBJECTIVPROC) glewGetProcAddress ("glGetQueryBufferObjectiv");
    s_deviceConfig.m_glGetQueryBufferObjectui64v = (PFNGLGETQUERYBUFFEROBJECTUI64VPROC) glewGetProcAddress ("glGetQueryBufferObjectui64v");
    s_deviceConfig.m_glGetQueryBufferObjectuiv = (PFNGLGETQUERYBUFFEROBJECTUIVPROC) glewGetProcAddress ("glGetQueryBufferObjectuiv");
  }

  // GL_ARB_draw_buffers
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_draw_buffers])
  {
    s_deviceConfig.m_glDrawBuffersARB = (PFNGLDRAWBUFFERSARBPROC) glewGetProcAddress ("glDrawBuffersARB");
  }

  // GL_ARB_draw_buffers_blend
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_draw_buffers_blend])
  {
    s_deviceConfig.m_glBlendEquationiARB = (PFNGLBLENDEQUATIONIARBPROC) glewGetProcAddress ("glBlendEquationiARB");
    s_deviceConfig.m_glBlendEquationSeparateiARB = (PFNGLBLENDEQUATIONSEPARATEIARBPROC) glewGetProcAddress ("glBlendEquationSeparateiARB");
    s_deviceConfig.m_glBlendFunciARB = (PFNGLBLENDFUNCIARBPROC) glewGetProcAddress ("glBlendFunciARB");
    s_deviceConfig.m_glBlendFuncSeparateiARB = (PFNGLBLENDFUNCSEPARATEIARBPROC) glewGetProcAddress ("glBlendFuncSeparateiARB");
  }

  // GL_ARB_draw_elements_base_vertex
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_draw_elements_base_vertex])
  {
    s_deviceConfig.m_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC) glewGetProcAddress ("glDrawElementsBaseVertex");
    s_deviceConfig.m_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) glewGetProcAddress ("glDrawRangeElementsBaseVertex");
    s_deviceConfig.m_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) glewGetProcAddress ("glDrawElementsInstancedBaseVertex");
    s_deviceConfig.m_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) glewGetProcAddress ("glMultiDrawElementsBaseVertex");
  }

  // GL_ARB_draw_indirect
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_draw_indirect])
  {
    s_deviceConfig.m_glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC) glewGetProcAddress ("glDrawArraysIndirect");
    s_deviceConfig.m_glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC) glewGetProcAddress ("glDrawElementsIndirect");
  }

  // GL_ARB_draw_instanced
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_draw_instanced])
  {
    s_deviceConfig.m_glDrawArraysInstancedARB = (PFNGLDRAWARRAYSINSTANCEDARBPROC) glewGetProcAddress ("glDrawArraysInstancedARB");
    s_deviceConfig.m_glDrawElementsInstancedARB = (PFNGLDRAWELEMENTSINSTANCEDARBPROC) glewGetProcAddress ("glDrawElementsInstancedARB");
  }

  // GL_ARB_fragment_program
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_fragment_program])
  {
    s_deviceConfig.m_glProgramStringARB = (PFNGLPROGRAMSTRINGARBPROC) glewGetProcAddress ("glProgramStringARB");
    s_deviceConfig.m_glBindProgramARB = (PFNGLBINDPROGRAMARBPROC) glewGetProcAddress ("glBindProgramARB");
    s_deviceConfig.m_glDeleteProgramsARB = (PFNGLDELETEPROGRAMSARBPROC) glewGetProcAddress ("glDeleteProgramsARB");
    s_deviceConfig.m_glGenProgramsARB = (PFNGLGENPROGRAMSARBPROC) glewGetProcAddress ("glGenProgramsARB");
    s_deviceConfig.m_glProgramEnvParameter4dARB = (PFNGLPROGRAMENVPARAMETER4DARBPROC) glewGetProcAddress ("glProgramEnvParameter4dARB");
    s_deviceConfig.m_glProgramEnvParameter4dvARB = (PFNGLPROGRAMENVPARAMETER4DVARBPROC) glewGetProcAddress ("glProgramEnvParameter4dvARB");
    s_deviceConfig.m_glProgramEnvParameter4fARB = (PFNGLPROGRAMENVPARAMETER4FARBPROC) glewGetProcAddress ("glProgramEnvParameter4fARB");
    s_deviceConfig.m_glProgramEnvParameter4fvARB = (PFNGLPROGRAMENVPARAMETER4FVARBPROC) glewGetProcAddress ("glProgramEnvParameter4fvARB");
    s_deviceConfig.m_glProgramLocalParameter4dARB = (PFNGLPROGRAMLOCALPARAMETER4DARBPROC) glewGetProcAddress ("glProgramLocalParameter4dARB");
    s_deviceConfig.m_glProgramLocalParameter4dvARB = (PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) glewGetProcAddress ("glProgramLocalParameter4dvARB");
    s_deviceConfig.m_glProgramLocalParameter4fARB = (PFNGLPROGRAMLOCALPARAMETER4FARBPROC) glewGetProcAddress ("glProgramLocalParameter4fARB");
    s_deviceConfig.m_glProgramLocalParameter4fvARB = (PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) glewGetProcAddress ("glProgramLocalParameter4fvARB");
    s_deviceConfig.m_glGetProgramEnvParameterdvARB = (PFNGLGETPROGRAMENVPARAMETERDVARBPROC) glewGetProcAddress ("glGetProgramEnvParameterdvARB");
    s_deviceConfig.m_glGetProgramEnvParameterfvARB = (PFNGLGETPROGRAMENVPARAMETERFVARBPROC) glewGetProcAddress ("glGetProgramEnvParameterfvARB");
    s_deviceConfig.m_glGetProgramLocalParameterdvARB = (PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) glewGetProcAddress ("glGetProgramLocalParameterdvARB");
    s_deviceConfig.m_glGetProgramLocalParameterfvARB = (PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) glewGetProcAddress ("glGetProgramLocalParameterfvARB");
    s_deviceConfig.m_glGetProgramivARB = (PFNGLGETPROGRAMIVARBPROC) glewGetProcAddress ("glGetProgramivARB");
    s_deviceConfig.m_glGetProgramStringARB = (PFNGLGETPROGRAMSTRINGARBPROC) glewGetProcAddress ("glGetProgramStringARB");
    s_deviceConfig.m_glIsProgramARB = (PFNGLISPROGRAMARBPROC) glewGetProcAddress ("glIsProgramARB");
  }

  // GL_ARB_framebuffer_no_attachments
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_no_attachments])
  {
    s_deviceConfig.m_glFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC) glewGetProcAddress ("glFramebufferParameteri");
    s_deviceConfig.m_glGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetFramebufferParameteriv");
  }

  // GL_ARB_framebuffer_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_framebuffer_object])
  {
    s_deviceConfig.m_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC) glewGetProcAddress ("glIsRenderbuffer");
    s_deviceConfig.m_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC) glewGetProcAddress ("glBindRenderbuffer");
    s_deviceConfig.m_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC) glewGetProcAddress ("glDeleteRenderbuffers");
    s_deviceConfig.m_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC) glewGetProcAddress ("glGenRenderbuffers");
    s_deviceConfig.m_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC) glewGetProcAddress ("glRenderbufferStorage");
    s_deviceConfig.m_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC) glewGetProcAddress ("glGetRenderbufferParameteriv");
    s_deviceConfig.m_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC) glewGetProcAddress ("glIsFramebuffer");
    s_deviceConfig.m_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC) glewGetProcAddress ("glBindFramebuffer");
    s_deviceConfig.m_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC) glewGetProcAddress ("glDeleteFramebuffers");
    s_deviceConfig.m_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC) glewGetProcAddress ("glGenFramebuffers");
    s_deviceConfig.m_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC) glewGetProcAddress ("glCheckFramebufferStatus");
    s_deviceConfig.m_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC) glewGetProcAddress ("glFramebufferTexture1D");
    s_deviceConfig.m_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC) glewGetProcAddress ("glFramebufferTexture2D");
    s_deviceConfig.m_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC) glewGetProcAddress ("glFramebufferTexture3D");
    s_deviceConfig.m_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC) glewGetProcAddress ("glFramebufferRenderbuffer");
    s_deviceConfig.m_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) glewGetProcAddress ("glGetFramebufferAttachmentParameteriv");
    s_deviceConfig.m_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC) glewGetProcAddress ("glGenerateMipmap");
    s_deviceConfig.m_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC) glewGetProcAddress ("glBlitFramebuffer");
    s_deviceConfig.m_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) glewGetProcAddress ("glRenderbufferStorageMultisample");
    s_deviceConfig.m_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC) glewGetProcAddress ("glFramebufferTextureLayer");
  }

  // GL_ARB_geometry_shader4
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_geometry_shader4])
  {
    s_deviceConfig.m_glProgramParameteriARB = (PFNGLPROGRAMPARAMETERIARBPROC) glewGetProcAddress ("glProgramParameteriARB");
    s_deviceConfig.m_glFramebufferTextureARB = (PFNGLFRAMEBUFFERTEXTUREARBPROC) glewGetProcAddress ("glFramebufferTextureARB");
    s_deviceConfig.m_glFramebufferTextureLayerARB = (PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) glewGetProcAddress ("glFramebufferTextureLayerARB");
    s_deviceConfig.m_glFramebufferTextureFaceARB = (PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) glewGetProcAddress ("glFramebufferTextureFaceARB");
  }

  // GL_ARB_get_program_binary
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_get_program_binary])
  {
    s_deviceConfig.m_glGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC) glewGetProcAddress ("glGetProgramBinary");
    s_deviceConfig.m_glProgramBinary = (PFNGLPROGRAMBINARYPROC) glewGetProcAddress ("glProgramBinary");
    s_deviceConfig.m_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC) glewGetProcAddress ("glProgramParameteri");
  }

  // GL_ARB_get_texture_sub_image
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_get_texture_sub_image])
  {
    s_deviceConfig.m_glGetTextureSubImage = (PFNGLGETTEXTURESUBIMAGEPROC) glewGetProcAddress ("glGetTextureSubImage");
    s_deviceConfig.m_glGetCompressedTextureSubImage = (PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) glewGetProcAddress ("glGetCompressedTextureSubImage");
  }

  // GL_ARB_gl_spirv
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_gl_spirv])
  {
    s_deviceConfig.m_glSpecializeShaderARB = (PFNGLSPECIALIZESHADERARBPROC) glewGetProcAddress ("glSpecializeShaderARB");
  }

  // GL_ARB_gpu_shader_fp64
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_fp64])
  {
    s_deviceConfig.m_glUniform1d = (PFNGLUNIFORM1DPROC) glewGetProcAddress ("glUniform1d");
    s_deviceConfig.m_glUniform2d = (PFNGLUNIFORM2DPROC) glewGetProcAddress ("glUniform2d");
    s_deviceConfig.m_glUniform3d = (PFNGLUNIFORM3DPROC) glewGetProcAddress ("glUniform3d");
    s_deviceConfig.m_glUniform4d = (PFNGLUNIFORM4DPROC) glewGetProcAddress ("glUniform4d");
    s_deviceConfig.m_glUniform1dv = (PFNGLUNIFORM1DVPROC) glewGetProcAddress ("glUniform1dv");
    s_deviceConfig.m_glUniform2dv = (PFNGLUNIFORM2DVPROC) glewGetProcAddress ("glUniform2dv");
    s_deviceConfig.m_glUniform3dv = (PFNGLUNIFORM3DVPROC) glewGetProcAddress ("glUniform3dv");
    s_deviceConfig.m_glUniform4dv = (PFNGLUNIFORM4DVPROC) glewGetProcAddress ("glUniform4dv");
    s_deviceConfig.m_glUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC) glewGetProcAddress ("glUniformMatrix2dv");
    s_deviceConfig.m_glUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC) glewGetProcAddress ("glUniformMatrix3dv");
    s_deviceConfig.m_glUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC) glewGetProcAddress ("glUniformMatrix4dv");
    s_deviceConfig.m_glUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC) glewGetProcAddress ("glUniformMatrix2x3dv");
    s_deviceConfig.m_glUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC) glewGetProcAddress ("glUniformMatrix2x4dv");
    s_deviceConfig.m_glUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC) glewGetProcAddress ("glUniformMatrix3x2dv");
    s_deviceConfig.m_glUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC) glewGetProcAddress ("glUniformMatrix3x4dv");
    s_deviceConfig.m_glUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC) glewGetProcAddress ("glUniformMatrix4x2dv");
    s_deviceConfig.m_glUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC) glewGetProcAddress ("glUniformMatrix4x3dv");
    s_deviceConfig.m_glGetUniformdv = (PFNGLGETUNIFORMDVPROC) glewGetProcAddress ("glGetUniformdv");
  }

  // GL_ARB_gpu_shader_int64
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_gpu_shader_int64])
  {
    s_deviceConfig.m_glUniform1i64ARB = (PFNGLUNIFORM1I64ARBPROC) glewGetProcAddress ("glUniform1i64ARB");
    s_deviceConfig.m_glUniform2i64ARB = (PFNGLUNIFORM2I64ARBPROC) glewGetProcAddress ("glUniform2i64ARB");
    s_deviceConfig.m_glUniform3i64ARB = (PFNGLUNIFORM3I64ARBPROC) glewGetProcAddress ("glUniform3i64ARB");
    s_deviceConfig.m_glUniform4i64ARB = (PFNGLUNIFORM4I64ARBPROC) glewGetProcAddress ("glUniform4i64ARB");
    s_deviceConfig.m_glUniform1i64vARB = (PFNGLUNIFORM1I64VARBPROC) glewGetProcAddress ("glUniform1i64vARB");
    s_deviceConfig.m_glUniform2i64vARB = (PFNGLUNIFORM2I64VARBPROC) glewGetProcAddress ("glUniform2i64vARB");
    s_deviceConfig.m_glUniform3i64vARB = (PFNGLUNIFORM3I64VARBPROC) glewGetProcAddress ("glUniform3i64vARB");
    s_deviceConfig.m_glUniform4i64vARB = (PFNGLUNIFORM4I64VARBPROC) glewGetProcAddress ("glUniform4i64vARB");
    s_deviceConfig.m_glUniform1ui64ARB = (PFNGLUNIFORM1UI64ARBPROC) glewGetProcAddress ("glUniform1ui64ARB");
    s_deviceConfig.m_glUniform2ui64ARB = (PFNGLUNIFORM2UI64ARBPROC) glewGetProcAddress ("glUniform2ui64ARB");
    s_deviceConfig.m_glUniform3ui64ARB = (PFNGLUNIFORM3UI64ARBPROC) glewGetProcAddress ("glUniform3ui64ARB");
    s_deviceConfig.m_glUniform4ui64ARB = (PFNGLUNIFORM4UI64ARBPROC) glewGetProcAddress ("glUniform4ui64ARB");
    s_deviceConfig.m_glUniform1ui64vARB = (PFNGLUNIFORM1UI64VARBPROC) glewGetProcAddress ("glUniform1ui64vARB");
    s_deviceConfig.m_glUniform2ui64vARB = (PFNGLUNIFORM2UI64VARBPROC) glewGetProcAddress ("glUniform2ui64vARB");
    s_deviceConfig.m_glUniform3ui64vARB = (PFNGLUNIFORM3UI64VARBPROC) glewGetProcAddress ("glUniform3ui64vARB");
    s_deviceConfig.m_glUniform4ui64vARB = (PFNGLUNIFORM4UI64VARBPROC) glewGetProcAddress ("glUniform4ui64vARB");
    s_deviceConfig.m_glGetUniformi64vARB = (PFNGLGETUNIFORMI64VARBPROC) glewGetProcAddress ("glGetUniformi64vARB");
    s_deviceConfig.m_glGetUniformui64vARB = (PFNGLGETUNIFORMUI64VARBPROC) glewGetProcAddress ("glGetUniformui64vARB");
    s_deviceConfig.m_glGetnUniformi64vARB = (PFNGLGETNUNIFORMI64VARBPROC) glewGetProcAddress ("glGetnUniformi64vARB");
    s_deviceConfig.m_glGetnUniformui64vARB = (PFNGLGETNUNIFORMUI64VARBPROC) glewGetProcAddress ("glGetnUniformui64vARB");
    s_deviceConfig.m_glProgramUniform1i64ARB = (PFNGLPROGRAMUNIFORM1I64ARBPROC) glewGetProcAddress ("glProgramUniform1i64ARB");
    s_deviceConfig.m_glProgramUniform2i64ARB = (PFNGLPROGRAMUNIFORM2I64ARBPROC) glewGetProcAddress ("glProgramUniform2i64ARB");
    s_deviceConfig.m_glProgramUniform3i64ARB = (PFNGLPROGRAMUNIFORM3I64ARBPROC) glewGetProcAddress ("glProgramUniform3i64ARB");
    s_deviceConfig.m_glProgramUniform4i64ARB = (PFNGLPROGRAMUNIFORM4I64ARBPROC) glewGetProcAddress ("glProgramUniform4i64ARB");
    s_deviceConfig.m_glProgramUniform1i64vARB = (PFNGLPROGRAMUNIFORM1I64VARBPROC) glewGetProcAddress ("glProgramUniform1i64vARB");
    s_deviceConfig.m_glProgramUniform2i64vARB = (PFNGLPROGRAMUNIFORM2I64VARBPROC) glewGetProcAddress ("glProgramUniform2i64vARB");
    s_deviceConfig.m_glProgramUniform3i64vARB = (PFNGLPROGRAMUNIFORM3I64VARBPROC) glewGetProcAddress ("glProgramUniform3i64vARB");
    s_deviceConfig.m_glProgramUniform4i64vARB = (PFNGLPROGRAMUNIFORM4I64VARBPROC) glewGetProcAddress ("glProgramUniform4i64vARB");
    s_deviceConfig.m_glProgramUniform1ui64ARB = (PFNGLPROGRAMUNIFORM1UI64ARBPROC) glewGetProcAddress ("glProgramUniform1ui64ARB");
    s_deviceConfig.m_glProgramUniform2ui64ARB = (PFNGLPROGRAMUNIFORM2UI64ARBPROC) glewGetProcAddress ("glProgramUniform2ui64ARB");
    s_deviceConfig.m_glProgramUniform3ui64ARB = (PFNGLPROGRAMUNIFORM3UI64ARBPROC) glewGetProcAddress ("glProgramUniform3ui64ARB");
    s_deviceConfig.m_glProgramUniform4ui64ARB = (PFNGLPROGRAMUNIFORM4UI64ARBPROC) glewGetProcAddress ("glProgramUniform4ui64ARB");
    s_deviceConfig.m_glProgramUniform1ui64vARB = (PFNGLPROGRAMUNIFORM1UI64VARBPROC) glewGetProcAddress ("glProgramUniform1ui64vARB");
    s_deviceConfig.m_glProgramUniform2ui64vARB = (PFNGLPROGRAMUNIFORM2UI64VARBPROC) glewGetProcAddress ("glProgramUniform2ui64vARB");
    s_deviceConfig.m_glProgramUniform3ui64vARB = (PFNGLPROGRAMUNIFORM3UI64VARBPROC) glewGetProcAddress ("glProgramUniform3ui64vARB");
    s_deviceConfig.m_glProgramUniform4ui64vARB = (PFNGLPROGRAMUNIFORM4UI64VARBPROC) glewGetProcAddress ("glProgramUniform4ui64vARB");
  }

  // GL_ARB_imaging
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_imaging])
  {
    s_deviceConfig.m_glBlendColor = (PFNGLBLENDCOLORPROC) glewGetProcAddress ("glBlendColor");
    s_deviceConfig.m_glBlendEquation = (PFNGLBLENDEQUATIONPROC) glewGetProcAddress ("glBlendEquation");
    s_deviceConfig.m_glColorTable = (PFNGLCOLORTABLEPROC) glewGetProcAddress ("glColorTable");
    s_deviceConfig.m_glColorTableParameterfv = (PFNGLCOLORTABLEPARAMETERFVPROC) glewGetProcAddress ("glColorTableParameterfv");
    s_deviceConfig.m_glColorTableParameteriv = (PFNGLCOLORTABLEPARAMETERIVPROC) glewGetProcAddress ("glColorTableParameteriv");
    s_deviceConfig.m_glCopyColorTable = (PFNGLCOPYCOLORTABLEPROC) glewGetProcAddress ("glCopyColorTable");
    s_deviceConfig.m_glGetColorTable = (PFNGLGETCOLORTABLEPROC) glewGetProcAddress ("glGetColorTable");
    s_deviceConfig.m_glGetColorTableParameterfv = (PFNGLGETCOLORTABLEPARAMETERFVPROC) glewGetProcAddress ("glGetColorTableParameterfv");
    s_deviceConfig.m_glGetColorTableParameteriv = (PFNGLGETCOLORTABLEPARAMETERIVPROC) glewGetProcAddress ("glGetColorTableParameteriv");
    s_deviceConfig.m_glColorSubTable = (PFNGLCOLORSUBTABLEPROC) glewGetProcAddress ("glColorSubTable");
    s_deviceConfig.m_glCopyColorSubTable = (PFNGLCOPYCOLORSUBTABLEPROC) glewGetProcAddress ("glCopyColorSubTable");
    s_deviceConfig.m_glConvolutionFilter1D = (PFNGLCONVOLUTIONFILTER1DPROC) glewGetProcAddress ("glConvolutionFilter1D");
    s_deviceConfig.m_glConvolutionFilter2D = (PFNGLCONVOLUTIONFILTER2DPROC) glewGetProcAddress ("glConvolutionFilter2D");
    s_deviceConfig.m_glConvolutionParameterf = (PFNGLCONVOLUTIONPARAMETERFPROC) glewGetProcAddress ("glConvolutionParameterf");
    s_deviceConfig.m_glConvolutionParameterfv = (PFNGLCONVOLUTIONPARAMETERFVPROC) glewGetProcAddress ("glConvolutionParameterfv");
    s_deviceConfig.m_glConvolutionParameteri = (PFNGLCONVOLUTIONPARAMETERIPROC) glewGetProcAddress ("glConvolutionParameteri");
    s_deviceConfig.m_glConvolutionParameteriv = (PFNGLCONVOLUTIONPARAMETERIVPROC) glewGetProcAddress ("glConvolutionParameteriv");
    s_deviceConfig.m_glCopyConvolutionFilter1D = (PFNGLCOPYCONVOLUTIONFILTER1DPROC) glewGetProcAddress ("glCopyConvolutionFilter1D");
    s_deviceConfig.m_glCopyConvolutionFilter2D = (PFNGLCOPYCONVOLUTIONFILTER2DPROC) glewGetProcAddress ("glCopyConvolutionFilter2D");
    s_deviceConfig.m_glGetConvolutionFilter = (PFNGLGETCONVOLUTIONFILTERPROC) glewGetProcAddress ("glGetConvolutionFilter");
    s_deviceConfig.m_glGetConvolutionParameterfv = (PFNGLGETCONVOLUTIONPARAMETERFVPROC) glewGetProcAddress ("glGetConvolutionParameterfv");
    s_deviceConfig.m_glGetConvolutionParameteriv = (PFNGLGETCONVOLUTIONPARAMETERIVPROC) glewGetProcAddress ("glGetConvolutionParameteriv");
    s_deviceConfig.m_glGetSeparableFilter = (PFNGLGETSEPARABLEFILTERPROC) glewGetProcAddress ("glGetSeparableFilter");
    s_deviceConfig.m_glSeparableFilter2D = (PFNGLSEPARABLEFILTER2DPROC) glewGetProcAddress ("glSeparableFilter2D");
    s_deviceConfig.m_glGetHistogram = (PFNGLGETHISTOGRAMPROC) glewGetProcAddress ("glGetHistogram");
    s_deviceConfig.m_glGetHistogramParameterfv = (PFNGLGETHISTOGRAMPARAMETERFVPROC) glewGetProcAddress ("glGetHistogramParameterfv");
    s_deviceConfig.m_glGetHistogramParameteriv = (PFNGLGETHISTOGRAMPARAMETERIVPROC) glewGetProcAddress ("glGetHistogramParameteriv");
    s_deviceConfig.m_glGetMinmax = (PFNGLGETMINMAXPROC) glewGetProcAddress ("glGetMinmax");
    s_deviceConfig.m_glGetMinmaxParameterfv = (PFNGLGETMINMAXPARAMETERFVPROC) glewGetProcAddress ("glGetMinmaxParameterfv");
    s_deviceConfig.m_glGetMinmaxParameteriv = (PFNGLGETMINMAXPARAMETERIVPROC) glewGetProcAddress ("glGetMinmaxParameteriv");
    s_deviceConfig.m_glHistogram = (PFNGLHISTOGRAMPROC) glewGetProcAddress ("glHistogram");
    s_deviceConfig.m_glMinmax = (PFNGLMINMAXPROC) glewGetProcAddress ("glMinmax");
    s_deviceConfig.m_glResetHistogram = (PFNGLRESETHISTOGRAMPROC) glewGetProcAddress ("glResetHistogram");
    s_deviceConfig.m_glResetMinmax = (PFNGLRESETMINMAXPROC) glewGetProcAddress ("glResetMinmax");
  }

  // GL_ARB_indirect_parameters
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_indirect_parameters])
  {
    s_deviceConfig.m_glMultiDrawArraysIndirectCountARB = (PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) glewGetProcAddress ("glMultiDrawArraysIndirectCountARB");
    s_deviceConfig.m_glMultiDrawElementsIndirectCountARB = (PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) glewGetProcAddress ("glMultiDrawElementsIndirectCountARB");
  }

  // GL_ARB_instanced_arrays
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_instanced_arrays])
  {
    s_deviceConfig.m_glVertexAttribDivisorARB = (PFNGLVERTEXATTRIBDIVISORARBPROC) glewGetProcAddress ("glVertexAttribDivisorARB");
  }

  // GL_ARB_internalformat_query
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_internalformat_query])
  {
    s_deviceConfig.m_glGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC) glewGetProcAddress ("glGetInternalformativ");
  }

  // GL_ARB_internalformat_query2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_internalformat_query2])
  {
    s_deviceConfig.m_glGetInternalformati64v = (PFNGLGETINTERNALFORMATI64VPROC) glewGetProcAddress ("glGetInternalformati64v");
  }

  // GL_ARB_invalidate_subdata
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_invalidate_subdata])
  {
    s_deviceConfig.m_glInvalidateTexSubImage = (PFNGLINVALIDATETEXSUBIMAGEPROC) glewGetProcAddress ("glInvalidateTexSubImage");
    s_deviceConfig.m_glInvalidateTexImage = (PFNGLINVALIDATETEXIMAGEPROC) glewGetProcAddress ("glInvalidateTexImage");
    s_deviceConfig.m_glInvalidateBufferSubData = (PFNGLINVALIDATEBUFFERSUBDATAPROC) glewGetProcAddress ("glInvalidateBufferSubData");
    s_deviceConfig.m_glInvalidateBufferData = (PFNGLINVALIDATEBUFFERDATAPROC) glewGetProcAddress ("glInvalidateBufferData");
    s_deviceConfig.m_glInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC) glewGetProcAddress ("glInvalidateFramebuffer");
    s_deviceConfig.m_glInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC) glewGetProcAddress ("glInvalidateSubFramebuffer");
  }

  // GL_ARB_map_buffer_range
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_map_buffer_range])
  {
    s_deviceConfig.m_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC) glewGetProcAddress ("glMapBufferRange");
    s_deviceConfig.m_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC) glewGetProcAddress ("glFlushMappedBufferRange");
  }

  // GL_ARB_matrix_palette
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_matrix_palette])
  {
    s_deviceConfig.m_glCurrentPaletteMatrixARB = (PFNGLCURRENTPALETTEMATRIXARBPROC) glewGetProcAddress ("glCurrentPaletteMatrixARB");
    s_deviceConfig.m_glMatrixIndexubvARB = (PFNGLMATRIXINDEXUBVARBPROC) glewGetProcAddress ("glMatrixIndexubvARB");
    s_deviceConfig.m_glMatrixIndexusvARB = (PFNGLMATRIXINDEXUSVARBPROC) glewGetProcAddress ("glMatrixIndexusvARB");
    s_deviceConfig.m_glMatrixIndexuivARB = (PFNGLMATRIXINDEXUIVARBPROC) glewGetProcAddress ("glMatrixIndexuivARB");
    s_deviceConfig.m_glMatrixIndexPointerARB = (PFNGLMATRIXINDEXPOINTERARBPROC) glewGetProcAddress ("glMatrixIndexPointerARB");
  }

  // GL_ARB_multi_bind
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_multi_bind])
  {
    s_deviceConfig.m_glBindBuffersBase = (PFNGLBINDBUFFERSBASEPROC) glewGetProcAddress ("glBindBuffersBase");
    s_deviceConfig.m_glBindBuffersRange = (PFNGLBINDBUFFERSRANGEPROC) glewGetProcAddress ("glBindBuffersRange");
    s_deviceConfig.m_glBindTextures = (PFNGLBINDTEXTURESPROC) glewGetProcAddress ("glBindTextures");
    s_deviceConfig.m_glBindSamplers = (PFNGLBINDSAMPLERSPROC) glewGetProcAddress ("glBindSamplers");
    s_deviceConfig.m_glBindImageTextures = (PFNGLBINDIMAGETEXTURESPROC) glewGetProcAddress ("glBindImageTextures");
    s_deviceConfig.m_glBindVertexBuffers = (PFNGLBINDVERTEXBUFFERSPROC) glewGetProcAddress ("glBindVertexBuffers");
  }

  // GL_ARB_multi_draw_indirect
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_multi_draw_indirect])
  {
    s_deviceConfig.m_glMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC) glewGetProcAddress ("glMultiDrawArraysIndirect");
    s_deviceConfig.m_glMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC) glewGetProcAddress ("glMultiDrawElementsIndirect");
  }

  // GL_ARB_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_multisample])
  {
    s_deviceConfig.m_glSampleCoverageARB = (PFNGLSAMPLECOVERAGEARBPROC) glewGetProcAddress ("glSampleCoverageARB");
  }

  // GL_ARB_multitexture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_multitexture])
  {
    s_deviceConfig.m_glActiveTextureARB = (PFNGLACTIVETEXTUREARBPROC) glewGetProcAddress ("glActiveTextureARB");
    s_deviceConfig.m_glClientActiveTextureARB = (PFNGLCLIENTACTIVETEXTUREARBPROC) glewGetProcAddress ("glClientActiveTextureARB");
    s_deviceConfig.m_glMultiTexCoord1dARB = (PFNGLMULTITEXCOORD1DARBPROC) glewGetProcAddress ("glMultiTexCoord1dARB");
    s_deviceConfig.m_glMultiTexCoord1dvARB = (PFNGLMULTITEXCOORD1DVARBPROC) glewGetProcAddress ("glMultiTexCoord1dvARB");
    s_deviceConfig.m_glMultiTexCoord1fARB = (PFNGLMULTITEXCOORD1FARBPROC) glewGetProcAddress ("glMultiTexCoord1fARB");
    s_deviceConfig.m_glMultiTexCoord1fvARB = (PFNGLMULTITEXCOORD1FVARBPROC) glewGetProcAddress ("glMultiTexCoord1fvARB");
    s_deviceConfig.m_glMultiTexCoord1iARB = (PFNGLMULTITEXCOORD1IARBPROC) glewGetProcAddress ("glMultiTexCoord1iARB");
    s_deviceConfig.m_glMultiTexCoord1ivARB = (PFNGLMULTITEXCOORD1IVARBPROC) glewGetProcAddress ("glMultiTexCoord1ivARB");
    s_deviceConfig.m_glMultiTexCoord1sARB = (PFNGLMULTITEXCOORD1SARBPROC) glewGetProcAddress ("glMultiTexCoord1sARB");
    s_deviceConfig.m_glMultiTexCoord1svARB = (PFNGLMULTITEXCOORD1SVARBPROC) glewGetProcAddress ("glMultiTexCoord1svARB");
    s_deviceConfig.m_glMultiTexCoord2dARB = (PFNGLMULTITEXCOORD2DARBPROC) glewGetProcAddress ("glMultiTexCoord2dARB");
    s_deviceConfig.m_glMultiTexCoord2dvARB = (PFNGLMULTITEXCOORD2DVARBPROC) glewGetProcAddress ("glMultiTexCoord2dvARB");
    s_deviceConfig.m_glMultiTexCoord2fARB = (PFNGLMULTITEXCOORD2FARBPROC) glewGetProcAddress ("glMultiTexCoord2fARB");
    s_deviceConfig.m_glMultiTexCoord2fvARB = (PFNGLMULTITEXCOORD2FVARBPROC) glewGetProcAddress ("glMultiTexCoord2fvARB");
    s_deviceConfig.m_glMultiTexCoord2iARB = (PFNGLMULTITEXCOORD2IARBPROC) glewGetProcAddress ("glMultiTexCoord2iARB");
    s_deviceConfig.m_glMultiTexCoord2ivARB = (PFNGLMULTITEXCOORD2IVARBPROC) glewGetProcAddress ("glMultiTexCoord2ivARB");
    s_deviceConfig.m_glMultiTexCoord2sARB = (PFNGLMULTITEXCOORD2SARBPROC) glewGetProcAddress ("glMultiTexCoord2sARB");
    s_deviceConfig.m_glMultiTexCoord2svARB = (PFNGLMULTITEXCOORD2SVARBPROC) glewGetProcAddress ("glMultiTexCoord2svARB");
    s_deviceConfig.m_glMultiTexCoord3dARB = (PFNGLMULTITEXCOORD3DARBPROC) glewGetProcAddress ("glMultiTexCoord3dARB");
    s_deviceConfig.m_glMultiTexCoord3dvARB = (PFNGLMULTITEXCOORD3DVARBPROC) glewGetProcAddress ("glMultiTexCoord3dvARB");
    s_deviceConfig.m_glMultiTexCoord3fARB = (PFNGLMULTITEXCOORD3FARBPROC) glewGetProcAddress ("glMultiTexCoord3fARB");
    s_deviceConfig.m_glMultiTexCoord3fvARB = (PFNGLMULTITEXCOORD3FVARBPROC) glewGetProcAddress ("glMultiTexCoord3fvARB");
    s_deviceConfig.m_glMultiTexCoord3iARB = (PFNGLMULTITEXCOORD3IARBPROC) glewGetProcAddress ("glMultiTexCoord3iARB");
    s_deviceConfig.m_glMultiTexCoord3ivARB = (PFNGLMULTITEXCOORD3IVARBPROC) glewGetProcAddress ("glMultiTexCoord3ivARB");
    s_deviceConfig.m_glMultiTexCoord3sARB = (PFNGLMULTITEXCOORD3SARBPROC) glewGetProcAddress ("glMultiTexCoord3sARB");
    s_deviceConfig.m_glMultiTexCoord3svARB = (PFNGLMULTITEXCOORD3SVARBPROC) glewGetProcAddress ("glMultiTexCoord3svARB");
    s_deviceConfig.m_glMultiTexCoord4dARB = (PFNGLMULTITEXCOORD4DARBPROC) glewGetProcAddress ("glMultiTexCoord4dARB");
    s_deviceConfig.m_glMultiTexCoord4dvARB = (PFNGLMULTITEXCOORD4DVARBPROC) glewGetProcAddress ("glMultiTexCoord4dvARB");
    s_deviceConfig.m_glMultiTexCoord4fARB = (PFNGLMULTITEXCOORD4FARBPROC) glewGetProcAddress ("glMultiTexCoord4fARB");
    s_deviceConfig.m_glMultiTexCoord4fvARB = (PFNGLMULTITEXCOORD4FVARBPROC) glewGetProcAddress ("glMultiTexCoord4fvARB");
    s_deviceConfig.m_glMultiTexCoord4iARB = (PFNGLMULTITEXCOORD4IARBPROC) glewGetProcAddress ("glMultiTexCoord4iARB");
    s_deviceConfig.m_glMultiTexCoord4ivARB = (PFNGLMULTITEXCOORD4IVARBPROC) glewGetProcAddress ("glMultiTexCoord4ivARB");
    s_deviceConfig.m_glMultiTexCoord4sARB = (PFNGLMULTITEXCOORD4SARBPROC) glewGetProcAddress ("glMultiTexCoord4sARB");
    s_deviceConfig.m_glMultiTexCoord4svARB = (PFNGLMULTITEXCOORD4SVARBPROC) glewGetProcAddress ("glMultiTexCoord4svARB");
  }

  // GL_ARB_occlusion_query
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_occlusion_query])
  {
    s_deviceConfig.m_glGenQueriesARB = (PFNGLGENQUERIESARBPROC) glewGetProcAddress ("glGenQueriesARB");
    s_deviceConfig.m_glDeleteQueriesARB = (PFNGLDELETEQUERIESARBPROC) glewGetProcAddress ("glDeleteQueriesARB");
    s_deviceConfig.m_glIsQueryARB = (PFNGLISQUERYARBPROC) glewGetProcAddress ("glIsQueryARB");
    s_deviceConfig.m_glBeginQueryARB = (PFNGLBEGINQUERYARBPROC) glewGetProcAddress ("glBeginQueryARB");
    s_deviceConfig.m_glEndQueryARB = (PFNGLENDQUERYARBPROC) glewGetProcAddress ("glEndQueryARB");
    s_deviceConfig.m_glGetQueryivARB = (PFNGLGETQUERYIVARBPROC) glewGetProcAddress ("glGetQueryivARB");
    s_deviceConfig.m_glGetQueryObjectivARB = (PFNGLGETQUERYOBJECTIVARBPROC) glewGetProcAddress ("glGetQueryObjectivARB");
    s_deviceConfig.m_glGetQueryObjectuivARB = (PFNGLGETQUERYOBJECTUIVARBPROC) glewGetProcAddress ("glGetQueryObjectuivARB");
  }

  // GL_ARB_parallel_shader_compile
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_parallel_shader_compile])
  {
    s_deviceConfig.m_glMaxShaderCompilerThreadsARB = (PFNGLMAXSHADERCOMPILERTHREADSARBPROC) glewGetProcAddress ("glMaxShaderCompilerThreadsARB");
  }

  // GL_ARB_point_parameters
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_point_parameters])
  {
    s_deviceConfig.m_glPointParameterfARB = (PFNGLPOINTPARAMETERFARBPROC) glewGetProcAddress ("glPointParameterfARB");
    s_deviceConfig.m_glPointParameterfvARB = (PFNGLPOINTPARAMETERFVARBPROC) glewGetProcAddress ("glPointParameterfvARB");
  }

  // GL_ARB_polygon_offset_clamp
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_polygon_offset_clamp])
  {
    s_deviceConfig.m_glPolygonOffsetClamp = (PFNGLPOLYGONOFFSETCLAMPPROC) glewGetProcAddress ("glPolygonOffsetClamp");
  }

  // GL_ARB_program_interface_query
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_program_interface_query])
  {
    s_deviceConfig.m_glGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC) glewGetProcAddress ("glGetProgramInterfaceiv");
    s_deviceConfig.m_glGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC) glewGetProcAddress ("glGetProgramResourceIndex");
    s_deviceConfig.m_glGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC) glewGetProcAddress ("glGetProgramResourceName");
    s_deviceConfig.m_glGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC) glewGetProcAddress ("glGetProgramResourceiv");
    s_deviceConfig.m_glGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC) glewGetProcAddress ("glGetProgramResourceLocation");
    s_deviceConfig.m_glGetProgramResourceLocationIndex = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) glewGetProcAddress ("glGetProgramResourceLocationIndex");
  }

  // GL_ARB_provoking_vertex
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_provoking_vertex])
  {
    s_deviceConfig.m_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC) glewGetProcAddress ("glProvokingVertex");
  }

  // GL_ARB_robustness
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_robustness])
  {
    s_deviceConfig.m_glGetGraphicsResetStatusARB = (PFNGLGETGRAPHICSRESETSTATUSARBPROC) glewGetProcAddress ("glGetGraphicsResetStatusARB");
    s_deviceConfig.m_glGetnTexImageARB = (PFNGLGETNTEXIMAGEARBPROC) glewGetProcAddress ("glGetnTexImageARB");
    s_deviceConfig.m_glReadnPixelsARB = (PFNGLREADNPIXELSARBPROC) glewGetProcAddress ("glReadnPixelsARB");
    s_deviceConfig.m_glGetnCompressedTexImageARB = (PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) glewGetProcAddress ("glGetnCompressedTexImageARB");
    s_deviceConfig.m_glGetnUniformfvARB = (PFNGLGETNUNIFORMFVARBPROC) glewGetProcAddress ("glGetnUniformfvARB");
    s_deviceConfig.m_glGetnUniformivARB = (PFNGLGETNUNIFORMIVARBPROC) glewGetProcAddress ("glGetnUniformivARB");
    s_deviceConfig.m_glGetnUniformuivARB = (PFNGLGETNUNIFORMUIVARBPROC) glewGetProcAddress ("glGetnUniformuivARB");
    s_deviceConfig.m_glGetnUniformdvARB = (PFNGLGETNUNIFORMDVARBPROC) glewGetProcAddress ("glGetnUniformdvARB");
    s_deviceConfig.m_glGetnMapdvARB = (PFNGLGETNMAPDVARBPROC) glewGetProcAddress ("glGetnMapdvARB");
    s_deviceConfig.m_glGetnMapfvARB = (PFNGLGETNMAPFVARBPROC) glewGetProcAddress ("glGetnMapfvARB");
    s_deviceConfig.m_glGetnMapivARB = (PFNGLGETNMAPIVARBPROC) glewGetProcAddress ("glGetnMapivARB");
    s_deviceConfig.m_glGetnPixelMapfvARB = (PFNGLGETNPIXELMAPFVARBPROC) glewGetProcAddress ("glGetnPixelMapfvARB");
    s_deviceConfig.m_glGetnPixelMapuivARB = (PFNGLGETNPIXELMAPUIVARBPROC) glewGetProcAddress ("glGetnPixelMapuivARB");
    s_deviceConfig.m_glGetnPixelMapusvARB = (PFNGLGETNPIXELMAPUSVARBPROC) glewGetProcAddress ("glGetnPixelMapusvARB");
    s_deviceConfig.m_glGetnPolygonStippleARB = (PFNGLGETNPOLYGONSTIPPLEARBPROC) glewGetProcAddress ("glGetnPolygonStippleARB");
    s_deviceConfig.m_glGetnColorTableARB = (PFNGLGETNCOLORTABLEARBPROC) glewGetProcAddress ("glGetnColorTableARB");
    s_deviceConfig.m_glGetnConvolutionFilterARB = (PFNGLGETNCONVOLUTIONFILTERARBPROC) glewGetProcAddress ("glGetnConvolutionFilterARB");
    s_deviceConfig.m_glGetnSeparableFilterARB = (PFNGLGETNSEPARABLEFILTERARBPROC) glewGetProcAddress ("glGetnSeparableFilterARB");
    s_deviceConfig.m_glGetnHistogramARB = (PFNGLGETNHISTOGRAMARBPROC) glewGetProcAddress ("glGetnHistogramARB");
    s_deviceConfig.m_glGetnMinmaxARB = (PFNGLGETNMINMAXARBPROC) glewGetProcAddress ("glGetnMinmaxARB");
  }

  // GL_ARB_sample_locations
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sample_locations])
  {
    s_deviceConfig.m_glFramebufferSampleLocationsfvARB = (PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) glewGetProcAddress ("glFramebufferSampleLocationsfvARB");
    s_deviceConfig.m_glNamedFramebufferSampleLocationsfvARB = (PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) glewGetProcAddress ("glNamedFramebufferSampleLocationsfvARB");
    s_deviceConfig.m_glEvaluateDepthValuesARB = (PFNGLEVALUATEDEPTHVALUESARBPROC) glewGetProcAddress ("glEvaluateDepthValuesARB");
  }

  // GL_ARB_sample_shading
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sample_shading])
  {
    s_deviceConfig.m_glMinSampleShadingARB = (PFNGLMINSAMPLESHADINGARBPROC) glewGetProcAddress ("glMinSampleShadingARB");
  }

  // GL_ARB_sampler_objects
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sampler_objects])
  {
    s_deviceConfig.m_glGenSamplers = (PFNGLGENSAMPLERSPROC) glewGetProcAddress ("glGenSamplers");
    s_deviceConfig.m_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC) glewGetProcAddress ("glDeleteSamplers");
    s_deviceConfig.m_glIsSampler = (PFNGLISSAMPLERPROC) glewGetProcAddress ("glIsSampler");
    s_deviceConfig.m_glBindSampler = (PFNGLBINDSAMPLERPROC) glewGetProcAddress ("glBindSampler");
    s_deviceConfig.m_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC) glewGetProcAddress ("glSamplerParameteri");
    s_deviceConfig.m_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC) glewGetProcAddress ("glSamplerParameteriv");
    s_deviceConfig.m_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC) glewGetProcAddress ("glSamplerParameterf");
    s_deviceConfig.m_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC) glewGetProcAddress ("glSamplerParameterfv");
    s_deviceConfig.m_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC) glewGetProcAddress ("glSamplerParameterIiv");
    s_deviceConfig.m_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC) glewGetProcAddress ("glSamplerParameterIuiv");
    s_deviceConfig.m_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC) glewGetProcAddress ("glGetSamplerParameteriv");
    s_deviceConfig.m_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC) glewGetProcAddress ("glGetSamplerParameterIiv");
    s_deviceConfig.m_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC) glewGetProcAddress ("glGetSamplerParameterfv");
    s_deviceConfig.m_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC) glewGetProcAddress ("glGetSamplerParameterIuiv");
  }

  // GL_ARB_separate_shader_objects
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_separate_shader_objects])
  {
    s_deviceConfig.m_glUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC) glewGetProcAddress ("glUseProgramStages");
    s_deviceConfig.m_glActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC) glewGetProcAddress ("glActiveShaderProgram");
    s_deviceConfig.m_glCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC) glewGetProcAddress ("glCreateShaderProgramv");
    s_deviceConfig.m_glBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC) glewGetProcAddress ("glBindProgramPipeline");
    s_deviceConfig.m_glDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC) glewGetProcAddress ("glDeleteProgramPipelines");
    s_deviceConfig.m_glGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC) glewGetProcAddress ("glGenProgramPipelines");
    s_deviceConfig.m_glIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC) glewGetProcAddress ("glIsProgramPipeline");
    s_deviceConfig.m_glGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC) glewGetProcAddress ("glGetProgramPipelineiv");
    s_deviceConfig.m_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC) glewGetProcAddress ("glProgramParameteri");
    s_deviceConfig.m_glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC) glewGetProcAddress ("glProgramUniform1i");
    s_deviceConfig.m_glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC) glewGetProcAddress ("glProgramUniform1iv");
    s_deviceConfig.m_glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC) glewGetProcAddress ("glProgramUniform1f");
    s_deviceConfig.m_glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC) glewGetProcAddress ("glProgramUniform1fv");
    s_deviceConfig.m_glProgramUniform1d = (PFNGLPROGRAMUNIFORM1DPROC) glewGetProcAddress ("glProgramUniform1d");
    s_deviceConfig.m_glProgramUniform1dv = (PFNGLPROGRAMUNIFORM1DVPROC) glewGetProcAddress ("glProgramUniform1dv");
    s_deviceConfig.m_glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC) glewGetProcAddress ("glProgramUniform1ui");
    s_deviceConfig.m_glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC) glewGetProcAddress ("glProgramUniform1uiv");
    s_deviceConfig.m_glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC) glewGetProcAddress ("glProgramUniform2i");
    s_deviceConfig.m_glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC) glewGetProcAddress ("glProgramUniform2iv");
    s_deviceConfig.m_glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC) glewGetProcAddress ("glProgramUniform2f");
    s_deviceConfig.m_glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC) glewGetProcAddress ("glProgramUniform2fv");
    s_deviceConfig.m_glProgramUniform2d = (PFNGLPROGRAMUNIFORM2DPROC) glewGetProcAddress ("glProgramUniform2d");
    s_deviceConfig.m_glProgramUniform2dv = (PFNGLPROGRAMUNIFORM2DVPROC) glewGetProcAddress ("glProgramUniform2dv");
    s_deviceConfig.m_glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC) glewGetProcAddress ("glProgramUniform2ui");
    s_deviceConfig.m_glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC) glewGetProcAddress ("glProgramUniform2uiv");
    s_deviceConfig.m_glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC) glewGetProcAddress ("glProgramUniform3i");
    s_deviceConfig.m_glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC) glewGetProcAddress ("glProgramUniform3iv");
    s_deviceConfig.m_glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC) glewGetProcAddress ("glProgramUniform3f");
    s_deviceConfig.m_glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC) glewGetProcAddress ("glProgramUniform3fv");
    s_deviceConfig.m_glProgramUniform3d = (PFNGLPROGRAMUNIFORM3DPROC) glewGetProcAddress ("glProgramUniform3d");
    s_deviceConfig.m_glProgramUniform3dv = (PFNGLPROGRAMUNIFORM3DVPROC) glewGetProcAddress ("glProgramUniform3dv");
    s_deviceConfig.m_glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC) glewGetProcAddress ("glProgramUniform3ui");
    s_deviceConfig.m_glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC) glewGetProcAddress ("glProgramUniform3uiv");
    s_deviceConfig.m_glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC) glewGetProcAddress ("glProgramUniform4i");
    s_deviceConfig.m_glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC) glewGetProcAddress ("glProgramUniform4iv");
    s_deviceConfig.m_glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC) glewGetProcAddress ("glProgramUniform4f");
    s_deviceConfig.m_glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC) glewGetProcAddress ("glProgramUniform4fv");
    s_deviceConfig.m_glProgramUniform4d = (PFNGLPROGRAMUNIFORM4DPROC) glewGetProcAddress ("glProgramUniform4d");
    s_deviceConfig.m_glProgramUniform4dv = (PFNGLPROGRAMUNIFORM4DVPROC) glewGetProcAddress ("glProgramUniform4dv");
    s_deviceConfig.m_glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC) glewGetProcAddress ("glProgramUniform4ui");
    s_deviceConfig.m_glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC) glewGetProcAddress ("glProgramUniform4uiv");
    s_deviceConfig.m_glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC) glewGetProcAddress ("glProgramUniformMatrix2fv");
    s_deviceConfig.m_glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC) glewGetProcAddress ("glProgramUniformMatrix3fv");
    s_deviceConfig.m_glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC) glewGetProcAddress ("glProgramUniformMatrix4fv");
    s_deviceConfig.m_glProgramUniformMatrix2dv = (PFNGLPROGRAMUNIFORMMATRIX2DVPROC) glewGetProcAddress ("glProgramUniformMatrix2dv");
    s_deviceConfig.m_glProgramUniformMatrix3dv = (PFNGLPROGRAMUNIFORMMATRIX3DVPROC) glewGetProcAddress ("glProgramUniformMatrix3dv");
    s_deviceConfig.m_glProgramUniformMatrix4dv = (PFNGLPROGRAMUNIFORMMATRIX4DVPROC) glewGetProcAddress ("glProgramUniformMatrix4dv");
    s_deviceConfig.m_glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) glewGetProcAddress ("glProgramUniformMatrix2x3fv");
    s_deviceConfig.m_glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) glewGetProcAddress ("glProgramUniformMatrix3x2fv");
    s_deviceConfig.m_glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) glewGetProcAddress ("glProgramUniformMatrix2x4fv");
    s_deviceConfig.m_glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) glewGetProcAddress ("glProgramUniformMatrix4x2fv");
    s_deviceConfig.m_glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) glewGetProcAddress ("glProgramUniformMatrix3x4fv");
    s_deviceConfig.m_glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) glewGetProcAddress ("glProgramUniformMatrix4x3fv");
    s_deviceConfig.m_glProgramUniformMatrix2x3dv = (PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) glewGetProcAddress ("glProgramUniformMatrix2x3dv");
    s_deviceConfig.m_glProgramUniformMatrix3x2dv = (PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) glewGetProcAddress ("glProgramUniformMatrix3x2dv");
    s_deviceConfig.m_glProgramUniformMatrix2x4dv = (PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) glewGetProcAddress ("glProgramUniformMatrix2x4dv");
    s_deviceConfig.m_glProgramUniformMatrix4x2dv = (PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) glewGetProcAddress ("glProgramUniformMatrix4x2dv");
    s_deviceConfig.m_glProgramUniformMatrix3x4dv = (PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) glewGetProcAddress ("glProgramUniformMatrix3x4dv");
    s_deviceConfig.m_glProgramUniformMatrix4x3dv = (PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) glewGetProcAddress ("glProgramUniformMatrix4x3dv");
    s_deviceConfig.m_glValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC) glewGetProcAddress ("glValidateProgramPipeline");
    s_deviceConfig.m_glGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC) glewGetProcAddress ("glGetProgramPipelineInfoLog");
  }

  // GL_ARB_shader_atomic_counters
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_atomic_counters])
  {
    s_deviceConfig.m_glGetActiveAtomicCounterBufferiv = (PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) glewGetProcAddress ("glGetActiveAtomicCounterBufferiv");
  }

  // GL_ARB_shader_image_load_store
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_image_load_store])
  {
    s_deviceConfig.m_glBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC) glewGetProcAddress ("glBindImageTexture");
    s_deviceConfig.m_glMemoryBarrier = (PFNGLMEMORYBARRIERPROC) glewGetProcAddress ("glMemoryBarrier");
  }

  // GL_ARB_shader_objects
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_objects])
  {
    s_deviceConfig.m_glDeleteObjectARB = (PFNGLDELETEOBJECTARBPROC) glewGetProcAddress ("glDeleteObjectARB");
    s_deviceConfig.m_glGetHandleARB = (PFNGLGETHANDLEARBPROC) glewGetProcAddress ("glGetHandleARB");
    s_deviceConfig.m_glDetachObjectARB = (PFNGLDETACHOBJECTARBPROC) glewGetProcAddress ("glDetachObjectARB");
    s_deviceConfig.m_glCreateShaderObjectARB = (PFNGLCREATESHADEROBJECTARBPROC) glewGetProcAddress ("glCreateShaderObjectARB");
    s_deviceConfig.m_glShaderSourceARB = (PFNGLSHADERSOURCEARBPROC) glewGetProcAddress ("glShaderSourceARB");
    s_deviceConfig.m_glCompileShaderARB = (PFNGLCOMPILESHADERARBPROC) glewGetProcAddress ("glCompileShaderARB");
    s_deviceConfig.m_glCreateProgramObjectARB = (PFNGLCREATEPROGRAMOBJECTARBPROC) glewGetProcAddress ("glCreateProgramObjectARB");
    s_deviceConfig.m_glAttachObjectARB = (PFNGLATTACHOBJECTARBPROC) glewGetProcAddress ("glAttachObjectARB");
    s_deviceConfig.m_glLinkProgramARB = (PFNGLLINKPROGRAMARBPROC) glewGetProcAddress ("glLinkProgramARB");
    s_deviceConfig.m_glUseProgramObjectARB = (PFNGLUSEPROGRAMOBJECTARBPROC) glewGetProcAddress ("glUseProgramObjectARB");
    s_deviceConfig.m_glValidateProgramARB = (PFNGLVALIDATEPROGRAMARBPROC) glewGetProcAddress ("glValidateProgramARB");
    s_deviceConfig.m_glUniform1fARB = (PFNGLUNIFORM1FARBPROC) glewGetProcAddress ("glUniform1fARB");
    s_deviceConfig.m_glUniform2fARB = (PFNGLUNIFORM2FARBPROC) glewGetProcAddress ("glUniform2fARB");
    s_deviceConfig.m_glUniform3fARB = (PFNGLUNIFORM3FARBPROC) glewGetProcAddress ("glUniform3fARB");
    s_deviceConfig.m_glUniform4fARB = (PFNGLUNIFORM4FARBPROC) glewGetProcAddress ("glUniform4fARB");
    s_deviceConfig.m_glUniform1iARB = (PFNGLUNIFORM1IARBPROC) glewGetProcAddress ("glUniform1iARB");
    s_deviceConfig.m_glUniform2iARB = (PFNGLUNIFORM2IARBPROC) glewGetProcAddress ("glUniform2iARB");
    s_deviceConfig.m_glUniform3iARB = (PFNGLUNIFORM3IARBPROC) glewGetProcAddress ("glUniform3iARB");
    s_deviceConfig.m_glUniform4iARB = (PFNGLUNIFORM4IARBPROC) glewGetProcAddress ("glUniform4iARB");
    s_deviceConfig.m_glUniform1fvARB = (PFNGLUNIFORM1FVARBPROC) glewGetProcAddress ("glUniform1fvARB");
    s_deviceConfig.m_glUniform2fvARB = (PFNGLUNIFORM2FVARBPROC) glewGetProcAddress ("glUniform2fvARB");
    s_deviceConfig.m_glUniform3fvARB = (PFNGLUNIFORM3FVARBPROC) glewGetProcAddress ("glUniform3fvARB");
    s_deviceConfig.m_glUniform4fvARB = (PFNGLUNIFORM4FVARBPROC) glewGetProcAddress ("glUniform4fvARB");
    s_deviceConfig.m_glUniform1ivARB = (PFNGLUNIFORM1IVARBPROC) glewGetProcAddress ("glUniform1ivARB");
    s_deviceConfig.m_glUniform2ivARB = (PFNGLUNIFORM2IVARBPROC) glewGetProcAddress ("glUniform2ivARB");
    s_deviceConfig.m_glUniform3ivARB = (PFNGLUNIFORM3IVARBPROC) glewGetProcAddress ("glUniform3ivARB");
    s_deviceConfig.m_glUniform4ivARB = (PFNGLUNIFORM4IVARBPROC) glewGetProcAddress ("glUniform4ivARB");
    s_deviceConfig.m_glUniformMatrix2fvARB = (PFNGLUNIFORMMATRIX2FVARBPROC) glewGetProcAddress ("glUniformMatrix2fvARB");
    s_deviceConfig.m_glUniformMatrix3fvARB = (PFNGLUNIFORMMATRIX3FVARBPROC) glewGetProcAddress ("glUniformMatrix3fvARB");
    s_deviceConfig.m_glUniformMatrix4fvARB = (PFNGLUNIFORMMATRIX4FVARBPROC) glewGetProcAddress ("glUniformMatrix4fvARB");
    s_deviceConfig.m_glGetObjectParameterfvARB = (PFNGLGETOBJECTPARAMETERFVARBPROC) glewGetProcAddress ("glGetObjectParameterfvARB");
    s_deviceConfig.m_glGetObjectParameterivARB = (PFNGLGETOBJECTPARAMETERIVARBPROC) glewGetProcAddress ("glGetObjectParameterivARB");
    s_deviceConfig.m_glGetInfoLogARB = (PFNGLGETINFOLOGARBPROC) glewGetProcAddress ("glGetInfoLogARB");
    s_deviceConfig.m_glGetAttachedObjectsARB = (PFNGLGETATTACHEDOBJECTSARBPROC) glewGetProcAddress ("glGetAttachedObjectsARB");
    s_deviceConfig.m_glGetUniformLocationARB = (PFNGLGETUNIFORMLOCATIONARBPROC) glewGetProcAddress ("glGetUniformLocationARB");
    s_deviceConfig.m_glGetActiveUniformARB = (PFNGLGETACTIVEUNIFORMARBPROC) glewGetProcAddress ("glGetActiveUniformARB");
    s_deviceConfig.m_glGetUniformfvARB = (PFNGLGETUNIFORMFVARBPROC) glewGetProcAddress ("glGetUniformfvARB");
    s_deviceConfig.m_glGetUniformivARB = (PFNGLGETUNIFORMIVARBPROC) glewGetProcAddress ("glGetUniformivARB");
    s_deviceConfig.m_glGetShaderSourceARB = (PFNGLGETSHADERSOURCEARBPROC) glewGetProcAddress ("glGetShaderSourceARB");
  }

  // GL_ARB_shader_storage_buffer_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_storage_buffer_object])
  {
    s_deviceConfig.m_glShaderStorageBlockBinding = (PFNGLSHADERSTORAGEBLOCKBINDINGPROC) glewGetProcAddress ("glShaderStorageBlockBinding");
  }

  // GL_ARB_shader_subroutine
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shader_subroutine])
  {
    s_deviceConfig.m_glGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) glewGetProcAddress ("glGetSubroutineUniformLocation");
    s_deviceConfig.m_glGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC) glewGetProcAddress ("glGetSubroutineIndex");
    s_deviceConfig.m_glGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) glewGetProcAddress ("glGetActiveSubroutineUniformiv");
    s_deviceConfig.m_glGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) glewGetProcAddress ("glGetActiveSubroutineUniformName");
    s_deviceConfig.m_glGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC) glewGetProcAddress ("glGetActiveSubroutineName");
    s_deviceConfig.m_glUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC) glewGetProcAddress ("glUniformSubroutinesuiv");
    s_deviceConfig.m_glGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC) glewGetProcAddress ("glGetUniformSubroutineuiv");
    s_deviceConfig.m_glGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC) glewGetProcAddress ("glGetProgramStageiv");
  }

  // GL_ARB_shading_language_include
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_shading_language_include])
  {
    s_deviceConfig.m_glNamedStringARB = (PFNGLNAMEDSTRINGARBPROC) glewGetProcAddress ("glNamedStringARB");
    s_deviceConfig.m_glDeleteNamedStringARB = (PFNGLDELETENAMEDSTRINGARBPROC) glewGetProcAddress ("glDeleteNamedStringARB");
    s_deviceConfig.m_glCompileShaderIncludeARB = (PFNGLCOMPILESHADERINCLUDEARBPROC) glewGetProcAddress ("glCompileShaderIncludeARB");
    s_deviceConfig.m_glIsNamedStringARB = (PFNGLISNAMEDSTRINGARBPROC) glewGetProcAddress ("glIsNamedStringARB");
    s_deviceConfig.m_glGetNamedStringARB = (PFNGLGETNAMEDSTRINGARBPROC) glewGetProcAddress ("glGetNamedStringARB");
    s_deviceConfig.m_glGetNamedStringivARB = (PFNGLGETNAMEDSTRINGIVARBPROC) glewGetProcAddress ("glGetNamedStringivARB");
  }

  // GL_ARB_sparse_buffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sparse_buffer])
  {
    s_deviceConfig.m_glBufferPageCommitmentARB = (PFNGLBUFFERPAGECOMMITMENTARBPROC) glewGetProcAddress ("glBufferPageCommitmentARB");
    s_deviceConfig.m_glNamedBufferPageCommitmentEXT = (PFNGLNAMEDBUFFERPAGECOMMITMENTEXTPROC) glewGetProcAddress ("glNamedBufferPageCommitmentEXT");
    s_deviceConfig.m_glNamedBufferPageCommitmentARB = (PFNGLNAMEDBUFFERPAGECOMMITMENTARBPROC) glewGetProcAddress ("glNamedBufferPageCommitmentARB");
  }

  // GL_ARB_sparse_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sparse_texture])
  {
    s_deviceConfig.m_glTexPageCommitmentARB = (PFNGLTEXPAGECOMMITMENTARBPROC) glewGetProcAddress ("glTexPageCommitmentARB");
  }

  // GL_ARB_sync
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_sync])
  {
    s_deviceConfig.m_glFenceSync = (PFNGLFENCESYNCPROC) glewGetProcAddress ("glFenceSync");
    s_deviceConfig.m_glIsSync = (PFNGLISSYNCPROC) glewGetProcAddress ("glIsSync");
    s_deviceConfig.m_glDeleteSync = (PFNGLDELETESYNCPROC) glewGetProcAddress ("glDeleteSync");
    s_deviceConfig.m_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC) glewGetProcAddress ("glClientWaitSync");
    s_deviceConfig.m_glWaitSync = (PFNGLWAITSYNCPROC) glewGetProcAddress ("glWaitSync");
    s_deviceConfig.m_glGetInteger64v = (PFNGLGETINTEGER64VPROC) glewGetProcAddress ("glGetInteger64v");
    s_deviceConfig.m_glGetSynciv = (PFNGLGETSYNCIVPROC) glewGetProcAddress ("glGetSynciv");
  }

  // GL_ARB_tessellation_shader
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_tessellation_shader])
  {
    s_deviceConfig.m_glPatchParameteri = (PFNGLPATCHPARAMETERIPROC) glewGetProcAddress ("glPatchParameteri");
    s_deviceConfig.m_glPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC) glewGetProcAddress ("glPatchParameterfv");
  }

  // GL_ARB_texture_barrier
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_barrier])
  {
    s_deviceConfig.m_glTextureBarrier = (PFNGLTEXTUREBARRIERPROC) glewGetProcAddress ("glTextureBarrier");
  }

  // GL_ARB_texture_buffer_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_buffer_object])
  {
    s_deviceConfig.m_glTexBufferARB = (PFNGLTEXBUFFERARBPROC) glewGetProcAddress ("glTexBufferARB");
  }

  // GL_ARB_texture_buffer_range
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_buffer_range])
  {
    s_deviceConfig.m_glTexBufferRange = (PFNGLTEXBUFFERRANGEPROC) glewGetProcAddress ("glTexBufferRange");
  }

  // GL_ARB_texture_compression
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_compression])
  {
    s_deviceConfig.m_glCompressedTexImage3DARB = (PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) glewGetProcAddress ("glCompressedTexImage3DARB");
    s_deviceConfig.m_glCompressedTexImage2DARB = (PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) glewGetProcAddress ("glCompressedTexImage2DARB");
    s_deviceConfig.m_glCompressedTexImage1DARB = (PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) glewGetProcAddress ("glCompressedTexImage1DARB");
    s_deviceConfig.m_glCompressedTexSubImage3DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) glewGetProcAddress ("glCompressedTexSubImage3DARB");
    s_deviceConfig.m_glCompressedTexSubImage2DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) glewGetProcAddress ("glCompressedTexSubImage2DARB");
    s_deviceConfig.m_glCompressedTexSubImage1DARB = (PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) glewGetProcAddress ("glCompressedTexSubImage1DARB");
    s_deviceConfig.m_glGetCompressedTexImageARB = (PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) glewGetProcAddress ("glGetCompressedTexImageARB");
  }

  // GL_ARB_texture_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_multisample])
  {
    s_deviceConfig.m_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC) glewGetProcAddress ("glTexImage2DMultisample");
    s_deviceConfig.m_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC) glewGetProcAddress ("glTexImage3DMultisample");
    s_deviceConfig.m_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC) glewGetProcAddress ("glGetMultisamplefv");
    s_deviceConfig.m_glSampleMaski = (PFNGLSAMPLEMASKIPROC) glewGetProcAddress ("glSampleMaski");
  }

  // GL_ARB_texture_storage
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_storage])
  {
    s_deviceConfig.m_glTexStorage1D = (PFNGLTEXSTORAGE1DPROC) glewGetProcAddress ("glTexStorage1D");
    s_deviceConfig.m_glTexStorage2D = (PFNGLTEXSTORAGE2DPROC) glewGetProcAddress ("glTexStorage2D");
    s_deviceConfig.m_glTexStorage3D = (PFNGLTEXSTORAGE3DPROC) glewGetProcAddress ("glTexStorage3D");
  }

  // GL_ARB_texture_storage_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_storage_multisample])
  {
    s_deviceConfig.m_glTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC) glewGetProcAddress ("glTexStorage2DMultisample");
    s_deviceConfig.m_glTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC) glewGetProcAddress ("glTexStorage3DMultisample");
  }

  // GL_ARB_texture_view
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_texture_view])
  {
    s_deviceConfig.m_glTextureView = (PFNGLTEXTUREVIEWPROC) glewGetProcAddress ("glTextureView");
  }

  // GL_ARB_timer_query
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_timer_query])
  {
    s_deviceConfig.m_glQueryCounter = (PFNGLQUERYCOUNTERPROC) glewGetProcAddress ("glQueryCounter");
    s_deviceConfig.m_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC) glewGetProcAddress ("glGetQueryObjecti64v");
    s_deviceConfig.m_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC) glewGetProcAddress ("glGetQueryObjectui64v");
  }

  // GL_ARB_transform_feedback2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback2])
  {
    s_deviceConfig.m_glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glBindTransformFeedback");
    s_deviceConfig.m_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC) glewGetProcAddress ("glDeleteTransformFeedbacks");
    s_deviceConfig.m_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC) glewGetProcAddress ("glGenTransformFeedbacks");
    s_deviceConfig.m_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glIsTransformFeedback");
    s_deviceConfig.m_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC) glewGetProcAddress ("glPauseTransformFeedback");
    s_deviceConfig.m_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC) glewGetProcAddress ("glResumeTransformFeedback");
    s_deviceConfig.m_glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC) glewGetProcAddress ("glDrawTransformFeedback");
  }

  // GL_ARB_transform_feedback3
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback3])
  {
    s_deviceConfig.m_glDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) glewGetProcAddress ("glDrawTransformFeedbackStream");
    s_deviceConfig.m_glBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC) glewGetProcAddress ("glBeginQueryIndexed");
    s_deviceConfig.m_glEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC) glewGetProcAddress ("glEndQueryIndexed");
    s_deviceConfig.m_glGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC) glewGetProcAddress ("glGetQueryIndexediv");
  }

  // GL_ARB_transform_feedback_instanced
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_transform_feedback_instanced])
  {
    s_deviceConfig.m_glDrawTransformFeedbackInstanced = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) glewGetProcAddress ("glDrawTransformFeedbackInstanced");
    s_deviceConfig.m_glDrawTransformFeedbackStreamInstanced = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) glewGetProcAddress ("glDrawTransformFeedbackStreamInstanced");
  }

  // GL_ARB_transpose_matrix
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_transpose_matrix])
  {
    s_deviceConfig.m_glLoadTransposeMatrixfARB = (PFNGLLOADTRANSPOSEMATRIXFARBPROC) glewGetProcAddress ("glLoadTransposeMatrixfARB");
    s_deviceConfig.m_glLoadTransposeMatrixdARB = (PFNGLLOADTRANSPOSEMATRIXDARBPROC) glewGetProcAddress ("glLoadTransposeMatrixdARB");
    s_deviceConfig.m_glMultTransposeMatrixfARB = (PFNGLMULTTRANSPOSEMATRIXFARBPROC) glewGetProcAddress ("glMultTransposeMatrixfARB");
    s_deviceConfig.m_glMultTransposeMatrixdARB = (PFNGLMULTTRANSPOSEMATRIXDARBPROC) glewGetProcAddress ("glMultTransposeMatrixdARB");
  }

  // GL_ARB_uniform_buffer_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_uniform_buffer_object])
  {
    s_deviceConfig.m_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC) glewGetProcAddress ("glGetUniformIndices");
    s_deviceConfig.m_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC) glewGetProcAddress ("glGetActiveUniformsiv");
    s_deviceConfig.m_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC) glewGetProcAddress ("glGetActiveUniformName");
    s_deviceConfig.m_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC) glewGetProcAddress ("glGetUniformBlockIndex");
    s_deviceConfig.m_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC) glewGetProcAddress ("glGetActiveUniformBlockiv");
    s_deviceConfig.m_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) glewGetProcAddress ("glGetActiveUniformBlockName");
    s_deviceConfig.m_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC) glewGetProcAddress ("glUniformBlockBinding");
    s_deviceConfig.m_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC) glewGetProcAddress ("glBindBufferRange");
    s_deviceConfig.m_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC) glewGetProcAddress ("glBindBufferBase");
    s_deviceConfig.m_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC) glewGetProcAddress ("glGetIntegeri_v");
  }

  // GL_ARB_vertex_array_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_array_object])
  {
    s_deviceConfig.m_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC) glewGetProcAddress ("glBindVertexArray");
    s_deviceConfig.m_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC) glewGetProcAddress ("glDeleteVertexArrays");
    s_deviceConfig.m_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC) glewGetProcAddress ("glGenVertexArrays");
    s_deviceConfig.m_glIsVertexArray = (PFNGLISVERTEXARRAYPROC) glewGetProcAddress ("glIsVertexArray");
  }

  // GL_ARB_vertex_attrib_64bit
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_64bit])
  {
    s_deviceConfig.m_glVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC) glewGetProcAddress ("glVertexAttribL1d");
    s_deviceConfig.m_glVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC) glewGetProcAddress ("glVertexAttribL2d");
    s_deviceConfig.m_glVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC) glewGetProcAddress ("glVertexAttribL3d");
    s_deviceConfig.m_glVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC) glewGetProcAddress ("glVertexAttribL4d");
    s_deviceConfig.m_glVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC) glewGetProcAddress ("glVertexAttribL1dv");
    s_deviceConfig.m_glVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC) glewGetProcAddress ("glVertexAttribL2dv");
    s_deviceConfig.m_glVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC) glewGetProcAddress ("glVertexAttribL3dv");
    s_deviceConfig.m_glVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC) glewGetProcAddress ("glVertexAttribL4dv");
    s_deviceConfig.m_glVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC) glewGetProcAddress ("glVertexAttribLPointer");
    s_deviceConfig.m_glGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC) glewGetProcAddress ("glGetVertexAttribLdv");
  }

  // GL_ARB_vertex_attrib_binding
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_attrib_binding])
  {
    s_deviceConfig.m_glBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC) glewGetProcAddress ("glBindVertexBuffer");
    s_deviceConfig.m_glVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC) glewGetProcAddress ("glVertexAttribFormat");
    s_deviceConfig.m_glVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC) glewGetProcAddress ("glVertexAttribIFormat");
    s_deviceConfig.m_glVertexAttribLFormat = (PFNGLVERTEXATTRIBLFORMATPROC) glewGetProcAddress ("glVertexAttribLFormat");
    s_deviceConfig.m_glVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC) glewGetProcAddress ("glVertexAttribBinding");
    s_deviceConfig.m_glVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC) glewGetProcAddress ("glVertexBindingDivisor");
  }

  // GL_ARB_vertex_blend
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_blend])
  {
    s_deviceConfig.m_glWeightbvARB = (PFNGLWEIGHTBVARBPROC) glewGetProcAddress ("glWeightbvARB");
    s_deviceConfig.m_glWeightsvARB = (PFNGLWEIGHTSVARBPROC) glewGetProcAddress ("glWeightsvARB");
    s_deviceConfig.m_glWeightivARB = (PFNGLWEIGHTIVARBPROC) glewGetProcAddress ("glWeightivARB");
    s_deviceConfig.m_glWeightfvARB = (PFNGLWEIGHTFVARBPROC) glewGetProcAddress ("glWeightfvARB");
    s_deviceConfig.m_glWeightdvARB = (PFNGLWEIGHTDVARBPROC) glewGetProcAddress ("glWeightdvARB");
    s_deviceConfig.m_glWeightubvARB = (PFNGLWEIGHTUBVARBPROC) glewGetProcAddress ("glWeightubvARB");
    s_deviceConfig.m_glWeightusvARB = (PFNGLWEIGHTUSVARBPROC) glewGetProcAddress ("glWeightusvARB");
    s_deviceConfig.m_glWeightuivARB = (PFNGLWEIGHTUIVARBPROC) glewGetProcAddress ("glWeightuivARB");
    s_deviceConfig.m_glWeightPointerARB = (PFNGLWEIGHTPOINTERARBPROC) glewGetProcAddress ("glWeightPointerARB");
    s_deviceConfig.m_glVertexBlendARB = (PFNGLVERTEXBLENDARBPROC) glewGetProcAddress ("glVertexBlendARB");
  }

  // GL_ARB_vertex_buffer_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_buffer_object])
  {
    s_deviceConfig.m_glBindBufferARB = (PFNGLBINDBUFFERARBPROC) glewGetProcAddress ("glBindBufferARB");
    s_deviceConfig.m_glDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC) glewGetProcAddress ("glDeleteBuffersARB");
    s_deviceConfig.m_glGenBuffersARB = (PFNGLGENBUFFERSARBPROC) glewGetProcAddress ("glGenBuffersARB");
    s_deviceConfig.m_glIsBufferARB = (PFNGLISBUFFERARBPROC) glewGetProcAddress ("glIsBufferARB");
    s_deviceConfig.m_glBufferDataARB = (PFNGLBUFFERDATAARBPROC) glewGetProcAddress ("glBufferDataARB");
    s_deviceConfig.m_glBufferSubDataARB = (PFNGLBUFFERSUBDATAARBPROC) glewGetProcAddress ("glBufferSubDataARB");
    s_deviceConfig.m_glGetBufferSubDataARB = (PFNGLGETBUFFERSUBDATAARBPROC) glewGetProcAddress ("glGetBufferSubDataARB");
    s_deviceConfig.m_glMapBufferARB = (PFNGLMAPBUFFERARBPROC) glewGetProcAddress ("glMapBufferARB");
    s_deviceConfig.m_glUnmapBufferARB = (PFNGLUNMAPBUFFERARBPROC) glewGetProcAddress ("glUnmapBufferARB");
    s_deviceConfig.m_glGetBufferParameterivARB = (PFNGLGETBUFFERPARAMETERIVARBPROC) glewGetProcAddress ("glGetBufferParameterivARB");
    s_deviceConfig.m_glGetBufferPointervARB = (PFNGLGETBUFFERPOINTERVARBPROC) glewGetProcAddress ("glGetBufferPointervARB");
  }

  // GL_ARB_vertex_program
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_program])
  {
    s_deviceConfig.m_glVertexAttrib1dARB = (PFNGLVERTEXATTRIB1DARBPROC) glewGetProcAddress ("glVertexAttrib1dARB");
    s_deviceConfig.m_glVertexAttrib1dvARB = (PFNGLVERTEXATTRIB1DVARBPROC) glewGetProcAddress ("glVertexAttrib1dvARB");
    s_deviceConfig.m_glVertexAttrib1fARB = (PFNGLVERTEXATTRIB1FARBPROC) glewGetProcAddress ("glVertexAttrib1fARB");
    s_deviceConfig.m_glVertexAttrib1fvARB = (PFNGLVERTEXATTRIB1FVARBPROC) glewGetProcAddress ("glVertexAttrib1fvARB");
    s_deviceConfig.m_glVertexAttrib1sARB = (PFNGLVERTEXATTRIB1SARBPROC) glewGetProcAddress ("glVertexAttrib1sARB");
    s_deviceConfig.m_glVertexAttrib1svARB = (PFNGLVERTEXATTRIB1SVARBPROC) glewGetProcAddress ("glVertexAttrib1svARB");
    s_deviceConfig.m_glVertexAttrib2dARB = (PFNGLVERTEXATTRIB2DARBPROC) glewGetProcAddress ("glVertexAttrib2dARB");
    s_deviceConfig.m_glVertexAttrib2dvARB = (PFNGLVERTEXATTRIB2DVARBPROC) glewGetProcAddress ("glVertexAttrib2dvARB");
    s_deviceConfig.m_glVertexAttrib2fARB = (PFNGLVERTEXATTRIB2FARBPROC) glewGetProcAddress ("glVertexAttrib2fARB");
    s_deviceConfig.m_glVertexAttrib2fvARB = (PFNGLVERTEXATTRIB2FVARBPROC) glewGetProcAddress ("glVertexAttrib2fvARB");
    s_deviceConfig.m_glVertexAttrib2sARB = (PFNGLVERTEXATTRIB2SARBPROC) glewGetProcAddress ("glVertexAttrib2sARB");
    s_deviceConfig.m_glVertexAttrib2svARB = (PFNGLVERTEXATTRIB2SVARBPROC) glewGetProcAddress ("glVertexAttrib2svARB");
    s_deviceConfig.m_glVertexAttrib3dARB = (PFNGLVERTEXATTRIB3DARBPROC) glewGetProcAddress ("glVertexAttrib3dARB");
    s_deviceConfig.m_glVertexAttrib3dvARB = (PFNGLVERTEXATTRIB3DVARBPROC) glewGetProcAddress ("glVertexAttrib3dvARB");
    s_deviceConfig.m_glVertexAttrib3fARB = (PFNGLVERTEXATTRIB3FARBPROC) glewGetProcAddress ("glVertexAttrib3fARB");
    s_deviceConfig.m_glVertexAttrib3fvARB = (PFNGLVERTEXATTRIB3FVARBPROC) glewGetProcAddress ("glVertexAttrib3fvARB");
    s_deviceConfig.m_glVertexAttrib3sARB = (PFNGLVERTEXATTRIB3SARBPROC) glewGetProcAddress ("glVertexAttrib3sARB");
    s_deviceConfig.m_glVertexAttrib3svARB = (PFNGLVERTEXATTRIB3SVARBPROC) glewGetProcAddress ("glVertexAttrib3svARB");
    s_deviceConfig.m_glVertexAttrib4NbvARB = (PFNGLVERTEXATTRIB4NBVARBPROC) glewGetProcAddress ("glVertexAttrib4NbvARB");
    s_deviceConfig.m_glVertexAttrib4NivARB = (PFNGLVERTEXATTRIB4NIVARBPROC) glewGetProcAddress ("glVertexAttrib4NivARB");
    s_deviceConfig.m_glVertexAttrib4NsvARB = (PFNGLVERTEXATTRIB4NSVARBPROC) glewGetProcAddress ("glVertexAttrib4NsvARB");
    s_deviceConfig.m_glVertexAttrib4NubARB = (PFNGLVERTEXATTRIB4NUBARBPROC) glewGetProcAddress ("glVertexAttrib4NubARB");
    s_deviceConfig.m_glVertexAttrib4NubvARB = (PFNGLVERTEXATTRIB4NUBVARBPROC) glewGetProcAddress ("glVertexAttrib4NubvARB");
    s_deviceConfig.m_glVertexAttrib4NuivARB = (PFNGLVERTEXATTRIB4NUIVARBPROC) glewGetProcAddress ("glVertexAttrib4NuivARB");
    s_deviceConfig.m_glVertexAttrib4NusvARB = (PFNGLVERTEXATTRIB4NUSVARBPROC) glewGetProcAddress ("glVertexAttrib4NusvARB");
    s_deviceConfig.m_glVertexAttrib4bvARB = (PFNGLVERTEXATTRIB4BVARBPROC) glewGetProcAddress ("glVertexAttrib4bvARB");
    s_deviceConfig.m_glVertexAttrib4dARB = (PFNGLVERTEXATTRIB4DARBPROC) glewGetProcAddress ("glVertexAttrib4dARB");
    s_deviceConfig.m_glVertexAttrib4dvARB = (PFNGLVERTEXATTRIB4DVARBPROC) glewGetProcAddress ("glVertexAttrib4dvARB");
    s_deviceConfig.m_glVertexAttrib4fARB = (PFNGLVERTEXATTRIB4FARBPROC) glewGetProcAddress ("glVertexAttrib4fARB");
    s_deviceConfig.m_glVertexAttrib4fvARB = (PFNGLVERTEXATTRIB4FVARBPROC) glewGetProcAddress ("glVertexAttrib4fvARB");
    s_deviceConfig.m_glVertexAttrib4ivARB = (PFNGLVERTEXATTRIB4IVARBPROC) glewGetProcAddress ("glVertexAttrib4ivARB");
    s_deviceConfig.m_glVertexAttrib4sARB = (PFNGLVERTEXATTRIB4SARBPROC) glewGetProcAddress ("glVertexAttrib4sARB");
    s_deviceConfig.m_glVertexAttrib4svARB = (PFNGLVERTEXATTRIB4SVARBPROC) glewGetProcAddress ("glVertexAttrib4svARB");
    s_deviceConfig.m_glVertexAttrib4ubvARB = (PFNGLVERTEXATTRIB4UBVARBPROC) glewGetProcAddress ("glVertexAttrib4ubvARB");
    s_deviceConfig.m_glVertexAttrib4uivARB = (PFNGLVERTEXATTRIB4UIVARBPROC) glewGetProcAddress ("glVertexAttrib4uivARB");
    s_deviceConfig.m_glVertexAttrib4usvARB = (PFNGLVERTEXATTRIB4USVARBPROC) glewGetProcAddress ("glVertexAttrib4usvARB");
    s_deviceConfig.m_glVertexAttribPointerARB = (PFNGLVERTEXATTRIBPOINTERARBPROC) glewGetProcAddress ("glVertexAttribPointerARB");
    s_deviceConfig.m_glEnableVertexAttribArrayARB = (PFNGLENABLEVERTEXATTRIBARRAYARBPROC) glewGetProcAddress ("glEnableVertexAttribArrayARB");
    s_deviceConfig.m_glDisableVertexAttribArrayARB = (PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) glewGetProcAddress ("glDisableVertexAttribArrayARB");
    s_deviceConfig.m_glProgramStringARB = (PFNGLPROGRAMSTRINGARBPROC) glewGetProcAddress ("glProgramStringARB");
    s_deviceConfig.m_glBindProgramARB = (PFNGLBINDPROGRAMARBPROC) glewGetProcAddress ("glBindProgramARB");
    s_deviceConfig.m_glDeleteProgramsARB = (PFNGLDELETEPROGRAMSARBPROC) glewGetProcAddress ("glDeleteProgramsARB");
    s_deviceConfig.m_glGenProgramsARB = (PFNGLGENPROGRAMSARBPROC) glewGetProcAddress ("glGenProgramsARB");
    s_deviceConfig.m_glProgramEnvParameter4dARB = (PFNGLPROGRAMENVPARAMETER4DARBPROC) glewGetProcAddress ("glProgramEnvParameter4dARB");
    s_deviceConfig.m_glProgramEnvParameter4dvARB = (PFNGLPROGRAMENVPARAMETER4DVARBPROC) glewGetProcAddress ("glProgramEnvParameter4dvARB");
    s_deviceConfig.m_glProgramEnvParameter4fARB = (PFNGLPROGRAMENVPARAMETER4FARBPROC) glewGetProcAddress ("glProgramEnvParameter4fARB");
    s_deviceConfig.m_glProgramEnvParameter4fvARB = (PFNGLPROGRAMENVPARAMETER4FVARBPROC) glewGetProcAddress ("glProgramEnvParameter4fvARB");
    s_deviceConfig.m_glProgramLocalParameter4dARB = (PFNGLPROGRAMLOCALPARAMETER4DARBPROC) glewGetProcAddress ("glProgramLocalParameter4dARB");
    s_deviceConfig.m_glProgramLocalParameter4dvARB = (PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) glewGetProcAddress ("glProgramLocalParameter4dvARB");
    s_deviceConfig.m_glProgramLocalParameter4fARB = (PFNGLPROGRAMLOCALPARAMETER4FARBPROC) glewGetProcAddress ("glProgramLocalParameter4fARB");
    s_deviceConfig.m_glProgramLocalParameter4fvARB = (PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) glewGetProcAddress ("glProgramLocalParameter4fvARB");
    s_deviceConfig.m_glGetProgramEnvParameterdvARB = (PFNGLGETPROGRAMENVPARAMETERDVARBPROC) glewGetProcAddress ("glGetProgramEnvParameterdvARB");
    s_deviceConfig.m_glGetProgramEnvParameterfvARB = (PFNGLGETPROGRAMENVPARAMETERFVARBPROC) glewGetProcAddress ("glGetProgramEnvParameterfvARB");
    s_deviceConfig.m_glGetProgramLocalParameterdvARB = (PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) glewGetProcAddress ("glGetProgramLocalParameterdvARB");
    s_deviceConfig.m_glGetProgramLocalParameterfvARB = (PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) glewGetProcAddress ("glGetProgramLocalParameterfvARB");
    s_deviceConfig.m_glGetProgramivARB = (PFNGLGETPROGRAMIVARBPROC) glewGetProcAddress ("glGetProgramivARB");
    s_deviceConfig.m_glGetProgramStringARB = (PFNGLGETPROGRAMSTRINGARBPROC) glewGetProcAddress ("glGetProgramStringARB");
    s_deviceConfig.m_glGetVertexAttribdvARB = (PFNGLGETVERTEXATTRIBDVARBPROC) glewGetProcAddress ("glGetVertexAttribdvARB");
    s_deviceConfig.m_glGetVertexAttribfvARB = (PFNGLGETVERTEXATTRIBFVARBPROC) glewGetProcAddress ("glGetVertexAttribfvARB");
    s_deviceConfig.m_glGetVertexAttribivARB = (PFNGLGETVERTEXATTRIBIVARBPROC) glewGetProcAddress ("glGetVertexAttribivARB");
    s_deviceConfig.m_glGetVertexAttribPointervARB = (PFNGLGETVERTEXATTRIBPOINTERVARBPROC) glewGetProcAddress ("glGetVertexAttribPointervARB");
    s_deviceConfig.m_glIsProgramARB = (PFNGLISPROGRAMARBPROC) glewGetProcAddress ("glIsProgramARB");
  }

  // GL_ARB_vertex_shader
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_shader])
  {
    s_deviceConfig.m_glVertexAttrib1fARB = (PFNGLVERTEXATTRIB1FARBPROC) glewGetProcAddress ("glVertexAttrib1fARB");
    s_deviceConfig.m_glVertexAttrib1sARB = (PFNGLVERTEXATTRIB1SARBPROC) glewGetProcAddress ("glVertexAttrib1sARB");
    s_deviceConfig.m_glVertexAttrib1dARB = (PFNGLVERTEXATTRIB1DARBPROC) glewGetProcAddress ("glVertexAttrib1dARB");
    s_deviceConfig.m_glVertexAttrib2fARB = (PFNGLVERTEXATTRIB2FARBPROC) glewGetProcAddress ("glVertexAttrib2fARB");
    s_deviceConfig.m_glVertexAttrib2sARB = (PFNGLVERTEXATTRIB2SARBPROC) glewGetProcAddress ("glVertexAttrib2sARB");
    s_deviceConfig.m_glVertexAttrib2dARB = (PFNGLVERTEXATTRIB2DARBPROC) glewGetProcAddress ("glVertexAttrib2dARB");
    s_deviceConfig.m_glVertexAttrib3fARB = (PFNGLVERTEXATTRIB3FARBPROC) glewGetProcAddress ("glVertexAttrib3fARB");
    s_deviceConfig.m_glVertexAttrib3sARB = (PFNGLVERTEXATTRIB3SARBPROC) glewGetProcAddress ("glVertexAttrib3sARB");
    s_deviceConfig.m_glVertexAttrib3dARB = (PFNGLVERTEXATTRIB3DARBPROC) glewGetProcAddress ("glVertexAttrib3dARB");
    s_deviceConfig.m_glVertexAttrib4fARB = (PFNGLVERTEXATTRIB4FARBPROC) glewGetProcAddress ("glVertexAttrib4fARB");
    s_deviceConfig.m_glVertexAttrib4sARB = (PFNGLVERTEXATTRIB4SARBPROC) glewGetProcAddress ("glVertexAttrib4sARB");
    s_deviceConfig.m_glVertexAttrib4dARB = (PFNGLVERTEXATTRIB4DARBPROC) glewGetProcAddress ("glVertexAttrib4dARB");
    s_deviceConfig.m_glVertexAttrib4NubARB = (PFNGLVERTEXATTRIB4NUBARBPROC) glewGetProcAddress ("glVertexAttrib4NubARB");
    s_deviceConfig.m_glVertexAttrib1fvARB = (PFNGLVERTEXATTRIB1FVARBPROC) glewGetProcAddress ("glVertexAttrib1fvARB");
    s_deviceConfig.m_glVertexAttrib1svARB = (PFNGLVERTEXATTRIB1SVARBPROC) glewGetProcAddress ("glVertexAttrib1svARB");
    s_deviceConfig.m_glVertexAttrib1dvARB = (PFNGLVERTEXATTRIB1DVARBPROC) glewGetProcAddress ("glVertexAttrib1dvARB");
    s_deviceConfig.m_glVertexAttrib2fvARB = (PFNGLVERTEXATTRIB2FVARBPROC) glewGetProcAddress ("glVertexAttrib2fvARB");
    s_deviceConfig.m_glVertexAttrib2svARB = (PFNGLVERTEXATTRIB2SVARBPROC) glewGetProcAddress ("glVertexAttrib2svARB");
    s_deviceConfig.m_glVertexAttrib2dvARB = (PFNGLVERTEXATTRIB2DVARBPROC) glewGetProcAddress ("glVertexAttrib2dvARB");
    s_deviceConfig.m_glVertexAttrib3fvARB = (PFNGLVERTEXATTRIB3FVARBPROC) glewGetProcAddress ("glVertexAttrib3fvARB");
    s_deviceConfig.m_glVertexAttrib3svARB = (PFNGLVERTEXATTRIB3SVARBPROC) glewGetProcAddress ("glVertexAttrib3svARB");
    s_deviceConfig.m_glVertexAttrib3dvARB = (PFNGLVERTEXATTRIB3DVARBPROC) glewGetProcAddress ("glVertexAttrib3dvARB");
    s_deviceConfig.m_glVertexAttrib4fvARB = (PFNGLVERTEXATTRIB4FVARBPROC) glewGetProcAddress ("glVertexAttrib4fvARB");
    s_deviceConfig.m_glVertexAttrib4svARB = (PFNGLVERTEXATTRIB4SVARBPROC) glewGetProcAddress ("glVertexAttrib4svARB");
    s_deviceConfig.m_glVertexAttrib4dvARB = (PFNGLVERTEXATTRIB4DVARBPROC) glewGetProcAddress ("glVertexAttrib4dvARB");
    s_deviceConfig.m_glVertexAttrib4ivARB = (PFNGLVERTEXATTRIB4IVARBPROC) glewGetProcAddress ("glVertexAttrib4ivARB");
    s_deviceConfig.m_glVertexAttrib4bvARB = (PFNGLVERTEXATTRIB4BVARBPROC) glewGetProcAddress ("glVertexAttrib4bvARB");
    s_deviceConfig.m_glVertexAttrib4ubvARB = (PFNGLVERTEXATTRIB4UBVARBPROC) glewGetProcAddress ("glVertexAttrib4ubvARB");
    s_deviceConfig.m_glVertexAttrib4usvARB = (PFNGLVERTEXATTRIB4USVARBPROC) glewGetProcAddress ("glVertexAttrib4usvARB");
    s_deviceConfig.m_glVertexAttrib4uivARB = (PFNGLVERTEXATTRIB4UIVARBPROC) glewGetProcAddress ("glVertexAttrib4uivARB");
    s_deviceConfig.m_glVertexAttrib4NbvARB = (PFNGLVERTEXATTRIB4NBVARBPROC) glewGetProcAddress ("glVertexAttrib4NbvARB");
    s_deviceConfig.m_glVertexAttrib4NsvARB = (PFNGLVERTEXATTRIB4NSVARBPROC) glewGetProcAddress ("glVertexAttrib4NsvARB");
    s_deviceConfig.m_glVertexAttrib4NivARB = (PFNGLVERTEXATTRIB4NIVARBPROC) glewGetProcAddress ("glVertexAttrib4NivARB");
    s_deviceConfig.m_glVertexAttrib4NubvARB = (PFNGLVERTEXATTRIB4NUBVARBPROC) glewGetProcAddress ("glVertexAttrib4NubvARB");
    s_deviceConfig.m_glVertexAttrib4NusvARB = (PFNGLVERTEXATTRIB4NUSVARBPROC) glewGetProcAddress ("glVertexAttrib4NusvARB");
    s_deviceConfig.m_glVertexAttrib4NuivARB = (PFNGLVERTEXATTRIB4NUIVARBPROC) glewGetProcAddress ("glVertexAttrib4NuivARB");
    s_deviceConfig.m_glVertexAttribPointerARB = (PFNGLVERTEXATTRIBPOINTERARBPROC) glewGetProcAddress ("glVertexAttribPointerARB");
    s_deviceConfig.m_glEnableVertexAttribArrayARB = (PFNGLENABLEVERTEXATTRIBARRAYARBPROC) glewGetProcAddress ("glEnableVertexAttribArrayARB");
    s_deviceConfig.m_glDisableVertexAttribArrayARB = (PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) glewGetProcAddress ("glDisableVertexAttribArrayARB");
    s_deviceConfig.m_glBindAttribLocationARB = (PFNGLBINDATTRIBLOCATIONARBPROC) glewGetProcAddress ("glBindAttribLocationARB");
    s_deviceConfig.m_glGetActiveAttribARB = (PFNGLGETACTIVEATTRIBARBPROC) glewGetProcAddress ("glGetActiveAttribARB");
    s_deviceConfig.m_glGetAttribLocationARB = (PFNGLGETATTRIBLOCATIONARBPROC) glewGetProcAddress ("glGetAttribLocationARB");
    s_deviceConfig.m_glGetVertexAttribdvARB = (PFNGLGETVERTEXATTRIBDVARBPROC) glewGetProcAddress ("glGetVertexAttribdvARB");
    s_deviceConfig.m_glGetVertexAttribfvARB = (PFNGLGETVERTEXATTRIBFVARBPROC) glewGetProcAddress ("glGetVertexAttribfvARB");
    s_deviceConfig.m_glGetVertexAttribivARB = (PFNGLGETVERTEXATTRIBIVARBPROC) glewGetProcAddress ("glGetVertexAttribivARB");
    s_deviceConfig.m_glGetVertexAttribPointervARB = (PFNGLGETVERTEXATTRIBPOINTERVARBPROC) glewGetProcAddress ("glGetVertexAttribPointervARB");
  }

  // GL_ARB_vertex_type_2_10_10_10_rev
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_vertex_type_2_10_10_10_rev])
  {
    s_deviceConfig.m_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC) glewGetProcAddress ("glVertexAttribP1ui");
    s_deviceConfig.m_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC) glewGetProcAddress ("glVertexAttribP1uiv");
    s_deviceConfig.m_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC) glewGetProcAddress ("glVertexAttribP2ui");
    s_deviceConfig.m_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC) glewGetProcAddress ("glVertexAttribP2uiv");
    s_deviceConfig.m_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC) glewGetProcAddress ("glVertexAttribP3ui");
    s_deviceConfig.m_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC) glewGetProcAddress ("glVertexAttribP3uiv");
    s_deviceConfig.m_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC) glewGetProcAddress ("glVertexAttribP4ui");
    s_deviceConfig.m_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC) glewGetProcAddress ("glVertexAttribP4uiv");
    s_deviceConfig.m_glVertexP2ui = (PFNGLVERTEXP2UIPROC) glewGetProcAddress ("glVertexP2ui");
    s_deviceConfig.m_glVertexP2uiv = (PFNGLVERTEXP2UIVPROC) glewGetProcAddress ("glVertexP2uiv");
    s_deviceConfig.m_glVertexP3ui = (PFNGLVERTEXP3UIPROC) glewGetProcAddress ("glVertexP3ui");
    s_deviceConfig.m_glVertexP3uiv = (PFNGLVERTEXP3UIVPROC) glewGetProcAddress ("glVertexP3uiv");
    s_deviceConfig.m_glVertexP4ui = (PFNGLVERTEXP4UIPROC) glewGetProcAddress ("glVertexP4ui");
    s_deviceConfig.m_glVertexP4uiv = (PFNGLVERTEXP4UIVPROC) glewGetProcAddress ("glVertexP4uiv");
    s_deviceConfig.m_glTexCoordP1ui = (PFNGLTEXCOORDP1UIPROC) glewGetProcAddress ("glTexCoordP1ui");
    s_deviceConfig.m_glTexCoordP1uiv = (PFNGLTEXCOORDP1UIVPROC) glewGetProcAddress ("glTexCoordP1uiv");
    s_deviceConfig.m_glTexCoordP2ui = (PFNGLTEXCOORDP2UIPROC) glewGetProcAddress ("glTexCoordP2ui");
    s_deviceConfig.m_glTexCoordP2uiv = (PFNGLTEXCOORDP2UIVPROC) glewGetProcAddress ("glTexCoordP2uiv");
    s_deviceConfig.m_glTexCoordP3ui = (PFNGLTEXCOORDP3UIPROC) glewGetProcAddress ("glTexCoordP3ui");
    s_deviceConfig.m_glTexCoordP3uiv = (PFNGLTEXCOORDP3UIVPROC) glewGetProcAddress ("glTexCoordP3uiv");
    s_deviceConfig.m_glTexCoordP4ui = (PFNGLTEXCOORDP4UIPROC) glewGetProcAddress ("glTexCoordP4ui");
    s_deviceConfig.m_glTexCoordP4uiv = (PFNGLTEXCOORDP4UIVPROC) glewGetProcAddress ("glTexCoordP4uiv");
    s_deviceConfig.m_glMultiTexCoordP1ui = (PFNGLMULTITEXCOORDP1UIPROC) glewGetProcAddress ("glMultiTexCoordP1ui");
    s_deviceConfig.m_glMultiTexCoordP1uiv = (PFNGLMULTITEXCOORDP1UIVPROC) glewGetProcAddress ("glMultiTexCoordP1uiv");
    s_deviceConfig.m_glMultiTexCoordP2ui = (PFNGLMULTITEXCOORDP2UIPROC) glewGetProcAddress ("glMultiTexCoordP2ui");
    s_deviceConfig.m_glMultiTexCoordP2uiv = (PFNGLMULTITEXCOORDP2UIVPROC) glewGetProcAddress ("glMultiTexCoordP2uiv");
    s_deviceConfig.m_glMultiTexCoordP3ui = (PFNGLMULTITEXCOORDP3UIPROC) glewGetProcAddress ("glMultiTexCoordP3ui");
    s_deviceConfig.m_glMultiTexCoordP3uiv = (PFNGLMULTITEXCOORDP3UIVPROC) glewGetProcAddress ("glMultiTexCoordP3uiv");
    s_deviceConfig.m_glMultiTexCoordP4ui = (PFNGLMULTITEXCOORDP4UIPROC) glewGetProcAddress ("glMultiTexCoordP4ui");
    s_deviceConfig.m_glMultiTexCoordP4uiv = (PFNGLMULTITEXCOORDP4UIVPROC) glewGetProcAddress ("glMultiTexCoordP4uiv");
    s_deviceConfig.m_glNormalP3ui = (PFNGLNORMALP3UIPROC) glewGetProcAddress ("glNormalP3ui");
    s_deviceConfig.m_glNormalP3uiv = (PFNGLNORMALP3UIVPROC) glewGetProcAddress ("glNormalP3uiv");
    s_deviceConfig.m_glColorP3ui = (PFNGLCOLORP3UIPROC) glewGetProcAddress ("glColorP3ui");
    s_deviceConfig.m_glColorP3uiv = (PFNGLCOLORP3UIVPROC) glewGetProcAddress ("glColorP3uiv");
    s_deviceConfig.m_glColorP4ui = (PFNGLCOLORP4UIPROC) glewGetProcAddress ("glColorP4ui");
    s_deviceConfig.m_glColorP4uiv = (PFNGLCOLORP4UIVPROC) glewGetProcAddress ("glColorP4uiv");
    s_deviceConfig.m_glSecondaryColorP3ui = (PFNGLSECONDARYCOLORP3UIPROC) glewGetProcAddress ("glSecondaryColorP3ui");
    s_deviceConfig.m_glSecondaryColorP3uiv = (PFNGLSECONDARYCOLORP3UIVPROC) glewGetProcAddress ("glSecondaryColorP3uiv");
  }

  // GL_ARB_viewport_array
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_viewport_array])
  {
    s_deviceConfig.m_glViewportArrayv = (PFNGLVIEWPORTARRAYVPROC) glewGetProcAddress ("glViewportArrayv");
    s_deviceConfig.m_glViewportIndexedf = (PFNGLVIEWPORTINDEXEDFPROC) glewGetProcAddress ("glViewportIndexedf");
    s_deviceConfig.m_glViewportIndexedfv = (PFNGLVIEWPORTINDEXEDFVPROC) glewGetProcAddress ("glViewportIndexedfv");
    s_deviceConfig.m_glScissorArrayv = (PFNGLSCISSORARRAYVPROC) glewGetProcAddress ("glScissorArrayv");
    s_deviceConfig.m_glScissorIndexed = (PFNGLSCISSORINDEXEDPROC) glewGetProcAddress ("glScissorIndexed");
    s_deviceConfig.m_glScissorIndexedv = (PFNGLSCISSORINDEXEDVPROC) glewGetProcAddress ("glScissorIndexedv");
    s_deviceConfig.m_glDepthRangeArrayv = (PFNGLDEPTHRANGEARRAYVPROC) glewGetProcAddress ("glDepthRangeArrayv");
    s_deviceConfig.m_glDepthRangeIndexed = (PFNGLDEPTHRANGEINDEXEDPROC) glewGetProcAddress ("glDepthRangeIndexed");
    s_deviceConfig.m_glGetFloati_v = (PFNGLGETFLOATI_VPROC) glewGetProcAddress ("glGetFloati_v");
    s_deviceConfig.m_glGetDoublei_v = (PFNGLGETDOUBLEI_VPROC) glewGetProcAddress ("glGetDoublei_v");
    s_deviceConfig.m_glDepthRangeArraydvNV = (PFNGLDEPTHRANGEARRAYDVNVPROC) glewGetProcAddress ("glDepthRangeArraydvNV");
    s_deviceConfig.m_glDepthRangeIndexeddNV = (PFNGLDEPTHRANGEINDEXEDDNVPROC) glewGetProcAddress ("glDepthRangeIndexeddNV");
  }

  // GL_ARB_window_pos
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARB_window_pos])
  {
    s_deviceConfig.m_glWindowPos2dARB = (PFNGLWINDOWPOS2DARBPROC) glewGetProcAddress ("glWindowPos2dARB");
    s_deviceConfig.m_glWindowPos2dvARB = (PFNGLWINDOWPOS2DVARBPROC) glewGetProcAddress ("glWindowPos2dvARB");
    s_deviceConfig.m_glWindowPos2fARB = (PFNGLWINDOWPOS2FARBPROC) glewGetProcAddress ("glWindowPos2fARB");
    s_deviceConfig.m_glWindowPos2fvARB = (PFNGLWINDOWPOS2FVARBPROC) glewGetProcAddress ("glWindowPos2fvARB");
    s_deviceConfig.m_glWindowPos2iARB = (PFNGLWINDOWPOS2IARBPROC) glewGetProcAddress ("glWindowPos2iARB");
    s_deviceConfig.m_glWindowPos2ivARB = (PFNGLWINDOWPOS2IVARBPROC) glewGetProcAddress ("glWindowPos2ivARB");
    s_deviceConfig.m_glWindowPos2sARB = (PFNGLWINDOWPOS2SARBPROC) glewGetProcAddress ("glWindowPos2sARB");
    s_deviceConfig.m_glWindowPos2svARB = (PFNGLWINDOWPOS2SVARBPROC) glewGetProcAddress ("glWindowPos2svARB");
    s_deviceConfig.m_glWindowPos3dARB = (PFNGLWINDOWPOS3DARBPROC) glewGetProcAddress ("glWindowPos3dARB");
    s_deviceConfig.m_glWindowPos3dvARB = (PFNGLWINDOWPOS3DVARBPROC) glewGetProcAddress ("glWindowPos3dvARB");
    s_deviceConfig.m_glWindowPos3fARB = (PFNGLWINDOWPOS3FARBPROC) glewGetProcAddress ("glWindowPos3fARB");
    s_deviceConfig.m_glWindowPos3fvARB = (PFNGLWINDOWPOS3FVARBPROC) glewGetProcAddress ("glWindowPos3fvARB");
    s_deviceConfig.m_glWindowPos3iARB = (PFNGLWINDOWPOS3IARBPROC) glewGetProcAddress ("glWindowPos3iARB");
    s_deviceConfig.m_glWindowPos3ivARB = (PFNGLWINDOWPOS3IVARBPROC) glewGetProcAddress ("glWindowPos3ivARB");
    s_deviceConfig.m_glWindowPos3sARB = (PFNGLWINDOWPOS3SARBPROC) glewGetProcAddress ("glWindowPos3sARB");
    s_deviceConfig.m_glWindowPos3svARB = (PFNGLWINDOWPOS3SVARBPROC) glewGetProcAddress ("glWindowPos3svARB");
  }

  // GL_ARM_shader_core_properties
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ARM_shader_core_properties])
  {
    s_deviceConfig.m_glMaxActiveShaderCoresARM = (PFNGLMAXACTIVESHADERCORESARMPROC) glewGetProcAddress ("glMaxActiveShaderCoresARM");
  }

  // GL_ATI_draw_buffers
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ATI_draw_buffers])
  {
    s_deviceConfig.m_glDrawBuffersATI = (PFNGLDRAWBUFFERSATIPROC) glewGetProcAddress ("glDrawBuffersATI");
  }

  // GL_ATI_element_array
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ATI_element_array])
  {
    s_deviceConfig.m_glElementPointerATI = (PFNGLELEMENTPOINTERATIPROC) glewGetProcAddress ("glElementPointerATI");
    s_deviceConfig.m_glDrawElementArrayATI = (PFNGLDRAWELEMENTARRAYATIPROC) glewGetProcAddress ("glDrawElementArrayATI");
    s_deviceConfig.m_glDrawRangeElementArrayATI = (PFNGLDRAWRANGEELEMENTARRAYATIPROC) glewGetProcAddress ("glDrawRangeElementArrayATI");
  }

  // GL_ATI_envmap_bumpmap
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ATI_envmap_bumpmap])
  {
    s_deviceConfig.m_glTexBumpParameterivATI = (PFNGLTEXBUMPPARAMETERIVATIPROC) glewGetProcAddress ("glTexBumpParameterivATI");
    s_deviceConfig.m_glTexBumpParameterfvATI = (PFNGLTEXBUMPPARAMETERFVATIPROC) glewGetProcAddress ("glTexBumpParameterfvATI");
    s_deviceConfig.m_glGetTexBumpParameterivATI = (PFNGLGETTEXBUMPPARAMETERIVATIPROC) glewGetProcAddress ("glGetTexBumpParameterivATI");
    s_deviceConfig.m_glGetTexBumpParameterfvATI = (PFNGLGETTEXBUMPPARAMETERFVATIPROC) glewGetProcAddress ("glGetTexBumpParameterfvATI");
  }

  // GL_ATI_fragment_shader
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ATI_fragment_shader])
  {
    s_deviceConfig.m_glGenFragmentShadersATI = (PFNGLGENFRAGMENTSHADERSATIPROC) glewGetProcAddress ("glGenFragmentShadersATI");
    s_deviceConfig.m_glBindFragmentShaderATI = (PFNGLBINDFRAGMENTSHADERATIPROC) glewGetProcAddress ("glBindFragmentShaderATI");
    s_deviceConfig.m_glDeleteFragmentShaderATI = (PFNGLDELETEFRAGMENTSHADERATIPROC) glewGetProcAddress ("glDeleteFragmentShaderATI");
    s_deviceConfig.m_glBeginFragmentShaderATI = (PFNGLBEGINFRAGMENTSHADERATIPROC) glewGetProcAddress ("glBeginFragmentShaderATI");
    s_deviceConfig.m_glEndFragmentShaderATI = (PFNGLENDFRAGMENTSHADERATIPROC) glewGetProcAddress ("glEndFragmentShaderATI");
    s_deviceConfig.m_glPassTexCoordATI = (PFNGLPASSTEXCOORDATIPROC) glewGetProcAddress ("glPassTexCoordATI");
    s_deviceConfig.m_glSampleMapATI = (PFNGLSAMPLEMAPATIPROC) glewGetProcAddress ("glSampleMapATI");
    s_deviceConfig.m_glColorFragmentOp1ATI = (PFNGLCOLORFRAGMENTOP1ATIPROC) glewGetProcAddress ("glColorFragmentOp1ATI");
    s_deviceConfig.m_glColorFragmentOp2ATI = (PFNGLCOLORFRAGMENTOP2ATIPROC) glewGetProcAddress ("glColorFragmentOp2ATI");
    s_deviceConfig.m_glColorFragmentOp3ATI = (PFNGLCOLORFRAGMENTOP3ATIPROC) glewGetProcAddress ("glColorFragmentOp3ATI");
    s_deviceConfig.m_glAlphaFragmentOp1ATI = (PFNGLALPHAFRAGMENTOP1ATIPROC) glewGetProcAddress ("glAlphaFragmentOp1ATI");
    s_deviceConfig.m_glAlphaFragmentOp2ATI = (PFNGLALPHAFRAGMENTOP2ATIPROC) glewGetProcAddress ("glAlphaFragmentOp2ATI");
    s_deviceConfig.m_glAlphaFragmentOp3ATI = (PFNGLALPHAFRAGMENTOP3ATIPROC) glewGetProcAddress ("glAlphaFragmentOp3ATI");
    s_deviceConfig.m_glSetFragmentShaderConstantATI = (PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) glewGetProcAddress ("glSetFragmentShaderConstantATI");
  }

  // GL_ATI_map_object_buffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ATI_map_object_buffer])
  {
    s_deviceConfig.m_glMapObjectBufferATI = (PFNGLMAPOBJECTBUFFERATIPROC) glewGetProcAddress ("glMapObjectBufferATI");
    s_deviceConfig.m_glUnmapObjectBufferATI = (PFNGLUNMAPOBJECTBUFFERATIPROC) glewGetProcAddress ("glUnmapObjectBufferATI");
  }

  // GL_ATI_pn_triangles
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ATI_pn_triangles])
  {
    s_deviceConfig.m_glPNTrianglesiATI = (PFNGLPNTRIANGLESIATIPROC) glewGetProcAddress ("glPNTrianglesiATI");
    s_deviceConfig.m_glPNTrianglesfATI = (PFNGLPNTRIANGLESFATIPROC) glewGetProcAddress ("glPNTrianglesfATI");
  }

  // GL_ATI_separate_stencil
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ATI_separate_stencil])
  {
    s_deviceConfig.m_glStencilOpSeparateATI = (PFNGLSTENCILOPSEPARATEATIPROC) glewGetProcAddress ("glStencilOpSeparateATI");
    s_deviceConfig.m_glStencilFuncSeparateATI = (PFNGLSTENCILFUNCSEPARATEATIPROC) glewGetProcAddress ("glStencilFuncSeparateATI");
  }

  // GL_ATI_vertex_array_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ATI_vertex_array_object])
  {
    s_deviceConfig.m_glNewObjectBufferATI = (PFNGLNEWOBJECTBUFFERATIPROC) glewGetProcAddress ("glNewObjectBufferATI");
    s_deviceConfig.m_glIsObjectBufferATI = (PFNGLISOBJECTBUFFERATIPROC) glewGetProcAddress ("glIsObjectBufferATI");
    s_deviceConfig.m_glUpdateObjectBufferATI = (PFNGLUPDATEOBJECTBUFFERATIPROC) glewGetProcAddress ("glUpdateObjectBufferATI");
    s_deviceConfig.m_glGetObjectBufferfvATI = (PFNGLGETOBJECTBUFFERFVATIPROC) glewGetProcAddress ("glGetObjectBufferfvATI");
    s_deviceConfig.m_glGetObjectBufferivATI = (PFNGLGETOBJECTBUFFERIVATIPROC) glewGetProcAddress ("glGetObjectBufferivATI");
    s_deviceConfig.m_glFreeObjectBufferATI = (PFNGLFREEOBJECTBUFFERATIPROC) glewGetProcAddress ("glFreeObjectBufferATI");
    s_deviceConfig.m_glArrayObjectATI = (PFNGLARRAYOBJECTATIPROC) glewGetProcAddress ("glArrayObjectATI");
    s_deviceConfig.m_glGetArrayObjectfvATI = (PFNGLGETARRAYOBJECTFVATIPROC) glewGetProcAddress ("glGetArrayObjectfvATI");
    s_deviceConfig.m_glGetArrayObjectivATI = (PFNGLGETARRAYOBJECTIVATIPROC) glewGetProcAddress ("glGetArrayObjectivATI");
    s_deviceConfig.m_glVariantArrayObjectATI = (PFNGLVARIANTARRAYOBJECTATIPROC) glewGetProcAddress ("glVariantArrayObjectATI");
    s_deviceConfig.m_glGetVariantArrayObjectfvATI = (PFNGLGETVARIANTARRAYOBJECTFVATIPROC) glewGetProcAddress ("glGetVariantArrayObjectfvATI");
    s_deviceConfig.m_glGetVariantArrayObjectivATI = (PFNGLGETVARIANTARRAYOBJECTIVATIPROC) glewGetProcAddress ("glGetVariantArrayObjectivATI");
  }

  // GL_ATI_vertex_attrib_array_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ATI_vertex_attrib_array_object])
  {
    s_deviceConfig.m_glVertexAttribArrayObjectATI = (PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) glewGetProcAddress ("glVertexAttribArrayObjectATI");
    s_deviceConfig.m_glGetVertexAttribArrayObjectfvATI = (PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) glewGetProcAddress ("glGetVertexAttribArrayObjectfvATI");
    s_deviceConfig.m_glGetVertexAttribArrayObjectivATI = (PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) glewGetProcAddress ("glGetVertexAttribArrayObjectivATI");
  }

  // GL_ATI_vertex_streams
  if (s_deviceConfig.m_featureSupported [GLEW_GL_ATI_vertex_streams])
  {
    s_deviceConfig.m_glVertexStream1sATI = (PFNGLVERTEXSTREAM1SATIPROC) glewGetProcAddress ("glVertexStream1sATI");
    s_deviceConfig.m_glVertexStream1svATI = (PFNGLVERTEXSTREAM1SVATIPROC) glewGetProcAddress ("glVertexStream1svATI");
    s_deviceConfig.m_glVertexStream1iATI = (PFNGLVERTEXSTREAM1IATIPROC) glewGetProcAddress ("glVertexStream1iATI");
    s_deviceConfig.m_glVertexStream1ivATI = (PFNGLVERTEXSTREAM1IVATIPROC) glewGetProcAddress ("glVertexStream1ivATI");
    s_deviceConfig.m_glVertexStream1fATI = (PFNGLVERTEXSTREAM1FATIPROC) glewGetProcAddress ("glVertexStream1fATI");
    s_deviceConfig.m_glVertexStream1fvATI = (PFNGLVERTEXSTREAM1FVATIPROC) glewGetProcAddress ("glVertexStream1fvATI");
    s_deviceConfig.m_glVertexStream1dATI = (PFNGLVERTEXSTREAM1DATIPROC) glewGetProcAddress ("glVertexStream1dATI");
    s_deviceConfig.m_glVertexStream1dvATI = (PFNGLVERTEXSTREAM1DVATIPROC) glewGetProcAddress ("glVertexStream1dvATI");
    s_deviceConfig.m_glVertexStream2sATI = (PFNGLVERTEXSTREAM2SATIPROC) glewGetProcAddress ("glVertexStream2sATI");
    s_deviceConfig.m_glVertexStream2svATI = (PFNGLVERTEXSTREAM2SVATIPROC) glewGetProcAddress ("glVertexStream2svATI");
    s_deviceConfig.m_glVertexStream2iATI = (PFNGLVERTEXSTREAM2IATIPROC) glewGetProcAddress ("glVertexStream2iATI");
    s_deviceConfig.m_glVertexStream2ivATI = (PFNGLVERTEXSTREAM2IVATIPROC) glewGetProcAddress ("glVertexStream2ivATI");
    s_deviceConfig.m_glVertexStream2fATI = (PFNGLVERTEXSTREAM2FATIPROC) glewGetProcAddress ("glVertexStream2fATI");
    s_deviceConfig.m_glVertexStream2fvATI = (PFNGLVERTEXSTREAM2FVATIPROC) glewGetProcAddress ("glVertexStream2fvATI");
    s_deviceConfig.m_glVertexStream2dATI = (PFNGLVERTEXSTREAM2DATIPROC) glewGetProcAddress ("glVertexStream2dATI");
    s_deviceConfig.m_glVertexStream2dvATI = (PFNGLVERTEXSTREAM2DVATIPROC) glewGetProcAddress ("glVertexStream2dvATI");
    s_deviceConfig.m_glVertexStream3sATI = (PFNGLVERTEXSTREAM3SATIPROC) glewGetProcAddress ("glVertexStream3sATI");
    s_deviceConfig.m_glVertexStream3svATI = (PFNGLVERTEXSTREAM3SVATIPROC) glewGetProcAddress ("glVertexStream3svATI");
    s_deviceConfig.m_glVertexStream3iATI = (PFNGLVERTEXSTREAM3IATIPROC) glewGetProcAddress ("glVertexStream3iATI");
    s_deviceConfig.m_glVertexStream3ivATI = (PFNGLVERTEXSTREAM3IVATIPROC) glewGetProcAddress ("glVertexStream3ivATI");
    s_deviceConfig.m_glVertexStream3fATI = (PFNGLVERTEXSTREAM3FATIPROC) glewGetProcAddress ("glVertexStream3fATI");
    s_deviceConfig.m_glVertexStream3fvATI = (PFNGLVERTEXSTREAM3FVATIPROC) glewGetProcAddress ("glVertexStream3fvATI");
    s_deviceConfig.m_glVertexStream3dATI = (PFNGLVERTEXSTREAM3DATIPROC) glewGetProcAddress ("glVertexStream3dATI");
    s_deviceConfig.m_glVertexStream3dvATI = (PFNGLVERTEXSTREAM3DVATIPROC) glewGetProcAddress ("glVertexStream3dvATI");
    s_deviceConfig.m_glVertexStream4sATI = (PFNGLVERTEXSTREAM4SATIPROC) glewGetProcAddress ("glVertexStream4sATI");
    s_deviceConfig.m_glVertexStream4svATI = (PFNGLVERTEXSTREAM4SVATIPROC) glewGetProcAddress ("glVertexStream4svATI");
    s_deviceConfig.m_glVertexStream4iATI = (PFNGLVERTEXSTREAM4IATIPROC) glewGetProcAddress ("glVertexStream4iATI");
    s_deviceConfig.m_glVertexStream4ivATI = (PFNGLVERTEXSTREAM4IVATIPROC) glewGetProcAddress ("glVertexStream4ivATI");
    s_deviceConfig.m_glVertexStream4fATI = (PFNGLVERTEXSTREAM4FATIPROC) glewGetProcAddress ("glVertexStream4fATI");
    s_deviceConfig.m_glVertexStream4fvATI = (PFNGLVERTEXSTREAM4FVATIPROC) glewGetProcAddress ("glVertexStream4fvATI");
    s_deviceConfig.m_glVertexStream4dATI = (PFNGLVERTEXSTREAM4DATIPROC) glewGetProcAddress ("glVertexStream4dATI");
    s_deviceConfig.m_glVertexStream4dvATI = (PFNGLVERTEXSTREAM4DVATIPROC) glewGetProcAddress ("glVertexStream4dvATI");
    s_deviceConfig.m_glNormalStream3bATI = (PFNGLNORMALSTREAM3BATIPROC) glewGetProcAddress ("glNormalStream3bATI");
    s_deviceConfig.m_glNormalStream3bvATI = (PFNGLNORMALSTREAM3BVATIPROC) glewGetProcAddress ("glNormalStream3bvATI");
    s_deviceConfig.m_glNormalStream3sATI = (PFNGLNORMALSTREAM3SATIPROC) glewGetProcAddress ("glNormalStream3sATI");
    s_deviceConfig.m_glNormalStream3svATI = (PFNGLNORMALSTREAM3SVATIPROC) glewGetProcAddress ("glNormalStream3svATI");
    s_deviceConfig.m_glNormalStream3iATI = (PFNGLNORMALSTREAM3IATIPROC) glewGetProcAddress ("glNormalStream3iATI");
    s_deviceConfig.m_glNormalStream3ivATI = (PFNGLNORMALSTREAM3IVATIPROC) glewGetProcAddress ("glNormalStream3ivATI");
    s_deviceConfig.m_glNormalStream3fATI = (PFNGLNORMALSTREAM3FATIPROC) glewGetProcAddress ("glNormalStream3fATI");
    s_deviceConfig.m_glNormalStream3fvATI = (PFNGLNORMALSTREAM3FVATIPROC) glewGetProcAddress ("glNormalStream3fvATI");
    s_deviceConfig.m_glNormalStream3dATI = (PFNGLNORMALSTREAM3DATIPROC) glewGetProcAddress ("glNormalStream3dATI");
    s_deviceConfig.m_glNormalStream3dvATI = (PFNGLNORMALSTREAM3DVATIPROC) glewGetProcAddress ("glNormalStream3dvATI");
    s_deviceConfig.m_glClientActiveVertexStreamATI = (PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) glewGetProcAddress ("glClientActiveVertexStreamATI");
    s_deviceConfig.m_glVertexBlendEnviATI = (PFNGLVERTEXBLENDENVIATIPROC) glewGetProcAddress ("glVertexBlendEnviATI");
    s_deviceConfig.m_glVertexBlendEnvfATI = (PFNGLVERTEXBLENDENVFATIPROC) glewGetProcAddress ("glVertexBlendEnvfATI");
  }

  // GL_EXT_EGL_image_storage
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_EGL_image_storage])
  {
    s_deviceConfig.m_glEGLImageTargetTexStorageEXT = (PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC) glewGetProcAddress ("glEGLImageTargetTexStorageEXT");
    s_deviceConfig.m_glEGLImageTargetTextureStorageEXT = (PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC) glewGetProcAddress ("glEGLImageTargetTextureStorageEXT");
  }

  // GL_EXT_base_instance
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_base_instance])
  {
    s_deviceConfig.m_glDrawArraysInstancedBaseInstanceEXT = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEEXTPROC) glewGetProcAddress ("glDrawArraysInstancedBaseInstanceEXT");
    s_deviceConfig.m_glDrawElementsInstancedBaseInstanceEXT = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEEXTPROC) glewGetProcAddress ("glDrawElementsInstancedBaseInstanceEXT");
    s_deviceConfig.m_glDrawElementsInstancedBaseVertexBaseInstanceEXT = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEEXTPROC) glewGetProcAddress ("glDrawElementsInstancedBaseVertexBaseInstanceEXT");
  }

  // GL_EXT_bindable_uniform
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_bindable_uniform])
  {
    s_deviceConfig.m_glUniformBufferEXT = (PFNGLUNIFORMBUFFEREXTPROC) glewGetProcAddress ("glUniformBufferEXT");
    s_deviceConfig.m_glGetUniformBufferSizeEXT = (PFNGLGETUNIFORMBUFFERSIZEEXTPROC) glewGetProcAddress ("glGetUniformBufferSizeEXT");
    s_deviceConfig.m_glGetUniformOffsetEXT = (PFNGLGETUNIFORMOFFSETEXTPROC) glewGetProcAddress ("glGetUniformOffsetEXT");
  }

  // GL_EXT_blend_color
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_color])
  {
    s_deviceConfig.m_glBlendColorEXT = (PFNGLBLENDCOLOREXTPROC) glewGetProcAddress ("glBlendColorEXT");
  }

  // GL_EXT_blend_equation_separate
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_equation_separate])
  {
    s_deviceConfig.m_glBlendEquationSeparateEXT = (PFNGLBLENDEQUATIONSEPARATEEXTPROC) glewGetProcAddress ("glBlendEquationSeparateEXT");
  }

  // GL_EXT_blend_func_extended
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_func_extended])
  {
    s_deviceConfig.m_glBindFragDataLocationIndexedEXT = (PFNGLBINDFRAGDATALOCATIONINDEXEDEXTPROC) glewGetProcAddress ("glBindFragDataLocationIndexedEXT");
    s_deviceConfig.m_glBindFragDataLocationEXT = (PFNGLBINDFRAGDATALOCATIONEXTPROC) glewGetProcAddress ("glBindFragDataLocationEXT");
    s_deviceConfig.m_glGetProgramResourceLocationIndexEXT = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXEXTPROC) glewGetProcAddress ("glGetProgramResourceLocationIndexEXT");
    s_deviceConfig.m_glGetFragDataIndexEXT = (PFNGLGETFRAGDATAINDEXEXTPROC) glewGetProcAddress ("glGetFragDataIndexEXT");
  }

  // GL_EXT_blend_func_separate
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_func_separate])
  {
    s_deviceConfig.m_glBlendFuncSeparateEXT = (PFNGLBLENDFUNCSEPARATEEXTPROC) glewGetProcAddress ("glBlendFuncSeparateEXT");
  }

  // GL_EXT_blend_minmax
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_blend_minmax])
  {
    s_deviceConfig.m_glBlendEquationEXT = (PFNGLBLENDEQUATIONEXTPROC) glewGetProcAddress ("glBlendEquationEXT");
  }

  // GL_EXT_buffer_storage
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_buffer_storage])
  {
    s_deviceConfig.m_glBufferStorageEXT = (PFNGLBUFFERSTORAGEEXTPROC) glewGetProcAddress ("glBufferStorageEXT");
  }

  // GL_EXT_clear_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_clear_texture])
  {
    s_deviceConfig.m_glClearTexImageEXT = (PFNGLCLEARTEXIMAGEEXTPROC) glewGetProcAddress ("glClearTexImageEXT");
    s_deviceConfig.m_glClearTexSubImageEXT = (PFNGLCLEARTEXSUBIMAGEEXTPROC) glewGetProcAddress ("glClearTexSubImageEXT");
  }

  // GL_EXT_clip_control
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_clip_control])
  {
    s_deviceConfig.m_glClipControlEXT = (PFNGLCLIPCONTROLEXTPROC) glewGetProcAddress ("glClipControlEXT");
  }

  // GL_EXT_color_subtable
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_color_subtable])
  {
    s_deviceConfig.m_glColorSubTableEXT = (PFNGLCOLORSUBTABLEEXTPROC) glewGetProcAddress ("glColorSubTableEXT");
    s_deviceConfig.m_glCopyColorSubTableEXT = (PFNGLCOPYCOLORSUBTABLEEXTPROC) glewGetProcAddress ("glCopyColorSubTableEXT");
  }

  // GL_EXT_compiled_vertex_array
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_compiled_vertex_array])
  {
    s_deviceConfig.m_glLockArraysEXT = (PFNGLLOCKARRAYSEXTPROC) glewGetProcAddress ("glLockArraysEXT");
    s_deviceConfig.m_glUnlockArraysEXT = (PFNGLUNLOCKARRAYSEXTPROC) glewGetProcAddress ("glUnlockArraysEXT");
  }

  // GL_EXT_convolution
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_convolution])
  {
    s_deviceConfig.m_glConvolutionFilter1DEXT = (PFNGLCONVOLUTIONFILTER1DEXTPROC) glewGetProcAddress ("glConvolutionFilter1DEXT");
    s_deviceConfig.m_glConvolutionFilter2DEXT = (PFNGLCONVOLUTIONFILTER2DEXTPROC) glewGetProcAddress ("glConvolutionFilter2DEXT");
    s_deviceConfig.m_glConvolutionParameterfEXT = (PFNGLCONVOLUTIONPARAMETERFEXTPROC) glewGetProcAddress ("glConvolutionParameterfEXT");
    s_deviceConfig.m_glConvolutionParameterfvEXT = (PFNGLCONVOLUTIONPARAMETERFVEXTPROC) glewGetProcAddress ("glConvolutionParameterfvEXT");
    s_deviceConfig.m_glConvolutionParameteriEXT = (PFNGLCONVOLUTIONPARAMETERIEXTPROC) glewGetProcAddress ("glConvolutionParameteriEXT");
    s_deviceConfig.m_glConvolutionParameterivEXT = (PFNGLCONVOLUTIONPARAMETERIVEXTPROC) glewGetProcAddress ("glConvolutionParameterivEXT");
    s_deviceConfig.m_glCopyConvolutionFilter1DEXT = (PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) glewGetProcAddress ("glCopyConvolutionFilter1DEXT");
    s_deviceConfig.m_glCopyConvolutionFilter2DEXT = (PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) glewGetProcAddress ("glCopyConvolutionFilter2DEXT");
    s_deviceConfig.m_glGetConvolutionFilterEXT = (PFNGLGETCONVOLUTIONFILTEREXTPROC) glewGetProcAddress ("glGetConvolutionFilterEXT");
    s_deviceConfig.m_glGetConvolutionParameterfvEXT = (PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) glewGetProcAddress ("glGetConvolutionParameterfvEXT");
    s_deviceConfig.m_glGetConvolutionParameterivEXT = (PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) glewGetProcAddress ("glGetConvolutionParameterivEXT");
    s_deviceConfig.m_glGetSeparableFilterEXT = (PFNGLGETSEPARABLEFILTEREXTPROC) glewGetProcAddress ("glGetSeparableFilterEXT");
    s_deviceConfig.m_glSeparableFilter2DEXT = (PFNGLSEPARABLEFILTER2DEXTPROC) glewGetProcAddress ("glSeparableFilter2DEXT");
  }

  // GL_EXT_coordinate_frame
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_coordinate_frame])
  {
    s_deviceConfig.m_glTangent3bEXT = (PFNGLTANGENT3BEXTPROC) glewGetProcAddress ("glTangent3bEXT");
    s_deviceConfig.m_glTangent3bvEXT = (PFNGLTANGENT3BVEXTPROC) glewGetProcAddress ("glTangent3bvEXT");
    s_deviceConfig.m_glTangent3dEXT = (PFNGLTANGENT3DEXTPROC) glewGetProcAddress ("glTangent3dEXT");
    s_deviceConfig.m_glTangent3dvEXT = (PFNGLTANGENT3DVEXTPROC) glewGetProcAddress ("glTangent3dvEXT");
    s_deviceConfig.m_glTangent3fEXT = (PFNGLTANGENT3FEXTPROC) glewGetProcAddress ("glTangent3fEXT");
    s_deviceConfig.m_glTangent3fvEXT = (PFNGLTANGENT3FVEXTPROC) glewGetProcAddress ("glTangent3fvEXT");
    s_deviceConfig.m_glTangent3iEXT = (PFNGLTANGENT3IEXTPROC) glewGetProcAddress ("glTangent3iEXT");
    s_deviceConfig.m_glTangent3ivEXT = (PFNGLTANGENT3IVEXTPROC) glewGetProcAddress ("glTangent3ivEXT");
    s_deviceConfig.m_glTangent3sEXT = (PFNGLTANGENT3SEXTPROC) glewGetProcAddress ("glTangent3sEXT");
    s_deviceConfig.m_glTangent3svEXT = (PFNGLTANGENT3SVEXTPROC) glewGetProcAddress ("glTangent3svEXT");
    s_deviceConfig.m_glBinormal3bEXT = (PFNGLBINORMAL3BEXTPROC) glewGetProcAddress ("glBinormal3bEXT");
    s_deviceConfig.m_glBinormal3bvEXT = (PFNGLBINORMAL3BVEXTPROC) glewGetProcAddress ("glBinormal3bvEXT");
    s_deviceConfig.m_glBinormal3dEXT = (PFNGLBINORMAL3DEXTPROC) glewGetProcAddress ("glBinormal3dEXT");
    s_deviceConfig.m_glBinormal3dvEXT = (PFNGLBINORMAL3DVEXTPROC) glewGetProcAddress ("glBinormal3dvEXT");
    s_deviceConfig.m_glBinormal3fEXT = (PFNGLBINORMAL3FEXTPROC) glewGetProcAddress ("glBinormal3fEXT");
    s_deviceConfig.m_glBinormal3fvEXT = (PFNGLBINORMAL3FVEXTPROC) glewGetProcAddress ("glBinormal3fvEXT");
    s_deviceConfig.m_glBinormal3iEXT = (PFNGLBINORMAL3IEXTPROC) glewGetProcAddress ("glBinormal3iEXT");
    s_deviceConfig.m_glBinormal3ivEXT = (PFNGLBINORMAL3IVEXTPROC) glewGetProcAddress ("glBinormal3ivEXT");
    s_deviceConfig.m_glBinormal3sEXT = (PFNGLBINORMAL3SEXTPROC) glewGetProcAddress ("glBinormal3sEXT");
    s_deviceConfig.m_glBinormal3svEXT = (PFNGLBINORMAL3SVEXTPROC) glewGetProcAddress ("glBinormal3svEXT");
    s_deviceConfig.m_glTangentPointerEXT = (PFNGLTANGENTPOINTEREXTPROC) glewGetProcAddress ("glTangentPointerEXT");
    s_deviceConfig.m_glBinormalPointerEXT = (PFNGLBINORMALPOINTEREXTPROC) glewGetProcAddress ("glBinormalPointerEXT");
  }

  // GL_EXT_copy_image
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_copy_image])
  {
    s_deviceConfig.m_glCopyImageSubDataEXT = (PFNGLCOPYIMAGESUBDATAEXTPROC) glewGetProcAddress ("glCopyImageSubDataEXT");
  }

  // GL_EXT_copy_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_copy_texture])
  {
    s_deviceConfig.m_glCopyTexImage1DEXT = (PFNGLCOPYTEXIMAGE1DEXTPROC) glewGetProcAddress ("glCopyTexImage1DEXT");
    s_deviceConfig.m_glCopyTexImage2DEXT = (PFNGLCOPYTEXIMAGE2DEXTPROC) glewGetProcAddress ("glCopyTexImage2DEXT");
    s_deviceConfig.m_glCopyTexSubImage1DEXT = (PFNGLCOPYTEXSUBIMAGE1DEXTPROC) glewGetProcAddress ("glCopyTexSubImage1DEXT");
    s_deviceConfig.m_glCopyTexSubImage2DEXT = (PFNGLCOPYTEXSUBIMAGE2DEXTPROC) glewGetProcAddress ("glCopyTexSubImage2DEXT");
    s_deviceConfig.m_glCopyTexSubImage3DEXT = (PFNGLCOPYTEXSUBIMAGE3DEXTPROC) glewGetProcAddress ("glCopyTexSubImage3DEXT");
  }

  // GL_EXT_cull_vertex
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_cull_vertex])
  {
    s_deviceConfig.m_glCullParameterdvEXT = (PFNGLCULLPARAMETERDVEXTPROC) glewGetProcAddress ("glCullParameterdvEXT");
    s_deviceConfig.m_glCullParameterfvEXT = (PFNGLCULLPARAMETERFVEXTPROC) glewGetProcAddress ("glCullParameterfvEXT");
  }

  // GL_EXT_debug_label
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_debug_label])
  {
    s_deviceConfig.m_glLabelObjectEXT = (PFNGLLABELOBJECTEXTPROC) glewGetProcAddress ("glLabelObjectEXT");
    s_deviceConfig.m_glGetObjectLabelEXT = (PFNGLGETOBJECTLABELEXTPROC) glewGetProcAddress ("glGetObjectLabelEXT");
  }

  // GL_EXT_debug_marker
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_debug_marker])
  {
    s_deviceConfig.m_glInsertEventMarkerEXT = (PFNGLINSERTEVENTMARKEREXTPROC) glewGetProcAddress ("glInsertEventMarkerEXT");
    s_deviceConfig.m_glPushGroupMarkerEXT = (PFNGLPUSHGROUPMARKEREXTPROC) glewGetProcAddress ("glPushGroupMarkerEXT");
    s_deviceConfig.m_glPopGroupMarkerEXT = (PFNGLPOPGROUPMARKEREXTPROC) glewGetProcAddress ("glPopGroupMarkerEXT");
  }

  // GL_EXT_depth_bounds_test
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_depth_bounds_test])
  {
    s_deviceConfig.m_glDepthBoundsEXT = (PFNGLDEPTHBOUNDSEXTPROC) glewGetProcAddress ("glDepthBoundsEXT");
  }

  // GL_EXT_direct_state_access
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_direct_state_access])
  {
    s_deviceConfig.m_glMatrixLoadfEXT = (PFNGLMATRIXLOADFEXTPROC) glewGetProcAddress ("glMatrixLoadfEXT");
    s_deviceConfig.m_glMatrixLoaddEXT = (PFNGLMATRIXLOADDEXTPROC) glewGetProcAddress ("glMatrixLoaddEXT");
    s_deviceConfig.m_glMatrixMultfEXT = (PFNGLMATRIXMULTFEXTPROC) glewGetProcAddress ("glMatrixMultfEXT");
    s_deviceConfig.m_glMatrixMultdEXT = (PFNGLMATRIXMULTDEXTPROC) glewGetProcAddress ("glMatrixMultdEXT");
    s_deviceConfig.m_glMatrixLoadIdentityEXT = (PFNGLMATRIXLOADIDENTITYEXTPROC) glewGetProcAddress ("glMatrixLoadIdentityEXT");
    s_deviceConfig.m_glMatrixRotatefEXT = (PFNGLMATRIXROTATEFEXTPROC) glewGetProcAddress ("glMatrixRotatefEXT");
    s_deviceConfig.m_glMatrixRotatedEXT = (PFNGLMATRIXROTATEDEXTPROC) glewGetProcAddress ("glMatrixRotatedEXT");
    s_deviceConfig.m_glMatrixScalefEXT = (PFNGLMATRIXSCALEFEXTPROC) glewGetProcAddress ("glMatrixScalefEXT");
    s_deviceConfig.m_glMatrixScaledEXT = (PFNGLMATRIXSCALEDEXTPROC) glewGetProcAddress ("glMatrixScaledEXT");
    s_deviceConfig.m_glMatrixTranslatefEXT = (PFNGLMATRIXTRANSLATEFEXTPROC) glewGetProcAddress ("glMatrixTranslatefEXT");
    s_deviceConfig.m_glMatrixTranslatedEXT = (PFNGLMATRIXTRANSLATEDEXTPROC) glewGetProcAddress ("glMatrixTranslatedEXT");
    s_deviceConfig.m_glMatrixFrustumEXT = (PFNGLMATRIXFRUSTUMEXTPROC) glewGetProcAddress ("glMatrixFrustumEXT");
    s_deviceConfig.m_glMatrixOrthoEXT = (PFNGLMATRIXORTHOEXTPROC) glewGetProcAddress ("glMatrixOrthoEXT");
    s_deviceConfig.m_glMatrixPopEXT = (PFNGLMATRIXPOPEXTPROC) glewGetProcAddress ("glMatrixPopEXT");
    s_deviceConfig.m_glMatrixPushEXT = (PFNGLMATRIXPUSHEXTPROC) glewGetProcAddress ("glMatrixPushEXT");
    s_deviceConfig.m_glClientAttribDefaultEXT = (PFNGLCLIENTATTRIBDEFAULTEXTPROC) glewGetProcAddress ("glClientAttribDefaultEXT");
    s_deviceConfig.m_glPushClientAttribDefaultEXT = (PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) glewGetProcAddress ("glPushClientAttribDefaultEXT");
    s_deviceConfig.m_glTextureParameterfEXT = (PFNGLTEXTUREPARAMETERFEXTPROC) glewGetProcAddress ("glTextureParameterfEXT");
    s_deviceConfig.m_glTextureParameterfvEXT = (PFNGLTEXTUREPARAMETERFVEXTPROC) glewGetProcAddress ("glTextureParameterfvEXT");
    s_deviceConfig.m_glTextureParameteriEXT = (PFNGLTEXTUREPARAMETERIEXTPROC) glewGetProcAddress ("glTextureParameteriEXT");
    s_deviceConfig.m_glTextureParameterivEXT = (PFNGLTEXTUREPARAMETERIVEXTPROC) glewGetProcAddress ("glTextureParameterivEXT");
    s_deviceConfig.m_glTextureImage1DEXT = (PFNGLTEXTUREIMAGE1DEXTPROC) glewGetProcAddress ("glTextureImage1DEXT");
    s_deviceConfig.m_glTextureImage2DEXT = (PFNGLTEXTUREIMAGE2DEXTPROC) glewGetProcAddress ("glTextureImage2DEXT");
    s_deviceConfig.m_glTextureSubImage1DEXT = (PFNGLTEXTURESUBIMAGE1DEXTPROC) glewGetProcAddress ("glTextureSubImage1DEXT");
    s_deviceConfig.m_glTextureSubImage2DEXT = (PFNGLTEXTURESUBIMAGE2DEXTPROC) glewGetProcAddress ("glTextureSubImage2DEXT");
    s_deviceConfig.m_glCopyTextureImage1DEXT = (PFNGLCOPYTEXTUREIMAGE1DEXTPROC) glewGetProcAddress ("glCopyTextureImage1DEXT");
    s_deviceConfig.m_glCopyTextureImage2DEXT = (PFNGLCOPYTEXTUREIMAGE2DEXTPROC) glewGetProcAddress ("glCopyTextureImage2DEXT");
    s_deviceConfig.m_glCopyTextureSubImage1DEXT = (PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) glewGetProcAddress ("glCopyTextureSubImage1DEXT");
    s_deviceConfig.m_glCopyTextureSubImage2DEXT = (PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) glewGetProcAddress ("glCopyTextureSubImage2DEXT");
    s_deviceConfig.m_glGetTextureImageEXT = (PFNGLGETTEXTUREIMAGEEXTPROC) glewGetProcAddress ("glGetTextureImageEXT");
    s_deviceConfig.m_glGetTextureParameterfvEXT = (PFNGLGETTEXTUREPARAMETERFVEXTPROC) glewGetProcAddress ("glGetTextureParameterfvEXT");
    s_deviceConfig.m_glGetTextureParameterivEXT = (PFNGLGETTEXTUREPARAMETERIVEXTPROC) glewGetProcAddress ("glGetTextureParameterivEXT");
    s_deviceConfig.m_glGetTextureLevelParameterfvEXT = (PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) glewGetProcAddress ("glGetTextureLevelParameterfvEXT");
    s_deviceConfig.m_glGetTextureLevelParameterivEXT = (PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) glewGetProcAddress ("glGetTextureLevelParameterivEXT");
    s_deviceConfig.m_glTextureImage3DEXT = (PFNGLTEXTUREIMAGE3DEXTPROC) glewGetProcAddress ("glTextureImage3DEXT");
    s_deviceConfig.m_glTextureSubImage3DEXT = (PFNGLTEXTURESUBIMAGE3DEXTPROC) glewGetProcAddress ("glTextureSubImage3DEXT");
    s_deviceConfig.m_glCopyTextureSubImage3DEXT = (PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) glewGetProcAddress ("glCopyTextureSubImage3DEXT");
    s_deviceConfig.m_glBindMultiTextureEXT = (PFNGLBINDMULTITEXTUREEXTPROC) glewGetProcAddress ("glBindMultiTextureEXT");
    s_deviceConfig.m_glMultiTexCoordPointerEXT = (PFNGLMULTITEXCOORDPOINTEREXTPROC) glewGetProcAddress ("glMultiTexCoordPointerEXT");
    s_deviceConfig.m_glMultiTexEnvfEXT = (PFNGLMULTITEXENVFEXTPROC) glewGetProcAddress ("glMultiTexEnvfEXT");
    s_deviceConfig.m_glMultiTexEnvfvEXT = (PFNGLMULTITEXENVFVEXTPROC) glewGetProcAddress ("glMultiTexEnvfvEXT");
    s_deviceConfig.m_glMultiTexEnviEXT = (PFNGLMULTITEXENVIEXTPROC) glewGetProcAddress ("glMultiTexEnviEXT");
    s_deviceConfig.m_glMultiTexEnvivEXT = (PFNGLMULTITEXENVIVEXTPROC) glewGetProcAddress ("glMultiTexEnvivEXT");
    s_deviceConfig.m_glMultiTexGendEXT = (PFNGLMULTITEXGENDEXTPROC) glewGetProcAddress ("glMultiTexGendEXT");
    s_deviceConfig.m_glMultiTexGendvEXT = (PFNGLMULTITEXGENDVEXTPROC) glewGetProcAddress ("glMultiTexGendvEXT");
    s_deviceConfig.m_glMultiTexGenfEXT = (PFNGLMULTITEXGENFEXTPROC) glewGetProcAddress ("glMultiTexGenfEXT");
    s_deviceConfig.m_glMultiTexGenfvEXT = (PFNGLMULTITEXGENFVEXTPROC) glewGetProcAddress ("glMultiTexGenfvEXT");
    s_deviceConfig.m_glMultiTexGeniEXT = (PFNGLMULTITEXGENIEXTPROC) glewGetProcAddress ("glMultiTexGeniEXT");
    s_deviceConfig.m_glMultiTexGenivEXT = (PFNGLMULTITEXGENIVEXTPROC) glewGetProcAddress ("glMultiTexGenivEXT");
    s_deviceConfig.m_glGetMultiTexEnvfvEXT = (PFNGLGETMULTITEXENVFVEXTPROC) glewGetProcAddress ("glGetMultiTexEnvfvEXT");
    s_deviceConfig.m_glGetMultiTexEnvivEXT = (PFNGLGETMULTITEXENVIVEXTPROC) glewGetProcAddress ("glGetMultiTexEnvivEXT");
    s_deviceConfig.m_glGetMultiTexGendvEXT = (PFNGLGETMULTITEXGENDVEXTPROC) glewGetProcAddress ("glGetMultiTexGendvEXT");
    s_deviceConfig.m_glGetMultiTexGenfvEXT = (PFNGLGETMULTITEXGENFVEXTPROC) glewGetProcAddress ("glGetMultiTexGenfvEXT");
    s_deviceConfig.m_glGetMultiTexGenivEXT = (PFNGLGETMULTITEXGENIVEXTPROC) glewGetProcAddress ("glGetMultiTexGenivEXT");
    s_deviceConfig.m_glMultiTexParameteriEXT = (PFNGLMULTITEXPARAMETERIEXTPROC) glewGetProcAddress ("glMultiTexParameteriEXT");
    s_deviceConfig.m_glMultiTexParameterivEXT = (PFNGLMULTITEXPARAMETERIVEXTPROC) glewGetProcAddress ("glMultiTexParameterivEXT");
    s_deviceConfig.m_glMultiTexParameterfEXT = (PFNGLMULTITEXPARAMETERFEXTPROC) glewGetProcAddress ("glMultiTexParameterfEXT");
    s_deviceConfig.m_glMultiTexParameterfvEXT = (PFNGLMULTITEXPARAMETERFVEXTPROC) glewGetProcAddress ("glMultiTexParameterfvEXT");
    s_deviceConfig.m_glMultiTexImage1DEXT = (PFNGLMULTITEXIMAGE1DEXTPROC) glewGetProcAddress ("glMultiTexImage1DEXT");
    s_deviceConfig.m_glMultiTexImage2DEXT = (PFNGLMULTITEXIMAGE2DEXTPROC) glewGetProcAddress ("glMultiTexImage2DEXT");
    s_deviceConfig.m_glMultiTexSubImage1DEXT = (PFNGLMULTITEXSUBIMAGE1DEXTPROC) glewGetProcAddress ("glMultiTexSubImage1DEXT");
    s_deviceConfig.m_glMultiTexSubImage2DEXT = (PFNGLMULTITEXSUBIMAGE2DEXTPROC) glewGetProcAddress ("glMultiTexSubImage2DEXT");
    s_deviceConfig.m_glCopyMultiTexImage1DEXT = (PFNGLCOPYMULTITEXIMAGE1DEXTPROC) glewGetProcAddress ("glCopyMultiTexImage1DEXT");
    s_deviceConfig.m_glCopyMultiTexImage2DEXT = (PFNGLCOPYMULTITEXIMAGE2DEXTPROC) glewGetProcAddress ("glCopyMultiTexImage2DEXT");
    s_deviceConfig.m_glCopyMultiTexSubImage1DEXT = (PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) glewGetProcAddress ("glCopyMultiTexSubImage1DEXT");
    s_deviceConfig.m_glCopyMultiTexSubImage2DEXT = (PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) glewGetProcAddress ("glCopyMultiTexSubImage2DEXT");
    s_deviceConfig.m_glGetMultiTexImageEXT = (PFNGLGETMULTITEXIMAGEEXTPROC) glewGetProcAddress ("glGetMultiTexImageEXT");
    s_deviceConfig.m_glGetMultiTexParameterfvEXT = (PFNGLGETMULTITEXPARAMETERFVEXTPROC) glewGetProcAddress ("glGetMultiTexParameterfvEXT");
    s_deviceConfig.m_glGetMultiTexParameterivEXT = (PFNGLGETMULTITEXPARAMETERIVEXTPROC) glewGetProcAddress ("glGetMultiTexParameterivEXT");
    s_deviceConfig.m_glGetMultiTexLevelParameterfvEXT = (PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) glewGetProcAddress ("glGetMultiTexLevelParameterfvEXT");
    s_deviceConfig.m_glGetMultiTexLevelParameterivEXT = (PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) glewGetProcAddress ("glGetMultiTexLevelParameterivEXT");
    s_deviceConfig.m_glMultiTexImage3DEXT = (PFNGLMULTITEXIMAGE3DEXTPROC) glewGetProcAddress ("glMultiTexImage3DEXT");
    s_deviceConfig.m_glMultiTexSubImage3DEXT = (PFNGLMULTITEXSUBIMAGE3DEXTPROC) glewGetProcAddress ("glMultiTexSubImage3DEXT");
    s_deviceConfig.m_glCopyMultiTexSubImage3DEXT = (PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) glewGetProcAddress ("glCopyMultiTexSubImage3DEXT");
    s_deviceConfig.m_glEnableClientStateIndexedEXT = (PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) glewGetProcAddress ("glEnableClientStateIndexedEXT");
    s_deviceConfig.m_glDisableClientStateIndexedEXT = (PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) glewGetProcAddress ("glDisableClientStateIndexedEXT");
    s_deviceConfig.m_glGetFloatIndexedvEXT = (PFNGLGETFLOATINDEXEDVEXTPROC) glewGetProcAddress ("glGetFloatIndexedvEXT");
    s_deviceConfig.m_glGetDoubleIndexedvEXT = (PFNGLGETDOUBLEINDEXEDVEXTPROC) glewGetProcAddress ("glGetDoubleIndexedvEXT");
    s_deviceConfig.m_glGetPointerIndexedvEXT = (PFNGLGETPOINTERINDEXEDVEXTPROC) glewGetProcAddress ("glGetPointerIndexedvEXT");
    s_deviceConfig.m_glEnableIndexedEXT = (PFNGLENABLEINDEXEDEXTPROC) glewGetProcAddress ("glEnableIndexedEXT");
    s_deviceConfig.m_glDisableIndexedEXT = (PFNGLDISABLEINDEXEDEXTPROC) glewGetProcAddress ("glDisableIndexedEXT");
    s_deviceConfig.m_glIsEnabledIndexedEXT = (PFNGLISENABLEDINDEXEDEXTPROC) glewGetProcAddress ("glIsEnabledIndexedEXT");
    s_deviceConfig.m_glGetIntegerIndexedvEXT = (PFNGLGETINTEGERINDEXEDVEXTPROC) glewGetProcAddress ("glGetIntegerIndexedvEXT");
    s_deviceConfig.m_glGetBooleanIndexedvEXT = (PFNGLGETBOOLEANINDEXEDVEXTPROC) glewGetProcAddress ("glGetBooleanIndexedvEXT");
    s_deviceConfig.m_glCompressedTextureImage3DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) glewGetProcAddress ("glCompressedTextureImage3DEXT");
    s_deviceConfig.m_glCompressedTextureImage2DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) glewGetProcAddress ("glCompressedTextureImage2DEXT");
    s_deviceConfig.m_glCompressedTextureImage1DEXT = (PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) glewGetProcAddress ("glCompressedTextureImage1DEXT");
    s_deviceConfig.m_glCompressedTextureSubImage3DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) glewGetProcAddress ("glCompressedTextureSubImage3DEXT");
    s_deviceConfig.m_glCompressedTextureSubImage2DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) glewGetProcAddress ("glCompressedTextureSubImage2DEXT");
    s_deviceConfig.m_glCompressedTextureSubImage1DEXT = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) glewGetProcAddress ("glCompressedTextureSubImage1DEXT");
    s_deviceConfig.m_glGetCompressedTextureImageEXT = (PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) glewGetProcAddress ("glGetCompressedTextureImageEXT");
    s_deviceConfig.m_glCompressedMultiTexImage3DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) glewGetProcAddress ("glCompressedMultiTexImage3DEXT");
    s_deviceConfig.m_glCompressedMultiTexImage2DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) glewGetProcAddress ("glCompressedMultiTexImage2DEXT");
    s_deviceConfig.m_glCompressedMultiTexImage1DEXT = (PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) glewGetProcAddress ("glCompressedMultiTexImage1DEXT");
    s_deviceConfig.m_glCompressedMultiTexSubImage3DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) glewGetProcAddress ("glCompressedMultiTexSubImage3DEXT");
    s_deviceConfig.m_glCompressedMultiTexSubImage2DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) glewGetProcAddress ("glCompressedMultiTexSubImage2DEXT");
    s_deviceConfig.m_glCompressedMultiTexSubImage1DEXT = (PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) glewGetProcAddress ("glCompressedMultiTexSubImage1DEXT");
    s_deviceConfig.m_glGetCompressedMultiTexImageEXT = (PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) glewGetProcAddress ("glGetCompressedMultiTexImageEXT");
    s_deviceConfig.m_glMatrixLoadTransposefEXT = (PFNGLMATRIXLOADTRANSPOSEFEXTPROC) glewGetProcAddress ("glMatrixLoadTransposefEXT");
    s_deviceConfig.m_glMatrixLoadTransposedEXT = (PFNGLMATRIXLOADTRANSPOSEDEXTPROC) glewGetProcAddress ("glMatrixLoadTransposedEXT");
    s_deviceConfig.m_glMatrixMultTransposefEXT = (PFNGLMATRIXMULTTRANSPOSEFEXTPROC) glewGetProcAddress ("glMatrixMultTransposefEXT");
    s_deviceConfig.m_glMatrixMultTransposedEXT = (PFNGLMATRIXMULTTRANSPOSEDEXTPROC) glewGetProcAddress ("glMatrixMultTransposedEXT");
    s_deviceConfig.m_glNamedBufferDataEXT = (PFNGLNAMEDBUFFERDATAEXTPROC) glewGetProcAddress ("glNamedBufferDataEXT");
    s_deviceConfig.m_glNamedBufferSubDataEXT = (PFNGLNAMEDBUFFERSUBDATAEXTPROC) glewGetProcAddress ("glNamedBufferSubDataEXT");
    s_deviceConfig.m_glMapNamedBufferEXT = (PFNGLMAPNAMEDBUFFEREXTPROC) glewGetProcAddress ("glMapNamedBufferEXT");
    s_deviceConfig.m_glUnmapNamedBufferEXT = (PFNGLUNMAPNAMEDBUFFEREXTPROC) glewGetProcAddress ("glUnmapNamedBufferEXT");
    s_deviceConfig.m_glGetNamedBufferParameterivEXT = (PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) glewGetProcAddress ("glGetNamedBufferParameterivEXT");
    s_deviceConfig.m_glGetNamedBufferPointervEXT = (PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) glewGetProcAddress ("glGetNamedBufferPointervEXT");
    s_deviceConfig.m_glGetNamedBufferSubDataEXT = (PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) glewGetProcAddress ("glGetNamedBufferSubDataEXT");
    s_deviceConfig.m_glProgramUniform1fEXT = (PFNGLPROGRAMUNIFORM1FEXTPROC) glewGetProcAddress ("glProgramUniform1fEXT");
    s_deviceConfig.m_glProgramUniform2fEXT = (PFNGLPROGRAMUNIFORM2FEXTPROC) glewGetProcAddress ("glProgramUniform2fEXT");
    s_deviceConfig.m_glProgramUniform3fEXT = (PFNGLPROGRAMUNIFORM3FEXTPROC) glewGetProcAddress ("glProgramUniform3fEXT");
    s_deviceConfig.m_glProgramUniform4fEXT = (PFNGLPROGRAMUNIFORM4FEXTPROC) glewGetProcAddress ("glProgramUniform4fEXT");
    s_deviceConfig.m_glProgramUniform1iEXT = (PFNGLPROGRAMUNIFORM1IEXTPROC) glewGetProcAddress ("glProgramUniform1iEXT");
    s_deviceConfig.m_glProgramUniform2iEXT = (PFNGLPROGRAMUNIFORM2IEXTPROC) glewGetProcAddress ("glProgramUniform2iEXT");
    s_deviceConfig.m_glProgramUniform3iEXT = (PFNGLPROGRAMUNIFORM3IEXTPROC) glewGetProcAddress ("glProgramUniform3iEXT");
    s_deviceConfig.m_glProgramUniform4iEXT = (PFNGLPROGRAMUNIFORM4IEXTPROC) glewGetProcAddress ("glProgramUniform4iEXT");
    s_deviceConfig.m_glProgramUniform1fvEXT = (PFNGLPROGRAMUNIFORM1FVEXTPROC) glewGetProcAddress ("glProgramUniform1fvEXT");
    s_deviceConfig.m_glProgramUniform2fvEXT = (PFNGLPROGRAMUNIFORM2FVEXTPROC) glewGetProcAddress ("glProgramUniform2fvEXT");
    s_deviceConfig.m_glProgramUniform3fvEXT = (PFNGLPROGRAMUNIFORM3FVEXTPROC) glewGetProcAddress ("glProgramUniform3fvEXT");
    s_deviceConfig.m_glProgramUniform4fvEXT = (PFNGLPROGRAMUNIFORM4FVEXTPROC) glewGetProcAddress ("glProgramUniform4fvEXT");
    s_deviceConfig.m_glProgramUniform1ivEXT = (PFNGLPROGRAMUNIFORM1IVEXTPROC) glewGetProcAddress ("glProgramUniform1ivEXT");
    s_deviceConfig.m_glProgramUniform2ivEXT = (PFNGLPROGRAMUNIFORM2IVEXTPROC) glewGetProcAddress ("glProgramUniform2ivEXT");
    s_deviceConfig.m_glProgramUniform3ivEXT = (PFNGLPROGRAMUNIFORM3IVEXTPROC) glewGetProcAddress ("glProgramUniform3ivEXT");
    s_deviceConfig.m_glProgramUniform4ivEXT = (PFNGLPROGRAMUNIFORM4IVEXTPROC) glewGetProcAddress ("glProgramUniform4ivEXT");
    s_deviceConfig.m_glProgramUniformMatrix2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix2fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix3fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix4fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix2x3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix2x3fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix3x2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix3x2fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix2x4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix2x4fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix4x2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix4x2fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix3x4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix3x4fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix4x3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix4x3fvEXT");
    s_deviceConfig.m_glTextureBufferEXT = (PFNGLTEXTUREBUFFEREXTPROC) glewGetProcAddress ("glTextureBufferEXT");
    s_deviceConfig.m_glMultiTexBufferEXT = (PFNGLMULTITEXBUFFEREXTPROC) glewGetProcAddress ("glMultiTexBufferEXT");
    s_deviceConfig.m_glTextureParameterIivEXT = (PFNGLTEXTUREPARAMETERIIVEXTPROC) glewGetProcAddress ("glTextureParameterIivEXT");
    s_deviceConfig.m_glTextureParameterIuivEXT = (PFNGLTEXTUREPARAMETERIUIVEXTPROC) glewGetProcAddress ("glTextureParameterIuivEXT");
    s_deviceConfig.m_glGetTextureParameterIivEXT = (PFNGLGETTEXTUREPARAMETERIIVEXTPROC) glewGetProcAddress ("glGetTextureParameterIivEXT");
    s_deviceConfig.m_glGetTextureParameterIuivEXT = (PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) glewGetProcAddress ("glGetTextureParameterIuivEXT");
    s_deviceConfig.m_glMultiTexParameterIivEXT = (PFNGLMULTITEXPARAMETERIIVEXTPROC) glewGetProcAddress ("glMultiTexParameterIivEXT");
    s_deviceConfig.m_glMultiTexParameterIuivEXT = (PFNGLMULTITEXPARAMETERIUIVEXTPROC) glewGetProcAddress ("glMultiTexParameterIuivEXT");
    s_deviceConfig.m_glGetMultiTexParameterIivEXT = (PFNGLGETMULTITEXPARAMETERIIVEXTPROC) glewGetProcAddress ("glGetMultiTexParameterIivEXT");
    s_deviceConfig.m_glGetMultiTexParameterIuivEXT = (PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) glewGetProcAddress ("glGetMultiTexParameterIuivEXT");
    s_deviceConfig.m_glProgramUniform1uiEXT = (PFNGLPROGRAMUNIFORM1UIEXTPROC) glewGetProcAddress ("glProgramUniform1uiEXT");
    s_deviceConfig.m_glProgramUniform2uiEXT = (PFNGLPROGRAMUNIFORM2UIEXTPROC) glewGetProcAddress ("glProgramUniform2uiEXT");
    s_deviceConfig.m_glProgramUniform3uiEXT = (PFNGLPROGRAMUNIFORM3UIEXTPROC) glewGetProcAddress ("glProgramUniform3uiEXT");
    s_deviceConfig.m_glProgramUniform4uiEXT = (PFNGLPROGRAMUNIFORM4UIEXTPROC) glewGetProcAddress ("glProgramUniform4uiEXT");
    s_deviceConfig.m_glProgramUniform1uivEXT = (PFNGLPROGRAMUNIFORM1UIVEXTPROC) glewGetProcAddress ("glProgramUniform1uivEXT");
    s_deviceConfig.m_glProgramUniform2uivEXT = (PFNGLPROGRAMUNIFORM2UIVEXTPROC) glewGetProcAddress ("glProgramUniform2uivEXT");
    s_deviceConfig.m_glProgramUniform3uivEXT = (PFNGLPROGRAMUNIFORM3UIVEXTPROC) glewGetProcAddress ("glProgramUniform3uivEXT");
    s_deviceConfig.m_glProgramUniform4uivEXT = (PFNGLPROGRAMUNIFORM4UIVEXTPROC) glewGetProcAddress ("glProgramUniform4uivEXT");
    s_deviceConfig.m_glNamedProgramLocalParameters4fvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) glewGetProcAddress ("glNamedProgramLocalParameters4fvEXT");
    s_deviceConfig.m_glNamedProgramLocalParameterI4iEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) glewGetProcAddress ("glNamedProgramLocalParameterI4iEXT");
    s_deviceConfig.m_glNamedProgramLocalParameterI4ivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) glewGetProcAddress ("glNamedProgramLocalParameterI4ivEXT");
    s_deviceConfig.m_glNamedProgramLocalParametersI4ivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) glewGetProcAddress ("glNamedProgramLocalParametersI4ivEXT");
    s_deviceConfig.m_glNamedProgramLocalParameterI4uiEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) glewGetProcAddress ("glNamedProgramLocalParameterI4uiEXT");
    s_deviceConfig.m_glNamedProgramLocalParameterI4uivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) glewGetProcAddress ("glNamedProgramLocalParameterI4uivEXT");
    s_deviceConfig.m_glNamedProgramLocalParametersI4uivEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) glewGetProcAddress ("glNamedProgramLocalParametersI4uivEXT");
    s_deviceConfig.m_glGetNamedProgramLocalParameterIivEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) glewGetProcAddress ("glGetNamedProgramLocalParameterIivEXT");
    s_deviceConfig.m_glGetNamedProgramLocalParameterIuivEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) glewGetProcAddress ("glGetNamedProgramLocalParameterIuivEXT");
    s_deviceConfig.m_glEnableClientStateiEXT = (PFNGLENABLECLIENTSTATEIEXTPROC) glewGetProcAddress ("glEnableClientStateiEXT");
    s_deviceConfig.m_glDisableClientStateiEXT = (PFNGLDISABLECLIENTSTATEIEXTPROC) glewGetProcAddress ("glDisableClientStateiEXT");
    s_deviceConfig.m_glGetFloati_vEXT = (PFNGLGETFLOATI_VEXTPROC) glewGetProcAddress ("glGetFloati_vEXT");
    s_deviceConfig.m_glGetDoublei_vEXT = (PFNGLGETDOUBLEI_VEXTPROC) glewGetProcAddress ("glGetDoublei_vEXT");
    s_deviceConfig.m_glGetPointeri_vEXT = (PFNGLGETPOINTERI_VEXTPROC) glewGetProcAddress ("glGetPointeri_vEXT");
    s_deviceConfig.m_glNamedProgramStringEXT = (PFNGLNAMEDPROGRAMSTRINGEXTPROC) glewGetProcAddress ("glNamedProgramStringEXT");
    s_deviceConfig.m_glNamedProgramLocalParameter4dEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) glewGetProcAddress ("glNamedProgramLocalParameter4dEXT");
    s_deviceConfig.m_glNamedProgramLocalParameter4dvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) glewGetProcAddress ("glNamedProgramLocalParameter4dvEXT");
    s_deviceConfig.m_glNamedProgramLocalParameter4fEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) glewGetProcAddress ("glNamedProgramLocalParameter4fEXT");
    s_deviceConfig.m_glNamedProgramLocalParameter4fvEXT = (PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) glewGetProcAddress ("glNamedProgramLocalParameter4fvEXT");
    s_deviceConfig.m_glGetNamedProgramLocalParameterdvEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) glewGetProcAddress ("glGetNamedProgramLocalParameterdvEXT");
    s_deviceConfig.m_glGetNamedProgramLocalParameterfvEXT = (PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) glewGetProcAddress ("glGetNamedProgramLocalParameterfvEXT");
    s_deviceConfig.m_glGetNamedProgramivEXT = (PFNGLGETNAMEDPROGRAMIVEXTPROC) glewGetProcAddress ("glGetNamedProgramivEXT");
    s_deviceConfig.m_glGetNamedProgramStringEXT = (PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) glewGetProcAddress ("glGetNamedProgramStringEXT");
    s_deviceConfig.m_glNamedRenderbufferStorageEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) glewGetProcAddress ("glNamedRenderbufferStorageEXT");
    s_deviceConfig.m_glGetNamedRenderbufferParameterivEXT = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) glewGetProcAddress ("glGetNamedRenderbufferParameterivEXT");
    s_deviceConfig.m_glNamedRenderbufferStorageMultisampleEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) glewGetProcAddress ("glNamedRenderbufferStorageMultisampleEXT");
    s_deviceConfig.m_glNamedRenderbufferStorageMultisampleCoverageEXT = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) glewGetProcAddress ("glNamedRenderbufferStorageMultisampleCoverageEXT");
    s_deviceConfig.m_glCheckNamedFramebufferStatusEXT = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) glewGetProcAddress ("glCheckNamedFramebufferStatusEXT");
    s_deviceConfig.m_glNamedFramebufferTexture1DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) glewGetProcAddress ("glNamedFramebufferTexture1DEXT");
    s_deviceConfig.m_glNamedFramebufferTexture2DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) glewGetProcAddress ("glNamedFramebufferTexture2DEXT");
    s_deviceConfig.m_glNamedFramebufferTexture3DEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) glewGetProcAddress ("glNamedFramebufferTexture3DEXT");
    s_deviceConfig.m_glNamedFramebufferRenderbufferEXT = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) glewGetProcAddress ("glNamedFramebufferRenderbufferEXT");
    s_deviceConfig.m_glGetNamedFramebufferAttachmentParameterivEXT = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) glewGetProcAddress ("glGetNamedFramebufferAttachmentParameterivEXT");
    s_deviceConfig.m_glGenerateTextureMipmapEXT = (PFNGLGENERATETEXTUREMIPMAPEXTPROC) glewGetProcAddress ("glGenerateTextureMipmapEXT");
    s_deviceConfig.m_glGenerateMultiTexMipmapEXT = (PFNGLGENERATEMULTITEXMIPMAPEXTPROC) glewGetProcAddress ("glGenerateMultiTexMipmapEXT");
    s_deviceConfig.m_glFramebufferDrawBufferEXT = (PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) glewGetProcAddress ("glFramebufferDrawBufferEXT");
    s_deviceConfig.m_glFramebufferDrawBuffersEXT = (PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) glewGetProcAddress ("glFramebufferDrawBuffersEXT");
    s_deviceConfig.m_glFramebufferReadBufferEXT = (PFNGLFRAMEBUFFERREADBUFFEREXTPROC) glewGetProcAddress ("glFramebufferReadBufferEXT");
    s_deviceConfig.m_glGetFramebufferParameterivEXT = (PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) glewGetProcAddress ("glGetFramebufferParameterivEXT");
    s_deviceConfig.m_glNamedCopyBufferSubDataEXT = (PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) glewGetProcAddress ("glNamedCopyBufferSubDataEXT");
    s_deviceConfig.m_glNamedFramebufferTextureEXT = (PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) glewGetProcAddress ("glNamedFramebufferTextureEXT");
    s_deviceConfig.m_glNamedFramebufferTextureLayerEXT = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) glewGetProcAddress ("glNamedFramebufferTextureLayerEXT");
    s_deviceConfig.m_glNamedFramebufferTextureFaceEXT = (PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) glewGetProcAddress ("glNamedFramebufferTextureFaceEXT");
    s_deviceConfig.m_glTextureRenderbufferEXT = (PFNGLTEXTURERENDERBUFFEREXTPROC) glewGetProcAddress ("glTextureRenderbufferEXT");
    s_deviceConfig.m_glMultiTexRenderbufferEXT = (PFNGLMULTITEXRENDERBUFFEREXTPROC) glewGetProcAddress ("glMultiTexRenderbufferEXT");
    s_deviceConfig.m_glVertexArrayVertexOffsetEXT = (PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) glewGetProcAddress ("glVertexArrayVertexOffsetEXT");
    s_deviceConfig.m_glVertexArrayColorOffsetEXT = (PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) glewGetProcAddress ("glVertexArrayColorOffsetEXT");
    s_deviceConfig.m_glVertexArrayEdgeFlagOffsetEXT = (PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) glewGetProcAddress ("glVertexArrayEdgeFlagOffsetEXT");
    s_deviceConfig.m_glVertexArrayIndexOffsetEXT = (PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) glewGetProcAddress ("glVertexArrayIndexOffsetEXT");
    s_deviceConfig.m_glVertexArrayNormalOffsetEXT = (PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) glewGetProcAddress ("glVertexArrayNormalOffsetEXT");
    s_deviceConfig.m_glVertexArrayTexCoordOffsetEXT = (PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) glewGetProcAddress ("glVertexArrayTexCoordOffsetEXT");
    s_deviceConfig.m_glVertexArrayMultiTexCoordOffsetEXT = (PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) glewGetProcAddress ("glVertexArrayMultiTexCoordOffsetEXT");
    s_deviceConfig.m_glVertexArrayFogCoordOffsetEXT = (PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) glewGetProcAddress ("glVertexArrayFogCoordOffsetEXT");
    s_deviceConfig.m_glVertexArraySecondaryColorOffsetEXT = (PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) glewGetProcAddress ("glVertexArraySecondaryColorOffsetEXT");
    s_deviceConfig.m_glVertexArrayVertexAttribOffsetEXT = (PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) glewGetProcAddress ("glVertexArrayVertexAttribOffsetEXT");
    s_deviceConfig.m_glVertexArrayVertexAttribIOffsetEXT = (PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) glewGetProcAddress ("glVertexArrayVertexAttribIOffsetEXT");
    s_deviceConfig.m_glEnableVertexArrayEXT = (PFNGLENABLEVERTEXARRAYEXTPROC) glewGetProcAddress ("glEnableVertexArrayEXT");
    s_deviceConfig.m_glDisableVertexArrayEXT = (PFNGLDISABLEVERTEXARRAYEXTPROC) glewGetProcAddress ("glDisableVertexArrayEXT");
    s_deviceConfig.m_glEnableVertexArrayAttribEXT = (PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) glewGetProcAddress ("glEnableVertexArrayAttribEXT");
    s_deviceConfig.m_glDisableVertexArrayAttribEXT = (PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) glewGetProcAddress ("glDisableVertexArrayAttribEXT");
    s_deviceConfig.m_glGetVertexArrayIntegervEXT = (PFNGLGETVERTEXARRAYINTEGERVEXTPROC) glewGetProcAddress ("glGetVertexArrayIntegervEXT");
    s_deviceConfig.m_glGetVertexArrayPointervEXT = (PFNGLGETVERTEXARRAYPOINTERVEXTPROC) glewGetProcAddress ("glGetVertexArrayPointervEXT");
    s_deviceConfig.m_glGetVertexArrayIntegeri_vEXT = (PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) glewGetProcAddress ("glGetVertexArrayIntegeri_vEXT");
    s_deviceConfig.m_glGetVertexArrayPointeri_vEXT = (PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) glewGetProcAddress ("glGetVertexArrayPointeri_vEXT");
    s_deviceConfig.m_glMapNamedBufferRangeEXT = (PFNGLMAPNAMEDBUFFERRANGEEXTPROC) glewGetProcAddress ("glMapNamedBufferRangeEXT");
    s_deviceConfig.m_glFlushMappedNamedBufferRangeEXT = (PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) glewGetProcAddress ("glFlushMappedNamedBufferRangeEXT");
    s_deviceConfig.m_glNamedBufferStorageEXT = (PFNGLNAMEDBUFFERSTORAGEEXTPROC) glewGetProcAddress ("glNamedBufferStorageEXT");
    s_deviceConfig.m_glClearNamedBufferDataEXT = (PFNGLCLEARNAMEDBUFFERDATAEXTPROC) glewGetProcAddress ("glClearNamedBufferDataEXT");
    s_deviceConfig.m_glClearNamedBufferSubDataEXT = (PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) glewGetProcAddress ("glClearNamedBufferSubDataEXT");
    s_deviceConfig.m_glNamedFramebufferParameteriEXT = (PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) glewGetProcAddress ("glNamedFramebufferParameteriEXT");
    s_deviceConfig.m_glGetNamedFramebufferParameterivEXT = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) glewGetProcAddress ("glGetNamedFramebufferParameterivEXT");
    s_deviceConfig.m_glProgramUniform1dEXT = (PFNGLPROGRAMUNIFORM1DEXTPROC) glewGetProcAddress ("glProgramUniform1dEXT");
    s_deviceConfig.m_glProgramUniform2dEXT = (PFNGLPROGRAMUNIFORM2DEXTPROC) glewGetProcAddress ("glProgramUniform2dEXT");
    s_deviceConfig.m_glProgramUniform3dEXT = (PFNGLPROGRAMUNIFORM3DEXTPROC) glewGetProcAddress ("glProgramUniform3dEXT");
    s_deviceConfig.m_glProgramUniform4dEXT = (PFNGLPROGRAMUNIFORM4DEXTPROC) glewGetProcAddress ("glProgramUniform4dEXT");
    s_deviceConfig.m_glProgramUniform1dvEXT = (PFNGLPROGRAMUNIFORM1DVEXTPROC) glewGetProcAddress ("glProgramUniform1dvEXT");
    s_deviceConfig.m_glProgramUniform2dvEXT = (PFNGLPROGRAMUNIFORM2DVEXTPROC) glewGetProcAddress ("glProgramUniform2dvEXT");
    s_deviceConfig.m_glProgramUniform3dvEXT = (PFNGLPROGRAMUNIFORM3DVEXTPROC) glewGetProcAddress ("glProgramUniform3dvEXT");
    s_deviceConfig.m_glProgramUniform4dvEXT = (PFNGLPROGRAMUNIFORM4DVEXTPROC) glewGetProcAddress ("glProgramUniform4dvEXT");
    s_deviceConfig.m_glProgramUniformMatrix2dvEXT = (PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix2dvEXT");
    s_deviceConfig.m_glProgramUniformMatrix3dvEXT = (PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix3dvEXT");
    s_deviceConfig.m_glProgramUniformMatrix4dvEXT = (PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix4dvEXT");
    s_deviceConfig.m_glProgramUniformMatrix2x3dvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix2x3dvEXT");
    s_deviceConfig.m_glProgramUniformMatrix2x4dvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix2x4dvEXT");
    s_deviceConfig.m_glProgramUniformMatrix3x2dvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix3x2dvEXT");
    s_deviceConfig.m_glProgramUniformMatrix3x4dvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix3x4dvEXT");
    s_deviceConfig.m_glProgramUniformMatrix4x2dvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix4x2dvEXT");
    s_deviceConfig.m_glProgramUniformMatrix4x3dvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix4x3dvEXT");
    s_deviceConfig.m_glTextureBufferRangeEXT = (PFNGLTEXTUREBUFFERRANGEEXTPROC) glewGetProcAddress ("glTextureBufferRangeEXT");
    s_deviceConfig.m_glTextureStorage1DEXT = (PFNGLTEXTURESTORAGE1DEXTPROC) glewGetProcAddress ("glTextureStorage1DEXT");
    s_deviceConfig.m_glTextureStorage2DEXT = (PFNGLTEXTURESTORAGE2DEXTPROC) glewGetProcAddress ("glTextureStorage2DEXT");
    s_deviceConfig.m_glTextureStorage3DEXT = (PFNGLTEXTURESTORAGE3DEXTPROC) glewGetProcAddress ("glTextureStorage3DEXT");
    s_deviceConfig.m_glTextureStorage2DMultisampleEXT = (PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) glewGetProcAddress ("glTextureStorage2DMultisampleEXT");
    s_deviceConfig.m_glTextureStorage3DMultisampleEXT = (PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) glewGetProcAddress ("glTextureStorage3DMultisampleEXT");
    s_deviceConfig.m_glVertexArrayBindVertexBufferEXT = (PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) glewGetProcAddress ("glVertexArrayBindVertexBufferEXT");
    s_deviceConfig.m_glVertexArrayVertexAttribFormatEXT = (PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) glewGetProcAddress ("glVertexArrayVertexAttribFormatEXT");
    s_deviceConfig.m_glVertexArrayVertexAttribIFormatEXT = (PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) glewGetProcAddress ("glVertexArrayVertexAttribIFormatEXT");
    s_deviceConfig.m_glVertexArrayVertexAttribLFormatEXT = (PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) glewGetProcAddress ("glVertexArrayVertexAttribLFormatEXT");
    s_deviceConfig.m_glVertexArrayVertexAttribBindingEXT = (PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) glewGetProcAddress ("glVertexArrayVertexAttribBindingEXT");
    s_deviceConfig.m_glVertexArrayVertexBindingDivisorEXT = (PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) glewGetProcAddress ("glVertexArrayVertexBindingDivisorEXT");
    s_deviceConfig.m_glVertexArrayVertexAttribLOffsetEXT = (PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) glewGetProcAddress ("glVertexArrayVertexAttribLOffsetEXT");
    s_deviceConfig.m_glTexturePageCommitmentEXT = (PFNGLTEXTUREPAGECOMMITMENTEXTPROC) glewGetProcAddress ("glTexturePageCommitmentEXT");
    s_deviceConfig.m_glVertexArrayVertexAttribDivisorEXT = (PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC) glewGetProcAddress ("glVertexArrayVertexAttribDivisorEXT");
  }

  // GL_EXT_discard_framebuffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_discard_framebuffer])
  {
    s_deviceConfig.m_glDiscardFramebufferEXT = (PFNGLDISCARDFRAMEBUFFEREXTPROC) glewGetProcAddress ("glDiscardFramebufferEXT");
  }

  // GL_EXT_disjoint_timer_query
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_disjoint_timer_query])
  {
    s_deviceConfig.m_glGenQueriesEXT = (PFNGLGENQUERIESEXTPROC) glewGetProcAddress ("glGenQueriesEXT");
    s_deviceConfig.m_glDeleteQueriesEXT = (PFNGLDELETEQUERIESEXTPROC) glewGetProcAddress ("glDeleteQueriesEXT");
    s_deviceConfig.m_glIsQueryEXT = (PFNGLISQUERYEXTPROC) glewGetProcAddress ("glIsQueryEXT");
    s_deviceConfig.m_glBeginQueryEXT = (PFNGLBEGINQUERYEXTPROC) glewGetProcAddress ("glBeginQueryEXT");
    s_deviceConfig.m_glEndQueryEXT = (PFNGLENDQUERYEXTPROC) glewGetProcAddress ("glEndQueryEXT");
    s_deviceConfig.m_glQueryCounterEXT = (PFNGLQUERYCOUNTEREXTPROC) glewGetProcAddress ("glQueryCounterEXT");
    s_deviceConfig.m_glGetQueryivEXT = (PFNGLGETQUERYIVEXTPROC) glewGetProcAddress ("glGetQueryivEXT");
    s_deviceConfig.m_glGetQueryObjectivEXT = (PFNGLGETQUERYOBJECTIVEXTPROC) glewGetProcAddress ("glGetQueryObjectivEXT");
    s_deviceConfig.m_glGetQueryObjectuivEXT = (PFNGLGETQUERYOBJECTUIVEXTPROC) glewGetProcAddress ("glGetQueryObjectuivEXT");
    s_deviceConfig.m_glGetQueryObjecti64vEXT = (PFNGLGETQUERYOBJECTI64VEXTPROC) glewGetProcAddress ("glGetQueryObjecti64vEXT");
    s_deviceConfig.m_glGetQueryObjectui64vEXT = (PFNGLGETQUERYOBJECTUI64VEXTPROC) glewGetProcAddress ("glGetQueryObjectui64vEXT");
    s_deviceConfig.m_glGetInteger64vEXT = (PFNGLGETINTEGER64VEXTPROC) glewGetProcAddress ("glGetInteger64vEXT");
  }

  // GL_EXT_draw_buffers
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers])
  {
    s_deviceConfig.m_glDrawBuffersEXT = (PFNGLDRAWBUFFERSEXTPROC) glewGetProcAddress ("glDrawBuffersEXT");
  }

  // GL_EXT_draw_buffers2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers2])
  {
    s_deviceConfig.m_glColorMaskIndexedEXT = (PFNGLCOLORMASKINDEXEDEXTPROC) glewGetProcAddress ("glColorMaskIndexedEXT");
    s_deviceConfig.m_glGetBooleanIndexedvEXT = (PFNGLGETBOOLEANINDEXEDVEXTPROC) glewGetProcAddress ("glGetBooleanIndexedvEXT");
    s_deviceConfig.m_glGetIntegerIndexedvEXT = (PFNGLGETINTEGERINDEXEDVEXTPROC) glewGetProcAddress ("glGetIntegerIndexedvEXT");
    s_deviceConfig.m_glEnableIndexedEXT = (PFNGLENABLEINDEXEDEXTPROC) glewGetProcAddress ("glEnableIndexedEXT");
    s_deviceConfig.m_glDisableIndexedEXT = (PFNGLDISABLEINDEXEDEXTPROC) glewGetProcAddress ("glDisableIndexedEXT");
    s_deviceConfig.m_glIsEnabledIndexedEXT = (PFNGLISENABLEDINDEXEDEXTPROC) glewGetProcAddress ("glIsEnabledIndexedEXT");
  }

  // GL_EXT_draw_buffers_indexed
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_buffers_indexed])
  {
    s_deviceConfig.m_glEnableiEXT = (PFNGLENABLEIEXTPROC) glewGetProcAddress ("glEnableiEXT");
    s_deviceConfig.m_glDisableiEXT = (PFNGLDISABLEIEXTPROC) glewGetProcAddress ("glDisableiEXT");
    s_deviceConfig.m_glBlendEquationiEXT = (PFNGLBLENDEQUATIONIEXTPROC) glewGetProcAddress ("glBlendEquationiEXT");
    s_deviceConfig.m_glBlendEquationSeparateiEXT = (PFNGLBLENDEQUATIONSEPARATEIEXTPROC) glewGetProcAddress ("glBlendEquationSeparateiEXT");
    s_deviceConfig.m_glBlendFunciEXT = (PFNGLBLENDFUNCIEXTPROC) glewGetProcAddress ("glBlendFunciEXT");
    s_deviceConfig.m_glBlendFuncSeparateiEXT = (PFNGLBLENDFUNCSEPARATEIEXTPROC) glewGetProcAddress ("glBlendFuncSeparateiEXT");
    s_deviceConfig.m_glColorMaskiEXT = (PFNGLCOLORMASKIEXTPROC) glewGetProcAddress ("glColorMaskiEXT");
    s_deviceConfig.m_glIsEnablediEXT = (PFNGLISENABLEDIEXTPROC) glewGetProcAddress ("glIsEnablediEXT");
  }

  // GL_EXT_draw_elements_base_vertex
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_elements_base_vertex])
  {
    s_deviceConfig.m_glDrawElementsBaseVertexEXT = (PFNGLDRAWELEMENTSBASEVERTEXEXTPROC) glewGetProcAddress ("glDrawElementsBaseVertexEXT");
    s_deviceConfig.m_glDrawRangeElementsBaseVertexEXT = (PFNGLDRAWRANGEELEMENTSBASEVERTEXEXTPROC) glewGetProcAddress ("glDrawRangeElementsBaseVertexEXT");
    s_deviceConfig.m_glDrawElementsInstancedBaseVertexEXT = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXEXTPROC) glewGetProcAddress ("glDrawElementsInstancedBaseVertexEXT");
    s_deviceConfig.m_glMultiDrawElementsBaseVertexEXT = (PFNGLMULTIDRAWELEMENTSBASEVERTEXEXTPROC) glewGetProcAddress ("glMultiDrawElementsBaseVertexEXT");
  }

  // GL_EXT_draw_instanced
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_instanced])
  {
    s_deviceConfig.m_glDrawArraysInstancedEXT = (PFNGLDRAWARRAYSINSTANCEDEXTPROC) glewGetProcAddress ("glDrawArraysInstancedEXT");
    s_deviceConfig.m_glDrawElementsInstancedEXT = (PFNGLDRAWELEMENTSINSTANCEDEXTPROC) glewGetProcAddress ("glDrawElementsInstancedEXT");
  }

  // GL_EXT_draw_range_elements
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_range_elements])
  {
    s_deviceConfig.m_glDrawRangeElementsEXT = (PFNGLDRAWRANGEELEMENTSEXTPROC) glewGetProcAddress ("glDrawRangeElementsEXT");
  }

  // GL_EXT_draw_transform_feedback
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_draw_transform_feedback])
  {
    s_deviceConfig.m_glDrawTransformFeedbackEXT = (PFNGLDRAWTRANSFORMFEEDBACKEXTPROC) glewGetProcAddress ("glDrawTransformFeedbackEXT");
    s_deviceConfig.m_glDrawTransformFeedbackInstancedEXT = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDEXTPROC) glewGetProcAddress ("glDrawTransformFeedbackInstancedEXT");
  }

  // GL_EXT_external_buffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_external_buffer])
  {
    s_deviceConfig.m_glBufferStorageExternalEXT = (PFNGLBUFFERSTORAGEEXTERNALEXTPROC) glewGetProcAddress ("glBufferStorageExternalEXT");
    s_deviceConfig.m_glNamedBufferStorageExternalEXT = (PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC) glewGetProcAddress ("glNamedBufferStorageExternalEXT");
  }

  // GL_EXT_fog_coord
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_fog_coord])
  {
    s_deviceConfig.m_glFogCoordfEXT = (PFNGLFOGCOORDFEXTPROC) glewGetProcAddress ("glFogCoordfEXT");
    s_deviceConfig.m_glFogCoordfvEXT = (PFNGLFOGCOORDFVEXTPROC) glewGetProcAddress ("glFogCoordfvEXT");
    s_deviceConfig.m_glFogCoorddEXT = (PFNGLFOGCOORDDEXTPROC) glewGetProcAddress ("glFogCoorddEXT");
    s_deviceConfig.m_glFogCoorddvEXT = (PFNGLFOGCOORDDVEXTPROC) glewGetProcAddress ("glFogCoorddvEXT");
    s_deviceConfig.m_glFogCoordPointerEXT = (PFNGLFOGCOORDPOINTEREXTPROC) glewGetProcAddress ("glFogCoordPointerEXT");
  }

  // GL_EXT_fragment_shading_rate
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_fragment_shading_rate])
  {
    s_deviceConfig.m_glGetFragmentShadingRatesEXT = (PFNGLGETFRAGMENTSHADINGRATESEXTPROC) glewGetProcAddress ("glGetFragmentShadingRatesEXT");
    s_deviceConfig.m_glShadingRateEXT = (PFNGLSHADINGRATEEXTPROC) glewGetProcAddress ("glShadingRateEXT");
    s_deviceConfig.m_glShadingRateCombinerOpsEXT = (PFNGLSHADINGRATECOMBINEROPSEXTPROC) glewGetProcAddress ("glShadingRateCombinerOpsEXT");
    s_deviceConfig.m_glFramebufferShadingRateEXT = (PFNGLFRAMEBUFFERSHADINGRATEEXTPROC) glewGetProcAddress ("glFramebufferShadingRateEXT");
  }

  // GL_EXT_framebuffer_blit
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_blit])
  {
    s_deviceConfig.m_glBlitFramebufferEXT = (PFNGLBLITFRAMEBUFFEREXTPROC) glewGetProcAddress ("glBlitFramebufferEXT");
  }

  // GL_EXT_framebuffer_blit_layers
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_blit_layers])
  {
    s_deviceConfig.m_glBlitFramebufferLayersEXT = (PFNGLBLITFRAMEBUFFERLAYERSEXTPROC) glewGetProcAddress ("glBlitFramebufferLayersEXT");
    s_deviceConfig.m_glBlitFramebufferLayerEXT = (PFNGLBLITFRAMEBUFFERLAYEREXTPROC) glewGetProcAddress ("glBlitFramebufferLayerEXT");
  }

  // GL_EXT_framebuffer_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_multisample])
  {
    s_deviceConfig.m_glRenderbufferStorageMultisampleEXT = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) glewGetProcAddress ("glRenderbufferStorageMultisampleEXT");
  }

  // GL_EXT_framebuffer_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_framebuffer_object])
  {
    s_deviceConfig.m_glIsRenderbufferEXT = (PFNGLISRENDERBUFFEREXTPROC) glewGetProcAddress ("glIsRenderbufferEXT");
    s_deviceConfig.m_glBindRenderbufferEXT = (PFNGLBINDRENDERBUFFEREXTPROC) glewGetProcAddress ("glBindRenderbufferEXT");
    s_deviceConfig.m_glDeleteRenderbuffersEXT = (PFNGLDELETERENDERBUFFERSEXTPROC) glewGetProcAddress ("glDeleteRenderbuffersEXT");
    s_deviceConfig.m_glGenRenderbuffersEXT = (PFNGLGENRENDERBUFFERSEXTPROC) glewGetProcAddress ("glGenRenderbuffersEXT");
    s_deviceConfig.m_glRenderbufferStorageEXT = (PFNGLRENDERBUFFERSTORAGEEXTPROC) glewGetProcAddress ("glRenderbufferStorageEXT");
    s_deviceConfig.m_glGetRenderbufferParameterivEXT = (PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) glewGetProcAddress ("glGetRenderbufferParameterivEXT");
    s_deviceConfig.m_glIsFramebufferEXT = (PFNGLISFRAMEBUFFEREXTPROC) glewGetProcAddress ("glIsFramebufferEXT");
    s_deviceConfig.m_glBindFramebufferEXT = (PFNGLBINDFRAMEBUFFEREXTPROC) glewGetProcAddress ("glBindFramebufferEXT");
    s_deviceConfig.m_glDeleteFramebuffersEXT = (PFNGLDELETEFRAMEBUFFERSEXTPROC) glewGetProcAddress ("glDeleteFramebuffersEXT");
    s_deviceConfig.m_glGenFramebuffersEXT = (PFNGLGENFRAMEBUFFERSEXTPROC) glewGetProcAddress ("glGenFramebuffersEXT");
    s_deviceConfig.m_glCheckFramebufferStatusEXT = (PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) glewGetProcAddress ("glCheckFramebufferStatusEXT");
    s_deviceConfig.m_glFramebufferTexture1DEXT = (PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) glewGetProcAddress ("glFramebufferTexture1DEXT");
    s_deviceConfig.m_glFramebufferTexture2DEXT = (PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) glewGetProcAddress ("glFramebufferTexture2DEXT");
    s_deviceConfig.m_glFramebufferTexture3DEXT = (PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) glewGetProcAddress ("glFramebufferTexture3DEXT");
    s_deviceConfig.m_glFramebufferRenderbufferEXT = (PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) glewGetProcAddress ("glFramebufferRenderbufferEXT");
    s_deviceConfig.m_glGetFramebufferAttachmentParameterivEXT = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) glewGetProcAddress ("glGetFramebufferAttachmentParameterivEXT");
    s_deviceConfig.m_glGenerateMipmapEXT = (PFNGLGENERATEMIPMAPEXTPROC) glewGetProcAddress ("glGenerateMipmapEXT");
  }

  // GL_EXT_geometry_shader
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_geometry_shader])
  {
    s_deviceConfig.m_glFramebufferTextureEXT = (PFNGLFRAMEBUFFERTEXTUREEXTPROC) glewGetProcAddress ("glFramebufferTextureEXT");
  }

  // GL_EXT_geometry_shader4
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_geometry_shader4])
  {
    s_deviceConfig.m_glProgramParameteriEXT = (PFNGLPROGRAMPARAMETERIEXTPROC) glewGetProcAddress ("glProgramParameteriEXT");
  }

  // GL_EXT_gpu_program_parameters
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_gpu_program_parameters])
  {
    s_deviceConfig.m_glProgramEnvParameters4fvEXT = (PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) glewGetProcAddress ("glProgramEnvParameters4fvEXT");
    s_deviceConfig.m_glProgramLocalParameters4fvEXT = (PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) glewGetProcAddress ("glProgramLocalParameters4fvEXT");
  }

  // GL_EXT_gpu_shader4
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_gpu_shader4])
  {
    s_deviceConfig.m_glGetUniformuivEXT = (PFNGLGETUNIFORMUIVEXTPROC) glewGetProcAddress ("glGetUniformuivEXT");
    s_deviceConfig.m_glBindFragDataLocationEXT = (PFNGLBINDFRAGDATALOCATIONEXTPROC) glewGetProcAddress ("glBindFragDataLocationEXT");
    s_deviceConfig.m_glGetFragDataLocationEXT = (PFNGLGETFRAGDATALOCATIONEXTPROC) glewGetProcAddress ("glGetFragDataLocationEXT");
    s_deviceConfig.m_glUniform1uiEXT = (PFNGLUNIFORM1UIEXTPROC) glewGetProcAddress ("glUniform1uiEXT");
    s_deviceConfig.m_glUniform2uiEXT = (PFNGLUNIFORM2UIEXTPROC) glewGetProcAddress ("glUniform2uiEXT");
    s_deviceConfig.m_glUniform3uiEXT = (PFNGLUNIFORM3UIEXTPROC) glewGetProcAddress ("glUniform3uiEXT");
    s_deviceConfig.m_glUniform4uiEXT = (PFNGLUNIFORM4UIEXTPROC) glewGetProcAddress ("glUniform4uiEXT");
    s_deviceConfig.m_glUniform1uivEXT = (PFNGLUNIFORM1UIVEXTPROC) glewGetProcAddress ("glUniform1uivEXT");
    s_deviceConfig.m_glUniform2uivEXT = (PFNGLUNIFORM2UIVEXTPROC) glewGetProcAddress ("glUniform2uivEXT");
    s_deviceConfig.m_glUniform3uivEXT = (PFNGLUNIFORM3UIVEXTPROC) glewGetProcAddress ("glUniform3uivEXT");
    s_deviceConfig.m_glUniform4uivEXT = (PFNGLUNIFORM4UIVEXTPROC) glewGetProcAddress ("glUniform4uivEXT");
    s_deviceConfig.m_glVertexAttribI1iEXT = (PFNGLVERTEXATTRIBI1IEXTPROC) glewGetProcAddress ("glVertexAttribI1iEXT");
    s_deviceConfig.m_glVertexAttribI2iEXT = (PFNGLVERTEXATTRIBI2IEXTPROC) glewGetProcAddress ("glVertexAttribI2iEXT");
    s_deviceConfig.m_glVertexAttribI3iEXT = (PFNGLVERTEXATTRIBI3IEXTPROC) glewGetProcAddress ("glVertexAttribI3iEXT");
    s_deviceConfig.m_glVertexAttribI4iEXT = (PFNGLVERTEXATTRIBI4IEXTPROC) glewGetProcAddress ("glVertexAttribI4iEXT");
    s_deviceConfig.m_glVertexAttribI1uiEXT = (PFNGLVERTEXATTRIBI1UIEXTPROC) glewGetProcAddress ("glVertexAttribI1uiEXT");
    s_deviceConfig.m_glVertexAttribI2uiEXT = (PFNGLVERTEXATTRIBI2UIEXTPROC) glewGetProcAddress ("glVertexAttribI2uiEXT");
    s_deviceConfig.m_glVertexAttribI3uiEXT = (PFNGLVERTEXATTRIBI3UIEXTPROC) glewGetProcAddress ("glVertexAttribI3uiEXT");
    s_deviceConfig.m_glVertexAttribI4uiEXT = (PFNGLVERTEXATTRIBI4UIEXTPROC) glewGetProcAddress ("glVertexAttribI4uiEXT");
    s_deviceConfig.m_glVertexAttribI1ivEXT = (PFNGLVERTEXATTRIBI1IVEXTPROC) glewGetProcAddress ("glVertexAttribI1ivEXT");
    s_deviceConfig.m_glVertexAttribI2ivEXT = (PFNGLVERTEXATTRIBI2IVEXTPROC) glewGetProcAddress ("glVertexAttribI2ivEXT");
    s_deviceConfig.m_glVertexAttribI3ivEXT = (PFNGLVERTEXATTRIBI3IVEXTPROC) glewGetProcAddress ("glVertexAttribI3ivEXT");
    s_deviceConfig.m_glVertexAttribI4ivEXT = (PFNGLVERTEXATTRIBI4IVEXTPROC) glewGetProcAddress ("glVertexAttribI4ivEXT");
    s_deviceConfig.m_glVertexAttribI1uivEXT = (PFNGLVERTEXATTRIBI1UIVEXTPROC) glewGetProcAddress ("glVertexAttribI1uivEXT");
    s_deviceConfig.m_glVertexAttribI2uivEXT = (PFNGLVERTEXATTRIBI2UIVEXTPROC) glewGetProcAddress ("glVertexAttribI2uivEXT");
    s_deviceConfig.m_glVertexAttribI3uivEXT = (PFNGLVERTEXATTRIBI3UIVEXTPROC) glewGetProcAddress ("glVertexAttribI3uivEXT");
    s_deviceConfig.m_glVertexAttribI4uivEXT = (PFNGLVERTEXATTRIBI4UIVEXTPROC) glewGetProcAddress ("glVertexAttribI4uivEXT");
    s_deviceConfig.m_glVertexAttribI4bvEXT = (PFNGLVERTEXATTRIBI4BVEXTPROC) glewGetProcAddress ("glVertexAttribI4bvEXT");
    s_deviceConfig.m_glVertexAttribI4svEXT = (PFNGLVERTEXATTRIBI4SVEXTPROC) glewGetProcAddress ("glVertexAttribI4svEXT");
    s_deviceConfig.m_glVertexAttribI4ubvEXT = (PFNGLVERTEXATTRIBI4UBVEXTPROC) glewGetProcAddress ("glVertexAttribI4ubvEXT");
    s_deviceConfig.m_glVertexAttribI4usvEXT = (PFNGLVERTEXATTRIBI4USVEXTPROC) glewGetProcAddress ("glVertexAttribI4usvEXT");
    s_deviceConfig.m_glVertexAttribIPointerEXT = (PFNGLVERTEXATTRIBIPOINTEREXTPROC) glewGetProcAddress ("glVertexAttribIPointerEXT");
    s_deviceConfig.m_glGetVertexAttribIivEXT = (PFNGLGETVERTEXATTRIBIIVEXTPROC) glewGetProcAddress ("glGetVertexAttribIivEXT");
    s_deviceConfig.m_glGetVertexAttribIuivEXT = (PFNGLGETVERTEXATTRIBIUIVEXTPROC) glewGetProcAddress ("glGetVertexAttribIuivEXT");
  }

  // GL_EXT_histogram
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_histogram])
  {
    s_deviceConfig.m_glGetHistogramEXT = (PFNGLGETHISTOGRAMEXTPROC) glewGetProcAddress ("glGetHistogramEXT");
    s_deviceConfig.m_glGetHistogramParameterfvEXT = (PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) glewGetProcAddress ("glGetHistogramParameterfvEXT");
    s_deviceConfig.m_glGetHistogramParameterivEXT = (PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) glewGetProcAddress ("glGetHistogramParameterivEXT");
    s_deviceConfig.m_glGetMinmaxEXT = (PFNGLGETMINMAXEXTPROC) glewGetProcAddress ("glGetMinmaxEXT");
    s_deviceConfig.m_glGetMinmaxParameterfvEXT = (PFNGLGETMINMAXPARAMETERFVEXTPROC) glewGetProcAddress ("glGetMinmaxParameterfvEXT");
    s_deviceConfig.m_glGetMinmaxParameterivEXT = (PFNGLGETMINMAXPARAMETERIVEXTPROC) glewGetProcAddress ("glGetMinmaxParameterivEXT");
    s_deviceConfig.m_glHistogramEXT = (PFNGLHISTOGRAMEXTPROC) glewGetProcAddress ("glHistogramEXT");
    s_deviceConfig.m_glMinmaxEXT = (PFNGLMINMAXEXTPROC) glewGetProcAddress ("glMinmaxEXT");
    s_deviceConfig.m_glResetHistogramEXT = (PFNGLRESETHISTOGRAMEXTPROC) glewGetProcAddress ("glResetHistogramEXT");
    s_deviceConfig.m_glResetMinmaxEXT = (PFNGLRESETMINMAXEXTPROC) glewGetProcAddress ("glResetMinmaxEXT");
  }

  // GL_EXT_index_func
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_index_func])
  {
    s_deviceConfig.m_glIndexFuncEXT = (PFNGLINDEXFUNCEXTPROC) glewGetProcAddress ("glIndexFuncEXT");
  }

  // GL_EXT_index_material
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_index_material])
  {
    s_deviceConfig.m_glIndexMaterialEXT = (PFNGLINDEXMATERIALEXTPROC) glewGetProcAddress ("glIndexMaterialEXT");
  }

  // GL_EXT_instanced_arrays
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_instanced_arrays])
  {
    s_deviceConfig.m_glDrawArraysInstancedEXT = (PFNGLDRAWARRAYSINSTANCEDEXTPROC) glewGetProcAddress ("glDrawArraysInstancedEXT");
    s_deviceConfig.m_glDrawElementsInstancedEXT = (PFNGLDRAWELEMENTSINSTANCEDEXTPROC) glewGetProcAddress ("glDrawElementsInstancedEXT");
    s_deviceConfig.m_glVertexAttribDivisorEXT = (PFNGLVERTEXATTRIBDIVISOREXTPROC) glewGetProcAddress ("glVertexAttribDivisorEXT");
  }

  // GL_EXT_light_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_light_texture])
  {
    s_deviceConfig.m_glApplyTextureEXT = (PFNGLAPPLYTEXTUREEXTPROC) glewGetProcAddress ("glApplyTextureEXT");
    s_deviceConfig.m_glTextureLightEXT = (PFNGLTEXTURELIGHTEXTPROC) glewGetProcAddress ("glTextureLightEXT");
    s_deviceConfig.m_glTextureMaterialEXT = (PFNGLTEXTUREMATERIALEXTPROC) glewGetProcAddress ("glTextureMaterialEXT");
  }

  // GL_EXT_map_buffer_range
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_map_buffer_range])
  {
    s_deviceConfig.m_glMapBufferRangeEXT = (PFNGLMAPBUFFERRANGEEXTPROC) glewGetProcAddress ("glMapBufferRangeEXT");
    s_deviceConfig.m_glFlushMappedBufferRangeEXT = (PFNGLFLUSHMAPPEDBUFFERRANGEEXTPROC) glewGetProcAddress ("glFlushMappedBufferRangeEXT");
  }

  // GL_EXT_memory_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_memory_object])
  {
    s_deviceConfig.m_glGetUnsignedBytevEXT = (PFNGLGETUNSIGNEDBYTEVEXTPROC) glewGetProcAddress ("glGetUnsignedBytevEXT");
    s_deviceConfig.m_glGetUnsignedBytei_vEXT = (PFNGLGETUNSIGNEDBYTEI_VEXTPROC) glewGetProcAddress ("glGetUnsignedBytei_vEXT");
    s_deviceConfig.m_glDeleteMemoryObjectsEXT = (PFNGLDELETEMEMORYOBJECTSEXTPROC) glewGetProcAddress ("glDeleteMemoryObjectsEXT");
    s_deviceConfig.m_glIsMemoryObjectEXT = (PFNGLISMEMORYOBJECTEXTPROC) glewGetProcAddress ("glIsMemoryObjectEXT");
    s_deviceConfig.m_glCreateMemoryObjectsEXT = (PFNGLCREATEMEMORYOBJECTSEXTPROC) glewGetProcAddress ("glCreateMemoryObjectsEXT");
    s_deviceConfig.m_glMemoryObjectParameterivEXT = (PFNGLMEMORYOBJECTPARAMETERIVEXTPROC) glewGetProcAddress ("glMemoryObjectParameterivEXT");
    s_deviceConfig.m_glGetMemoryObjectParameterivEXT = (PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC) glewGetProcAddress ("glGetMemoryObjectParameterivEXT");
    s_deviceConfig.m_glTexStorageMem2DEXT = (PFNGLTEXSTORAGEMEM2DEXTPROC) glewGetProcAddress ("glTexStorageMem2DEXT");
    s_deviceConfig.m_glTexStorageMem2DMultisampleEXT = (PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC) glewGetProcAddress ("glTexStorageMem2DMultisampleEXT");
    s_deviceConfig.m_glTexStorageMem3DEXT = (PFNGLTEXSTORAGEMEM3DEXTPROC) glewGetProcAddress ("glTexStorageMem3DEXT");
    s_deviceConfig.m_glTexStorageMem3DMultisampleEXT = (PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC) glewGetProcAddress ("glTexStorageMem3DMultisampleEXT");
    s_deviceConfig.m_glBufferStorageMemEXT = (PFNGLBUFFERSTORAGEMEMEXTPROC) glewGetProcAddress ("glBufferStorageMemEXT");
    s_deviceConfig.m_glTextureStorageMem2DEXT = (PFNGLTEXTURESTORAGEMEM2DEXTPROC) glewGetProcAddress ("glTextureStorageMem2DEXT");
    s_deviceConfig.m_glTextureStorageMem2DMultisampleEXT = (PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC) glewGetProcAddress ("glTextureStorageMem2DMultisampleEXT");
    s_deviceConfig.m_glTextureStorageMem3DEXT = (PFNGLTEXTURESTORAGEMEM3DEXTPROC) glewGetProcAddress ("glTextureStorageMem3DEXT");
    s_deviceConfig.m_glTextureStorageMem3DMultisampleEXT = (PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC) glewGetProcAddress ("glTextureStorageMem3DMultisampleEXT");
    s_deviceConfig.m_glNamedBufferStorageMemEXT = (PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC) glewGetProcAddress ("glNamedBufferStorageMemEXT");
    s_deviceConfig.m_glTexStorageMem1DEXT = (PFNGLTEXSTORAGEMEM1DEXTPROC) glewGetProcAddress ("glTexStorageMem1DEXT");
    s_deviceConfig.m_glTextureStorageMem1DEXT = (PFNGLTEXTURESTORAGEMEM1DEXTPROC) glewGetProcAddress ("glTextureStorageMem1DEXT");
  }

  // GL_EXT_memory_object_fd
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_memory_object_fd])
  {
    s_deviceConfig.m_glImportMemoryFdEXT = (PFNGLIMPORTMEMORYFDEXTPROC) glewGetProcAddress ("glImportMemoryFdEXT");
  }

  // GL_EXT_memory_object_win32
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_memory_object_win32])
  {
    s_deviceConfig.m_glImportMemoryWin32HandleEXT = (PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC) glewGetProcAddress ("glImportMemoryWin32HandleEXT");
    s_deviceConfig.m_glImportMemoryWin32NameEXT = (PFNGLIMPORTMEMORYWIN32NAMEEXTPROC) glewGetProcAddress ("glImportMemoryWin32NameEXT");
  }

  // GL_EXT_multi_draw_arrays
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multi_draw_arrays])
  {
    s_deviceConfig.m_glMultiDrawArraysEXT = (PFNGLMULTIDRAWARRAYSEXTPROC) glewGetProcAddress ("glMultiDrawArraysEXT");
    s_deviceConfig.m_glMultiDrawElementsEXT = (PFNGLMULTIDRAWELEMENTSEXTPROC) glewGetProcAddress ("glMultiDrawElementsEXT");
  }

  // GL_EXT_multi_draw_indirect
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multi_draw_indirect])
  {
    s_deviceConfig.m_glMultiDrawArraysIndirectEXT = (PFNGLMULTIDRAWARRAYSINDIRECTEXTPROC) glewGetProcAddress ("glMultiDrawArraysIndirectEXT");
    s_deviceConfig.m_glMultiDrawElementsIndirectEXT = (PFNGLMULTIDRAWELEMENTSINDIRECTEXTPROC) glewGetProcAddress ("glMultiDrawElementsIndirectEXT");
  }

  // GL_EXT_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multisample])
  {
    s_deviceConfig.m_glSampleMaskEXT = (PFNGLSAMPLEMASKEXTPROC) glewGetProcAddress ("glSampleMaskEXT");
    s_deviceConfig.m_glSamplePatternEXT = (PFNGLSAMPLEPATTERNEXTPROC) glewGetProcAddress ("glSamplePatternEXT");
  }

  // GL_EXT_multisampled_render_to_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multisampled_render_to_texture])
  {
    s_deviceConfig.m_glRenderbufferStorageMultisampleEXT = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) glewGetProcAddress ("glRenderbufferStorageMultisampleEXT");
    s_deviceConfig.m_glFramebufferTexture2DMultisampleEXT = (PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXTPROC) glewGetProcAddress ("glFramebufferTexture2DMultisampleEXT");
  }

  // GL_EXT_multiview_draw_buffers
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_multiview_draw_buffers])
  {
    s_deviceConfig.m_glReadBufferIndexedEXT = (PFNGLREADBUFFERINDEXEDEXTPROC) glewGetProcAddress ("glReadBufferIndexedEXT");
    s_deviceConfig.m_glDrawBuffersIndexedEXT = (PFNGLDRAWBUFFERSINDEXEDEXTPROC) glewGetProcAddress ("glDrawBuffersIndexedEXT");
    s_deviceConfig.m_glGetIntegeri_vEXT = (PFNGLGETINTEGERI_VEXTPROC) glewGetProcAddress ("glGetIntegeri_vEXT");
  }

  // GL_EXT_occlusion_query_boolean
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_occlusion_query_boolean])
  {
    s_deviceConfig.m_glGenQueriesEXT = (PFNGLGENQUERIESEXTPROC) glewGetProcAddress ("glGenQueriesEXT");
    s_deviceConfig.m_glDeleteQueriesEXT = (PFNGLDELETEQUERIESEXTPROC) glewGetProcAddress ("glDeleteQueriesEXT");
    s_deviceConfig.m_glIsQueryEXT = (PFNGLISQUERYEXTPROC) glewGetProcAddress ("glIsQueryEXT");
    s_deviceConfig.m_glBeginQueryEXT = (PFNGLBEGINQUERYEXTPROC) glewGetProcAddress ("glBeginQueryEXT");
    s_deviceConfig.m_glEndQueryEXT = (PFNGLENDQUERYEXTPROC) glewGetProcAddress ("glEndQueryEXT");
    s_deviceConfig.m_glGetQueryivEXT = (PFNGLGETQUERYIVEXTPROC) glewGetProcAddress ("glGetQueryivEXT");
    s_deviceConfig.m_glGetQueryObjectuivEXT = (PFNGLGETQUERYOBJECTUIVEXTPROC) glewGetProcAddress ("glGetQueryObjectuivEXT");
  }

  // GL_EXT_paletted_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_paletted_texture])
  {
    s_deviceConfig.m_glColorTableEXT = (PFNGLCOLORTABLEEXTPROC) glewGetProcAddress ("glColorTableEXT");
    s_deviceConfig.m_glGetColorTableEXT = (PFNGLGETCOLORTABLEEXTPROC) glewGetProcAddress ("glGetColorTableEXT");
    s_deviceConfig.m_glGetColorTableParameterivEXT = (PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) glewGetProcAddress ("glGetColorTableParameterivEXT");
    s_deviceConfig.m_glGetColorTableParameterfvEXT = (PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) glewGetProcAddress ("glGetColorTableParameterfvEXT");
  }

  // GL_EXT_pixel_transform
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_pixel_transform])
  {
    s_deviceConfig.m_glPixelTransformParameteriEXT = (PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) glewGetProcAddress ("glPixelTransformParameteriEXT");
    s_deviceConfig.m_glPixelTransformParameterfEXT = (PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) glewGetProcAddress ("glPixelTransformParameterfEXT");
    s_deviceConfig.m_glPixelTransformParameterivEXT = (PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) glewGetProcAddress ("glPixelTransformParameterivEXT");
    s_deviceConfig.m_glPixelTransformParameterfvEXT = (PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) glewGetProcAddress ("glPixelTransformParameterfvEXT");
    s_deviceConfig.m_glGetPixelTransformParameterivEXT = (PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC) glewGetProcAddress ("glGetPixelTransformParameterivEXT");
    s_deviceConfig.m_glGetPixelTransformParameterfvEXT = (PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC) glewGetProcAddress ("glGetPixelTransformParameterfvEXT");
  }

  // GL_EXT_point_parameters
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_point_parameters])
  {
    s_deviceConfig.m_glPointParameterfEXT = (PFNGLPOINTPARAMETERFEXTPROC) glewGetProcAddress ("glPointParameterfEXT");
    s_deviceConfig.m_glPointParameterfvEXT = (PFNGLPOINTPARAMETERFVEXTPROC) glewGetProcAddress ("glPointParameterfvEXT");
  }

  // GL_EXT_polygon_offset
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_polygon_offset])
  {
    s_deviceConfig.m_glPolygonOffsetEXT = (PFNGLPOLYGONOFFSETEXTPROC) glewGetProcAddress ("glPolygonOffsetEXT");
  }

  // GL_EXT_polygon_offset_clamp
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_polygon_offset_clamp])
  {
    s_deviceConfig.m_glPolygonOffsetClampEXT = (PFNGLPOLYGONOFFSETCLAMPEXTPROC) glewGetProcAddress ("glPolygonOffsetClampEXT");
  }

  // GL_EXT_primitive_bounding_box
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_primitive_bounding_box])
  {
    s_deviceConfig.m_glPrimitiveBoundingBoxEXT = (PFNGLPRIMITIVEBOUNDINGBOXEXTPROC) glewGetProcAddress ("glPrimitiveBoundingBoxEXT");
  }

  // GL_EXT_provoking_vertex
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_provoking_vertex])
  {
    s_deviceConfig.m_glProvokingVertexEXT = (PFNGLPROVOKINGVERTEXEXTPROC) glewGetProcAddress ("glProvokingVertexEXT");
  }

  // GL_EXT_raster_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_raster_multisample])
  {
    s_deviceConfig.m_glRasterSamplesEXT = (PFNGLRASTERSAMPLESEXTPROC) glewGetProcAddress ("glRasterSamplesEXT");
  }

  // GL_EXT_robustness
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_robustness])
  {
    s_deviceConfig.m_glGetGraphicsResetStatusEXT = (PFNGLGETGRAPHICSRESETSTATUSEXTPROC) glewGetProcAddress ("glGetGraphicsResetStatusEXT");
    s_deviceConfig.m_glReadnPixelsEXT = (PFNGLREADNPIXELSEXTPROC) glewGetProcAddress ("glReadnPixelsEXT");
    s_deviceConfig.m_glGetnUniformfvEXT = (PFNGLGETNUNIFORMFVEXTPROC) glewGetProcAddress ("glGetnUniformfvEXT");
    s_deviceConfig.m_glGetnUniformivEXT = (PFNGLGETNUNIFORMIVEXTPROC) glewGetProcAddress ("glGetnUniformivEXT");
  }

  // GL_EXT_semaphore
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_semaphore])
  {
    s_deviceConfig.m_glGetUnsignedBytevEXT = (PFNGLGETUNSIGNEDBYTEVEXTPROC) glewGetProcAddress ("glGetUnsignedBytevEXT");
    s_deviceConfig.m_glGetUnsignedBytei_vEXT = (PFNGLGETUNSIGNEDBYTEI_VEXTPROC) glewGetProcAddress ("glGetUnsignedBytei_vEXT");
    s_deviceConfig.m_glGenSemaphoresEXT = (PFNGLGENSEMAPHORESEXTPROC) glewGetProcAddress ("glGenSemaphoresEXT");
    s_deviceConfig.m_glDeleteSemaphoresEXT = (PFNGLDELETESEMAPHORESEXTPROC) glewGetProcAddress ("glDeleteSemaphoresEXT");
    s_deviceConfig.m_glIsSemaphoreEXT = (PFNGLISSEMAPHOREEXTPROC) glewGetProcAddress ("glIsSemaphoreEXT");
    s_deviceConfig.m_glSemaphoreParameterui64vEXT = (PFNGLSEMAPHOREPARAMETERUI64VEXTPROC) glewGetProcAddress ("glSemaphoreParameterui64vEXT");
    s_deviceConfig.m_glGetSemaphoreParameterui64vEXT = (PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC) glewGetProcAddress ("glGetSemaphoreParameterui64vEXT");
    s_deviceConfig.m_glWaitSemaphoreEXT = (PFNGLWAITSEMAPHOREEXTPROC) glewGetProcAddress ("glWaitSemaphoreEXT");
    s_deviceConfig.m_glSignalSemaphoreEXT = (PFNGLSIGNALSEMAPHOREEXTPROC) glewGetProcAddress ("glSignalSemaphoreEXT");
  }

  // GL_EXT_semaphore_fd
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_semaphore_fd])
  {
    s_deviceConfig.m_glImportSemaphoreFdEXT = (PFNGLIMPORTSEMAPHOREFDEXTPROC) glewGetProcAddress ("glImportSemaphoreFdEXT");
  }

  // GL_EXT_semaphore_win32
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_semaphore_win32])
  {
    s_deviceConfig.m_glImportSemaphoreWin32HandleEXT = (PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC) glewGetProcAddress ("glImportSemaphoreWin32HandleEXT");
    s_deviceConfig.m_glImportSemaphoreWin32NameEXT = (PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC) glewGetProcAddress ("glImportSemaphoreWin32NameEXT");
  }

  // GL_EXT_secondary_color
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_secondary_color])
  {
    s_deviceConfig.m_glSecondaryColor3bEXT = (PFNGLSECONDARYCOLOR3BEXTPROC) glewGetProcAddress ("glSecondaryColor3bEXT");
    s_deviceConfig.m_glSecondaryColor3bvEXT = (PFNGLSECONDARYCOLOR3BVEXTPROC) glewGetProcAddress ("glSecondaryColor3bvEXT");
    s_deviceConfig.m_glSecondaryColor3dEXT = (PFNGLSECONDARYCOLOR3DEXTPROC) glewGetProcAddress ("glSecondaryColor3dEXT");
    s_deviceConfig.m_glSecondaryColor3dvEXT = (PFNGLSECONDARYCOLOR3DVEXTPROC) glewGetProcAddress ("glSecondaryColor3dvEXT");
    s_deviceConfig.m_glSecondaryColor3fEXT = (PFNGLSECONDARYCOLOR3FEXTPROC) glewGetProcAddress ("glSecondaryColor3fEXT");
    s_deviceConfig.m_glSecondaryColor3fvEXT = (PFNGLSECONDARYCOLOR3FVEXTPROC) glewGetProcAddress ("glSecondaryColor3fvEXT");
    s_deviceConfig.m_glSecondaryColor3iEXT = (PFNGLSECONDARYCOLOR3IEXTPROC) glewGetProcAddress ("glSecondaryColor3iEXT");
    s_deviceConfig.m_glSecondaryColor3ivEXT = (PFNGLSECONDARYCOLOR3IVEXTPROC) glewGetProcAddress ("glSecondaryColor3ivEXT");
    s_deviceConfig.m_glSecondaryColor3sEXT = (PFNGLSECONDARYCOLOR3SEXTPROC) glewGetProcAddress ("glSecondaryColor3sEXT");
    s_deviceConfig.m_glSecondaryColor3svEXT = (PFNGLSECONDARYCOLOR3SVEXTPROC) glewGetProcAddress ("glSecondaryColor3svEXT");
    s_deviceConfig.m_glSecondaryColor3ubEXT = (PFNGLSECONDARYCOLOR3UBEXTPROC) glewGetProcAddress ("glSecondaryColor3ubEXT");
    s_deviceConfig.m_glSecondaryColor3ubvEXT = (PFNGLSECONDARYCOLOR3UBVEXTPROC) glewGetProcAddress ("glSecondaryColor3ubvEXT");
    s_deviceConfig.m_glSecondaryColor3uiEXT = (PFNGLSECONDARYCOLOR3UIEXTPROC) glewGetProcAddress ("glSecondaryColor3uiEXT");
    s_deviceConfig.m_glSecondaryColor3uivEXT = (PFNGLSECONDARYCOLOR3UIVEXTPROC) glewGetProcAddress ("glSecondaryColor3uivEXT");
    s_deviceConfig.m_glSecondaryColor3usEXT = (PFNGLSECONDARYCOLOR3USEXTPROC) glewGetProcAddress ("glSecondaryColor3usEXT");
    s_deviceConfig.m_glSecondaryColor3usvEXT = (PFNGLSECONDARYCOLOR3USVEXTPROC) glewGetProcAddress ("glSecondaryColor3usvEXT");
    s_deviceConfig.m_glSecondaryColorPointerEXT = (PFNGLSECONDARYCOLORPOINTEREXTPROC) glewGetProcAddress ("glSecondaryColorPointerEXT");
  }

  // GL_EXT_separate_shader_objects
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_separate_shader_objects])
  {
    s_deviceConfig.m_glUseShaderProgramEXT = (PFNGLUSESHADERPROGRAMEXTPROC) glewGetProcAddress ("glUseShaderProgramEXT");
    s_deviceConfig.m_glActiveProgramEXT = (PFNGLACTIVEPROGRAMEXTPROC) glewGetProcAddress ("glActiveProgramEXT");
    s_deviceConfig.m_glCreateShaderProgramEXT = (PFNGLCREATESHADERPROGRAMEXTPROC) glewGetProcAddress ("glCreateShaderProgramEXT");
    s_deviceConfig.m_glActiveShaderProgramEXT = (PFNGLACTIVESHADERPROGRAMEXTPROC) glewGetProcAddress ("glActiveShaderProgramEXT");
    s_deviceConfig.m_glBindProgramPipelineEXT = (PFNGLBINDPROGRAMPIPELINEEXTPROC) glewGetProcAddress ("glBindProgramPipelineEXT");
    s_deviceConfig.m_glCreateShaderProgramvEXT = (PFNGLCREATESHADERPROGRAMVEXTPROC) glewGetProcAddress ("glCreateShaderProgramvEXT");
    s_deviceConfig.m_glDeleteProgramPipelinesEXT = (PFNGLDELETEPROGRAMPIPELINESEXTPROC) glewGetProcAddress ("glDeleteProgramPipelinesEXT");
    s_deviceConfig.m_glGenProgramPipelinesEXT = (PFNGLGENPROGRAMPIPELINESEXTPROC) glewGetProcAddress ("glGenProgramPipelinesEXT");
    s_deviceConfig.m_glGetProgramPipelineInfoLogEXT = (PFNGLGETPROGRAMPIPELINEINFOLOGEXTPROC) glewGetProcAddress ("glGetProgramPipelineInfoLogEXT");
    s_deviceConfig.m_glGetProgramPipelineivEXT = (PFNGLGETPROGRAMPIPELINEIVEXTPROC) glewGetProcAddress ("glGetProgramPipelineivEXT");
    s_deviceConfig.m_glIsProgramPipelineEXT = (PFNGLISPROGRAMPIPELINEEXTPROC) glewGetProcAddress ("glIsProgramPipelineEXT");
    s_deviceConfig.m_glProgramParameteriEXT = (PFNGLPROGRAMPARAMETERIEXTPROC) glewGetProcAddress ("glProgramParameteriEXT");
    s_deviceConfig.m_glProgramUniform1fEXT = (PFNGLPROGRAMUNIFORM1FEXTPROC) glewGetProcAddress ("glProgramUniform1fEXT");
    s_deviceConfig.m_glProgramUniform1fvEXT = (PFNGLPROGRAMUNIFORM1FVEXTPROC) glewGetProcAddress ("glProgramUniform1fvEXT");
    s_deviceConfig.m_glProgramUniform1iEXT = (PFNGLPROGRAMUNIFORM1IEXTPROC) glewGetProcAddress ("glProgramUniform1iEXT");
    s_deviceConfig.m_glProgramUniform1ivEXT = (PFNGLPROGRAMUNIFORM1IVEXTPROC) glewGetProcAddress ("glProgramUniform1ivEXT");
    s_deviceConfig.m_glProgramUniform2fEXT = (PFNGLPROGRAMUNIFORM2FEXTPROC) glewGetProcAddress ("glProgramUniform2fEXT");
    s_deviceConfig.m_glProgramUniform2fvEXT = (PFNGLPROGRAMUNIFORM2FVEXTPROC) glewGetProcAddress ("glProgramUniform2fvEXT");
    s_deviceConfig.m_glProgramUniform2iEXT = (PFNGLPROGRAMUNIFORM2IEXTPROC) glewGetProcAddress ("glProgramUniform2iEXT");
    s_deviceConfig.m_glProgramUniform2ivEXT = (PFNGLPROGRAMUNIFORM2IVEXTPROC) glewGetProcAddress ("glProgramUniform2ivEXT");
    s_deviceConfig.m_glProgramUniform3fEXT = (PFNGLPROGRAMUNIFORM3FEXTPROC) glewGetProcAddress ("glProgramUniform3fEXT");
    s_deviceConfig.m_glProgramUniform3fvEXT = (PFNGLPROGRAMUNIFORM3FVEXTPROC) glewGetProcAddress ("glProgramUniform3fvEXT");
    s_deviceConfig.m_glProgramUniform3iEXT = (PFNGLPROGRAMUNIFORM3IEXTPROC) glewGetProcAddress ("glProgramUniform3iEXT");
    s_deviceConfig.m_glProgramUniform3ivEXT = (PFNGLPROGRAMUNIFORM3IVEXTPROC) glewGetProcAddress ("glProgramUniform3ivEXT");
    s_deviceConfig.m_glProgramUniform4fEXT = (PFNGLPROGRAMUNIFORM4FEXTPROC) glewGetProcAddress ("glProgramUniform4fEXT");
    s_deviceConfig.m_glProgramUniform4fvEXT = (PFNGLPROGRAMUNIFORM4FVEXTPROC) glewGetProcAddress ("glProgramUniform4fvEXT");
    s_deviceConfig.m_glProgramUniform4iEXT = (PFNGLPROGRAMUNIFORM4IEXTPROC) glewGetProcAddress ("glProgramUniform4iEXT");
    s_deviceConfig.m_glProgramUniform4ivEXT = (PFNGLPROGRAMUNIFORM4IVEXTPROC) glewGetProcAddress ("glProgramUniform4ivEXT");
    s_deviceConfig.m_glProgramUniformMatrix2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix2fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix3fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix4fvEXT");
    s_deviceConfig.m_glUseProgramStagesEXT = (PFNGLUSEPROGRAMSTAGESEXTPROC) glewGetProcAddress ("glUseProgramStagesEXT");
    s_deviceConfig.m_glValidateProgramPipelineEXT = (PFNGLVALIDATEPROGRAMPIPELINEEXTPROC) glewGetProcAddress ("glValidateProgramPipelineEXT");
    s_deviceConfig.m_glProgramUniform1uiEXT = (PFNGLPROGRAMUNIFORM1UIEXTPROC) glewGetProcAddress ("glProgramUniform1uiEXT");
    s_deviceConfig.m_glProgramUniform2uiEXT = (PFNGLPROGRAMUNIFORM2UIEXTPROC) glewGetProcAddress ("glProgramUniform2uiEXT");
    s_deviceConfig.m_glProgramUniform3uiEXT = (PFNGLPROGRAMUNIFORM3UIEXTPROC) glewGetProcAddress ("glProgramUniform3uiEXT");
    s_deviceConfig.m_glProgramUniform4uiEXT = (PFNGLPROGRAMUNIFORM4UIEXTPROC) glewGetProcAddress ("glProgramUniform4uiEXT");
    s_deviceConfig.m_glProgramUniform1uivEXT = (PFNGLPROGRAMUNIFORM1UIVEXTPROC) glewGetProcAddress ("glProgramUniform1uivEXT");
    s_deviceConfig.m_glProgramUniform2uivEXT = (PFNGLPROGRAMUNIFORM2UIVEXTPROC) glewGetProcAddress ("glProgramUniform2uivEXT");
    s_deviceConfig.m_glProgramUniform3uivEXT = (PFNGLPROGRAMUNIFORM3UIVEXTPROC) glewGetProcAddress ("glProgramUniform3uivEXT");
    s_deviceConfig.m_glProgramUniform4uivEXT = (PFNGLPROGRAMUNIFORM4UIVEXTPROC) glewGetProcAddress ("glProgramUniform4uivEXT");
    s_deviceConfig.m_glProgramUniformMatrix2x3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix2x3fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix3x2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix3x2fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix2x4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix2x4fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix4x2fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix4x2fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix3x4fvEXT = (PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix3x4fvEXT");
    s_deviceConfig.m_glProgramUniformMatrix4x3fvEXT = (PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) glewGetProcAddress ("glProgramUniformMatrix4x3fvEXT");
  }

  // GL_EXT_shader_framebuffer_fetch_non_coherent
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_framebuffer_fetch_non_coherent])
  {
    s_deviceConfig.m_glFramebufferFetchBarrierEXT = (PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC) glewGetProcAddress ("glFramebufferFetchBarrierEXT");
  }

  // GL_EXT_shader_image_load_store
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_image_load_store])
  {
    s_deviceConfig.m_glBindImageTextureEXT = (PFNGLBINDIMAGETEXTUREEXTPROC) glewGetProcAddress ("glBindImageTextureEXT");
    s_deviceConfig.m_glMemoryBarrierEXT = (PFNGLMEMORYBARRIEREXTPROC) glewGetProcAddress ("glMemoryBarrierEXT");
  }

  // GL_EXT_shader_pixel_local_storage2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_shader_pixel_local_storage2])
  {
    s_deviceConfig.m_glFramebufferPixelLocalStorageSizeEXT = (PFNGLFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC) glewGetProcAddress ("glFramebufferPixelLocalStorageSizeEXT");
    s_deviceConfig.m_glGetFramebufferPixelLocalStorageSizeEXT = (PFNGLGETFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC) glewGetProcAddress ("glGetFramebufferPixelLocalStorageSizeEXT");
    s_deviceConfig.m_glClearPixelLocalStorageuiEXT = (PFNGLCLEARPIXELLOCALSTORAGEUIEXTPROC) glewGetProcAddress ("glClearPixelLocalStorageuiEXT");
  }

  // GL_EXT_sparse_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_sparse_texture])
  {
    s_deviceConfig.m_glTexPageCommitmentEXT = (PFNGLTEXPAGECOMMITMENTEXTPROC) glewGetProcAddress ("glTexPageCommitmentEXT");
  }

  // GL_EXT_stencil_clear_tag
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_stencil_clear_tag])
  {
    s_deviceConfig.m_glStencilClearTagEXT = (PFNGLSTENCILCLEARTAGEXTPROC) glewGetProcAddress ("glStencilClearTagEXT");
  }

  // GL_EXT_stencil_two_side
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_stencil_two_side])
  {
    s_deviceConfig.m_glActiveStencilFaceEXT = (PFNGLACTIVESTENCILFACEEXTPROC) glewGetProcAddress ("glActiveStencilFaceEXT");
  }

  // GL_EXT_subtexture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_subtexture])
  {
    s_deviceConfig.m_glTexSubImage1DEXT = (PFNGLTEXSUBIMAGE1DEXTPROC) glewGetProcAddress ("glTexSubImage1DEXT");
    s_deviceConfig.m_glTexSubImage2DEXT = (PFNGLTEXSUBIMAGE2DEXTPROC) glewGetProcAddress ("glTexSubImage2DEXT");
  }

  // GL_EXT_tessellation_shader
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_tessellation_shader])
  {
    s_deviceConfig.m_glPatchParameteriEXT = (PFNGLPATCHPARAMETERIEXTPROC) glewGetProcAddress ("glPatchParameteriEXT");
  }

  // GL_EXT_texture3D
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture3D])
  {
    s_deviceConfig.m_glTexImage3DEXT = (PFNGLTEXIMAGE3DEXTPROC) glewGetProcAddress ("glTexImage3DEXT");
    s_deviceConfig.m_glTexSubImage3DEXT = (PFNGLTEXSUBIMAGE3DEXTPROC) glewGetProcAddress ("glTexSubImage3DEXT");
  }

  // GL_EXT_texture_array
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_array])
  {
    s_deviceConfig.m_glFramebufferTextureLayerEXT = (PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) glewGetProcAddress ("glFramebufferTextureLayerEXT");
  }

  // GL_EXT_texture_border_clamp
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_border_clamp])
  {
    s_deviceConfig.m_glTexParameterIivEXT = (PFNGLTEXPARAMETERIIVEXTPROC) glewGetProcAddress ("glTexParameterIivEXT");
    s_deviceConfig.m_glTexParameterIuivEXT = (PFNGLTEXPARAMETERIUIVEXTPROC) glewGetProcAddress ("glTexParameterIuivEXT");
    s_deviceConfig.m_glGetTexParameterIivEXT = (PFNGLGETTEXPARAMETERIIVEXTPROC) glewGetProcAddress ("glGetTexParameterIivEXT");
    s_deviceConfig.m_glGetTexParameterIuivEXT = (PFNGLGETTEXPARAMETERIUIVEXTPROC) glewGetProcAddress ("glGetTexParameterIuivEXT");
    s_deviceConfig.m_glSamplerParameterIivEXT = (PFNGLSAMPLERPARAMETERIIVEXTPROC) glewGetProcAddress ("glSamplerParameterIivEXT");
    s_deviceConfig.m_glSamplerParameterIuivEXT = (PFNGLSAMPLERPARAMETERIUIVEXTPROC) glewGetProcAddress ("glSamplerParameterIuivEXT");
    s_deviceConfig.m_glGetSamplerParameterIivEXT = (PFNGLGETSAMPLERPARAMETERIIVEXTPROC) glewGetProcAddress ("glGetSamplerParameterIivEXT");
    s_deviceConfig.m_glGetSamplerParameterIuivEXT = (PFNGLGETSAMPLERPARAMETERIUIVEXTPROC) glewGetProcAddress ("glGetSamplerParameterIuivEXT");
  }

  // GL_EXT_texture_buffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_buffer])
  {
    s_deviceConfig.m_glTexBufferEXT = (PFNGLTEXBUFFEREXTPROC) glewGetProcAddress ("glTexBufferEXT");
    s_deviceConfig.m_glTexBufferRangeEXT = (PFNGLTEXBUFFERRANGEEXTPROC) glewGetProcAddress ("glTexBufferRangeEXT");
  }

  // GL_EXT_texture_buffer_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_buffer_object])
  {
    s_deviceConfig.m_glTexBufferEXT = (PFNGLTEXBUFFEREXTPROC) glewGetProcAddress ("glTexBufferEXT");
  }

  // GL_EXT_texture_integer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_integer])
  {
    s_deviceConfig.m_glTexParameterIivEXT = (PFNGLTEXPARAMETERIIVEXTPROC) glewGetProcAddress ("glTexParameterIivEXT");
    s_deviceConfig.m_glTexParameterIuivEXT = (PFNGLTEXPARAMETERIUIVEXTPROC) glewGetProcAddress ("glTexParameterIuivEXT");
    s_deviceConfig.m_glGetTexParameterIivEXT = (PFNGLGETTEXPARAMETERIIVEXTPROC) glewGetProcAddress ("glGetTexParameterIivEXT");
    s_deviceConfig.m_glGetTexParameterIuivEXT = (PFNGLGETTEXPARAMETERIUIVEXTPROC) glewGetProcAddress ("glGetTexParameterIuivEXT");
    s_deviceConfig.m_glClearColorIiEXT = (PFNGLCLEARCOLORIIEXTPROC) glewGetProcAddress ("glClearColorIiEXT");
    s_deviceConfig.m_glClearColorIuiEXT = (PFNGLCLEARCOLORIUIEXTPROC) glewGetProcAddress ("glClearColorIuiEXT");
  }

  // GL_EXT_texture_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_object])
  {
    s_deviceConfig.m_glAreTexturesResidentEXT = (PFNGLARETEXTURESRESIDENTEXTPROC) glewGetProcAddress ("glAreTexturesResidentEXT");
    s_deviceConfig.m_glBindTextureEXT = (PFNGLBINDTEXTUREEXTPROC) glewGetProcAddress ("glBindTextureEXT");
    s_deviceConfig.m_glDeleteTexturesEXT = (PFNGLDELETETEXTURESEXTPROC) glewGetProcAddress ("glDeleteTexturesEXT");
    s_deviceConfig.m_glGenTexturesEXT = (PFNGLGENTEXTURESEXTPROC) glewGetProcAddress ("glGenTexturesEXT");
    s_deviceConfig.m_glIsTextureEXT = (PFNGLISTEXTUREEXTPROC) glewGetProcAddress ("glIsTextureEXT");
    s_deviceConfig.m_glPrioritizeTexturesEXT = (PFNGLPRIORITIZETEXTURESEXTPROC) glewGetProcAddress ("glPrioritizeTexturesEXT");
  }

  // GL_EXT_texture_perturb_normal
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_perturb_normal])
  {
    s_deviceConfig.m_glTextureNormalEXT = (PFNGLTEXTURENORMALEXTPROC) glewGetProcAddress ("glTextureNormalEXT");
  }

  // GL_EXT_texture_storage
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_storage])
  {
    s_deviceConfig.m_glTexStorage1DEXT = (PFNGLTEXSTORAGE1DEXTPROC) glewGetProcAddress ("glTexStorage1DEXT");
    s_deviceConfig.m_glTexStorage2DEXT = (PFNGLTEXSTORAGE2DEXTPROC) glewGetProcAddress ("glTexStorage2DEXT");
    s_deviceConfig.m_glTexStorage3DEXT = (PFNGLTEXSTORAGE3DEXTPROC) glewGetProcAddress ("glTexStorage3DEXT");
    s_deviceConfig.m_glTextureStorage1DEXT = (PFNGLTEXTURESTORAGE1DEXTPROC) glewGetProcAddress ("glTextureStorage1DEXT");
    s_deviceConfig.m_glTextureStorage2DEXT = (PFNGLTEXTURESTORAGE2DEXTPROC) glewGetProcAddress ("glTextureStorage2DEXT");
    s_deviceConfig.m_glTextureStorage3DEXT = (PFNGLTEXTURESTORAGE3DEXTPROC) glewGetProcAddress ("glTextureStorage3DEXT");
  }

  // GL_EXT_texture_storage_compression
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_storage_compression])
  {
    s_deviceConfig.m_glTexStorageAttribs2DEXT = (PFNGLTEXSTORAGEATTRIBS2DEXTPROC) glewGetProcAddress ("glTexStorageAttribs2DEXT");
    s_deviceConfig.m_glTexStorageAttribs3DEXT = (PFNGLTEXSTORAGEATTRIBS3DEXTPROC) glewGetProcAddress ("glTexStorageAttribs3DEXT");
  }

  // GL_EXT_texture_view
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_texture_view])
  {
    s_deviceConfig.m_glTextureViewEXT = (PFNGLTEXTUREVIEWEXTPROC) glewGetProcAddress ("glTextureViewEXT");
  }

  // GL_NV_timeline_semaphore
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_timeline_semaphore])
  {
    s_deviceConfig.m_glCreateSemaphoresNV = (PFNGLCREATESEMAPHORESNVPROC) glewGetProcAddress ("glCreateSemaphoresNV");
    s_deviceConfig.m_glSemaphoreParameterivNV = (PFNGLSEMAPHOREPARAMETERIVNVPROC) glewGetProcAddress ("glSemaphoreParameterivNV");
    s_deviceConfig.m_glGetSemaphoreParameterivNV = (PFNGLGETSEMAPHOREPARAMETERIVNVPROC) glewGetProcAddress ("glGetSemaphoreParameterivNV");
  }

  // GL_EXT_timer_query
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_timer_query])
  {
    s_deviceConfig.m_glGetQueryObjecti64vEXT = (PFNGLGETQUERYOBJECTI64VEXTPROC) glewGetProcAddress ("glGetQueryObjecti64vEXT");
    s_deviceConfig.m_glGetQueryObjectui64vEXT = (PFNGLGETQUERYOBJECTUI64VEXTPROC) glewGetProcAddress ("glGetQueryObjectui64vEXT");
  }

  // GL_EXT_transform_feedback
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_transform_feedback])
  {
    s_deviceConfig.m_glBeginTransformFeedbackEXT = (PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) glewGetProcAddress ("glBeginTransformFeedbackEXT");
    s_deviceConfig.m_glEndTransformFeedbackEXT = (PFNGLENDTRANSFORMFEEDBACKEXTPROC) glewGetProcAddress ("glEndTransformFeedbackEXT");
    s_deviceConfig.m_glBindBufferRangeEXT = (PFNGLBINDBUFFERRANGEEXTPROC) glewGetProcAddress ("glBindBufferRangeEXT");
    s_deviceConfig.m_glBindBufferOffsetEXT = (PFNGLBINDBUFFEROFFSETEXTPROC) glewGetProcAddress ("glBindBufferOffsetEXT");
    s_deviceConfig.m_glBindBufferBaseEXT = (PFNGLBINDBUFFERBASEEXTPROC) glewGetProcAddress ("glBindBufferBaseEXT");
    s_deviceConfig.m_glTransformFeedbackVaryingsEXT = (PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) glewGetProcAddress ("glTransformFeedbackVaryingsEXT");
    s_deviceConfig.m_glGetTransformFeedbackVaryingEXT = (PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) glewGetProcAddress ("glGetTransformFeedbackVaryingEXT");
  }

  // GL_EXT_vertex_array
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_vertex_array])
  {
    s_deviceConfig.m_glArrayElementEXT = (PFNGLARRAYELEMENTEXTPROC) glewGetProcAddress ("glArrayElementEXT");
    s_deviceConfig.m_glColorPointerEXT = (PFNGLCOLORPOINTEREXTPROC) glewGetProcAddress ("glColorPointerEXT");
    s_deviceConfig.m_glDrawArraysEXT = (PFNGLDRAWARRAYSEXTPROC) glewGetProcAddress ("glDrawArraysEXT");
    s_deviceConfig.m_glEdgeFlagPointerEXT = (PFNGLEDGEFLAGPOINTEREXTPROC) glewGetProcAddress ("glEdgeFlagPointerEXT");
    s_deviceConfig.m_glGetPointervEXT = (PFNGLGETPOINTERVEXTPROC) glewGetProcAddress ("glGetPointervEXT");
    s_deviceConfig.m_glIndexPointerEXT = (PFNGLINDEXPOINTEREXTPROC) glewGetProcAddress ("glIndexPointerEXT");
    s_deviceConfig.m_glNormalPointerEXT = (PFNGLNORMALPOINTEREXTPROC) glewGetProcAddress ("glNormalPointerEXT");
    s_deviceConfig.m_glTexCoordPointerEXT = (PFNGLTEXCOORDPOINTEREXTPROC) glewGetProcAddress ("glTexCoordPointerEXT");
    s_deviceConfig.m_glVertexPointerEXT = (PFNGLVERTEXPOINTEREXTPROC) glewGetProcAddress ("glVertexPointerEXT");
  }

  // GL_EXT_vertex_attrib_64bit
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_vertex_attrib_64bit])
  {
    s_deviceConfig.m_glVertexAttribL1dEXT = (PFNGLVERTEXATTRIBL1DEXTPROC) glewGetProcAddress ("glVertexAttribL1dEXT");
    s_deviceConfig.m_glVertexAttribL2dEXT = (PFNGLVERTEXATTRIBL2DEXTPROC) glewGetProcAddress ("glVertexAttribL2dEXT");
    s_deviceConfig.m_glVertexAttribL3dEXT = (PFNGLVERTEXATTRIBL3DEXTPROC) glewGetProcAddress ("glVertexAttribL3dEXT");
    s_deviceConfig.m_glVertexAttribL4dEXT = (PFNGLVERTEXATTRIBL4DEXTPROC) glewGetProcAddress ("glVertexAttribL4dEXT");
    s_deviceConfig.m_glVertexAttribL1dvEXT = (PFNGLVERTEXATTRIBL1DVEXTPROC) glewGetProcAddress ("glVertexAttribL1dvEXT");
    s_deviceConfig.m_glVertexAttribL2dvEXT = (PFNGLVERTEXATTRIBL2DVEXTPROC) glewGetProcAddress ("glVertexAttribL2dvEXT");
    s_deviceConfig.m_glVertexAttribL3dvEXT = (PFNGLVERTEXATTRIBL3DVEXTPROC) glewGetProcAddress ("glVertexAttribL3dvEXT");
    s_deviceConfig.m_glVertexAttribL4dvEXT = (PFNGLVERTEXATTRIBL4DVEXTPROC) glewGetProcAddress ("glVertexAttribL4dvEXT");
    s_deviceConfig.m_glVertexAttribLPointerEXT = (PFNGLVERTEXATTRIBLPOINTEREXTPROC) glewGetProcAddress ("glVertexAttribLPointerEXT");
    s_deviceConfig.m_glGetVertexAttribLdvEXT = (PFNGLGETVERTEXATTRIBLDVEXTPROC) glewGetProcAddress ("glGetVertexAttribLdvEXT");
  }

  // GL_EXT_vertex_shader
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_vertex_shader])
  {
    s_deviceConfig.m_glBeginVertexShaderEXT = (PFNGLBEGINVERTEXSHADEREXTPROC) glewGetProcAddress ("glBeginVertexShaderEXT");
    s_deviceConfig.m_glEndVertexShaderEXT = (PFNGLENDVERTEXSHADEREXTPROC) glewGetProcAddress ("glEndVertexShaderEXT");
    s_deviceConfig.m_glBindVertexShaderEXT = (PFNGLBINDVERTEXSHADEREXTPROC) glewGetProcAddress ("glBindVertexShaderEXT");
    s_deviceConfig.m_glGenVertexShadersEXT = (PFNGLGENVERTEXSHADERSEXTPROC) glewGetProcAddress ("glGenVertexShadersEXT");
    s_deviceConfig.m_glDeleteVertexShaderEXT = (PFNGLDELETEVERTEXSHADEREXTPROC) glewGetProcAddress ("glDeleteVertexShaderEXT");
    s_deviceConfig.m_glShaderOp1EXT = (PFNGLSHADEROP1EXTPROC) glewGetProcAddress ("glShaderOp1EXT");
    s_deviceConfig.m_glShaderOp2EXT = (PFNGLSHADEROP2EXTPROC) glewGetProcAddress ("glShaderOp2EXT");
    s_deviceConfig.m_glShaderOp3EXT = (PFNGLSHADEROP3EXTPROC) glewGetProcAddress ("glShaderOp3EXT");
    s_deviceConfig.m_glSwizzleEXT = (PFNGLSWIZZLEEXTPROC) glewGetProcAddress ("glSwizzleEXT");
    s_deviceConfig.m_glWriteMaskEXT = (PFNGLWRITEMASKEXTPROC) glewGetProcAddress ("glWriteMaskEXT");
    s_deviceConfig.m_glInsertComponentEXT = (PFNGLINSERTCOMPONENTEXTPROC) glewGetProcAddress ("glInsertComponentEXT");
    s_deviceConfig.m_glExtractComponentEXT = (PFNGLEXTRACTCOMPONENTEXTPROC) glewGetProcAddress ("glExtractComponentEXT");
    s_deviceConfig.m_glGenSymbolsEXT = (PFNGLGENSYMBOLSEXTPROC) glewGetProcAddress ("glGenSymbolsEXT");
    s_deviceConfig.m_glSetInvariantEXT = (PFNGLSETINVARIANTEXTPROC) glewGetProcAddress ("glSetInvariantEXT");
    s_deviceConfig.m_glSetLocalConstantEXT = (PFNGLSETLOCALCONSTANTEXTPROC) glewGetProcAddress ("glSetLocalConstantEXT");
    s_deviceConfig.m_glVariantbvEXT = (PFNGLVARIANTBVEXTPROC) glewGetProcAddress ("glVariantbvEXT");
    s_deviceConfig.m_glVariantsvEXT = (PFNGLVARIANTSVEXTPROC) glewGetProcAddress ("glVariantsvEXT");
    s_deviceConfig.m_glVariantivEXT = (PFNGLVARIANTIVEXTPROC) glewGetProcAddress ("glVariantivEXT");
    s_deviceConfig.m_glVariantfvEXT = (PFNGLVARIANTFVEXTPROC) glewGetProcAddress ("glVariantfvEXT");
    s_deviceConfig.m_glVariantdvEXT = (PFNGLVARIANTDVEXTPROC) glewGetProcAddress ("glVariantdvEXT");
    s_deviceConfig.m_glVariantubvEXT = (PFNGLVARIANTUBVEXTPROC) glewGetProcAddress ("glVariantubvEXT");
    s_deviceConfig.m_glVariantusvEXT = (PFNGLVARIANTUSVEXTPROC) glewGetProcAddress ("glVariantusvEXT");
    s_deviceConfig.m_glVariantuivEXT = (PFNGLVARIANTUIVEXTPROC) glewGetProcAddress ("glVariantuivEXT");
    s_deviceConfig.m_glVariantPointerEXT = (PFNGLVARIANTPOINTEREXTPROC) glewGetProcAddress ("glVariantPointerEXT");
    s_deviceConfig.m_glEnableVariantClientStateEXT = (PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) glewGetProcAddress ("glEnableVariantClientStateEXT");
    s_deviceConfig.m_glDisableVariantClientStateEXT = (PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) glewGetProcAddress ("glDisableVariantClientStateEXT");
    s_deviceConfig.m_glBindLightParameterEXT = (PFNGLBINDLIGHTPARAMETEREXTPROC) glewGetProcAddress ("glBindLightParameterEXT");
    s_deviceConfig.m_glBindMaterialParameterEXT = (PFNGLBINDMATERIALPARAMETEREXTPROC) glewGetProcAddress ("glBindMaterialParameterEXT");
    s_deviceConfig.m_glBindTexGenParameterEXT = (PFNGLBINDTEXGENPARAMETEREXTPROC) glewGetProcAddress ("glBindTexGenParameterEXT");
    s_deviceConfig.m_glBindTextureUnitParameterEXT = (PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) glewGetProcAddress ("glBindTextureUnitParameterEXT");
    s_deviceConfig.m_glBindParameterEXT = (PFNGLBINDPARAMETEREXTPROC) glewGetProcAddress ("glBindParameterEXT");
    s_deviceConfig.m_glIsVariantEnabledEXT = (PFNGLISVARIANTENABLEDEXTPROC) glewGetProcAddress ("glIsVariantEnabledEXT");
    s_deviceConfig.m_glGetVariantBooleanvEXT = (PFNGLGETVARIANTBOOLEANVEXTPROC) glewGetProcAddress ("glGetVariantBooleanvEXT");
    s_deviceConfig.m_glGetVariantIntegervEXT = (PFNGLGETVARIANTINTEGERVEXTPROC) glewGetProcAddress ("glGetVariantIntegervEXT");
    s_deviceConfig.m_glGetVariantFloatvEXT = (PFNGLGETVARIANTFLOATVEXTPROC) glewGetProcAddress ("glGetVariantFloatvEXT");
    s_deviceConfig.m_glGetVariantPointervEXT = (PFNGLGETVARIANTPOINTERVEXTPROC) glewGetProcAddress ("glGetVariantPointervEXT");
    s_deviceConfig.m_glGetInvariantBooleanvEXT = (PFNGLGETINVARIANTBOOLEANVEXTPROC) glewGetProcAddress ("glGetInvariantBooleanvEXT");
    s_deviceConfig.m_glGetInvariantIntegervEXT = (PFNGLGETINVARIANTINTEGERVEXTPROC) glewGetProcAddress ("glGetInvariantIntegervEXT");
    s_deviceConfig.m_glGetInvariantFloatvEXT = (PFNGLGETINVARIANTFLOATVEXTPROC) glewGetProcAddress ("glGetInvariantFloatvEXT");
    s_deviceConfig.m_glGetLocalConstantBooleanvEXT = (PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) glewGetProcAddress ("glGetLocalConstantBooleanvEXT");
    s_deviceConfig.m_glGetLocalConstantIntegervEXT = (PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) glewGetProcAddress ("glGetLocalConstantIntegervEXT");
    s_deviceConfig.m_glGetLocalConstantFloatvEXT = (PFNGLGETLOCALCONSTANTFLOATVEXTPROC) glewGetProcAddress ("glGetLocalConstantFloatvEXT");
  }

  // GL_EXT_vertex_weighting
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_vertex_weighting])
  {
    s_deviceConfig.m_glVertexWeightfEXT = (PFNGLVERTEXWEIGHTFEXTPROC) glewGetProcAddress ("glVertexWeightfEXT");
    s_deviceConfig.m_glVertexWeightfvEXT = (PFNGLVERTEXWEIGHTFVEXTPROC) glewGetProcAddress ("glVertexWeightfvEXT");
    s_deviceConfig.m_glVertexWeightPointerEXT = (PFNGLVERTEXWEIGHTPOINTEREXTPROC) glewGetProcAddress ("glVertexWeightPointerEXT");
  }

  // GL_EXT_win32_keyed_mutex
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_win32_keyed_mutex])
  {
    s_deviceConfig.m_glAcquireKeyedMutexWin32EXT = (PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC) glewGetProcAddress ("glAcquireKeyedMutexWin32EXT");
    s_deviceConfig.m_glReleaseKeyedMutexWin32EXT = (PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC) glewGetProcAddress ("glReleaseKeyedMutexWin32EXT");
  }

  // GL_EXT_window_rectangles
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_window_rectangles])
  {
    s_deviceConfig.m_glWindowRectanglesEXT = (PFNGLWINDOWRECTANGLESEXTPROC) glewGetProcAddress ("glWindowRectanglesEXT");
  }

  // GL_EXT_x11_sync_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_EXT_x11_sync_object])
  {
    s_deviceConfig.m_glImportSyncEXT = (PFNGLIMPORTSYNCEXTPROC) glewGetProcAddress ("glImportSyncEXT");
  }

  // GL_GREMEDY_frame_terminator
  if (s_deviceConfig.m_featureSupported [GLEW_GL_GREMEDY_frame_terminator])
  {
    s_deviceConfig.m_glFrameTerminatorGREMEDY = (PFNGLFRAMETERMINATORGREMEDYPROC) glewGetProcAddress ("glFrameTerminatorGREMEDY");
  }

  // GL_GREMEDY_string_marker
  if (s_deviceConfig.m_featureSupported [GLEW_GL_GREMEDY_string_marker])
  {
    s_deviceConfig.m_glStringMarkerGREMEDY = (PFNGLSTRINGMARKERGREMEDYPROC) glewGetProcAddress ("glStringMarkerGREMEDY");
  }

  // GL_HP_image_transform
  if (s_deviceConfig.m_featureSupported [GLEW_GL_HP_image_transform])
  {
    s_deviceConfig.m_glImageTransformParameteriHP = (PFNGLIMAGETRANSFORMPARAMETERIHPPROC) glewGetProcAddress ("glImageTransformParameteriHP");
    s_deviceConfig.m_glImageTransformParameterfHP = (PFNGLIMAGETRANSFORMPARAMETERFHPPROC) glewGetProcAddress ("glImageTransformParameterfHP");
    s_deviceConfig.m_glImageTransformParameterivHP = (PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) glewGetProcAddress ("glImageTransformParameterivHP");
    s_deviceConfig.m_glImageTransformParameterfvHP = (PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) glewGetProcAddress ("glImageTransformParameterfvHP");
    s_deviceConfig.m_glGetImageTransformParameterivHP = (PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) glewGetProcAddress ("glGetImageTransformParameterivHP");
    s_deviceConfig.m_glGetImageTransformParameterfvHP = (PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) glewGetProcAddress ("glGetImageTransformParameterfvHP");
  }

  // GL_IBM_multimode_draw_arrays
  if (s_deviceConfig.m_featureSupported [GLEW_GL_IBM_multimode_draw_arrays])
  {
    s_deviceConfig.m_glMultiModeDrawArraysIBM = (PFNGLMULTIMODEDRAWARRAYSIBMPROC) glewGetProcAddress ("glMultiModeDrawArraysIBM");
    s_deviceConfig.m_glMultiModeDrawElementsIBM = (PFNGLMULTIMODEDRAWELEMENTSIBMPROC) glewGetProcAddress ("glMultiModeDrawElementsIBM");
  }

  // GL_IBM_static_data
  if (s_deviceConfig.m_featureSupported [GLEW_GL_IBM_static_data])
  {
    s_deviceConfig.m_glFlushStaticDataIBM = (PFNGLFLUSHSTATICDATAIBMPROC) glewGetProcAddress ("glFlushStaticDataIBM");
  }

  // GL_IBM_vertex_array_lists
  if (s_deviceConfig.m_featureSupported [GLEW_GL_IBM_vertex_array_lists])
  {
    s_deviceConfig.m_glColorPointerListIBM = (PFNGLCOLORPOINTERLISTIBMPROC) glewGetProcAddress ("glColorPointerListIBM");
    s_deviceConfig.m_glSecondaryColorPointerListIBM = (PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) glewGetProcAddress ("glSecondaryColorPointerListIBM");
    s_deviceConfig.m_glEdgeFlagPointerListIBM = (PFNGLEDGEFLAGPOINTERLISTIBMPROC) glewGetProcAddress ("glEdgeFlagPointerListIBM");
    s_deviceConfig.m_glFogCoordPointerListIBM = (PFNGLFOGCOORDPOINTERLISTIBMPROC) glewGetProcAddress ("glFogCoordPointerListIBM");
    s_deviceConfig.m_glIndexPointerListIBM = (PFNGLINDEXPOINTERLISTIBMPROC) glewGetProcAddress ("glIndexPointerListIBM");
    s_deviceConfig.m_glNormalPointerListIBM = (PFNGLNORMALPOINTERLISTIBMPROC) glewGetProcAddress ("glNormalPointerListIBM");
    s_deviceConfig.m_glTexCoordPointerListIBM = (PFNGLTEXCOORDPOINTERLISTIBMPROC) glewGetProcAddress ("glTexCoordPointerListIBM");
    s_deviceConfig.m_glVertexPointerListIBM = (PFNGLVERTEXPOINTERLISTIBMPROC) glewGetProcAddress ("glVertexPointerListIBM");
  }

  // GL_IMG_bindless_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_IMG_bindless_texture])
  {
    s_deviceConfig.m_glGetTextureHandleIMG = (PFNGLGETTEXTUREHANDLEIMGPROC) glewGetProcAddress ("glGetTextureHandleIMG");
    s_deviceConfig.m_glGetTextureSamplerHandleIMG = (PFNGLGETTEXTURESAMPLERHANDLEIMGPROC) glewGetProcAddress ("glGetTextureSamplerHandleIMG");
    s_deviceConfig.m_glUniformHandleui64IMG = (PFNGLUNIFORMHANDLEUI64IMGPROC) glewGetProcAddress ("glUniformHandleui64IMG");
    s_deviceConfig.m_glUniformHandleui64vIMG = (PFNGLUNIFORMHANDLEUI64VIMGPROC) glewGetProcAddress ("glUniformHandleui64vIMG");
    s_deviceConfig.m_glProgramUniformHandleui64IMG = (PFNGLPROGRAMUNIFORMHANDLEUI64IMGPROC) glewGetProcAddress ("glProgramUniformHandleui64IMG");
    s_deviceConfig.m_glProgramUniformHandleui64vIMG = (PFNGLPROGRAMUNIFORMHANDLEUI64VIMGPROC) glewGetProcAddress ("glProgramUniformHandleui64vIMG");
  }

  // GL_IMG_framebuffer_downsample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_IMG_framebuffer_downsample])
  {
    s_deviceConfig.m_glFramebufferTexture2DDownsampleIMG = (PFNGLFRAMEBUFFERTEXTURE2DDOWNSAMPLEIMGPROC) glewGetProcAddress ("glFramebufferTexture2DDownsampleIMG");
    s_deviceConfig.m_glFramebufferTextureLayerDownsampleIMG = (PFNGLFRAMEBUFFERTEXTURELAYERDOWNSAMPLEIMGPROC) glewGetProcAddress ("glFramebufferTextureLayerDownsampleIMG");
  }

  // GL_IMG_multisampled_render_to_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_IMG_multisampled_render_to_texture])
  {
    s_deviceConfig.m_glRenderbufferStorageMultisampleIMG = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEIMGPROC) glewGetProcAddress ("glRenderbufferStorageMultisampleIMG");
    s_deviceConfig.m_glFramebufferTexture2DMultisampleIMG = (PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEIMGPROC) glewGetProcAddress ("glFramebufferTexture2DMultisampleIMG");
  }

  // GL_INGR_blend_func_separate
  if (s_deviceConfig.m_featureSupported [GLEW_GL_INGR_blend_func_separate])
  {
    s_deviceConfig.m_glBlendFuncSeparateINGR = (PFNGLBLENDFUNCSEPARATEINGRPROC) glewGetProcAddress ("glBlendFuncSeparateINGR");
  }

  // GL_INTEL_framebuffer_CMAA
  if (s_deviceConfig.m_featureSupported [GLEW_GL_INTEL_framebuffer_CMAA])
  {
    s_deviceConfig.m_glApplyFramebufferAttachmentCMAAINTEL = (PFNGLAPPLYFRAMEBUFFERATTACHMENTCMAAINTELPROC) glewGetProcAddress ("glApplyFramebufferAttachmentCMAAINTEL");
  }

  // GL_INTEL_map_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_INTEL_map_texture])
  {
    s_deviceConfig.m_glSyncTextureINTEL = (PFNGLSYNCTEXTUREINTELPROC) glewGetProcAddress ("glSyncTextureINTEL");
    s_deviceConfig.m_glUnmapTexture2DINTEL = (PFNGLUNMAPTEXTURE2DINTELPROC) glewGetProcAddress ("glUnmapTexture2DINTEL");
    s_deviceConfig.m_glMapTexture2DINTEL = (PFNGLMAPTEXTURE2DINTELPROC) glewGetProcAddress ("glMapTexture2DINTEL");
  }

  // GL_INTEL_parallel_arrays
  if (s_deviceConfig.m_featureSupported [GLEW_GL_INTEL_parallel_arrays])
  {
    s_deviceConfig.m_glVertexPointervINTEL = (PFNGLVERTEXPOINTERVINTELPROC) glewGetProcAddress ("glVertexPointervINTEL");
    s_deviceConfig.m_glNormalPointervINTEL = (PFNGLNORMALPOINTERVINTELPROC) glewGetProcAddress ("glNormalPointervINTEL");
    s_deviceConfig.m_glColorPointervINTEL = (PFNGLCOLORPOINTERVINTELPROC) glewGetProcAddress ("glColorPointervINTEL");
    s_deviceConfig.m_glTexCoordPointervINTEL = (PFNGLTEXCOORDPOINTERVINTELPROC) glewGetProcAddress ("glTexCoordPointervINTEL");
  }

  // GL_INTEL_performance_query
  if (s_deviceConfig.m_featureSupported [GLEW_GL_INTEL_performance_query])
  {
    s_deviceConfig.m_glBeginPerfQueryINTEL = (PFNGLBEGINPERFQUERYINTELPROC) glewGetProcAddress ("glBeginPerfQueryINTEL");
    s_deviceConfig.m_glCreatePerfQueryINTEL = (PFNGLCREATEPERFQUERYINTELPROC) glewGetProcAddress ("glCreatePerfQueryINTEL");
    s_deviceConfig.m_glDeletePerfQueryINTEL = (PFNGLDELETEPERFQUERYINTELPROC) glewGetProcAddress ("glDeletePerfQueryINTEL");
    s_deviceConfig.m_glEndPerfQueryINTEL = (PFNGLENDPERFQUERYINTELPROC) glewGetProcAddress ("glEndPerfQueryINTEL");
    s_deviceConfig.m_glGetFirstPerfQueryIdINTEL = (PFNGLGETFIRSTPERFQUERYIDINTELPROC) glewGetProcAddress ("glGetFirstPerfQueryIdINTEL");
    s_deviceConfig.m_glGetNextPerfQueryIdINTEL = (PFNGLGETNEXTPERFQUERYIDINTELPROC) glewGetProcAddress ("glGetNextPerfQueryIdINTEL");
    s_deviceConfig.m_glGetPerfCounterInfoINTEL = (PFNGLGETPERFCOUNTERINFOINTELPROC) glewGetProcAddress ("glGetPerfCounterInfoINTEL");
    s_deviceConfig.m_glGetPerfQueryDataINTEL = (PFNGLGETPERFQUERYDATAINTELPROC) glewGetProcAddress ("glGetPerfQueryDataINTEL");
    s_deviceConfig.m_glGetPerfQueryIdByNameINTEL = (PFNGLGETPERFQUERYIDBYNAMEINTELPROC) glewGetProcAddress ("glGetPerfQueryIdByNameINTEL");
    s_deviceConfig.m_glGetPerfQueryInfoINTEL = (PFNGLGETPERFQUERYINFOINTELPROC) glewGetProcAddress ("glGetPerfQueryInfoINTEL");
  }

  // GL_KHR_blend_equation_advanced
  if (s_deviceConfig.m_featureSupported [GLEW_GL_KHR_blend_equation_advanced])
  {
    s_deviceConfig.m_glBlendBarrierKHR = (PFNGLBLENDBARRIERKHRPROC) glewGetProcAddress ("glBlendBarrierKHR");
  }

  // GL_KHR_debug
  if (s_deviceConfig.m_featureSupported [GLEW_GL_KHR_debug])
  {
    s_deviceConfig.m_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC) glewGetProcAddress ("glDebugMessageControl");
    s_deviceConfig.m_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC) glewGetProcAddress ("glDebugMessageInsert");
    s_deviceConfig.m_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC) glewGetProcAddress ("glDebugMessageCallback");
    s_deviceConfig.m_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC) glewGetProcAddress ("glGetDebugMessageLog");
    s_deviceConfig.m_glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC) glewGetProcAddress ("glPushDebugGroup");
    s_deviceConfig.m_glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC) glewGetProcAddress ("glPopDebugGroup");
    s_deviceConfig.m_glObjectLabel = (PFNGLOBJECTLABELPROC) glewGetProcAddress ("glObjectLabel");
    s_deviceConfig.m_glGetObjectLabel = (PFNGLGETOBJECTLABELPROC) glewGetProcAddress ("glGetObjectLabel");
    s_deviceConfig.m_glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC) glewGetProcAddress ("glObjectPtrLabel");
    s_deviceConfig.m_glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC) glewGetProcAddress ("glGetObjectPtrLabel");
    s_deviceConfig.m_glGetPointerv = (PFNGLGETPOINTERVPROC) glewGetProcAddress ("glGetPointerv");
    s_deviceConfig.m_glDebugMessageControlKHR = (PFNGLDEBUGMESSAGECONTROLKHRPROC) glewGetProcAddress ("glDebugMessageControlKHR");
    s_deviceConfig.m_glDebugMessageInsertKHR = (PFNGLDEBUGMESSAGEINSERTKHRPROC) glewGetProcAddress ("glDebugMessageInsertKHR");
    s_deviceConfig.m_glDebugMessageCallbackKHR = (PFNGLDEBUGMESSAGECALLBACKKHRPROC) glewGetProcAddress ("glDebugMessageCallbackKHR");
    s_deviceConfig.m_glGetDebugMessageLogKHR = (PFNGLGETDEBUGMESSAGELOGKHRPROC) glewGetProcAddress ("glGetDebugMessageLogKHR");
    s_deviceConfig.m_glPushDebugGroupKHR = (PFNGLPUSHDEBUGGROUPKHRPROC) glewGetProcAddress ("glPushDebugGroupKHR");
    s_deviceConfig.m_glPopDebugGroupKHR = (PFNGLPOPDEBUGGROUPKHRPROC) glewGetProcAddress ("glPopDebugGroupKHR");
    s_deviceConfig.m_glObjectLabelKHR = (PFNGLOBJECTLABELKHRPROC) glewGetProcAddress ("glObjectLabelKHR");
    s_deviceConfig.m_glGetObjectLabelKHR = (PFNGLGETOBJECTLABELKHRPROC) glewGetProcAddress ("glGetObjectLabelKHR");
    s_deviceConfig.m_glObjectPtrLabelKHR = (PFNGLOBJECTPTRLABELKHRPROC) glewGetProcAddress ("glObjectPtrLabelKHR");
    s_deviceConfig.m_glGetObjectPtrLabelKHR = (PFNGLGETOBJECTPTRLABELKHRPROC) glewGetProcAddress ("glGetObjectPtrLabelKHR");
    s_deviceConfig.m_glGetPointervKHR = (PFNGLGETPOINTERVKHRPROC) glewGetProcAddress ("glGetPointervKHR");
  }

  // GL_KHR_robustness
  if (s_deviceConfig.m_featureSupported [GLEW_GL_KHR_robustness])
  {
    s_deviceConfig.m_glGetGraphicsResetStatus = (PFNGLGETGRAPHICSRESETSTATUSPROC) glewGetProcAddress ("glGetGraphicsResetStatus");
    s_deviceConfig.m_glReadnPixels = (PFNGLREADNPIXELSPROC) glewGetProcAddress ("glReadnPixels");
    s_deviceConfig.m_glGetnUniformfv = (PFNGLGETNUNIFORMFVPROC) glewGetProcAddress ("glGetnUniformfv");
    s_deviceConfig.m_glGetnUniformiv = (PFNGLGETNUNIFORMIVPROC) glewGetProcAddress ("glGetnUniformiv");
    s_deviceConfig.m_glGetnUniformuiv = (PFNGLGETNUNIFORMUIVPROC) glewGetProcAddress ("glGetnUniformuiv");
    s_deviceConfig.m_glGetGraphicsResetStatusKHR = (PFNGLGETGRAPHICSRESETSTATUSKHRPROC) glewGetProcAddress ("glGetGraphicsResetStatusKHR");
    s_deviceConfig.m_glReadnPixelsKHR = (PFNGLREADNPIXELSKHRPROC) glewGetProcAddress ("glReadnPixelsKHR");
    s_deviceConfig.m_glGetnUniformfvKHR = (PFNGLGETNUNIFORMFVKHRPROC) glewGetProcAddress ("glGetnUniformfvKHR");
    s_deviceConfig.m_glGetnUniformivKHR = (PFNGLGETNUNIFORMIVKHRPROC) glewGetProcAddress ("glGetnUniformivKHR");
    s_deviceConfig.m_glGetnUniformuivKHR = (PFNGLGETNUNIFORMUIVKHRPROC) glewGetProcAddress ("glGetnUniformuivKHR");
  }

  // GL_KHR_parallel_shader_compile
  if (s_deviceConfig.m_featureSupported [GLEW_GL_KHR_parallel_shader_compile])
  {
    s_deviceConfig.m_glMaxShaderCompilerThreadsKHR = (PFNGLMAXSHADERCOMPILERTHREADSKHRPROC) glewGetProcAddress ("glMaxShaderCompilerThreadsKHR");
  }

  // GL_MESA_framebuffer_flip_y
  if (s_deviceConfig.m_featureSupported [GLEW_GL_MESA_framebuffer_flip_y])
  {
    s_deviceConfig.m_glFramebufferParameteriMESA = (PFNGLFRAMEBUFFERPARAMETERIMESAPROC) glewGetProcAddress ("glFramebufferParameteriMESA");
    s_deviceConfig.m_glGetFramebufferParameterivMESA = (PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC) glewGetProcAddress ("glGetFramebufferParameterivMESA");
  }

  // GL_MESA_resize_buffers
  if (s_deviceConfig.m_featureSupported [GLEW_GL_MESA_resize_buffers])
  {
    s_deviceConfig.m_glResizeBuffersMESA = (PFNGLRESIZEBUFFERSMESAPROC) glewGetProcAddress ("glResizeBuffersMESA");
  }

  // GL_MESA_sampler_objects
  if (s_deviceConfig.m_featureSupported [GLEW_GL_MESA_sampler_objects])
  {
    s_deviceConfig.m_glGenSamplers = (PFNGLGENSAMPLERSPROC) glewGetProcAddress ("glGenSamplers");
    s_deviceConfig.m_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC) glewGetProcAddress ("glDeleteSamplers");
    s_deviceConfig.m_glIsSampler = (PFNGLISSAMPLERPROC) glewGetProcAddress ("glIsSampler");
    s_deviceConfig.m_glBindSampler = (PFNGLBINDSAMPLERPROC) glewGetProcAddress ("glBindSampler");
    s_deviceConfig.m_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC) glewGetProcAddress ("glSamplerParameteri");
    s_deviceConfig.m_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC) glewGetProcAddress ("glSamplerParameteriv");
    s_deviceConfig.m_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC) glewGetProcAddress ("glSamplerParameterf");
    s_deviceConfig.m_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC) glewGetProcAddress ("glSamplerParameterfv");
    s_deviceConfig.m_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC) glewGetProcAddress ("glGetSamplerParameteriv");
    s_deviceConfig.m_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC) glewGetProcAddress ("glGetSamplerParameterfv");
  }

  // GL_MESA_window_pos
  if (s_deviceConfig.m_featureSupported [GLEW_GL_MESA_window_pos])
  {
    s_deviceConfig.m_glWindowPos2dMESA = (PFNGLWINDOWPOS2DMESAPROC) glewGetProcAddress ("glWindowPos2dMESA");
    s_deviceConfig.m_glWindowPos2dvMESA = (PFNGLWINDOWPOS2DVMESAPROC) glewGetProcAddress ("glWindowPos2dvMESA");
    s_deviceConfig.m_glWindowPos2fMESA = (PFNGLWINDOWPOS2FMESAPROC) glewGetProcAddress ("glWindowPos2fMESA");
    s_deviceConfig.m_glWindowPos2fvMESA = (PFNGLWINDOWPOS2FVMESAPROC) glewGetProcAddress ("glWindowPos2fvMESA");
    s_deviceConfig.m_glWindowPos2iMESA = (PFNGLWINDOWPOS2IMESAPROC) glewGetProcAddress ("glWindowPos2iMESA");
    s_deviceConfig.m_glWindowPos2ivMESA = (PFNGLWINDOWPOS2IVMESAPROC) glewGetProcAddress ("glWindowPos2ivMESA");
    s_deviceConfig.m_glWindowPos2sMESA = (PFNGLWINDOWPOS2SMESAPROC) glewGetProcAddress ("glWindowPos2sMESA");
    s_deviceConfig.m_glWindowPos2svMESA = (PFNGLWINDOWPOS2SVMESAPROC) glewGetProcAddress ("glWindowPos2svMESA");
    s_deviceConfig.m_glWindowPos3dMESA = (PFNGLWINDOWPOS3DMESAPROC) glewGetProcAddress ("glWindowPos3dMESA");
    s_deviceConfig.m_glWindowPos3dvMESA = (PFNGLWINDOWPOS3DVMESAPROC) glewGetProcAddress ("glWindowPos3dvMESA");
    s_deviceConfig.m_glWindowPos3fMESA = (PFNGLWINDOWPOS3FMESAPROC) glewGetProcAddress ("glWindowPos3fMESA");
    s_deviceConfig.m_glWindowPos3fvMESA = (PFNGLWINDOWPOS3FVMESAPROC) glewGetProcAddress ("glWindowPos3fvMESA");
    s_deviceConfig.m_glWindowPos3iMESA = (PFNGLWINDOWPOS3IMESAPROC) glewGetProcAddress ("glWindowPos3iMESA");
    s_deviceConfig.m_glWindowPos3ivMESA = (PFNGLWINDOWPOS3IVMESAPROC) glewGetProcAddress ("glWindowPos3ivMESA");
    s_deviceConfig.m_glWindowPos3sMESA = (PFNGLWINDOWPOS3SMESAPROC) glewGetProcAddress ("glWindowPos3sMESA");
    s_deviceConfig.m_glWindowPos3svMESA = (PFNGLWINDOWPOS3SVMESAPROC) glewGetProcAddress ("glWindowPos3svMESA");
    s_deviceConfig.m_glWindowPos4dMESA = (PFNGLWINDOWPOS4DMESAPROC) glewGetProcAddress ("glWindowPos4dMESA");
    s_deviceConfig.m_glWindowPos4dvMESA = (PFNGLWINDOWPOS4DVMESAPROC) glewGetProcAddress ("glWindowPos4dvMESA");
    s_deviceConfig.m_glWindowPos4fMESA = (PFNGLWINDOWPOS4FMESAPROC) glewGetProcAddress ("glWindowPos4fMESA");
    s_deviceConfig.m_glWindowPos4fvMESA = (PFNGLWINDOWPOS4FVMESAPROC) glewGetProcAddress ("glWindowPos4fvMESA");
    s_deviceConfig.m_glWindowPos4iMESA = (PFNGLWINDOWPOS4IMESAPROC) glewGetProcAddress ("glWindowPos4iMESA");
    s_deviceConfig.m_glWindowPos4ivMESA = (PFNGLWINDOWPOS4IVMESAPROC) glewGetProcAddress ("glWindowPos4ivMESA");
    s_deviceConfig.m_glWindowPos4sMESA = (PFNGLWINDOWPOS4SMESAPROC) glewGetProcAddress ("glWindowPos4sMESA");
    s_deviceConfig.m_glWindowPos4svMESA = (PFNGLWINDOWPOS4SVMESAPROC) glewGetProcAddress ("glWindowPos4svMESA");
  }

  // GL_NVX_conditional_render
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NVX_conditional_render])
  {
    s_deviceConfig.m_glBeginConditionalRenderNVX = (PFNGLBEGINCONDITIONALRENDERNVXPROC) glewGetProcAddress ("glBeginConditionalRenderNVX");
    s_deviceConfig.m_glEndConditionalRenderNVX = (PFNGLENDCONDITIONALRENDERNVXPROC) glewGetProcAddress ("glEndConditionalRenderNVX");
  }

  // GL_NVX_linked_gpu_multicast
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NVX_linked_gpu_multicast])
  {
    s_deviceConfig.m_glLGPUNamedBufferSubDataNVX = (PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC) glewGetProcAddress ("glLGPUNamedBufferSubDataNVX");
    s_deviceConfig.m_glLGPUCopyImageSubDataNVX = (PFNGLLGPUCOPYIMAGESUBDATANVXPROC) glewGetProcAddress ("glLGPUCopyImageSubDataNVX");
    s_deviceConfig.m_glLGPUInterlockNVX = (PFNGLLGPUINTERLOCKNVXPROC) glewGetProcAddress ("glLGPUInterlockNVX");
  }

  // GL_NV_alpha_to_coverage_dither_control
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_alpha_to_coverage_dither_control])
  {
    s_deviceConfig.m_glAlphaToCoverageDitherControlNV = (PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC) glewGetProcAddress ("glAlphaToCoverageDitherControlNV");
  }

  // GL_NV_bindless_multi_draw_indirect
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_bindless_multi_draw_indirect])
  {
    s_deviceConfig.m_glMultiDrawArraysIndirectBindlessNV = (PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) glewGetProcAddress ("glMultiDrawArraysIndirectBindlessNV");
    s_deviceConfig.m_glMultiDrawElementsIndirectBindlessNV = (PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) glewGetProcAddress ("glMultiDrawElementsIndirectBindlessNV");
  }

  // GL_NV_bindless_multi_draw_indirect_count
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_bindless_multi_draw_indirect_count])
  {
    s_deviceConfig.m_glMultiDrawArraysIndirectBindlessCountNV = (PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC) glewGetProcAddress ("glMultiDrawArraysIndirectBindlessCountNV");
    s_deviceConfig.m_glMultiDrawElementsIndirectBindlessCountNV = (PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC) glewGetProcAddress ("glMultiDrawElementsIndirectBindlessCountNV");
  }

  // GL_NV_bindless_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_bindless_texture])
  {
    s_deviceConfig.m_glGetTextureHandleNV = (PFNGLGETTEXTUREHANDLENVPROC) glewGetProcAddress ("glGetTextureHandleNV");
    s_deviceConfig.m_glGetTextureSamplerHandleNV = (PFNGLGETTEXTURESAMPLERHANDLENVPROC) glewGetProcAddress ("glGetTextureSamplerHandleNV");
    s_deviceConfig.m_glMakeTextureHandleResidentNV = (PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) glewGetProcAddress ("glMakeTextureHandleResidentNV");
    s_deviceConfig.m_glMakeTextureHandleNonResidentNV = (PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) glewGetProcAddress ("glMakeTextureHandleNonResidentNV");
    s_deviceConfig.m_glGetImageHandleNV = (PFNGLGETIMAGEHANDLENVPROC) glewGetProcAddress ("glGetImageHandleNV");
    s_deviceConfig.m_glMakeImageHandleResidentNV = (PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) glewGetProcAddress ("glMakeImageHandleResidentNV");
    s_deviceConfig.m_glMakeImageHandleNonResidentNV = (PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) glewGetProcAddress ("glMakeImageHandleNonResidentNV");
    s_deviceConfig.m_glUniformHandleui64NV = (PFNGLUNIFORMHANDLEUI64NVPROC) glewGetProcAddress ("glUniformHandleui64NV");
    s_deviceConfig.m_glUniformHandleui64vNV = (PFNGLUNIFORMHANDLEUI64VNVPROC) glewGetProcAddress ("glUniformHandleui64vNV");
    s_deviceConfig.m_glProgramUniformHandleui64NV = (PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) glewGetProcAddress ("glProgramUniformHandleui64NV");
    s_deviceConfig.m_glProgramUniformHandleui64vNV = (PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) glewGetProcAddress ("glProgramUniformHandleui64vNV");
    s_deviceConfig.m_glIsTextureHandleResidentNV = (PFNGLISTEXTUREHANDLERESIDENTNVPROC) glewGetProcAddress ("glIsTextureHandleResidentNV");
    s_deviceConfig.m_glIsImageHandleResidentNV = (PFNGLISIMAGEHANDLERESIDENTNVPROC) glewGetProcAddress ("glIsImageHandleResidentNV");
  }

  // GL_NV_blend_equation_advanced
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_blend_equation_advanced])
  {
    s_deviceConfig.m_glBlendParameteriNV = (PFNGLBLENDPARAMETERINVPROC) glewGetProcAddress ("glBlendParameteriNV");
    s_deviceConfig.m_glBlendBarrierNV = (PFNGLBLENDBARRIERNVPROC) glewGetProcAddress ("glBlendBarrierNV");
  }

  // GL_NV_clip_space_w_scaling
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_clip_space_w_scaling])
  {
    s_deviceConfig.m_glViewportPositionWScaleNV = (PFNGLVIEWPORTPOSITIONWSCALENVPROC) glewGetProcAddress ("glViewportPositionWScaleNV");
  }

  // GL_NV_command_list
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_command_list])
  {
    s_deviceConfig.m_glCreateStatesNV = (PFNGLCREATESTATESNVPROC) glewGetProcAddress ("glCreateStatesNV");
    s_deviceConfig.m_glDeleteStatesNV = (PFNGLDELETESTATESNVPROC) glewGetProcAddress ("glDeleteStatesNV");
    s_deviceConfig.m_glIsStateNV = (PFNGLISSTATENVPROC) glewGetProcAddress ("glIsStateNV");
    s_deviceConfig.m_glStateCaptureNV = (PFNGLSTATECAPTURENVPROC) glewGetProcAddress ("glStateCaptureNV");
    s_deviceConfig.m_glGetCommandHeaderNV = (PFNGLGETCOMMANDHEADERNVPROC) glewGetProcAddress ("glGetCommandHeaderNV");
    s_deviceConfig.m_glGetStageIndexNV = (PFNGLGETSTAGEINDEXNVPROC) glewGetProcAddress ("glGetStageIndexNV");
    s_deviceConfig.m_glDrawCommandsNV = (PFNGLDRAWCOMMANDSNVPROC) glewGetProcAddress ("glDrawCommandsNV");
    s_deviceConfig.m_glDrawCommandsAddressNV = (PFNGLDRAWCOMMANDSADDRESSNVPROC) glewGetProcAddress ("glDrawCommandsAddressNV");
    s_deviceConfig.m_glDrawCommandsStatesNV = (PFNGLDRAWCOMMANDSSTATESNVPROC) glewGetProcAddress ("glDrawCommandsStatesNV");
    s_deviceConfig.m_glDrawCommandsStatesAddressNV = (PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC) glewGetProcAddress ("glDrawCommandsStatesAddressNV");
    s_deviceConfig.m_glCreateCommandListsNV = (PFNGLCREATECOMMANDLISTSNVPROC) glewGetProcAddress ("glCreateCommandListsNV");
    s_deviceConfig.m_glDeleteCommandListsNV = (PFNGLDELETECOMMANDLISTSNVPROC) glewGetProcAddress ("glDeleteCommandListsNV");
    s_deviceConfig.m_glIsCommandListNV = (PFNGLISCOMMANDLISTNVPROC) glewGetProcAddress ("glIsCommandListNV");
    s_deviceConfig.m_glListDrawCommandsStatesClientNV = (PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC) glewGetProcAddress ("glListDrawCommandsStatesClientNV");
    s_deviceConfig.m_glCommandListSegmentsNV = (PFNGLCOMMANDLISTSEGMENTSNVPROC) glewGetProcAddress ("glCommandListSegmentsNV");
    s_deviceConfig.m_glCompileCommandListNV = (PFNGLCOMPILECOMMANDLISTNVPROC) glewGetProcAddress ("glCompileCommandListNV");
    s_deviceConfig.m_glCallCommandListNV = (PFNGLCALLCOMMANDLISTNVPROC) glewGetProcAddress ("glCallCommandListNV");
  }

  // GL_NV_conditional_render
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_conditional_render])
  {
    s_deviceConfig.m_glBeginConditionalRenderNV = (PFNGLBEGINCONDITIONALRENDERNVPROC) glewGetProcAddress ("glBeginConditionalRenderNV");
    s_deviceConfig.m_glEndConditionalRenderNV = (PFNGLENDCONDITIONALRENDERNVPROC) glewGetProcAddress ("glEndConditionalRenderNV");
  }

  // GL_NV_conservative_raster
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_conservative_raster])
  {
    s_deviceConfig.m_glSubpixelPrecisionBiasNV = (PFNGLSUBPIXELPRECISIONBIASNVPROC) glewGetProcAddress ("glSubpixelPrecisionBiasNV");
  }

  // GL_NV_conservative_raster_dilate
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_conservative_raster_dilate])
  {
    s_deviceConfig.m_glConservativeRasterParameterfNV = (PFNGLCONSERVATIVERASTERPARAMETERFNVPROC) glewGetProcAddress ("glConservativeRasterParameterfNV");
  }

  // GL_NV_conservative_raster_pre_snap_triangles
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_conservative_raster_pre_snap_triangles])
  {
    s_deviceConfig.m_glConservativeRasterParameteriNV = (PFNGLCONSERVATIVERASTERPARAMETERINVPROC) glewGetProcAddress ("glConservativeRasterParameteriNV");
  }

  // GL_NV_copy_buffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_copy_buffer])
  {
    s_deviceConfig.m_glCopyBufferSubDataNV = (PFNGLCOPYBUFFERSUBDATANVPROC) glewGetProcAddress ("glCopyBufferSubDataNV");
  }

  // GL_NV_copy_image
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_copy_image])
  {
    s_deviceConfig.m_glCopyImageSubDataNV = (PFNGLCOPYIMAGESUBDATANVPROC) glewGetProcAddress ("glCopyImageSubDataNV");
  }

  // GL_NV_coverage_sample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_coverage_sample])
  {
    s_deviceConfig.m_glCoverageMaskNV = (PFNGLCOVERAGEMASKNVPROC) glewGetProcAddress ("glCoverageMaskNV");
    s_deviceConfig.m_glCoverageOperationNV = (PFNGLCOVERAGEOPERATIONNVPROC) glewGetProcAddress ("glCoverageOperationNV");
  }

  // GL_NV_depth_buffer_float
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_depth_buffer_float])
  {
    s_deviceConfig.m_glDepthRangedNV = (PFNGLDEPTHRANGEDNVPROC) glewGetProcAddress ("glDepthRangedNV");
    s_deviceConfig.m_glClearDepthdNV = (PFNGLCLEARDEPTHDNVPROC) glewGetProcAddress ("glClearDepthdNV");
    s_deviceConfig.m_glDepthBoundsdNV = (PFNGLDEPTHBOUNDSDNVPROC) glewGetProcAddress ("glDepthBoundsdNV");
  }

  // GL_NV_draw_buffers
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_draw_buffers])
  {
    s_deviceConfig.m_glDrawBuffersNV = (PFNGLDRAWBUFFERSNVPROC) glewGetProcAddress ("glDrawBuffersNV");
  }

  // GL_NV_draw_instanced
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_draw_instanced])
  {
    s_deviceConfig.m_glDrawArraysInstancedNV = (PFNGLDRAWARRAYSINSTANCEDNVPROC) glewGetProcAddress ("glDrawArraysInstancedNV");
    s_deviceConfig.m_glDrawElementsInstancedNV = (PFNGLDRAWELEMENTSINSTANCEDNVPROC) glewGetProcAddress ("glDrawElementsInstancedNV");
  }

  // GL_NV_draw_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_draw_texture])
  {
    s_deviceConfig.m_glDrawTextureNV = (PFNGLDRAWTEXTURENVPROC) glewGetProcAddress ("glDrawTextureNV");
  }

  // GL_NV_draw_vulkan_image
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_draw_vulkan_image])
  {
    s_deviceConfig.m_glDrawVkImageNV = (PFNGLDRAWVKIMAGENVPROC) glewGetProcAddress ("glDrawVkImageNV");
    s_deviceConfig.m_glGetVkProcAddrNV = (PFNGLGETVKPROCADDRNVPROC) glewGetProcAddress ("glGetVkProcAddrNV");
    s_deviceConfig.m_glWaitVkSemaphoreNV = (PFNGLWAITVKSEMAPHORENVPROC) glewGetProcAddress ("glWaitVkSemaphoreNV");
    s_deviceConfig.m_glSignalVkSemaphoreNV = (PFNGLSIGNALVKSEMAPHORENVPROC) glewGetProcAddress ("glSignalVkSemaphoreNV");
    s_deviceConfig.m_glSignalVkFenceNV = (PFNGLSIGNALVKFENCENVPROC) glewGetProcAddress ("glSignalVkFenceNV");
  }

  // GL_NV_evaluators
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_evaluators])
  {
    s_deviceConfig.m_glMapControlPointsNV = (PFNGLMAPCONTROLPOINTSNVPROC) glewGetProcAddress ("glMapControlPointsNV");
    s_deviceConfig.m_glMapParameterivNV = (PFNGLMAPPARAMETERIVNVPROC) glewGetProcAddress ("glMapParameterivNV");
    s_deviceConfig.m_glMapParameterfvNV = (PFNGLMAPPARAMETERFVNVPROC) glewGetProcAddress ("glMapParameterfvNV");
    s_deviceConfig.m_glGetMapControlPointsNV = (PFNGLGETMAPCONTROLPOINTSNVPROC) glewGetProcAddress ("glGetMapControlPointsNV");
    s_deviceConfig.m_glGetMapParameterivNV = (PFNGLGETMAPPARAMETERIVNVPROC) glewGetProcAddress ("glGetMapParameterivNV");
    s_deviceConfig.m_glGetMapParameterfvNV = (PFNGLGETMAPPARAMETERFVNVPROC) glewGetProcAddress ("glGetMapParameterfvNV");
    s_deviceConfig.m_glGetMapAttribParameterivNV = (PFNGLGETMAPATTRIBPARAMETERIVNVPROC) glewGetProcAddress ("glGetMapAttribParameterivNV");
    s_deviceConfig.m_glGetMapAttribParameterfvNV = (PFNGLGETMAPATTRIBPARAMETERFVNVPROC) glewGetProcAddress ("glGetMapAttribParameterfvNV");
    s_deviceConfig.m_glEvalMapsNV = (PFNGLEVALMAPSNVPROC) glewGetProcAddress ("glEvalMapsNV");
  }

  // GL_NV_explicit_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_explicit_multisample])
  {
    s_deviceConfig.m_glGetMultisamplefvNV = (PFNGLGETMULTISAMPLEFVNVPROC) glewGetProcAddress ("glGetMultisamplefvNV");
    s_deviceConfig.m_glSampleMaskIndexedNV = (PFNGLSAMPLEMASKINDEXEDNVPROC) glewGetProcAddress ("glSampleMaskIndexedNV");
    s_deviceConfig.m_glTexRenderbufferNV = (PFNGLTEXRENDERBUFFERNVPROC) glewGetProcAddress ("glTexRenderbufferNV");
  }

  // GL_NV_fence
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_fence])
  {
    s_deviceConfig.m_glDeleteFencesNV = (PFNGLDELETEFENCESNVPROC) glewGetProcAddress ("glDeleteFencesNV");
    s_deviceConfig.m_glGenFencesNV = (PFNGLGENFENCESNVPROC) glewGetProcAddress ("glGenFencesNV");
    s_deviceConfig.m_glIsFenceNV = (PFNGLISFENCENVPROC) glewGetProcAddress ("glIsFenceNV");
    s_deviceConfig.m_glTestFenceNV = (PFNGLTESTFENCENVPROC) glewGetProcAddress ("glTestFenceNV");
    s_deviceConfig.m_glGetFenceivNV = (PFNGLGETFENCEIVNVPROC) glewGetProcAddress ("glGetFenceivNV");
    s_deviceConfig.m_glFinishFenceNV = (PFNGLFINISHFENCENVPROC) glewGetProcAddress ("glFinishFenceNV");
    s_deviceConfig.m_glSetFenceNV = (PFNGLSETFENCENVPROC) glewGetProcAddress ("glSetFenceNV");
  }

  // GL_NV_fragment_coverage_to_color
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_fragment_coverage_to_color])
  {
    s_deviceConfig.m_glFragmentCoverageColorNV = (PFNGLFRAGMENTCOVERAGECOLORNVPROC) glewGetProcAddress ("glFragmentCoverageColorNV");
  }

  // GL_NV_fragment_program
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_fragment_program])
  {
    s_deviceConfig.m_glProgramNamedParameter4fNV = (PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) glewGetProcAddress ("glProgramNamedParameter4fNV");
    s_deviceConfig.m_glProgramNamedParameter4fvNV = (PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) glewGetProcAddress ("glProgramNamedParameter4fvNV");
    s_deviceConfig.m_glProgramNamedParameter4dNV = (PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) glewGetProcAddress ("glProgramNamedParameter4dNV");
    s_deviceConfig.m_glProgramNamedParameter4dvNV = (PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) glewGetProcAddress ("glProgramNamedParameter4dvNV");
    s_deviceConfig.m_glGetProgramNamedParameterfvNV = (PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) glewGetProcAddress ("glGetProgramNamedParameterfvNV");
    s_deviceConfig.m_glGetProgramNamedParameterdvNV = (PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) glewGetProcAddress ("glGetProgramNamedParameterdvNV");
  }

  // GL_NV_framebuffer_blit
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_framebuffer_blit])
  {
    s_deviceConfig.m_glBlitFramebufferNV = (PFNGLBLITFRAMEBUFFERNVPROC) glewGetProcAddress ("glBlitFramebufferNV");
  }

  // GL_NV_framebuffer_mixed_samples
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_framebuffer_mixed_samples])
  {
    s_deviceConfig.m_glRasterSamplesEXT = (PFNGLRASTERSAMPLESEXTPROC) glewGetProcAddress ("glRasterSamplesEXT");
    s_deviceConfig.m_glCoverageModulationTableNV = (PFNGLCOVERAGEMODULATIONTABLENVPROC) glewGetProcAddress ("glCoverageModulationTableNV");
    s_deviceConfig.m_glGetCoverageModulationTableNV = (PFNGLGETCOVERAGEMODULATIONTABLENVPROC) glewGetProcAddress ("glGetCoverageModulationTableNV");
    s_deviceConfig.m_glCoverageModulationNV = (PFNGLCOVERAGEMODULATIONNVPROC) glewGetProcAddress ("glCoverageModulationNV");
  }

  // GL_NV_framebuffer_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_framebuffer_multisample])
  {
    s_deviceConfig.m_glRenderbufferStorageMultisampleNV = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLENVPROC) glewGetProcAddress ("glRenderbufferStorageMultisampleNV");
  }

  // GL_NV_framebuffer_multisample_coverage
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_framebuffer_multisample_coverage])
  {
    s_deviceConfig.m_glRenderbufferStorageMultisampleCoverageNV = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) glewGetProcAddress ("glRenderbufferStorageMultisampleCoverageNV");
  }

  // GL_NV_geometry_program4
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_geometry_program4])
  {
    s_deviceConfig.m_glProgramVertexLimitNV = (PFNGLPROGRAMVERTEXLIMITNVPROC) glewGetProcAddress ("glProgramVertexLimitNV");
    s_deviceConfig.m_glFramebufferTextureEXT = (PFNGLFRAMEBUFFERTEXTUREEXTPROC) glewGetProcAddress ("glFramebufferTextureEXT");
    s_deviceConfig.m_glFramebufferTextureLayerEXT = (PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) glewGetProcAddress ("glFramebufferTextureLayerEXT");
    s_deviceConfig.m_glFramebufferTextureFaceEXT = (PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) glewGetProcAddress ("glFramebufferTextureFaceEXT");
  }

  // GL_NV_gpu_program4
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_gpu_program4])
  {
    s_deviceConfig.m_glProgramLocalParameterI4iNV = (PFNGLPROGRAMLOCALPARAMETERI4INVPROC) glewGetProcAddress ("glProgramLocalParameterI4iNV");
    s_deviceConfig.m_glProgramLocalParameterI4ivNV = (PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) glewGetProcAddress ("glProgramLocalParameterI4ivNV");
    s_deviceConfig.m_glProgramLocalParametersI4ivNV = (PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) glewGetProcAddress ("glProgramLocalParametersI4ivNV");
    s_deviceConfig.m_glProgramLocalParameterI4uiNV = (PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) glewGetProcAddress ("glProgramLocalParameterI4uiNV");
    s_deviceConfig.m_glProgramLocalParameterI4uivNV = (PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) glewGetProcAddress ("glProgramLocalParameterI4uivNV");
    s_deviceConfig.m_glProgramLocalParametersI4uivNV = (PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) glewGetProcAddress ("glProgramLocalParametersI4uivNV");
    s_deviceConfig.m_glProgramEnvParameterI4iNV = (PFNGLPROGRAMENVPARAMETERI4INVPROC) glewGetProcAddress ("glProgramEnvParameterI4iNV");
    s_deviceConfig.m_glProgramEnvParameterI4ivNV = (PFNGLPROGRAMENVPARAMETERI4IVNVPROC) glewGetProcAddress ("glProgramEnvParameterI4ivNV");
    s_deviceConfig.m_glProgramEnvParametersI4ivNV = (PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) glewGetProcAddress ("glProgramEnvParametersI4ivNV");
    s_deviceConfig.m_glProgramEnvParameterI4uiNV = (PFNGLPROGRAMENVPARAMETERI4UINVPROC) glewGetProcAddress ("glProgramEnvParameterI4uiNV");
    s_deviceConfig.m_glProgramEnvParameterI4uivNV = (PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) glewGetProcAddress ("glProgramEnvParameterI4uivNV");
    s_deviceConfig.m_glProgramEnvParametersI4uivNV = (PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) glewGetProcAddress ("glProgramEnvParametersI4uivNV");
    s_deviceConfig.m_glGetProgramLocalParameterIivNV = (PFNGLGETPROGRAMLOCALPARAMETERIIVNVPROC) glewGetProcAddress ("glGetProgramLocalParameterIivNV");
    s_deviceConfig.m_glGetProgramLocalParameterIuivNV = (PFNGLGETPROGRAMLOCALPARAMETERIUIVNVPROC) glewGetProcAddress ("glGetProgramLocalParameterIuivNV");
    s_deviceConfig.m_glGetProgramEnvParameterIivNV = (PFNGLGETPROGRAMENVPARAMETERIIVNVPROC) glewGetProcAddress ("glGetProgramEnvParameterIivNV");
    s_deviceConfig.m_glGetProgramEnvParameterIuivNV = (PFNGLGETPROGRAMENVPARAMETERIUIVNVPROC) glewGetProcAddress ("glGetProgramEnvParameterIuivNV");
  }

  // GL_NV_gpu_program5
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_gpu_program5])
  {
    s_deviceConfig.m_glProgramSubroutineParametersuivNV = (PFNGLPROGRAMSUBROUTINEPARAMETERSUIVNVPROC) glewGetProcAddress ("glProgramSubroutineParametersuivNV");
    s_deviceConfig.m_glGetProgramSubroutineParameteruivNV = (PFNGLGETPROGRAMSUBROUTINEPARAMETERUIVNVPROC) glewGetProcAddress ("glGetProgramSubroutineParameteruivNV");
  }

  // GL_NV_gpu_shader5
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_gpu_shader5])
  {
    s_deviceConfig.m_glUniform1i64NV = (PFNGLUNIFORM1I64NVPROC) glewGetProcAddress ("glUniform1i64NV");
    s_deviceConfig.m_glUniform2i64NV = (PFNGLUNIFORM2I64NVPROC) glewGetProcAddress ("glUniform2i64NV");
    s_deviceConfig.m_glUniform3i64NV = (PFNGLUNIFORM3I64NVPROC) glewGetProcAddress ("glUniform3i64NV");
    s_deviceConfig.m_glUniform4i64NV = (PFNGLUNIFORM4I64NVPROC) glewGetProcAddress ("glUniform4i64NV");
    s_deviceConfig.m_glUniform1i64vNV = (PFNGLUNIFORM1I64VNVPROC) glewGetProcAddress ("glUniform1i64vNV");
    s_deviceConfig.m_glUniform2i64vNV = (PFNGLUNIFORM2I64VNVPROC) glewGetProcAddress ("glUniform2i64vNV");
    s_deviceConfig.m_glUniform3i64vNV = (PFNGLUNIFORM3I64VNVPROC) glewGetProcAddress ("glUniform3i64vNV");
    s_deviceConfig.m_glUniform4i64vNV = (PFNGLUNIFORM4I64VNVPROC) glewGetProcAddress ("glUniform4i64vNV");
    s_deviceConfig.m_glUniform1ui64NV = (PFNGLUNIFORM1UI64NVPROC) glewGetProcAddress ("glUniform1ui64NV");
    s_deviceConfig.m_glUniform2ui64NV = (PFNGLUNIFORM2UI64NVPROC) glewGetProcAddress ("glUniform2ui64NV");
    s_deviceConfig.m_glUniform3ui64NV = (PFNGLUNIFORM3UI64NVPROC) glewGetProcAddress ("glUniform3ui64NV");
    s_deviceConfig.m_glUniform4ui64NV = (PFNGLUNIFORM4UI64NVPROC) glewGetProcAddress ("glUniform4ui64NV");
    s_deviceConfig.m_glUniform1ui64vNV = (PFNGLUNIFORM1UI64VNVPROC) glewGetProcAddress ("glUniform1ui64vNV");
    s_deviceConfig.m_glUniform2ui64vNV = (PFNGLUNIFORM2UI64VNVPROC) glewGetProcAddress ("glUniform2ui64vNV");
    s_deviceConfig.m_glUniform3ui64vNV = (PFNGLUNIFORM3UI64VNVPROC) glewGetProcAddress ("glUniform3ui64vNV");
    s_deviceConfig.m_glUniform4ui64vNV = (PFNGLUNIFORM4UI64VNVPROC) glewGetProcAddress ("glUniform4ui64vNV");
    s_deviceConfig.m_glGetUniformi64vNV = (PFNGLGETUNIFORMI64VNVPROC) glewGetProcAddress ("glGetUniformi64vNV");
    s_deviceConfig.m_glProgramUniform1i64NV = (PFNGLPROGRAMUNIFORM1I64NVPROC) glewGetProcAddress ("glProgramUniform1i64NV");
    s_deviceConfig.m_glProgramUniform2i64NV = (PFNGLPROGRAMUNIFORM2I64NVPROC) glewGetProcAddress ("glProgramUniform2i64NV");
    s_deviceConfig.m_glProgramUniform3i64NV = (PFNGLPROGRAMUNIFORM3I64NVPROC) glewGetProcAddress ("glProgramUniform3i64NV");
    s_deviceConfig.m_glProgramUniform4i64NV = (PFNGLPROGRAMUNIFORM4I64NVPROC) glewGetProcAddress ("glProgramUniform4i64NV");
    s_deviceConfig.m_glProgramUniform1i64vNV = (PFNGLPROGRAMUNIFORM1I64VNVPROC) glewGetProcAddress ("glProgramUniform1i64vNV");
    s_deviceConfig.m_glProgramUniform2i64vNV = (PFNGLPROGRAMUNIFORM2I64VNVPROC) glewGetProcAddress ("glProgramUniform2i64vNV");
    s_deviceConfig.m_glProgramUniform3i64vNV = (PFNGLPROGRAMUNIFORM3I64VNVPROC) glewGetProcAddress ("glProgramUniform3i64vNV");
    s_deviceConfig.m_glProgramUniform4i64vNV = (PFNGLPROGRAMUNIFORM4I64VNVPROC) glewGetProcAddress ("glProgramUniform4i64vNV");
    s_deviceConfig.m_glProgramUniform1ui64NV = (PFNGLPROGRAMUNIFORM1UI64NVPROC) glewGetProcAddress ("glProgramUniform1ui64NV");
    s_deviceConfig.m_glProgramUniform2ui64NV = (PFNGLPROGRAMUNIFORM2UI64NVPROC) glewGetProcAddress ("glProgramUniform2ui64NV");
    s_deviceConfig.m_glProgramUniform3ui64NV = (PFNGLPROGRAMUNIFORM3UI64NVPROC) glewGetProcAddress ("glProgramUniform3ui64NV");
    s_deviceConfig.m_glProgramUniform4ui64NV = (PFNGLPROGRAMUNIFORM4UI64NVPROC) glewGetProcAddress ("glProgramUniform4ui64NV");
    s_deviceConfig.m_glProgramUniform1ui64vNV = (PFNGLPROGRAMUNIFORM1UI64VNVPROC) glewGetProcAddress ("glProgramUniform1ui64vNV");
    s_deviceConfig.m_glProgramUniform2ui64vNV = (PFNGLPROGRAMUNIFORM2UI64VNVPROC) glewGetProcAddress ("glProgramUniform2ui64vNV");
    s_deviceConfig.m_glProgramUniform3ui64vNV = (PFNGLPROGRAMUNIFORM3UI64VNVPROC) glewGetProcAddress ("glProgramUniform3ui64vNV");
    s_deviceConfig.m_glProgramUniform4ui64vNV = (PFNGLPROGRAMUNIFORM4UI64VNVPROC) glewGetProcAddress ("glProgramUniform4ui64vNV");
  }

  // GL_NV_half_float
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_half_float])
  {
    s_deviceConfig.m_glVertex2hNV = (PFNGLVERTEX2HNVPROC) glewGetProcAddress ("glVertex2hNV");
    s_deviceConfig.m_glVertex2hvNV = (PFNGLVERTEX2HVNVPROC) glewGetProcAddress ("glVertex2hvNV");
    s_deviceConfig.m_glVertex3hNV = (PFNGLVERTEX3HNVPROC) glewGetProcAddress ("glVertex3hNV");
    s_deviceConfig.m_glVertex3hvNV = (PFNGLVERTEX3HVNVPROC) glewGetProcAddress ("glVertex3hvNV");
    s_deviceConfig.m_glVertex4hNV = (PFNGLVERTEX4HNVPROC) glewGetProcAddress ("glVertex4hNV");
    s_deviceConfig.m_glVertex4hvNV = (PFNGLVERTEX4HVNVPROC) glewGetProcAddress ("glVertex4hvNV");
    s_deviceConfig.m_glNormal3hNV = (PFNGLNORMAL3HNVPROC) glewGetProcAddress ("glNormal3hNV");
    s_deviceConfig.m_glNormal3hvNV = (PFNGLNORMAL3HVNVPROC) glewGetProcAddress ("glNormal3hvNV");
    s_deviceConfig.m_glColor3hNV = (PFNGLCOLOR3HNVPROC) glewGetProcAddress ("glColor3hNV");
    s_deviceConfig.m_glColor3hvNV = (PFNGLCOLOR3HVNVPROC) glewGetProcAddress ("glColor3hvNV");
    s_deviceConfig.m_glColor4hNV = (PFNGLCOLOR4HNVPROC) glewGetProcAddress ("glColor4hNV");
    s_deviceConfig.m_glColor4hvNV = (PFNGLCOLOR4HVNVPROC) glewGetProcAddress ("glColor4hvNV");
    s_deviceConfig.m_glTexCoord1hNV = (PFNGLTEXCOORD1HNVPROC) glewGetProcAddress ("glTexCoord1hNV");
    s_deviceConfig.m_glTexCoord1hvNV = (PFNGLTEXCOORD1HVNVPROC) glewGetProcAddress ("glTexCoord1hvNV");
    s_deviceConfig.m_glTexCoord2hNV = (PFNGLTEXCOORD2HNVPROC) glewGetProcAddress ("glTexCoord2hNV");
    s_deviceConfig.m_glTexCoord2hvNV = (PFNGLTEXCOORD2HVNVPROC) glewGetProcAddress ("glTexCoord2hvNV");
    s_deviceConfig.m_glTexCoord3hNV = (PFNGLTEXCOORD3HNVPROC) glewGetProcAddress ("glTexCoord3hNV");
    s_deviceConfig.m_glTexCoord3hvNV = (PFNGLTEXCOORD3HVNVPROC) glewGetProcAddress ("glTexCoord3hvNV");
    s_deviceConfig.m_glTexCoord4hNV = (PFNGLTEXCOORD4HNVPROC) glewGetProcAddress ("glTexCoord4hNV");
    s_deviceConfig.m_glTexCoord4hvNV = (PFNGLTEXCOORD4HVNVPROC) glewGetProcAddress ("glTexCoord4hvNV");
    s_deviceConfig.m_glMultiTexCoord1hNV = (PFNGLMULTITEXCOORD1HNVPROC) glewGetProcAddress ("glMultiTexCoord1hNV");
    s_deviceConfig.m_glMultiTexCoord1hvNV = (PFNGLMULTITEXCOORD1HVNVPROC) glewGetProcAddress ("glMultiTexCoord1hvNV");
    s_deviceConfig.m_glMultiTexCoord2hNV = (PFNGLMULTITEXCOORD2HNVPROC) glewGetProcAddress ("glMultiTexCoord2hNV");
    s_deviceConfig.m_glMultiTexCoord2hvNV = (PFNGLMULTITEXCOORD2HVNVPROC) glewGetProcAddress ("glMultiTexCoord2hvNV");
    s_deviceConfig.m_glMultiTexCoord3hNV = (PFNGLMULTITEXCOORD3HNVPROC) glewGetProcAddress ("glMultiTexCoord3hNV");
    s_deviceConfig.m_glMultiTexCoord3hvNV = (PFNGLMULTITEXCOORD3HVNVPROC) glewGetProcAddress ("glMultiTexCoord3hvNV");
    s_deviceConfig.m_glMultiTexCoord4hNV = (PFNGLMULTITEXCOORD4HNVPROC) glewGetProcAddress ("glMultiTexCoord4hNV");
    s_deviceConfig.m_glMultiTexCoord4hvNV = (PFNGLMULTITEXCOORD4HVNVPROC) glewGetProcAddress ("glMultiTexCoord4hvNV");
    s_deviceConfig.m_glVertexAttrib1hNV = (PFNGLVERTEXATTRIB1HNVPROC) glewGetProcAddress ("glVertexAttrib1hNV");
    s_deviceConfig.m_glVertexAttrib1hvNV = (PFNGLVERTEXATTRIB1HVNVPROC) glewGetProcAddress ("glVertexAttrib1hvNV");
    s_deviceConfig.m_glVertexAttrib2hNV = (PFNGLVERTEXATTRIB2HNVPROC) glewGetProcAddress ("glVertexAttrib2hNV");
    s_deviceConfig.m_glVertexAttrib2hvNV = (PFNGLVERTEXATTRIB2HVNVPROC) glewGetProcAddress ("glVertexAttrib2hvNV");
    s_deviceConfig.m_glVertexAttrib3hNV = (PFNGLVERTEXATTRIB3HNVPROC) glewGetProcAddress ("glVertexAttrib3hNV");
    s_deviceConfig.m_glVertexAttrib3hvNV = (PFNGLVERTEXATTRIB3HVNVPROC) glewGetProcAddress ("glVertexAttrib3hvNV");
    s_deviceConfig.m_glVertexAttrib4hNV = (PFNGLVERTEXATTRIB4HNVPROC) glewGetProcAddress ("glVertexAttrib4hNV");
    s_deviceConfig.m_glVertexAttrib4hvNV = (PFNGLVERTEXATTRIB4HVNVPROC) glewGetProcAddress ("glVertexAttrib4hvNV");
    s_deviceConfig.m_glVertexAttribs1hvNV = (PFNGLVERTEXATTRIBS1HVNVPROC) glewGetProcAddress ("glVertexAttribs1hvNV");
    s_deviceConfig.m_glVertexAttribs2hvNV = (PFNGLVERTEXATTRIBS2HVNVPROC) glewGetProcAddress ("glVertexAttribs2hvNV");
    s_deviceConfig.m_glVertexAttribs3hvNV = (PFNGLVERTEXATTRIBS3HVNVPROC) glewGetProcAddress ("glVertexAttribs3hvNV");
    s_deviceConfig.m_glVertexAttribs4hvNV = (PFNGLVERTEXATTRIBS4HVNVPROC) glewGetProcAddress ("glVertexAttribs4hvNV");
    s_deviceConfig.m_glFogCoordhNV = (PFNGLFOGCOORDHNVPROC) glewGetProcAddress ("glFogCoordhNV");
    s_deviceConfig.m_glFogCoordhvNV = (PFNGLFOGCOORDHVNVPROC) glewGetProcAddress ("glFogCoordhvNV");
    s_deviceConfig.m_glSecondaryColor3hNV = (PFNGLSECONDARYCOLOR3HNVPROC) glewGetProcAddress ("glSecondaryColor3hNV");
    s_deviceConfig.m_glSecondaryColor3hvNV = (PFNGLSECONDARYCOLOR3HVNVPROC) glewGetProcAddress ("glSecondaryColor3hvNV");
    s_deviceConfig.m_glVertexWeighthNV = (PFNGLVERTEXWEIGHTHNVPROC) glewGetProcAddress ("glVertexWeighthNV");
    s_deviceConfig.m_glVertexWeighthvNV = (PFNGLVERTEXWEIGHTHVNVPROC) glewGetProcAddress ("glVertexWeighthvNV");
  }

  // GL_NV_instanced_arrays
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_instanced_arrays])
  {
    s_deviceConfig.m_glVertexAttribDivisorNV = (PFNGLVERTEXATTRIBDIVISORNVPROC) glewGetProcAddress ("glVertexAttribDivisorNV");
  }

  // GL_NV_internalformat_sample_query
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_internalformat_sample_query])
  {
    s_deviceConfig.m_glGetInternalformatSampleivNV = (PFNGLGETINTERNALFORMATSAMPLEIVNVPROC) glewGetProcAddress ("glGetInternalformatSampleivNV");
  }

  // GL_NV_gpu_multicast
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_gpu_multicast])
  {
    s_deviceConfig.m_glRenderGpuMaskNV = (PFNGLRENDERGPUMASKNVPROC) glewGetProcAddress ("glRenderGpuMaskNV");
    s_deviceConfig.m_glMulticastBufferSubDataNV = (PFNGLMULTICASTBUFFERSUBDATANVPROC) glewGetProcAddress ("glMulticastBufferSubDataNV");
    s_deviceConfig.m_glMulticastCopyBufferSubDataNV = (PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC) glewGetProcAddress ("glMulticastCopyBufferSubDataNV");
    s_deviceConfig.m_glMulticastCopyImageSubDataNV = (PFNGLMULTICASTCOPYIMAGESUBDATANVPROC) glewGetProcAddress ("glMulticastCopyImageSubDataNV");
    s_deviceConfig.m_glMulticastBlitFramebufferNV = (PFNGLMULTICASTBLITFRAMEBUFFERNVPROC) glewGetProcAddress ("glMulticastBlitFramebufferNV");
    s_deviceConfig.m_glMulticastFramebufferSampleLocationsfvNV = (PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) glewGetProcAddress ("glMulticastFramebufferSampleLocationsfvNV");
    s_deviceConfig.m_glMulticastBarrierNV = (PFNGLMULTICASTBARRIERNVPROC) glewGetProcAddress ("glMulticastBarrierNV");
    s_deviceConfig.m_glMulticastWaitSyncNV = (PFNGLMULTICASTWAITSYNCNVPROC) glewGetProcAddress ("glMulticastWaitSyncNV");
    s_deviceConfig.m_glMulticastGetQueryObjectivNV = (PFNGLMULTICASTGETQUERYOBJECTIVNVPROC) glewGetProcAddress ("glMulticastGetQueryObjectivNV");
    s_deviceConfig.m_glMulticastGetQueryObjectuivNV = (PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC) glewGetProcAddress ("glMulticastGetQueryObjectuivNV");
    s_deviceConfig.m_glMulticastGetQueryObjecti64vNV = (PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC) glewGetProcAddress ("glMulticastGetQueryObjecti64vNV");
    s_deviceConfig.m_glMulticastGetQueryObjectui64vNV = (PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC) glewGetProcAddress ("glMulticastGetQueryObjectui64vNV");
  }

  // GL_NVX_gpu_multicast2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NVX_gpu_multicast2])
  {
    s_deviceConfig.m_glUploadGpuMaskNVX = (PFNGLUPLOADGPUMASKNVXPROC) glewGetProcAddress ("glUploadGpuMaskNVX");
    s_deviceConfig.m_glMulticastViewportArrayvNVX = (PFNGLMULTICASTVIEWPORTARRAYVNVXPROC) glewGetProcAddress ("glMulticastViewportArrayvNVX");
    s_deviceConfig.m_glMulticastViewportPositionWScaleNVX = (PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC) glewGetProcAddress ("glMulticastViewportPositionWScaleNVX");
    s_deviceConfig.m_glMulticastScissorArrayvNVX = (PFNGLMULTICASTSCISSORARRAYVNVXPROC) glewGetProcAddress ("glMulticastScissorArrayvNVX");
    s_deviceConfig.m_glAsyncCopyBufferSubDataNVX = (PFNGLASYNCCOPYBUFFERSUBDATANVXPROC) glewGetProcAddress ("glAsyncCopyBufferSubDataNVX");
    s_deviceConfig.m_glAsyncCopyImageSubDataNVX = (PFNGLASYNCCOPYIMAGESUBDATANVXPROC) glewGetProcAddress ("glAsyncCopyImageSubDataNVX");
  }

  // GL_NVX_progress_fence
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NVX_progress_fence])
  {
    s_deviceConfig.m_glCreateProgressFenceNVX = (PFNGLCREATEPROGRESSFENCENVXPROC) glewGetProcAddress ("glCreateProgressFenceNVX");
    s_deviceConfig.m_glSignalSemaphoreui64NVX = (PFNGLSIGNALSEMAPHOREUI64NVXPROC) glewGetProcAddress ("glSignalSemaphoreui64NVX");
    s_deviceConfig.m_glWaitSemaphoreui64NVX = (PFNGLWAITSEMAPHOREUI64NVXPROC) glewGetProcAddress ("glWaitSemaphoreui64NVX");
    s_deviceConfig.m_glClientWaitSemaphoreui64NVX = (PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC) glewGetProcAddress ("glClientWaitSemaphoreui64NVX");
  }

  // GL_NV_memory_attachment
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_memory_attachment])
  {
    s_deviceConfig.m_glGetMemoryObjectDetachedResourcesuivNV = (PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC) glewGetProcAddress ("glGetMemoryObjectDetachedResourcesuivNV");
    s_deviceConfig.m_glResetMemoryObjectParameterNV = (PFNGLRESETMEMORYOBJECTPARAMETERNVPROC) glewGetProcAddress ("glResetMemoryObjectParameterNV");
    s_deviceConfig.m_glTexAttachMemoryNV = (PFNGLTEXATTACHMEMORYNVPROC) glewGetProcAddress ("glTexAttachMemoryNV");
    s_deviceConfig.m_glBufferAttachMemoryNV = (PFNGLBUFFERATTACHMEMORYNVPROC) glewGetProcAddress ("glBufferAttachMemoryNV");
    s_deviceConfig.m_glTextureAttachMemoryNV = (PFNGLTEXTUREATTACHMEMORYNVPROC) glewGetProcAddress ("glTextureAttachMemoryNV");
    s_deviceConfig.m_glNamedBufferAttachMemoryNV = (PFNGLNAMEDBUFFERATTACHMEMORYNVPROC) glewGetProcAddress ("glNamedBufferAttachMemoryNV");
  }

  // GL_NV_memory_object_sparse
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_memory_object_sparse])
  {
    s_deviceConfig.m_glBufferPageCommitmentMemNV = (PFNGLBUFFERPAGECOMMITMENTMEMNVPROC) glewGetProcAddress ("glBufferPageCommitmentMemNV");
    s_deviceConfig.m_glTexPageCommitmentMemNV = (PFNGLTEXPAGECOMMITMENTMEMNVPROC) glewGetProcAddress ("glTexPageCommitmentMemNV");
    s_deviceConfig.m_glNamedBufferPageCommitmentMemNV = (PFNGLNAMEDBUFFERPAGECOMMITMENTMEMNVPROC) glewGetProcAddress ("glNamedBufferPageCommitmentMemNV");
    s_deviceConfig.m_glTexturePageCommitmentMemNV = (PFNGLTEXTUREPAGECOMMITMENTMEMNVPROC) glewGetProcAddress ("glTexturePageCommitmentMemNV");
  }

  // GL_NV_mesh_shader
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_mesh_shader])
  {
    s_deviceConfig.m_glDrawMeshTasksNV = (PFNGLDRAWMESHTASKSNVPROC) glewGetProcAddress ("glDrawMeshTasksNV");
    s_deviceConfig.m_glDrawMeshTasksIndirectNV = (PFNGLDRAWMESHTASKSINDIRECTNVPROC) glewGetProcAddress ("glDrawMeshTasksIndirectNV");
    s_deviceConfig.m_glMultiDrawMeshTasksIndirectNV = (PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC) glewGetProcAddress ("glMultiDrawMeshTasksIndirectNV");
    s_deviceConfig.m_glMultiDrawMeshTasksIndirectCountNV = (PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC) glewGetProcAddress ("glMultiDrawMeshTasksIndirectCountNV");
  }

  // GL_NV_non_square_matrices
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_non_square_matrices])
  {
    s_deviceConfig.m_glUniformMatrix2x3fvNV = (PFNGLUNIFORMMATRIX2X3FVNVPROC) glewGetProcAddress ("glUniformMatrix2x3fvNV");
    s_deviceConfig.m_glUniformMatrix3x2fvNV = (PFNGLUNIFORMMATRIX3X2FVNVPROC) glewGetProcAddress ("glUniformMatrix3x2fvNV");
    s_deviceConfig.m_glUniformMatrix2x4fvNV = (PFNGLUNIFORMMATRIX2X4FVNVPROC) glewGetProcAddress ("glUniformMatrix2x4fvNV");
    s_deviceConfig.m_glUniformMatrix4x2fvNV = (PFNGLUNIFORMMATRIX4X2FVNVPROC) glewGetProcAddress ("glUniformMatrix4x2fvNV");
    s_deviceConfig.m_glUniformMatrix3x4fvNV = (PFNGLUNIFORMMATRIX3X4FVNVPROC) glewGetProcAddress ("glUniformMatrix3x4fvNV");
    s_deviceConfig.m_glUniformMatrix4x3fvNV = (PFNGLUNIFORMMATRIX4X3FVNVPROC) glewGetProcAddress ("glUniformMatrix4x3fvNV");
  }

  // GL_NV_occlusion_query
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_occlusion_query])
  {
    s_deviceConfig.m_glGenOcclusionQueriesNV = (PFNGLGENOCCLUSIONQUERIESNVPROC) glewGetProcAddress ("glGenOcclusionQueriesNV");
    s_deviceConfig.m_glDeleteOcclusionQueriesNV = (PFNGLDELETEOCCLUSIONQUERIESNVPROC) glewGetProcAddress ("glDeleteOcclusionQueriesNV");
    s_deviceConfig.m_glIsOcclusionQueryNV = (PFNGLISOCCLUSIONQUERYNVPROC) glewGetProcAddress ("glIsOcclusionQueryNV");
    s_deviceConfig.m_glBeginOcclusionQueryNV = (PFNGLBEGINOCCLUSIONQUERYNVPROC) glewGetProcAddress ("glBeginOcclusionQueryNV");
    s_deviceConfig.m_glEndOcclusionQueryNV = (PFNGLENDOCCLUSIONQUERYNVPROC) glewGetProcAddress ("glEndOcclusionQueryNV");
    s_deviceConfig.m_glGetOcclusionQueryivNV = (PFNGLGETOCCLUSIONQUERYIVNVPROC) glewGetProcAddress ("glGetOcclusionQueryivNV");
    s_deviceConfig.m_glGetOcclusionQueryuivNV = (PFNGLGETOCCLUSIONQUERYUIVNVPROC) glewGetProcAddress ("glGetOcclusionQueryuivNV");
  }

  // GL_NV_parameter_buffer_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_parameter_buffer_object])
  {
    s_deviceConfig.m_glProgramBufferParametersfvNV = (PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) glewGetProcAddress ("glProgramBufferParametersfvNV");
    s_deviceConfig.m_glProgramBufferParametersIivNV = (PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) glewGetProcAddress ("glProgramBufferParametersIivNV");
    s_deviceConfig.m_glProgramBufferParametersIuivNV = (PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) glewGetProcAddress ("glProgramBufferParametersIuivNV");
  }

  // GL_NV_path_rendering
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_path_rendering])
  {
    s_deviceConfig.m_glGenPathsNV = (PFNGLGENPATHSNVPROC) glewGetProcAddress ("glGenPathsNV");
    s_deviceConfig.m_glDeletePathsNV = (PFNGLDELETEPATHSNVPROC) glewGetProcAddress ("glDeletePathsNV");
    s_deviceConfig.m_glIsPathNV = (PFNGLISPATHNVPROC) glewGetProcAddress ("glIsPathNV");
    s_deviceConfig.m_glPathCommandsNV = (PFNGLPATHCOMMANDSNVPROC) glewGetProcAddress ("glPathCommandsNV");
    s_deviceConfig.m_glPathCoordsNV = (PFNGLPATHCOORDSNVPROC) glewGetProcAddress ("glPathCoordsNV");
    s_deviceConfig.m_glPathSubCommandsNV = (PFNGLPATHSUBCOMMANDSNVPROC) glewGetProcAddress ("glPathSubCommandsNV");
    s_deviceConfig.m_glPathSubCoordsNV = (PFNGLPATHSUBCOORDSNVPROC) glewGetProcAddress ("glPathSubCoordsNV");
    s_deviceConfig.m_glPathStringNV = (PFNGLPATHSTRINGNVPROC) glewGetProcAddress ("glPathStringNV");
    s_deviceConfig.m_glPathGlyphsNV = (PFNGLPATHGLYPHSNVPROC) glewGetProcAddress ("glPathGlyphsNV");
    s_deviceConfig.m_glPathGlyphRangeNV = (PFNGLPATHGLYPHRANGENVPROC) glewGetProcAddress ("glPathGlyphRangeNV");
    s_deviceConfig.m_glWeightPathsNV = (PFNGLWEIGHTPATHSNVPROC) glewGetProcAddress ("glWeightPathsNV");
    s_deviceConfig.m_glCopyPathNV = (PFNGLCOPYPATHNVPROC) glewGetProcAddress ("glCopyPathNV");
    s_deviceConfig.m_glInterpolatePathsNV = (PFNGLINTERPOLATEPATHSNVPROC) glewGetProcAddress ("glInterpolatePathsNV");
    s_deviceConfig.m_glTransformPathNV = (PFNGLTRANSFORMPATHNVPROC) glewGetProcAddress ("glTransformPathNV");
    s_deviceConfig.m_glPathParameterivNV = (PFNGLPATHPARAMETERIVNVPROC) glewGetProcAddress ("glPathParameterivNV");
    s_deviceConfig.m_glPathParameteriNV = (PFNGLPATHPARAMETERINVPROC) glewGetProcAddress ("glPathParameteriNV");
    s_deviceConfig.m_glPathParameterfvNV = (PFNGLPATHPARAMETERFVNVPROC) glewGetProcAddress ("glPathParameterfvNV");
    s_deviceConfig.m_glPathParameterfNV = (PFNGLPATHPARAMETERFNVPROC) glewGetProcAddress ("glPathParameterfNV");
    s_deviceConfig.m_glPathDashArrayNV = (PFNGLPATHDASHARRAYNVPROC) glewGetProcAddress ("glPathDashArrayNV");
    s_deviceConfig.m_glPathStencilFuncNV = (PFNGLPATHSTENCILFUNCNVPROC) glewGetProcAddress ("glPathStencilFuncNV");
    s_deviceConfig.m_glPathStencilDepthOffsetNV = (PFNGLPATHSTENCILDEPTHOFFSETNVPROC) glewGetProcAddress ("glPathStencilDepthOffsetNV");
    s_deviceConfig.m_glStencilFillPathNV = (PFNGLSTENCILFILLPATHNVPROC) glewGetProcAddress ("glStencilFillPathNV");
    s_deviceConfig.m_glStencilStrokePathNV = (PFNGLSTENCILSTROKEPATHNVPROC) glewGetProcAddress ("glStencilStrokePathNV");
    s_deviceConfig.m_glStencilFillPathInstancedNV = (PFNGLSTENCILFILLPATHINSTANCEDNVPROC) glewGetProcAddress ("glStencilFillPathInstancedNV");
    s_deviceConfig.m_glStencilStrokePathInstancedNV = (PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) glewGetProcAddress ("glStencilStrokePathInstancedNV");
    s_deviceConfig.m_glPathCoverDepthFuncNV = (PFNGLPATHCOVERDEPTHFUNCNVPROC) glewGetProcAddress ("glPathCoverDepthFuncNV");
    s_deviceConfig.m_glCoverFillPathNV = (PFNGLCOVERFILLPATHNVPROC) glewGetProcAddress ("glCoverFillPathNV");
    s_deviceConfig.m_glCoverStrokePathNV = (PFNGLCOVERSTROKEPATHNVPROC) glewGetProcAddress ("glCoverStrokePathNV");
    s_deviceConfig.m_glCoverFillPathInstancedNV = (PFNGLCOVERFILLPATHINSTANCEDNVPROC) glewGetProcAddress ("glCoverFillPathInstancedNV");
    s_deviceConfig.m_glCoverStrokePathInstancedNV = (PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) glewGetProcAddress ("glCoverStrokePathInstancedNV");
    s_deviceConfig.m_glGetPathParameterivNV = (PFNGLGETPATHPARAMETERIVNVPROC) glewGetProcAddress ("glGetPathParameterivNV");
    s_deviceConfig.m_glGetPathParameterfvNV = (PFNGLGETPATHPARAMETERFVNVPROC) glewGetProcAddress ("glGetPathParameterfvNV");
    s_deviceConfig.m_glGetPathCommandsNV = (PFNGLGETPATHCOMMANDSNVPROC) glewGetProcAddress ("glGetPathCommandsNV");
    s_deviceConfig.m_glGetPathCoordsNV = (PFNGLGETPATHCOORDSNVPROC) glewGetProcAddress ("glGetPathCoordsNV");
    s_deviceConfig.m_glGetPathDashArrayNV = (PFNGLGETPATHDASHARRAYNVPROC) glewGetProcAddress ("glGetPathDashArrayNV");
    s_deviceConfig.m_glGetPathMetricsNV = (PFNGLGETPATHMETRICSNVPROC) glewGetProcAddress ("glGetPathMetricsNV");
    s_deviceConfig.m_glGetPathMetricRangeNV = (PFNGLGETPATHMETRICRANGENVPROC) glewGetProcAddress ("glGetPathMetricRangeNV");
    s_deviceConfig.m_glGetPathSpacingNV = (PFNGLGETPATHSPACINGNVPROC) glewGetProcAddress ("glGetPathSpacingNV");
    s_deviceConfig.m_glIsPointInFillPathNV = (PFNGLISPOINTINFILLPATHNVPROC) glewGetProcAddress ("glIsPointInFillPathNV");
    s_deviceConfig.m_glIsPointInStrokePathNV = (PFNGLISPOINTINSTROKEPATHNVPROC) glewGetProcAddress ("glIsPointInStrokePathNV");
    s_deviceConfig.m_glGetPathLengthNV = (PFNGLGETPATHLENGTHNVPROC) glewGetProcAddress ("glGetPathLengthNV");
    s_deviceConfig.m_glPointAlongPathNV = (PFNGLPOINTALONGPATHNVPROC) glewGetProcAddress ("glPointAlongPathNV");
    s_deviceConfig.m_glMatrixLoad3x2fNV = (PFNGLMATRIXLOAD3X2FNVPROC) glewGetProcAddress ("glMatrixLoad3x2fNV");
    s_deviceConfig.m_glMatrixLoad3x3fNV = (PFNGLMATRIXLOAD3X3FNVPROC) glewGetProcAddress ("glMatrixLoad3x3fNV");
    s_deviceConfig.m_glMatrixLoadTranspose3x3fNV = (PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC) glewGetProcAddress ("glMatrixLoadTranspose3x3fNV");
    s_deviceConfig.m_glMatrixMult3x2fNV = (PFNGLMATRIXMULT3X2FNVPROC) glewGetProcAddress ("glMatrixMult3x2fNV");
    s_deviceConfig.m_glMatrixMult3x3fNV = (PFNGLMATRIXMULT3X3FNVPROC) glewGetProcAddress ("glMatrixMult3x3fNV");
    s_deviceConfig.m_glMatrixMultTranspose3x3fNV = (PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC) glewGetProcAddress ("glMatrixMultTranspose3x3fNV");
    s_deviceConfig.m_glStencilThenCoverFillPathNV = (PFNGLSTENCILTHENCOVERFILLPATHNVPROC) glewGetProcAddress ("glStencilThenCoverFillPathNV");
    s_deviceConfig.m_glStencilThenCoverStrokePathNV = (PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC) glewGetProcAddress ("glStencilThenCoverStrokePathNV");
    s_deviceConfig.m_glStencilThenCoverFillPathInstancedNV = (PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC) glewGetProcAddress ("glStencilThenCoverFillPathInstancedNV");
    s_deviceConfig.m_glStencilThenCoverStrokePathInstancedNV = (PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC) glewGetProcAddress ("glStencilThenCoverStrokePathInstancedNV");
    s_deviceConfig.m_glPathGlyphIndexRangeNV = (PFNGLPATHGLYPHINDEXRANGENVPROC) glewGetProcAddress ("glPathGlyphIndexRangeNV");
    s_deviceConfig.m_glPathGlyphIndexArrayNV = (PFNGLPATHGLYPHINDEXARRAYNVPROC) glewGetProcAddress ("glPathGlyphIndexArrayNV");
    s_deviceConfig.m_glPathMemoryGlyphIndexArrayNV = (PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC) glewGetProcAddress ("glPathMemoryGlyphIndexArrayNV");
    s_deviceConfig.m_glProgramPathFragmentInputGenNV = (PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC) glewGetProcAddress ("glProgramPathFragmentInputGenNV");
    s_deviceConfig.m_glGetProgramResourcefvNV = (PFNGLGETPROGRAMRESOURCEFVNVPROC) glewGetProcAddress ("glGetProgramResourcefvNV");
    s_deviceConfig.m_glPathColorGenNV = (PFNGLPATHCOLORGENNVPROC) glewGetProcAddress ("glPathColorGenNV");
    s_deviceConfig.m_glPathTexGenNV = (PFNGLPATHTEXGENNVPROC) glewGetProcAddress ("glPathTexGenNV");
    s_deviceConfig.m_glPathFogGenNV = (PFNGLPATHFOGGENNVPROC) glewGetProcAddress ("glPathFogGenNV");
    s_deviceConfig.m_glGetPathColorGenivNV = (PFNGLGETPATHCOLORGENIVNVPROC) glewGetProcAddress ("glGetPathColorGenivNV");
    s_deviceConfig.m_glGetPathColorGenfvNV = (PFNGLGETPATHCOLORGENFVNVPROC) glewGetProcAddress ("glGetPathColorGenfvNV");
    s_deviceConfig.m_glGetPathTexGenivNV = (PFNGLGETPATHTEXGENIVNVPROC) glewGetProcAddress ("glGetPathTexGenivNV");
    s_deviceConfig.m_glGetPathTexGenfvNV = (PFNGLGETPATHTEXGENFVNVPROC) glewGetProcAddress ("glGetPathTexGenfvNV");
    s_deviceConfig.m_glMatrixFrustumEXT = (PFNGLMATRIXFRUSTUMEXTPROC) glewGetProcAddress ("glMatrixFrustumEXT");
    s_deviceConfig.m_glMatrixLoadIdentityEXT = (PFNGLMATRIXLOADIDENTITYEXTPROC) glewGetProcAddress ("glMatrixLoadIdentityEXT");
    s_deviceConfig.m_glMatrixLoadTransposefEXT = (PFNGLMATRIXLOADTRANSPOSEFEXTPROC) glewGetProcAddress ("glMatrixLoadTransposefEXT");
    s_deviceConfig.m_glMatrixLoadTransposedEXT = (PFNGLMATRIXLOADTRANSPOSEDEXTPROC) glewGetProcAddress ("glMatrixLoadTransposedEXT");
    s_deviceConfig.m_glMatrixLoadfEXT = (PFNGLMATRIXLOADFEXTPROC) glewGetProcAddress ("glMatrixLoadfEXT");
    s_deviceConfig.m_glMatrixLoaddEXT = (PFNGLMATRIXLOADDEXTPROC) glewGetProcAddress ("glMatrixLoaddEXT");
    s_deviceConfig.m_glMatrixMultTransposefEXT = (PFNGLMATRIXMULTTRANSPOSEFEXTPROC) glewGetProcAddress ("glMatrixMultTransposefEXT");
    s_deviceConfig.m_glMatrixMultTransposedEXT = (PFNGLMATRIXMULTTRANSPOSEDEXTPROC) glewGetProcAddress ("glMatrixMultTransposedEXT");
    s_deviceConfig.m_glMatrixMultfEXT = (PFNGLMATRIXMULTFEXTPROC) glewGetProcAddress ("glMatrixMultfEXT");
    s_deviceConfig.m_glMatrixMultdEXT = (PFNGLMATRIXMULTDEXTPROC) glewGetProcAddress ("glMatrixMultdEXT");
    s_deviceConfig.m_glMatrixOrthoEXT = (PFNGLMATRIXORTHOEXTPROC) glewGetProcAddress ("glMatrixOrthoEXT");
    s_deviceConfig.m_glMatrixPopEXT = (PFNGLMATRIXPOPEXTPROC) glewGetProcAddress ("glMatrixPopEXT");
    s_deviceConfig.m_glMatrixPushEXT = (PFNGLMATRIXPUSHEXTPROC) glewGetProcAddress ("glMatrixPushEXT");
    s_deviceConfig.m_glMatrixRotatefEXT = (PFNGLMATRIXROTATEFEXTPROC) glewGetProcAddress ("glMatrixRotatefEXT");
    s_deviceConfig.m_glMatrixRotatedEXT = (PFNGLMATRIXROTATEDEXTPROC) glewGetProcAddress ("glMatrixRotatedEXT");
    s_deviceConfig.m_glMatrixScalefEXT = (PFNGLMATRIXSCALEFEXTPROC) glewGetProcAddress ("glMatrixScalefEXT");
    s_deviceConfig.m_glMatrixScaledEXT = (PFNGLMATRIXSCALEDEXTPROC) glewGetProcAddress ("glMatrixScaledEXT");
    s_deviceConfig.m_glMatrixTranslatefEXT = (PFNGLMATRIXTRANSLATEFEXTPROC) glewGetProcAddress ("glMatrixTranslatefEXT");
    s_deviceConfig.m_glMatrixTranslatedEXT = (PFNGLMATRIXTRANSLATEDEXTPROC) glewGetProcAddress ("glMatrixTranslatedEXT");
  }

  // GL_NV_pixel_data_range
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_pixel_data_range])
  {
    s_deviceConfig.m_glPixelDataRangeNV = (PFNGLPIXELDATARANGENVPROC) glewGetProcAddress ("glPixelDataRangeNV");
    s_deviceConfig.m_glFlushPixelDataRangeNV = (PFNGLFLUSHPIXELDATARANGENVPROC) glewGetProcAddress ("glFlushPixelDataRangeNV");
  }

  // GL_NV_point_sprite
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_point_sprite])
  {
    s_deviceConfig.m_glPointParameteriNV = (PFNGLPOINTPARAMETERINVPROC) glewGetProcAddress ("glPointParameteriNV");
    s_deviceConfig.m_glPointParameterivNV = (PFNGLPOINTPARAMETERIVNVPROC) glewGetProcAddress ("glPointParameterivNV");
  }

  // GL_NV_polygon_mode
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_polygon_mode])
  {
    s_deviceConfig.m_glPolygonModeNV = (PFNGLPOLYGONMODENVPROC) glewGetProcAddress ("glPolygonModeNV");
  }

  // GL_NV_present_video
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_present_video])
  {
    s_deviceConfig.m_glPresentFrameKeyedNV = (PFNGLPRESENTFRAMEKEYEDNVPROC) glewGetProcAddress ("glPresentFrameKeyedNV");
    s_deviceConfig.m_glPresentFrameDualFillNV = (PFNGLPRESENTFRAMEDUALFILLNVPROC) glewGetProcAddress ("glPresentFrameDualFillNV");
    s_deviceConfig.m_glGetVideoivNV = (PFNGLGETVIDEOIVNVPROC) glewGetProcAddress ("glGetVideoivNV");
    s_deviceConfig.m_glGetVideouivNV = (PFNGLGETVIDEOUIVNVPROC) glewGetProcAddress ("glGetVideouivNV");
    s_deviceConfig.m_glGetVideoi64vNV = (PFNGLGETVIDEOI64VNVPROC) glewGetProcAddress ("glGetVideoi64vNV");
    s_deviceConfig.m_glGetVideoui64vNV = (PFNGLGETVIDEOUI64VNVPROC) glewGetProcAddress ("glGetVideoui64vNV");
  }

  // GL_NV_primitive_restart
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_primitive_restart])
  {
    s_deviceConfig.m_glPrimitiveRestartNV = (PFNGLPRIMITIVERESTARTNVPROC) glewGetProcAddress ("glPrimitiveRestartNV");
    s_deviceConfig.m_glPrimitiveRestartIndexNV = (PFNGLPRIMITIVERESTARTINDEXNVPROC) glewGetProcAddress ("glPrimitiveRestartIndexNV");
  }

  // GL_NV_query_resource
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_query_resource])
  {
    s_deviceConfig.m_glQueryResourceNV = (PFNGLQUERYRESOURCENVPROC) glewGetProcAddress ("glQueryResourceNV");
  }

  // GL_NV_query_resource_tag
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_query_resource_tag])
  {
    s_deviceConfig.m_glGenQueryResourceTagNV = (PFNGLGENQUERYRESOURCETAGNVPROC) glewGetProcAddress ("glGenQueryResourceTagNV");
    s_deviceConfig.m_glDeleteQueryResourceTagNV = (PFNGLDELETEQUERYRESOURCETAGNVPROC) glewGetProcAddress ("glDeleteQueryResourceTagNV");
    s_deviceConfig.m_glQueryResourceTagNV = (PFNGLQUERYRESOURCETAGNVPROC) glewGetProcAddress ("glQueryResourceTagNV");
  }

  // GL_NV_read_buffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_read_buffer])
  {
    s_deviceConfig.m_glReadBufferNV = (PFNGLREADBUFFERNVPROC) glewGetProcAddress ("glReadBufferNV");
  }

  // GL_NV_register_combiners
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_register_combiners])
  {
    s_deviceConfig.m_glCombinerParameterfvNV = (PFNGLCOMBINERPARAMETERFVNVPROC) glewGetProcAddress ("glCombinerParameterfvNV");
    s_deviceConfig.m_glCombinerParameterfNV = (PFNGLCOMBINERPARAMETERFNVPROC) glewGetProcAddress ("glCombinerParameterfNV");
    s_deviceConfig.m_glCombinerParameterivNV = (PFNGLCOMBINERPARAMETERIVNVPROC) glewGetProcAddress ("glCombinerParameterivNV");
    s_deviceConfig.m_glCombinerParameteriNV = (PFNGLCOMBINERPARAMETERINVPROC) glewGetProcAddress ("glCombinerParameteriNV");
    s_deviceConfig.m_glCombinerInputNV = (PFNGLCOMBINERINPUTNVPROC) glewGetProcAddress ("glCombinerInputNV");
    s_deviceConfig.m_glCombinerOutputNV = (PFNGLCOMBINEROUTPUTNVPROC) glewGetProcAddress ("glCombinerOutputNV");
    s_deviceConfig.m_glFinalCombinerInputNV = (PFNGLFINALCOMBINERINPUTNVPROC) glewGetProcAddress ("glFinalCombinerInputNV");
    s_deviceConfig.m_glGetCombinerInputParameterfvNV = (PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) glewGetProcAddress ("glGetCombinerInputParameterfvNV");
    s_deviceConfig.m_glGetCombinerInputParameterivNV = (PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) glewGetProcAddress ("glGetCombinerInputParameterivNV");
    s_deviceConfig.m_glGetCombinerOutputParameterfvNV = (PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) glewGetProcAddress ("glGetCombinerOutputParameterfvNV");
    s_deviceConfig.m_glGetCombinerOutputParameterivNV = (PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) glewGetProcAddress ("glGetCombinerOutputParameterivNV");
    s_deviceConfig.m_glGetFinalCombinerInputParameterfvNV = (PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) glewGetProcAddress ("glGetFinalCombinerInputParameterfvNV");
    s_deviceConfig.m_glGetFinalCombinerInputParameterivNV = (PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) glewGetProcAddress ("glGetFinalCombinerInputParameterivNV");
  }

  // GL_NV_register_combiners2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_register_combiners2])
  {
    s_deviceConfig.m_glCombinerStageParameterfvNV = (PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) glewGetProcAddress ("glCombinerStageParameterfvNV");
    s_deviceConfig.m_glGetCombinerStageParameterfvNV = (PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) glewGetProcAddress ("glGetCombinerStageParameterfvNV");
  }

  // GL_NV_sample_locations
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_sample_locations])
  {
    s_deviceConfig.m_glFramebufferSampleLocationsfvNV = (PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) glewGetProcAddress ("glFramebufferSampleLocationsfvNV");
    s_deviceConfig.m_glNamedFramebufferSampleLocationsfvNV = (PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) glewGetProcAddress ("glNamedFramebufferSampleLocationsfvNV");
    s_deviceConfig.m_glResolveDepthValuesNV = (PFNGLRESOLVEDEPTHVALUESNVPROC) glewGetProcAddress ("glResolveDepthValuesNV");
  }

  // GL_NV_scissor_exclusive
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_scissor_exclusive])
  {
    s_deviceConfig.m_glScissorExclusiveNV = (PFNGLSCISSOREXCLUSIVENVPROC) glewGetProcAddress ("glScissorExclusiveNV");
    s_deviceConfig.m_glScissorExclusiveArrayvNV = (PFNGLSCISSOREXCLUSIVEARRAYVNVPROC) glewGetProcAddress ("glScissorExclusiveArrayvNV");
  }

  // GL_NV_shader_buffer_load
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_shader_buffer_load])
  {
    s_deviceConfig.m_glMakeBufferResidentNV = (PFNGLMAKEBUFFERRESIDENTNVPROC) glewGetProcAddress ("glMakeBufferResidentNV");
    s_deviceConfig.m_glMakeBufferNonResidentNV = (PFNGLMAKEBUFFERNONRESIDENTNVPROC) glewGetProcAddress ("glMakeBufferNonResidentNV");
    s_deviceConfig.m_glIsBufferResidentNV = (PFNGLISBUFFERRESIDENTNVPROC) glewGetProcAddress ("glIsBufferResidentNV");
    s_deviceConfig.m_glMakeNamedBufferResidentNV = (PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) glewGetProcAddress ("glMakeNamedBufferResidentNV");
    s_deviceConfig.m_glMakeNamedBufferNonResidentNV = (PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) glewGetProcAddress ("glMakeNamedBufferNonResidentNV");
    s_deviceConfig.m_glIsNamedBufferResidentNV = (PFNGLISNAMEDBUFFERRESIDENTNVPROC) glewGetProcAddress ("glIsNamedBufferResidentNV");
    s_deviceConfig.m_glGetBufferParameterui64vNV = (PFNGLGETBUFFERPARAMETERUI64VNVPROC) glewGetProcAddress ("glGetBufferParameterui64vNV");
    s_deviceConfig.m_glGetNamedBufferParameterui64vNV = (PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) glewGetProcAddress ("glGetNamedBufferParameterui64vNV");
    s_deviceConfig.m_glGetIntegerui64vNV = (PFNGLGETINTEGERUI64VNVPROC) glewGetProcAddress ("glGetIntegerui64vNV");
    s_deviceConfig.m_glUniformui64NV = (PFNGLUNIFORMUI64NVPROC) glewGetProcAddress ("glUniformui64NV");
    s_deviceConfig.m_glUniformui64vNV = (PFNGLUNIFORMUI64VNVPROC) glewGetProcAddress ("glUniformui64vNV");
    s_deviceConfig.m_glGetUniformui64vNV = (PFNGLGETUNIFORMUI64VNVPROC) glewGetProcAddress ("glGetUniformui64vNV");
    s_deviceConfig.m_glProgramUniformui64NV = (PFNGLPROGRAMUNIFORMUI64NVPROC) glewGetProcAddress ("glProgramUniformui64NV");
    s_deviceConfig.m_glProgramUniformui64vNV = (PFNGLPROGRAMUNIFORMUI64VNVPROC) glewGetProcAddress ("glProgramUniformui64vNV");
  }

  // GL_NV_shading_rate_image
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_shading_rate_image])
  {
    s_deviceConfig.m_glBindShadingRateImageNV = (PFNGLBINDSHADINGRATEIMAGENVPROC) glewGetProcAddress ("glBindShadingRateImageNV");
    s_deviceConfig.m_glGetShadingRateImagePaletteNV = (PFNGLGETSHADINGRATEIMAGEPALETTENVPROC) glewGetProcAddress ("glGetShadingRateImagePaletteNV");
    s_deviceConfig.m_glGetShadingRateSampleLocationivNV = (PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC) glewGetProcAddress ("glGetShadingRateSampleLocationivNV");
    s_deviceConfig.m_glShadingRateImageBarrierNV = (PFNGLSHADINGRATEIMAGEBARRIERNVPROC) glewGetProcAddress ("glShadingRateImageBarrierNV");
    s_deviceConfig.m_glShadingRateImagePaletteNV = (PFNGLSHADINGRATEIMAGEPALETTENVPROC) glewGetProcAddress ("glShadingRateImagePaletteNV");
    s_deviceConfig.m_glShadingRateSampleOrderNV = (PFNGLSHADINGRATESAMPLEORDERNVPROC) glewGetProcAddress ("glShadingRateSampleOrderNV");
    s_deviceConfig.m_glShadingRateSampleOrderCustomNV = (PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC) glewGetProcAddress ("glShadingRateSampleOrderCustomNV");
  }

  // GL_NV_texture_barrier
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_barrier])
  {
    s_deviceConfig.m_glTextureBarrierNV = (PFNGLTEXTUREBARRIERNVPROC) glewGetProcAddress ("glTextureBarrierNV");
  }

  // GL_NV_texture_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_texture_multisample])
  {
    s_deviceConfig.m_glTexImage2DMultisampleCoverageNV = (PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) glewGetProcAddress ("glTexImage2DMultisampleCoverageNV");
    s_deviceConfig.m_glTexImage3DMultisampleCoverageNV = (PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) glewGetProcAddress ("glTexImage3DMultisampleCoverageNV");
    s_deviceConfig.m_glTextureImage2DMultisampleNV = (PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) glewGetProcAddress ("glTextureImage2DMultisampleNV");
    s_deviceConfig.m_glTextureImage3DMultisampleNV = (PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) glewGetProcAddress ("glTextureImage3DMultisampleNV");
    s_deviceConfig.m_glTextureImage2DMultisampleCoverageNV = (PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) glewGetProcAddress ("glTextureImage2DMultisampleCoverageNV");
    s_deviceConfig.m_glTextureImage3DMultisampleCoverageNV = (PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) glewGetProcAddress ("glTextureImage3DMultisampleCoverageNV");
  }

  // GL_NV_transform_feedback
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_transform_feedback])
  {
    s_deviceConfig.m_glBeginTransformFeedbackNV = (PFNGLBEGINTRANSFORMFEEDBACKNVPROC) glewGetProcAddress ("glBeginTransformFeedbackNV");
    s_deviceConfig.m_glEndTransformFeedbackNV = (PFNGLENDTRANSFORMFEEDBACKNVPROC) glewGetProcAddress ("glEndTransformFeedbackNV");
    s_deviceConfig.m_glTransformFeedbackAttribsNV = (PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) glewGetProcAddress ("glTransformFeedbackAttribsNV");
    s_deviceConfig.m_glBindBufferRangeNV = (PFNGLBINDBUFFERRANGENVPROC) glewGetProcAddress ("glBindBufferRangeNV");
    s_deviceConfig.m_glBindBufferOffsetNV = (PFNGLBINDBUFFEROFFSETNVPROC) glewGetProcAddress ("glBindBufferOffsetNV");
    s_deviceConfig.m_glBindBufferBaseNV = (PFNGLBINDBUFFERBASENVPROC) glewGetProcAddress ("glBindBufferBaseNV");
    s_deviceConfig.m_glTransformFeedbackVaryingsNV = (PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) glewGetProcAddress ("glTransformFeedbackVaryingsNV");
    s_deviceConfig.m_glActiveVaryingNV = (PFNGLACTIVEVARYINGNVPROC) glewGetProcAddress ("glActiveVaryingNV");
    s_deviceConfig.m_glGetVaryingLocationNV = (PFNGLGETVARYINGLOCATIONNVPROC) glewGetProcAddress ("glGetVaryingLocationNV");
    s_deviceConfig.m_glGetActiveVaryingNV = (PFNGLGETACTIVEVARYINGNVPROC) glewGetProcAddress ("glGetActiveVaryingNV");
    s_deviceConfig.m_glGetTransformFeedbackVaryingNV = (PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) glewGetProcAddress ("glGetTransformFeedbackVaryingNV");
    s_deviceConfig.m_glTransformFeedbackStreamAttribsNV = (PFNGLTRANSFORMFEEDBACKSTREAMATTRIBSNVPROC) glewGetProcAddress ("glTransformFeedbackStreamAttribsNV");
  }

  // GL_NV_transform_feedback2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_transform_feedback2])
  {
    s_deviceConfig.m_glBindTransformFeedbackNV = (PFNGLBINDTRANSFORMFEEDBACKNVPROC) glewGetProcAddress ("glBindTransformFeedbackNV");
    s_deviceConfig.m_glDeleteTransformFeedbacksNV = (PFNGLDELETETRANSFORMFEEDBACKSNVPROC) glewGetProcAddress ("glDeleteTransformFeedbacksNV");
    s_deviceConfig.m_glGenTransformFeedbacksNV = (PFNGLGENTRANSFORMFEEDBACKSNVPROC) glewGetProcAddress ("glGenTransformFeedbacksNV");
    s_deviceConfig.m_glIsTransformFeedbackNV = (PFNGLISTRANSFORMFEEDBACKNVPROC) glewGetProcAddress ("glIsTransformFeedbackNV");
    s_deviceConfig.m_glPauseTransformFeedbackNV = (PFNGLPAUSETRANSFORMFEEDBACKNVPROC) glewGetProcAddress ("glPauseTransformFeedbackNV");
    s_deviceConfig.m_glResumeTransformFeedbackNV = (PFNGLRESUMETRANSFORMFEEDBACKNVPROC) glewGetProcAddress ("glResumeTransformFeedbackNV");
    s_deviceConfig.m_glDrawTransformFeedbackNV = (PFNGLDRAWTRANSFORMFEEDBACKNVPROC) glewGetProcAddress ("glDrawTransformFeedbackNV");
  }

  // GL_NV_vdpau_interop
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop])
  {
    s_deviceConfig.m_glVDPAUInitNV = (PFNGLVDPAUINITNVPROC) glewGetProcAddress ("glVDPAUInitNV");
    s_deviceConfig.m_glVDPAUFiniNV = (PFNGLVDPAUFININVPROC) glewGetProcAddress ("glVDPAUFiniNV");
    s_deviceConfig.m_glVDPAURegisterVideoSurfaceNV = (PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) glewGetProcAddress ("glVDPAURegisterVideoSurfaceNV");
    s_deviceConfig.m_glVDPAURegisterOutputSurfaceNV = (PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) glewGetProcAddress ("glVDPAURegisterOutputSurfaceNV");
    s_deviceConfig.m_glVDPAUIsSurfaceNV = (PFNGLVDPAUISSURFACENVPROC) glewGetProcAddress ("glVDPAUIsSurfaceNV");
    s_deviceConfig.m_glVDPAUUnregisterSurfaceNV = (PFNGLVDPAUUNREGISTERSURFACENVPROC) glewGetProcAddress ("glVDPAUUnregisterSurfaceNV");
    s_deviceConfig.m_glVDPAUGetSurfaceivNV = (PFNGLVDPAUGETSURFACEIVNVPROC) glewGetProcAddress ("glVDPAUGetSurfaceivNV");
    s_deviceConfig.m_glVDPAUSurfaceAccessNV = (PFNGLVDPAUSURFACEACCESSNVPROC) glewGetProcAddress ("glVDPAUSurfaceAccessNV");
    s_deviceConfig.m_glVDPAUMapSurfacesNV = (PFNGLVDPAUMAPSURFACESNVPROC) glewGetProcAddress ("glVDPAUMapSurfacesNV");
    s_deviceConfig.m_glVDPAUUnmapSurfacesNV = (PFNGLVDPAUUNMAPSURFACESNVPROC) glewGetProcAddress ("glVDPAUUnmapSurfacesNV");
  }

  // GL_NV_vdpau_interop2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_vdpau_interop2])
  {
    s_deviceConfig.m_glVDPAURegisterVideoSurfaceWithPictureStructureNV = (PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC) glewGetProcAddress ("glVDPAURegisterVideoSurfaceWithPictureStructureNV");
  }

  // GL_NV_vertex_array_range
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_array_range])
  {
    s_deviceConfig.m_glFlushVertexArrayRangeNV = (PFNGLFLUSHVERTEXARRAYRANGENVPROC) glewGetProcAddress ("glFlushVertexArrayRangeNV");
    s_deviceConfig.m_glVertexArrayRangeNV = (PFNGLVERTEXARRAYRANGENVPROC) glewGetProcAddress ("glVertexArrayRangeNV");
  }

  // GL_NV_vertex_attrib_integer_64bit
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_attrib_integer_64bit])
  {
    s_deviceConfig.m_glVertexAttribL1i64NV = (PFNGLVERTEXATTRIBL1I64NVPROC) glewGetProcAddress ("glVertexAttribL1i64NV");
    s_deviceConfig.m_glVertexAttribL2i64NV = (PFNGLVERTEXATTRIBL2I64NVPROC) glewGetProcAddress ("glVertexAttribL2i64NV");
    s_deviceConfig.m_glVertexAttribL3i64NV = (PFNGLVERTEXATTRIBL3I64NVPROC) glewGetProcAddress ("glVertexAttribL3i64NV");
    s_deviceConfig.m_glVertexAttribL4i64NV = (PFNGLVERTEXATTRIBL4I64NVPROC) glewGetProcAddress ("glVertexAttribL4i64NV");
    s_deviceConfig.m_glVertexAttribL1i64vNV = (PFNGLVERTEXATTRIBL1I64VNVPROC) glewGetProcAddress ("glVertexAttribL1i64vNV");
    s_deviceConfig.m_glVertexAttribL2i64vNV = (PFNGLVERTEXATTRIBL2I64VNVPROC) glewGetProcAddress ("glVertexAttribL2i64vNV");
    s_deviceConfig.m_glVertexAttribL3i64vNV = (PFNGLVERTEXATTRIBL3I64VNVPROC) glewGetProcAddress ("glVertexAttribL3i64vNV");
    s_deviceConfig.m_glVertexAttribL4i64vNV = (PFNGLVERTEXATTRIBL4I64VNVPROC) glewGetProcAddress ("glVertexAttribL4i64vNV");
    s_deviceConfig.m_glVertexAttribL1ui64NV = (PFNGLVERTEXATTRIBL1UI64NVPROC) glewGetProcAddress ("glVertexAttribL1ui64NV");
    s_deviceConfig.m_glVertexAttribL2ui64NV = (PFNGLVERTEXATTRIBL2UI64NVPROC) glewGetProcAddress ("glVertexAttribL2ui64NV");
    s_deviceConfig.m_glVertexAttribL3ui64NV = (PFNGLVERTEXATTRIBL3UI64NVPROC) glewGetProcAddress ("glVertexAttribL3ui64NV");
    s_deviceConfig.m_glVertexAttribL4ui64NV = (PFNGLVERTEXATTRIBL4UI64NVPROC) glewGetProcAddress ("glVertexAttribL4ui64NV");
    s_deviceConfig.m_glVertexAttribL1ui64vNV = (PFNGLVERTEXATTRIBL1UI64VNVPROC) glewGetProcAddress ("glVertexAttribL1ui64vNV");
    s_deviceConfig.m_glVertexAttribL2ui64vNV = (PFNGLVERTEXATTRIBL2UI64VNVPROC) glewGetProcAddress ("glVertexAttribL2ui64vNV");
    s_deviceConfig.m_glVertexAttribL3ui64vNV = (PFNGLVERTEXATTRIBL3UI64VNVPROC) glewGetProcAddress ("glVertexAttribL3ui64vNV");
    s_deviceConfig.m_glVertexAttribL4ui64vNV = (PFNGLVERTEXATTRIBL4UI64VNVPROC) glewGetProcAddress ("glVertexAttribL4ui64vNV");
    s_deviceConfig.m_glGetVertexAttribLi64vNV = (PFNGLGETVERTEXATTRIBLI64VNVPROC) glewGetProcAddress ("glGetVertexAttribLi64vNV");
    s_deviceConfig.m_glGetVertexAttribLui64vNV = (PFNGLGETVERTEXATTRIBLUI64VNVPROC) glewGetProcAddress ("glGetVertexAttribLui64vNV");
    s_deviceConfig.m_glVertexAttribLFormatNV = (PFNGLVERTEXATTRIBLFORMATNVPROC) glewGetProcAddress ("glVertexAttribLFormatNV");
  }

  // GL_NV_vertex_buffer_unified_memory
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_buffer_unified_memory])
  {
    s_deviceConfig.m_glBufferAddressRangeNV = (PFNGLBUFFERADDRESSRANGENVPROC) glewGetProcAddress ("glBufferAddressRangeNV");
    s_deviceConfig.m_glVertexFormatNV = (PFNGLVERTEXFORMATNVPROC) glewGetProcAddress ("glVertexFormatNV");
    s_deviceConfig.m_glNormalFormatNV = (PFNGLNORMALFORMATNVPROC) glewGetProcAddress ("glNormalFormatNV");
    s_deviceConfig.m_glColorFormatNV = (PFNGLCOLORFORMATNVPROC) glewGetProcAddress ("glColorFormatNV");
    s_deviceConfig.m_glIndexFormatNV = (PFNGLINDEXFORMATNVPROC) glewGetProcAddress ("glIndexFormatNV");
    s_deviceConfig.m_glTexCoordFormatNV = (PFNGLTEXCOORDFORMATNVPROC) glewGetProcAddress ("glTexCoordFormatNV");
    s_deviceConfig.m_glEdgeFlagFormatNV = (PFNGLEDGEFLAGFORMATNVPROC) glewGetProcAddress ("glEdgeFlagFormatNV");
    s_deviceConfig.m_glSecondaryColorFormatNV = (PFNGLSECONDARYCOLORFORMATNVPROC) glewGetProcAddress ("glSecondaryColorFormatNV");
    s_deviceConfig.m_glFogCoordFormatNV = (PFNGLFOGCOORDFORMATNVPROC) glewGetProcAddress ("glFogCoordFormatNV");
    s_deviceConfig.m_glVertexAttribFormatNV = (PFNGLVERTEXATTRIBFORMATNVPROC) glewGetProcAddress ("glVertexAttribFormatNV");
    s_deviceConfig.m_glVertexAttribIFormatNV = (PFNGLVERTEXATTRIBIFORMATNVPROC) glewGetProcAddress ("glVertexAttribIFormatNV");
    s_deviceConfig.m_glGetIntegerui64i_vNV = (PFNGLGETINTEGERUI64I_VNVPROC) glewGetProcAddress ("glGetIntegerui64i_vNV");
  }

  // GL_NV_vertex_program
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_program])
  {
    s_deviceConfig.m_glAreProgramsResidentNV = (PFNGLAREPROGRAMSRESIDENTNVPROC) glewGetProcAddress ("glAreProgramsResidentNV");
    s_deviceConfig.m_glBindProgramNV = (PFNGLBINDPROGRAMNVPROC) glewGetProcAddress ("glBindProgramNV");
    s_deviceConfig.m_glDeleteProgramsNV = (PFNGLDELETEPROGRAMSNVPROC) glewGetProcAddress ("glDeleteProgramsNV");
    s_deviceConfig.m_glExecuteProgramNV = (PFNGLEXECUTEPROGRAMNVPROC) glewGetProcAddress ("glExecuteProgramNV");
    s_deviceConfig.m_glGenProgramsNV = (PFNGLGENPROGRAMSNVPROC) glewGetProcAddress ("glGenProgramsNV");
    s_deviceConfig.m_glGetProgramParameterdvNV = (PFNGLGETPROGRAMPARAMETERDVNVPROC) glewGetProcAddress ("glGetProgramParameterdvNV");
    s_deviceConfig.m_glGetProgramParameterfvNV = (PFNGLGETPROGRAMPARAMETERFVNVPROC) glewGetProcAddress ("glGetProgramParameterfvNV");
    s_deviceConfig.m_glGetProgramivNV = (PFNGLGETPROGRAMIVNVPROC) glewGetProcAddress ("glGetProgramivNV");
    s_deviceConfig.m_glGetProgramStringNV = (PFNGLGETPROGRAMSTRINGNVPROC) glewGetProcAddress ("glGetProgramStringNV");
    s_deviceConfig.m_glGetTrackMatrixivNV = (PFNGLGETTRACKMATRIXIVNVPROC) glewGetProcAddress ("glGetTrackMatrixivNV");
    s_deviceConfig.m_glGetVertexAttribdvNV = (PFNGLGETVERTEXATTRIBDVNVPROC) glewGetProcAddress ("glGetVertexAttribdvNV");
    s_deviceConfig.m_glGetVertexAttribfvNV = (PFNGLGETVERTEXATTRIBFVNVPROC) glewGetProcAddress ("glGetVertexAttribfvNV");
    s_deviceConfig.m_glGetVertexAttribivNV = (PFNGLGETVERTEXATTRIBIVNVPROC) glewGetProcAddress ("glGetVertexAttribivNV");
    s_deviceConfig.m_glGetVertexAttribPointervNV = (PFNGLGETVERTEXATTRIBPOINTERVNVPROC) glewGetProcAddress ("glGetVertexAttribPointervNV");
    s_deviceConfig.m_glIsProgramNV = (PFNGLISPROGRAMNVPROC) glewGetProcAddress ("glIsProgramNV");
    s_deviceConfig.m_glLoadProgramNV = (PFNGLLOADPROGRAMNVPROC) glewGetProcAddress ("glLoadProgramNV");
    s_deviceConfig.m_glProgramParameter4dNV = (PFNGLPROGRAMPARAMETER4DNVPROC) glewGetProcAddress ("glProgramParameter4dNV");
    s_deviceConfig.m_glProgramParameter4dvNV = (PFNGLPROGRAMPARAMETER4DVNVPROC) glewGetProcAddress ("glProgramParameter4dvNV");
    s_deviceConfig.m_glProgramParameter4fNV = (PFNGLPROGRAMPARAMETER4FNVPROC) glewGetProcAddress ("glProgramParameter4fNV");
    s_deviceConfig.m_glProgramParameter4fvNV = (PFNGLPROGRAMPARAMETER4FVNVPROC) glewGetProcAddress ("glProgramParameter4fvNV");
    s_deviceConfig.m_glProgramParameters4dvNV = (PFNGLPROGRAMPARAMETERS4DVNVPROC) glewGetProcAddress ("glProgramParameters4dvNV");
    s_deviceConfig.m_glProgramParameters4fvNV = (PFNGLPROGRAMPARAMETERS4FVNVPROC) glewGetProcAddress ("glProgramParameters4fvNV");
    s_deviceConfig.m_glRequestResidentProgramsNV = (PFNGLREQUESTRESIDENTPROGRAMSNVPROC) glewGetProcAddress ("glRequestResidentProgramsNV");
    s_deviceConfig.m_glTrackMatrixNV = (PFNGLTRACKMATRIXNVPROC) glewGetProcAddress ("glTrackMatrixNV");
    s_deviceConfig.m_glVertexAttribPointerNV = (PFNGLVERTEXATTRIBPOINTERNVPROC) glewGetProcAddress ("glVertexAttribPointerNV");
    s_deviceConfig.m_glVertexAttrib1dNV = (PFNGLVERTEXATTRIB1DNVPROC) glewGetProcAddress ("glVertexAttrib1dNV");
    s_deviceConfig.m_glVertexAttrib1dvNV = (PFNGLVERTEXATTRIB1DVNVPROC) glewGetProcAddress ("glVertexAttrib1dvNV");
    s_deviceConfig.m_glVertexAttrib1fNV = (PFNGLVERTEXATTRIB1FNVPROC) glewGetProcAddress ("glVertexAttrib1fNV");
    s_deviceConfig.m_glVertexAttrib1fvNV = (PFNGLVERTEXATTRIB1FVNVPROC) glewGetProcAddress ("glVertexAttrib1fvNV");
    s_deviceConfig.m_glVertexAttrib1sNV = (PFNGLVERTEXATTRIB1SNVPROC) glewGetProcAddress ("glVertexAttrib1sNV");
    s_deviceConfig.m_glVertexAttrib1svNV = (PFNGLVERTEXATTRIB1SVNVPROC) glewGetProcAddress ("glVertexAttrib1svNV");
    s_deviceConfig.m_glVertexAttrib2dNV = (PFNGLVERTEXATTRIB2DNVPROC) glewGetProcAddress ("glVertexAttrib2dNV");
    s_deviceConfig.m_glVertexAttrib2dvNV = (PFNGLVERTEXATTRIB2DVNVPROC) glewGetProcAddress ("glVertexAttrib2dvNV");
    s_deviceConfig.m_glVertexAttrib2fNV = (PFNGLVERTEXATTRIB2FNVPROC) glewGetProcAddress ("glVertexAttrib2fNV");
    s_deviceConfig.m_glVertexAttrib2fvNV = (PFNGLVERTEXATTRIB2FVNVPROC) glewGetProcAddress ("glVertexAttrib2fvNV");
    s_deviceConfig.m_glVertexAttrib2sNV = (PFNGLVERTEXATTRIB2SNVPROC) glewGetProcAddress ("glVertexAttrib2sNV");
    s_deviceConfig.m_glVertexAttrib2svNV = (PFNGLVERTEXATTRIB2SVNVPROC) glewGetProcAddress ("glVertexAttrib2svNV");
    s_deviceConfig.m_glVertexAttrib3dNV = (PFNGLVERTEXATTRIB3DNVPROC) glewGetProcAddress ("glVertexAttrib3dNV");
    s_deviceConfig.m_glVertexAttrib3dvNV = (PFNGLVERTEXATTRIB3DVNVPROC) glewGetProcAddress ("glVertexAttrib3dvNV");
    s_deviceConfig.m_glVertexAttrib3fNV = (PFNGLVERTEXATTRIB3FNVPROC) glewGetProcAddress ("glVertexAttrib3fNV");
    s_deviceConfig.m_glVertexAttrib3fvNV = (PFNGLVERTEXATTRIB3FVNVPROC) glewGetProcAddress ("glVertexAttrib3fvNV");
    s_deviceConfig.m_glVertexAttrib3sNV = (PFNGLVERTEXATTRIB3SNVPROC) glewGetProcAddress ("glVertexAttrib3sNV");
    s_deviceConfig.m_glVertexAttrib3svNV = (PFNGLVERTEXATTRIB3SVNVPROC) glewGetProcAddress ("glVertexAttrib3svNV");
    s_deviceConfig.m_glVertexAttrib4dNV = (PFNGLVERTEXATTRIB4DNVPROC) glewGetProcAddress ("glVertexAttrib4dNV");
    s_deviceConfig.m_glVertexAttrib4dvNV = (PFNGLVERTEXATTRIB4DVNVPROC) glewGetProcAddress ("glVertexAttrib4dvNV");
    s_deviceConfig.m_glVertexAttrib4fNV = (PFNGLVERTEXATTRIB4FNVPROC) glewGetProcAddress ("glVertexAttrib4fNV");
    s_deviceConfig.m_glVertexAttrib4fvNV = (PFNGLVERTEXATTRIB4FVNVPROC) glewGetProcAddress ("glVertexAttrib4fvNV");
    s_deviceConfig.m_glVertexAttrib4sNV = (PFNGLVERTEXATTRIB4SNVPROC) glewGetProcAddress ("glVertexAttrib4sNV");
    s_deviceConfig.m_glVertexAttrib4svNV = (PFNGLVERTEXATTRIB4SVNVPROC) glewGetProcAddress ("glVertexAttrib4svNV");
    s_deviceConfig.m_glVertexAttrib4ubNV = (PFNGLVERTEXATTRIB4UBNVPROC) glewGetProcAddress ("glVertexAttrib4ubNV");
    s_deviceConfig.m_glVertexAttrib4ubvNV = (PFNGLVERTEXATTRIB4UBVNVPROC) glewGetProcAddress ("glVertexAttrib4ubvNV");
    s_deviceConfig.m_glVertexAttribs1dvNV = (PFNGLVERTEXATTRIBS1DVNVPROC) glewGetProcAddress ("glVertexAttribs1dvNV");
    s_deviceConfig.m_glVertexAttribs1fvNV = (PFNGLVERTEXATTRIBS1FVNVPROC) glewGetProcAddress ("glVertexAttribs1fvNV");
    s_deviceConfig.m_glVertexAttribs1svNV = (PFNGLVERTEXATTRIBS1SVNVPROC) glewGetProcAddress ("glVertexAttribs1svNV");
    s_deviceConfig.m_glVertexAttribs2dvNV = (PFNGLVERTEXATTRIBS2DVNVPROC) glewGetProcAddress ("glVertexAttribs2dvNV");
    s_deviceConfig.m_glVertexAttribs2fvNV = (PFNGLVERTEXATTRIBS2FVNVPROC) glewGetProcAddress ("glVertexAttribs2fvNV");
    s_deviceConfig.m_glVertexAttribs2svNV = (PFNGLVERTEXATTRIBS2SVNVPROC) glewGetProcAddress ("glVertexAttribs2svNV");
    s_deviceConfig.m_glVertexAttribs3dvNV = (PFNGLVERTEXATTRIBS3DVNVPROC) glewGetProcAddress ("glVertexAttribs3dvNV");
    s_deviceConfig.m_glVertexAttribs3fvNV = (PFNGLVERTEXATTRIBS3FVNVPROC) glewGetProcAddress ("glVertexAttribs3fvNV");
    s_deviceConfig.m_glVertexAttribs3svNV = (PFNGLVERTEXATTRIBS3SVNVPROC) glewGetProcAddress ("glVertexAttribs3svNV");
    s_deviceConfig.m_glVertexAttribs4dvNV = (PFNGLVERTEXATTRIBS4DVNVPROC) glewGetProcAddress ("glVertexAttribs4dvNV");
    s_deviceConfig.m_glVertexAttribs4fvNV = (PFNGLVERTEXATTRIBS4FVNVPROC) glewGetProcAddress ("glVertexAttribs4fvNV");
    s_deviceConfig.m_glVertexAttribs4svNV = (PFNGLVERTEXATTRIBS4SVNVPROC) glewGetProcAddress ("glVertexAttribs4svNV");
    s_deviceConfig.m_glVertexAttribs4ubvNV = (PFNGLVERTEXATTRIBS4UBVNVPROC) glewGetProcAddress ("glVertexAttribs4ubvNV");
  }

  // GL_NV_vertex_program4
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_vertex_program4])
  {
    s_deviceConfig.m_glVertexAttribI1iEXT = (PFNGLVERTEXATTRIBI1IEXTPROC) glewGetProcAddress ("glVertexAttribI1iEXT");
    s_deviceConfig.m_glVertexAttribI2iEXT = (PFNGLVERTEXATTRIBI2IEXTPROC) glewGetProcAddress ("glVertexAttribI2iEXT");
    s_deviceConfig.m_glVertexAttribI3iEXT = (PFNGLVERTEXATTRIBI3IEXTPROC) glewGetProcAddress ("glVertexAttribI3iEXT");
    s_deviceConfig.m_glVertexAttribI4iEXT = (PFNGLVERTEXATTRIBI4IEXTPROC) glewGetProcAddress ("glVertexAttribI4iEXT");
    s_deviceConfig.m_glVertexAttribI1uiEXT = (PFNGLVERTEXATTRIBI1UIEXTPROC) glewGetProcAddress ("glVertexAttribI1uiEXT");
    s_deviceConfig.m_glVertexAttribI2uiEXT = (PFNGLVERTEXATTRIBI2UIEXTPROC) glewGetProcAddress ("glVertexAttribI2uiEXT");
    s_deviceConfig.m_glVertexAttribI3uiEXT = (PFNGLVERTEXATTRIBI3UIEXTPROC) glewGetProcAddress ("glVertexAttribI3uiEXT");
    s_deviceConfig.m_glVertexAttribI4uiEXT = (PFNGLVERTEXATTRIBI4UIEXTPROC) glewGetProcAddress ("glVertexAttribI4uiEXT");
    s_deviceConfig.m_glVertexAttribI1ivEXT = (PFNGLVERTEXATTRIBI1IVEXTPROC) glewGetProcAddress ("glVertexAttribI1ivEXT");
    s_deviceConfig.m_glVertexAttribI2ivEXT = (PFNGLVERTEXATTRIBI2IVEXTPROC) glewGetProcAddress ("glVertexAttribI2ivEXT");
    s_deviceConfig.m_glVertexAttribI3ivEXT = (PFNGLVERTEXATTRIBI3IVEXTPROC) glewGetProcAddress ("glVertexAttribI3ivEXT");
    s_deviceConfig.m_glVertexAttribI4ivEXT = (PFNGLVERTEXATTRIBI4IVEXTPROC) glewGetProcAddress ("glVertexAttribI4ivEXT");
    s_deviceConfig.m_glVertexAttribI1uivEXT = (PFNGLVERTEXATTRIBI1UIVEXTPROC) glewGetProcAddress ("glVertexAttribI1uivEXT");
    s_deviceConfig.m_glVertexAttribI2uivEXT = (PFNGLVERTEXATTRIBI2UIVEXTPROC) glewGetProcAddress ("glVertexAttribI2uivEXT");
    s_deviceConfig.m_glVertexAttribI3uivEXT = (PFNGLVERTEXATTRIBI3UIVEXTPROC) glewGetProcAddress ("glVertexAttribI3uivEXT");
    s_deviceConfig.m_glVertexAttribI4uivEXT = (PFNGLVERTEXATTRIBI4UIVEXTPROC) glewGetProcAddress ("glVertexAttribI4uivEXT");
    s_deviceConfig.m_glVertexAttribI4bvEXT = (PFNGLVERTEXATTRIBI4BVEXTPROC) glewGetProcAddress ("glVertexAttribI4bvEXT");
    s_deviceConfig.m_glVertexAttribI4svEXT = (PFNGLVERTEXATTRIBI4SVEXTPROC) glewGetProcAddress ("glVertexAttribI4svEXT");
    s_deviceConfig.m_glVertexAttribI4ubvEXT = (PFNGLVERTEXATTRIBI4UBVEXTPROC) glewGetProcAddress ("glVertexAttribI4ubvEXT");
    s_deviceConfig.m_glVertexAttribI4usvEXT = (PFNGLVERTEXATTRIBI4USVEXTPROC) glewGetProcAddress ("glVertexAttribI4usvEXT");
    s_deviceConfig.m_glVertexAttribIPointerEXT = (PFNGLVERTEXATTRIBIPOINTEREXTPROC) glewGetProcAddress ("glVertexAttribIPointerEXT");
    s_deviceConfig.m_glGetVertexAttribIivEXT = (PFNGLGETVERTEXATTRIBIIVEXTPROC) glewGetProcAddress ("glGetVertexAttribIivEXT");
    s_deviceConfig.m_glGetVertexAttribIuivEXT = (PFNGLGETVERTEXATTRIBIUIVEXTPROC) glewGetProcAddress ("glGetVertexAttribIuivEXT");
  }

  // GL_NV_video_capture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_video_capture])
  {
    s_deviceConfig.m_glBeginVideoCaptureNV = (PFNGLBEGINVIDEOCAPTURENVPROC) glewGetProcAddress ("glBeginVideoCaptureNV");
    s_deviceConfig.m_glBindVideoCaptureStreamBufferNV = (PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) glewGetProcAddress ("glBindVideoCaptureStreamBufferNV");
    s_deviceConfig.m_glBindVideoCaptureStreamTextureNV = (PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) glewGetProcAddress ("glBindVideoCaptureStreamTextureNV");
    s_deviceConfig.m_glEndVideoCaptureNV = (PFNGLENDVIDEOCAPTURENVPROC) glewGetProcAddress ("glEndVideoCaptureNV");
    s_deviceConfig.m_glGetVideoCaptureivNV = (PFNGLGETVIDEOCAPTUREIVNVPROC) glewGetProcAddress ("glGetVideoCaptureivNV");
    s_deviceConfig.m_glGetVideoCaptureStreamivNV = (PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) glewGetProcAddress ("glGetVideoCaptureStreamivNV");
    s_deviceConfig.m_glGetVideoCaptureStreamfvNV = (PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) glewGetProcAddress ("glGetVideoCaptureStreamfvNV");
    s_deviceConfig.m_glGetVideoCaptureStreamdvNV = (PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) glewGetProcAddress ("glGetVideoCaptureStreamdvNV");
    s_deviceConfig.m_glVideoCaptureNV = (PFNGLVIDEOCAPTURENVPROC) glewGetProcAddress ("glVideoCaptureNV");
    s_deviceConfig.m_glVideoCaptureStreamParameterivNV = (PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) glewGetProcAddress ("glVideoCaptureStreamParameterivNV");
    s_deviceConfig.m_glVideoCaptureStreamParameterfvNV = (PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) glewGetProcAddress ("glVideoCaptureStreamParameterfvNV");
    s_deviceConfig.m_glVideoCaptureStreamParameterdvNV = (PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) glewGetProcAddress ("glVideoCaptureStreamParameterdvNV");
  }

  // GL_NV_viewport_array
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_viewport_array])
  {
    s_deviceConfig.m_glViewportArrayvNV = (PFNGLVIEWPORTARRAYVNVPROC) glewGetProcAddress ("glViewportArrayvNV");
    s_deviceConfig.m_glViewportIndexedfNV = (PFNGLVIEWPORTINDEXEDFNVPROC) glewGetProcAddress ("glViewportIndexedfNV");
    s_deviceConfig.m_glViewportIndexedfvNV = (PFNGLVIEWPORTINDEXEDFVNVPROC) glewGetProcAddress ("glViewportIndexedfvNV");
    s_deviceConfig.m_glScissorArrayvNV = (PFNGLSCISSORARRAYVNVPROC) glewGetProcAddress ("glScissorArrayvNV");
    s_deviceConfig.m_glScissorIndexedNV = (PFNGLSCISSORINDEXEDNVPROC) glewGetProcAddress ("glScissorIndexedNV");
    s_deviceConfig.m_glScissorIndexedvNV = (PFNGLSCISSORINDEXEDVNVPROC) glewGetProcAddress ("glScissorIndexedvNV");
    s_deviceConfig.m_glDepthRangeArrayfvNV = (PFNGLDEPTHRANGEARRAYFVNVPROC) glewGetProcAddress ("glDepthRangeArrayfvNV");
    s_deviceConfig.m_glDepthRangeIndexedfNV = (PFNGLDEPTHRANGEINDEXEDFNVPROC) glewGetProcAddress ("glDepthRangeIndexedfNV");
    s_deviceConfig.m_glGetFloati_vNV = (PFNGLGETFLOATI_VNVPROC) glewGetProcAddress ("glGetFloati_vNV");
    s_deviceConfig.m_glEnableiNV = (PFNGLENABLEINVPROC) glewGetProcAddress ("glEnableiNV");
    s_deviceConfig.m_glDisableiNV = (PFNGLDISABLEINVPROC) glewGetProcAddress ("glDisableiNV");
    s_deviceConfig.m_glIsEnablediNV = (PFNGLISENABLEDINVPROC) glewGetProcAddress ("glIsEnablediNV");
  }

  // GL_NV_viewport_swizzle
  if (s_deviceConfig.m_featureSupported [GLEW_GL_NV_viewport_swizzle])
  {
    s_deviceConfig.m_glViewportSwizzleNV = (PFNGLVIEWPORTSWIZZLENVPROC) glewGetProcAddress ("glViewportSwizzleNV");
  }

  // GL_OES_EGL_image
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_EGL_image])
  {
    s_deviceConfig.m_glEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC) glewGetProcAddress ("glEGLImageTargetTexture2DOES");
    s_deviceConfig.m_glEGLImageTargetRenderbufferStorageOES = (PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC) glewGetProcAddress ("glEGLImageTargetRenderbufferStorageOES");
  }

  // GL_OES_EGL_image_external
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_EGL_image_external])
  {
    s_deviceConfig.m_glEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC) glewGetProcAddress ("glEGLImageTargetTexture2DOES");
  }

  // GL_OES_byte_coordinates
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_byte_coordinates])
  {
    s_deviceConfig.m_glMultiTexCoord1bOES = (PFNGLMULTITEXCOORD1BOESPROC) glewGetProcAddress ("glMultiTexCoord1bOES");
    s_deviceConfig.m_glMultiTexCoord1bvOES = (PFNGLMULTITEXCOORD1BVOESPROC) glewGetProcAddress ("glMultiTexCoord1bvOES");
    s_deviceConfig.m_glMultiTexCoord2bOES = (PFNGLMULTITEXCOORD2BOESPROC) glewGetProcAddress ("glMultiTexCoord2bOES");
    s_deviceConfig.m_glMultiTexCoord2bvOES = (PFNGLMULTITEXCOORD2BVOESPROC) glewGetProcAddress ("glMultiTexCoord2bvOES");
    s_deviceConfig.m_glMultiTexCoord3bOES = (PFNGLMULTITEXCOORD3BOESPROC) glewGetProcAddress ("glMultiTexCoord3bOES");
    s_deviceConfig.m_glMultiTexCoord3bvOES = (PFNGLMULTITEXCOORD3BVOESPROC) glewGetProcAddress ("glMultiTexCoord3bvOES");
    s_deviceConfig.m_glMultiTexCoord4bOES = (PFNGLMULTITEXCOORD4BOESPROC) glewGetProcAddress ("glMultiTexCoord4bOES");
    s_deviceConfig.m_glMultiTexCoord4bvOES = (PFNGLMULTITEXCOORD4BVOESPROC) glewGetProcAddress ("glMultiTexCoord4bvOES");
    s_deviceConfig.m_glTexCoord1bOES = (PFNGLTEXCOORD1BOESPROC) glewGetProcAddress ("glTexCoord1bOES");
    s_deviceConfig.m_glTexCoord1bvOES = (PFNGLTEXCOORD1BVOESPROC) glewGetProcAddress ("glTexCoord1bvOES");
    s_deviceConfig.m_glTexCoord2bOES = (PFNGLTEXCOORD2BOESPROC) glewGetProcAddress ("glTexCoord2bOES");
    s_deviceConfig.m_glTexCoord2bvOES = (PFNGLTEXCOORD2BVOESPROC) glewGetProcAddress ("glTexCoord2bvOES");
    s_deviceConfig.m_glTexCoord3bOES = (PFNGLTEXCOORD3BOESPROC) glewGetProcAddress ("glTexCoord3bOES");
    s_deviceConfig.m_glTexCoord3bvOES = (PFNGLTEXCOORD3BVOESPROC) glewGetProcAddress ("glTexCoord3bvOES");
    s_deviceConfig.m_glTexCoord4bOES = (PFNGLTEXCOORD4BOESPROC) glewGetProcAddress ("glTexCoord4bOES");
    s_deviceConfig.m_glTexCoord4bvOES = (PFNGLTEXCOORD4BVOESPROC) glewGetProcAddress ("glTexCoord4bvOES");
    s_deviceConfig.m_glVertex2bOES = (PFNGLVERTEX2BOESPROC) glewGetProcAddress ("glVertex2bOES");
    s_deviceConfig.m_glVertex2bvOES = (PFNGLVERTEX2BVOESPROC) glewGetProcAddress ("glVertex2bvOES");
    s_deviceConfig.m_glVertex3bOES = (PFNGLVERTEX3BOESPROC) glewGetProcAddress ("glVertex3bOES");
    s_deviceConfig.m_glVertex3bvOES = (PFNGLVERTEX3BVOESPROC) glewGetProcAddress ("glVertex3bvOES");
    s_deviceConfig.m_glVertex4bOES = (PFNGLVERTEX4BOESPROC) glewGetProcAddress ("glVertex4bOES");
    s_deviceConfig.m_glVertex4bvOES = (PFNGLVERTEX4BVOESPROC) glewGetProcAddress ("glVertex4bvOES");
  }

  // GL_OES_copy_image
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_copy_image])
  {
    s_deviceConfig.m_glCopyImageSubDataOES = (PFNGLCOPYIMAGESUBDATAOESPROC) glewGetProcAddress ("glCopyImageSubDataOES");
  }

  // GL_OES_draw_buffers_indexed
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_draw_buffers_indexed])
  {
    s_deviceConfig.m_glEnableiOES = (PFNGLENABLEIOESPROC) glewGetProcAddress ("glEnableiOES");
    s_deviceConfig.m_glDisableiOES = (PFNGLDISABLEIOESPROC) glewGetProcAddress ("glDisableiOES");
    s_deviceConfig.m_glBlendEquationiOES = (PFNGLBLENDEQUATIONIOESPROC) glewGetProcAddress ("glBlendEquationiOES");
    s_deviceConfig.m_glBlendEquationSeparateiOES = (PFNGLBLENDEQUATIONSEPARATEIOESPROC) glewGetProcAddress ("glBlendEquationSeparateiOES");
    s_deviceConfig.m_glBlendFunciOES = (PFNGLBLENDFUNCIOESPROC) glewGetProcAddress ("glBlendFunciOES");
    s_deviceConfig.m_glBlendFuncSeparateiOES = (PFNGLBLENDFUNCSEPARATEIOESPROC) glewGetProcAddress ("glBlendFuncSeparateiOES");
    s_deviceConfig.m_glColorMaskiOES = (PFNGLCOLORMASKIOESPROC) glewGetProcAddress ("glColorMaskiOES");
    s_deviceConfig.m_glIsEnablediOES = (PFNGLISENABLEDIOESPROC) glewGetProcAddress ("glIsEnablediOES");
  }

  // GL_OES_draw_elements_base_vertex
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_draw_elements_base_vertex])
  {
    s_deviceConfig.m_glDrawElementsBaseVertexOES = (PFNGLDRAWELEMENTSBASEVERTEXOESPROC) glewGetProcAddress ("glDrawElementsBaseVertexOES");
    s_deviceConfig.m_glDrawRangeElementsBaseVertexOES = (PFNGLDRAWRANGEELEMENTSBASEVERTEXOESPROC) glewGetProcAddress ("glDrawRangeElementsBaseVertexOES");
    s_deviceConfig.m_glDrawElementsInstancedBaseVertexOES = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXOESPROC) glewGetProcAddress ("glDrawElementsInstancedBaseVertexOES");
    s_deviceConfig.m_glMultiDrawElementsBaseVertexEXT = (PFNGLMULTIDRAWELEMENTSBASEVERTEXEXTPROC) glewGetProcAddress ("glMultiDrawElementsBaseVertexEXT");
  }

  // GL_OES_fixed_point
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_fixed_point])
  {
    s_deviceConfig.m_glAlphaFuncxOES = (PFNGLALPHAFUNCXOESPROC) glewGetProcAddress ("glAlphaFuncxOES");
    s_deviceConfig.m_glClearColorxOES = (PFNGLCLEARCOLORXOESPROC) glewGetProcAddress ("glClearColorxOES");
    s_deviceConfig.m_glClearDepthxOES = (PFNGLCLEARDEPTHXOESPROC) glewGetProcAddress ("glClearDepthxOES");
    s_deviceConfig.m_glClipPlanexOES = (PFNGLCLIPPLANEXOESPROC) glewGetProcAddress ("glClipPlanexOES");
    s_deviceConfig.m_glColor4xOES = (PFNGLCOLOR4XOESPROC) glewGetProcAddress ("glColor4xOES");
    s_deviceConfig.m_glDepthRangexOES = (PFNGLDEPTHRANGEXOESPROC) glewGetProcAddress ("glDepthRangexOES");
    s_deviceConfig.m_glFogxOES = (PFNGLFOGXOESPROC) glewGetProcAddress ("glFogxOES");
    s_deviceConfig.m_glFogxvOES = (PFNGLFOGXVOESPROC) glewGetProcAddress ("glFogxvOES");
    s_deviceConfig.m_glFrustumxOES = (PFNGLFRUSTUMXOESPROC) glewGetProcAddress ("glFrustumxOES");
    s_deviceConfig.m_glGetClipPlanexOES = (PFNGLGETCLIPPLANEXOESPROC) glewGetProcAddress ("glGetClipPlanexOES");
    s_deviceConfig.m_glGetFixedvOES = (PFNGLGETFIXEDVOESPROC) glewGetProcAddress ("glGetFixedvOES");
    s_deviceConfig.m_glGetTexEnvxvOES = (PFNGLGETTEXENVXVOESPROC) glewGetProcAddress ("glGetTexEnvxvOES");
    s_deviceConfig.m_glGetTexParameterxvOES = (PFNGLGETTEXPARAMETERXVOESPROC) glewGetProcAddress ("glGetTexParameterxvOES");
    s_deviceConfig.m_glLightModelxOES = (PFNGLLIGHTMODELXOESPROC) glewGetProcAddress ("glLightModelxOES");
    s_deviceConfig.m_glLightModelxvOES = (PFNGLLIGHTMODELXVOESPROC) glewGetProcAddress ("glLightModelxvOES");
    s_deviceConfig.m_glLightxOES = (PFNGLLIGHTXOESPROC) glewGetProcAddress ("glLightxOES");
    s_deviceConfig.m_glLightxvOES = (PFNGLLIGHTXVOESPROC) glewGetProcAddress ("glLightxvOES");
    s_deviceConfig.m_glLineWidthxOES = (PFNGLLINEWIDTHXOESPROC) glewGetProcAddress ("glLineWidthxOES");
    s_deviceConfig.m_glLoadMatrixxOES = (PFNGLLOADMATRIXXOESPROC) glewGetProcAddress ("glLoadMatrixxOES");
    s_deviceConfig.m_glMaterialxOES = (PFNGLMATERIALXOESPROC) glewGetProcAddress ("glMaterialxOES");
    s_deviceConfig.m_glMaterialxvOES = (PFNGLMATERIALXVOESPROC) glewGetProcAddress ("glMaterialxvOES");
    s_deviceConfig.m_glMultMatrixxOES = (PFNGLMULTMATRIXXOESPROC) glewGetProcAddress ("glMultMatrixxOES");
    s_deviceConfig.m_glMultiTexCoord4xOES = (PFNGLMULTITEXCOORD4XOESPROC) glewGetProcAddress ("glMultiTexCoord4xOES");
    s_deviceConfig.m_glNormal3xOES = (PFNGLNORMAL3XOESPROC) glewGetProcAddress ("glNormal3xOES");
    s_deviceConfig.m_glOrthoxOES = (PFNGLORTHOXOESPROC) glewGetProcAddress ("glOrthoxOES");
    s_deviceConfig.m_glPointParameterxvOES = (PFNGLPOINTPARAMETERXVOESPROC) glewGetProcAddress ("glPointParameterxvOES");
    s_deviceConfig.m_glPointSizexOES = (PFNGLPOINTSIZEXOESPROC) glewGetProcAddress ("glPointSizexOES");
    s_deviceConfig.m_glPolygonOffsetxOES = (PFNGLPOLYGONOFFSETXOESPROC) glewGetProcAddress ("glPolygonOffsetxOES");
    s_deviceConfig.m_glRotatexOES = (PFNGLROTATEXOESPROC) glewGetProcAddress ("glRotatexOES");
    s_deviceConfig.m_glScalexOES = (PFNGLSCALEXOESPROC) glewGetProcAddress ("glScalexOES");
    s_deviceConfig.m_glTexEnvxOES = (PFNGLTEXENVXOESPROC) glewGetProcAddress ("glTexEnvxOES");
    s_deviceConfig.m_glTexEnvxvOES = (PFNGLTEXENVXVOESPROC) glewGetProcAddress ("glTexEnvxvOES");
    s_deviceConfig.m_glTexParameterxOES = (PFNGLTEXPARAMETERXOESPROC) glewGetProcAddress ("glTexParameterxOES");
    s_deviceConfig.m_glTexParameterxvOES = (PFNGLTEXPARAMETERXVOESPROC) glewGetProcAddress ("glTexParameterxvOES");
    s_deviceConfig.m_glTranslatexOES = (PFNGLTRANSLATEXOESPROC) glewGetProcAddress ("glTranslatexOES");
    s_deviceConfig.m_glAccumxOES = (PFNGLACCUMXOESPROC) glewGetProcAddress ("glAccumxOES");
    s_deviceConfig.m_glBitmapxOES = (PFNGLBITMAPXOESPROC) glewGetProcAddress ("glBitmapxOES");
    s_deviceConfig.m_glBlendColorxOES = (PFNGLBLENDCOLORXOESPROC) glewGetProcAddress ("glBlendColorxOES");
    s_deviceConfig.m_glClearAccumxOES = (PFNGLCLEARACCUMXOESPROC) glewGetProcAddress ("glClearAccumxOES");
    s_deviceConfig.m_glColor3xOES = (PFNGLCOLOR3XOESPROC) glewGetProcAddress ("glColor3xOES");
    s_deviceConfig.m_glColor3xvOES = (PFNGLCOLOR3XVOESPROC) glewGetProcAddress ("glColor3xvOES");
    s_deviceConfig.m_glColor4xvOES = (PFNGLCOLOR4XVOESPROC) glewGetProcAddress ("glColor4xvOES");
    s_deviceConfig.m_glConvolutionParameterxOES = (PFNGLCONVOLUTIONPARAMETERXOESPROC) glewGetProcAddress ("glConvolutionParameterxOES");
    s_deviceConfig.m_glConvolutionParameterxvOES = (PFNGLCONVOLUTIONPARAMETERXVOESPROC) glewGetProcAddress ("glConvolutionParameterxvOES");
    s_deviceConfig.m_glEvalCoord1xOES = (PFNGLEVALCOORD1XOESPROC) glewGetProcAddress ("glEvalCoord1xOES");
    s_deviceConfig.m_glEvalCoord1xvOES = (PFNGLEVALCOORD1XVOESPROC) glewGetProcAddress ("glEvalCoord1xvOES");
    s_deviceConfig.m_glEvalCoord2xOES = (PFNGLEVALCOORD2XOESPROC) glewGetProcAddress ("glEvalCoord2xOES");
    s_deviceConfig.m_glEvalCoord2xvOES = (PFNGLEVALCOORD2XVOESPROC) glewGetProcAddress ("glEvalCoord2xvOES");
    s_deviceConfig.m_glFeedbackBufferxOES = (PFNGLFEEDBACKBUFFERXOESPROC) glewGetProcAddress ("glFeedbackBufferxOES");
    s_deviceConfig.m_glGetConvolutionParameterxvOES = (PFNGLGETCONVOLUTIONPARAMETERXVOESPROC) glewGetProcAddress ("glGetConvolutionParameterxvOES");
    s_deviceConfig.m_glGetHistogramParameterxvOES = (PFNGLGETHISTOGRAMPARAMETERXVOESPROC) glewGetProcAddress ("glGetHistogramParameterxvOES");
    s_deviceConfig.m_glGetLightxOES = (PFNGLGETLIGHTXOESPROC) glewGetProcAddress ("glGetLightxOES");
    s_deviceConfig.m_glGetMapxvOES = (PFNGLGETMAPXVOESPROC) glewGetProcAddress ("glGetMapxvOES");
    s_deviceConfig.m_glGetMaterialxOES = (PFNGLGETMATERIALXOESPROC) glewGetProcAddress ("glGetMaterialxOES");
    s_deviceConfig.m_glGetPixelMapxv = (PFNGLGETPIXELMAPXVPROC) glewGetProcAddress ("glGetPixelMapxv");
    s_deviceConfig.m_glGetTexGenxvOES = (PFNGLGETTEXGENXVOESPROC) glewGetProcAddress ("glGetTexGenxvOES");
    s_deviceConfig.m_glGetTexLevelParameterxvOES = (PFNGLGETTEXLEVELPARAMETERXVOESPROC) glewGetProcAddress ("glGetTexLevelParameterxvOES");
    s_deviceConfig.m_glIndexxOES = (PFNGLINDEXXOESPROC) glewGetProcAddress ("glIndexxOES");
    s_deviceConfig.m_glIndexxvOES = (PFNGLINDEXXVOESPROC) glewGetProcAddress ("glIndexxvOES");
    s_deviceConfig.m_glLoadTransposeMatrixxOES = (PFNGLLOADTRANSPOSEMATRIXXOESPROC) glewGetProcAddress ("glLoadTransposeMatrixxOES");
    s_deviceConfig.m_glMap1xOES = (PFNGLMAP1XOESPROC) glewGetProcAddress ("glMap1xOES");
    s_deviceConfig.m_glMap2xOES = (PFNGLMAP2XOESPROC) glewGetProcAddress ("glMap2xOES");
    s_deviceConfig.m_glMapGrid1xOES = (PFNGLMAPGRID1XOESPROC) glewGetProcAddress ("glMapGrid1xOES");
    s_deviceConfig.m_glMapGrid2xOES = (PFNGLMAPGRID2XOESPROC) glewGetProcAddress ("glMapGrid2xOES");
    s_deviceConfig.m_glMultTransposeMatrixxOES = (PFNGLMULTTRANSPOSEMATRIXXOESPROC) glewGetProcAddress ("glMultTransposeMatrixxOES");
    s_deviceConfig.m_glMultiTexCoord1xOES = (PFNGLMULTITEXCOORD1XOESPROC) glewGetProcAddress ("glMultiTexCoord1xOES");
    s_deviceConfig.m_glMultiTexCoord1xvOES = (PFNGLMULTITEXCOORD1XVOESPROC) glewGetProcAddress ("glMultiTexCoord1xvOES");
    s_deviceConfig.m_glMultiTexCoord2xOES = (PFNGLMULTITEXCOORD2XOESPROC) glewGetProcAddress ("glMultiTexCoord2xOES");
    s_deviceConfig.m_glMultiTexCoord2xvOES = (PFNGLMULTITEXCOORD2XVOESPROC) glewGetProcAddress ("glMultiTexCoord2xvOES");
    s_deviceConfig.m_glMultiTexCoord3xOES = (PFNGLMULTITEXCOORD3XOESPROC) glewGetProcAddress ("glMultiTexCoord3xOES");
    s_deviceConfig.m_glMultiTexCoord3xvOES = (PFNGLMULTITEXCOORD3XVOESPROC) glewGetProcAddress ("glMultiTexCoord3xvOES");
    s_deviceConfig.m_glMultiTexCoord4xvOES = (PFNGLMULTITEXCOORD4XVOESPROC) glewGetProcAddress ("glMultiTexCoord4xvOES");
    s_deviceConfig.m_glNormal3xvOES = (PFNGLNORMAL3XVOESPROC) glewGetProcAddress ("glNormal3xvOES");
    s_deviceConfig.m_glPassThroughxOES = (PFNGLPASSTHROUGHXOESPROC) glewGetProcAddress ("glPassThroughxOES");
    s_deviceConfig.m_glPixelMapx = (PFNGLPIXELMAPXPROC) glewGetProcAddress ("glPixelMapx");
    s_deviceConfig.m_glPixelStorex = (PFNGLPIXELSTOREXPROC) glewGetProcAddress ("glPixelStorex");
    s_deviceConfig.m_glPixelTransferxOES = (PFNGLPIXELTRANSFERXOESPROC) glewGetProcAddress ("glPixelTransferxOES");
    s_deviceConfig.m_glPixelZoomxOES = (PFNGLPIXELZOOMXOESPROC) glewGetProcAddress ("glPixelZoomxOES");
    s_deviceConfig.m_glPrioritizeTexturesxOES = (PFNGLPRIORITIZETEXTURESXOESPROC) glewGetProcAddress ("glPrioritizeTexturesxOES");
    s_deviceConfig.m_glRasterPos2xOES = (PFNGLRASTERPOS2XOESPROC) glewGetProcAddress ("glRasterPos2xOES");
    s_deviceConfig.m_glRasterPos2xvOES = (PFNGLRASTERPOS2XVOESPROC) glewGetProcAddress ("glRasterPos2xvOES");
    s_deviceConfig.m_glRasterPos3xOES = (PFNGLRASTERPOS3XOESPROC) glewGetProcAddress ("glRasterPos3xOES");
    s_deviceConfig.m_glRasterPos3xvOES = (PFNGLRASTERPOS3XVOESPROC) glewGetProcAddress ("glRasterPos3xvOES");
    s_deviceConfig.m_glRasterPos4xOES = (PFNGLRASTERPOS4XOESPROC) glewGetProcAddress ("glRasterPos4xOES");
    s_deviceConfig.m_glRasterPos4xvOES = (PFNGLRASTERPOS4XVOESPROC) glewGetProcAddress ("glRasterPos4xvOES");
    s_deviceConfig.m_glRectxOES = (PFNGLRECTXOESPROC) glewGetProcAddress ("glRectxOES");
    s_deviceConfig.m_glRectxvOES = (PFNGLRECTXVOESPROC) glewGetProcAddress ("glRectxvOES");
    s_deviceConfig.m_glTexCoord1xOES = (PFNGLTEXCOORD1XOESPROC) glewGetProcAddress ("glTexCoord1xOES");
    s_deviceConfig.m_glTexCoord1xvOES = (PFNGLTEXCOORD1XVOESPROC) glewGetProcAddress ("glTexCoord1xvOES");
    s_deviceConfig.m_glTexCoord2xOES = (PFNGLTEXCOORD2XOESPROC) glewGetProcAddress ("glTexCoord2xOES");
    s_deviceConfig.m_glTexCoord2xvOES = (PFNGLTEXCOORD2XVOESPROC) glewGetProcAddress ("glTexCoord2xvOES");
    s_deviceConfig.m_glTexCoord3xOES = (PFNGLTEXCOORD3XOESPROC) glewGetProcAddress ("glTexCoord3xOES");
    s_deviceConfig.m_glTexCoord3xvOES = (PFNGLTEXCOORD3XVOESPROC) glewGetProcAddress ("glTexCoord3xvOES");
    s_deviceConfig.m_glTexCoord4xOES = (PFNGLTEXCOORD4XOESPROC) glewGetProcAddress ("glTexCoord4xOES");
    s_deviceConfig.m_glTexCoord4xvOES = (PFNGLTEXCOORD4XVOESPROC) glewGetProcAddress ("glTexCoord4xvOES");
    s_deviceConfig.m_glTexGenxOES = (PFNGLTEXGENXOESPROC) glewGetProcAddress ("glTexGenxOES");
    s_deviceConfig.m_glTexGenxvOES = (PFNGLTEXGENXVOESPROC) glewGetProcAddress ("glTexGenxvOES");
    s_deviceConfig.m_glVertex2xOES = (PFNGLVERTEX2XOESPROC) glewGetProcAddress ("glVertex2xOES");
    s_deviceConfig.m_glVertex2xvOES = (PFNGLVERTEX2XVOESPROC) glewGetProcAddress ("glVertex2xvOES");
    s_deviceConfig.m_glVertex3xOES = (PFNGLVERTEX3XOESPROC) glewGetProcAddress ("glVertex3xOES");
    s_deviceConfig.m_glVertex3xvOES = (PFNGLVERTEX3XVOESPROC) glewGetProcAddress ("glVertex3xvOES");
    s_deviceConfig.m_glVertex4xOES = (PFNGLVERTEX4XOESPROC) glewGetProcAddress ("glVertex4xOES");
    s_deviceConfig.m_glVertex4xvOES = (PFNGLVERTEX4XVOESPROC) glewGetProcAddress ("glVertex4xvOES");
  }

  // GL_OES_geometry_shader
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_geometry_shader])
  {
    s_deviceConfig.m_glFramebufferTextureOES = (PFNGLFRAMEBUFFERTEXTUREOESPROC) glewGetProcAddress ("glFramebufferTextureOES");
  }

  // GL_OES_get_program_binary
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_get_program_binary])
  {
    s_deviceConfig.m_glGetProgramBinaryOES = (PFNGLGETPROGRAMBINARYOESPROC) glewGetProcAddress ("glGetProgramBinaryOES");
    s_deviceConfig.m_glProgramBinaryOES = (PFNGLPROGRAMBINARYOESPROC) glewGetProcAddress ("glProgramBinaryOES");
  }

  // GL_OES_mapbuffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_mapbuffer])
  {
    s_deviceConfig.m_glMapBufferOES = (PFNGLMAPBUFFEROESPROC) glewGetProcAddress ("glMapBufferOES");
    s_deviceConfig.m_glUnmapBufferOES = (PFNGLUNMAPBUFFEROESPROC) glewGetProcAddress ("glUnmapBufferOES");
    s_deviceConfig.m_glGetBufferPointervOES = (PFNGLGETBUFFERPOINTERVOESPROC) glewGetProcAddress ("glGetBufferPointervOES");
  }

  // GL_OES_primitive_bounding_box
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_primitive_bounding_box])
  {
    s_deviceConfig.m_glPrimitiveBoundingBoxOES = (PFNGLPRIMITIVEBOUNDINGBOXOESPROC) glewGetProcAddress ("glPrimitiveBoundingBoxOES");
  }

  // GL_OES_query_matrix
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_query_matrix])
  {
    s_deviceConfig.m_glQueryMatrixxOES = (PFNGLQUERYMATRIXXOESPROC) glewGetProcAddress ("glQueryMatrixxOES");
  }

  // GL_OES_sample_shading
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_sample_shading])
  {
    s_deviceConfig.m_glMinSampleShadingOES = (PFNGLMINSAMPLESHADINGOESPROC) glewGetProcAddress ("glMinSampleShadingOES");
  }

  // GL_OES_single_precision
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_single_precision])
  {
    s_deviceConfig.m_glClearDepthfOES = (PFNGLCLEARDEPTHFOESPROC) glewGetProcAddress ("glClearDepthfOES");
    s_deviceConfig.m_glClipPlanefOES = (PFNGLCLIPPLANEFOESPROC) glewGetProcAddress ("glClipPlanefOES");
    s_deviceConfig.m_glDepthRangefOES = (PFNGLDEPTHRANGEFOESPROC) glewGetProcAddress ("glDepthRangefOES");
    s_deviceConfig.m_glFrustumfOES = (PFNGLFRUSTUMFOESPROC) glewGetProcAddress ("glFrustumfOES");
    s_deviceConfig.m_glGetClipPlanefOES = (PFNGLGETCLIPPLANEFOESPROC) glewGetProcAddress ("glGetClipPlanefOES");
    s_deviceConfig.m_glOrthofOES = (PFNGLORTHOFOESPROC) glewGetProcAddress ("glOrthofOES");
  }

  // GL_OES_tessellation_shader
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_tessellation_shader])
  {
    s_deviceConfig.m_glPatchParameteriOES = (PFNGLPATCHPARAMETERIOESPROC) glewGetProcAddress ("glPatchParameteriOES");
  }

  // GL_OES_texture_3D
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_3D])
  {
    s_deviceConfig.m_glTexImage3DOES = (PFNGLTEXIMAGE3DOESPROC) glewGetProcAddress ("glTexImage3DOES");
    s_deviceConfig.m_glTexSubImage3DOES = (PFNGLTEXSUBIMAGE3DOESPROC) glewGetProcAddress ("glTexSubImage3DOES");
    s_deviceConfig.m_glCopyTexSubImage3DOES = (PFNGLCOPYTEXSUBIMAGE3DOESPROC) glewGetProcAddress ("glCopyTexSubImage3DOES");
    s_deviceConfig.m_glCompressedTexImage3DOES = (PFNGLCOMPRESSEDTEXIMAGE3DOESPROC) glewGetProcAddress ("glCompressedTexImage3DOES");
    s_deviceConfig.m_glCompressedTexSubImage3DOES = (PFNGLCOMPRESSEDTEXSUBIMAGE3DOESPROC) glewGetProcAddress ("glCompressedTexSubImage3DOES");
    s_deviceConfig.m_glFramebufferTexture3DOES = (PFNGLFRAMEBUFFERTEXTURE3DOESPROC) glewGetProcAddress ("glFramebufferTexture3DOES");
  }

  // GL_OES_texture_border_clamp
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_border_clamp])
  {
    s_deviceConfig.m_glTexParameterIivOES = (PFNGLTEXPARAMETERIIVOESPROC) glewGetProcAddress ("glTexParameterIivOES");
    s_deviceConfig.m_glTexParameterIuivOES = (PFNGLTEXPARAMETERIUIVOESPROC) glewGetProcAddress ("glTexParameterIuivOES");
    s_deviceConfig.m_glGetTexParameterIivOES = (PFNGLGETTEXPARAMETERIIVOESPROC) glewGetProcAddress ("glGetTexParameterIivOES");
    s_deviceConfig.m_glGetTexParameterIuivOES = (PFNGLGETTEXPARAMETERIUIVOESPROC) glewGetProcAddress ("glGetTexParameterIuivOES");
    s_deviceConfig.m_glSamplerParameterIivOES = (PFNGLSAMPLERPARAMETERIIVOESPROC) glewGetProcAddress ("glSamplerParameterIivOES");
    s_deviceConfig.m_glSamplerParameterIuivOES = (PFNGLSAMPLERPARAMETERIUIVOESPROC) glewGetProcAddress ("glSamplerParameterIuivOES");
    s_deviceConfig.m_glGetSamplerParameterIivOES = (PFNGLGETSAMPLERPARAMETERIIVOESPROC) glewGetProcAddress ("glGetSamplerParameterIivOES");
    s_deviceConfig.m_glGetSamplerParameterIuivOES = (PFNGLGETSAMPLERPARAMETERIUIVOESPROC) glewGetProcAddress ("glGetSamplerParameterIuivOES");
  }

  // GL_OES_texture_buffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_buffer])
  {
    s_deviceConfig.m_glTexBufferOES = (PFNGLTEXBUFFEROESPROC) glewGetProcAddress ("glTexBufferOES");
    s_deviceConfig.m_glTexBufferRangeOES = (PFNGLTEXBUFFERRANGEOESPROC) glewGetProcAddress ("glTexBufferRangeOES");
  }

  // GL_OES_texture_storage_multisample_2d_array
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_storage_multisample_2d_array])
  {
    s_deviceConfig.m_glTexStorage3DMultisampleOES = (PFNGLTEXSTORAGE3DMULTISAMPLEOESPROC) glewGetProcAddress ("glTexStorage3DMultisampleOES");
  }

  // GL_OES_texture_view
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_texture_view])
  {
    s_deviceConfig.m_glTextureViewOES = (PFNGLTEXTUREVIEWOESPROC) glewGetProcAddress ("glTextureViewOES");
  }

  // GL_OES_vertex_array_object
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_vertex_array_object])
  {
    s_deviceConfig.m_glBindVertexArrayOES = (PFNGLBINDVERTEXARRAYOESPROC) glewGetProcAddress ("glBindVertexArrayOES");
    s_deviceConfig.m_glDeleteVertexArraysOES = (PFNGLDELETEVERTEXARRAYSOESPROC) glewGetProcAddress ("glDeleteVertexArraysOES");
    s_deviceConfig.m_glGenVertexArraysOES = (PFNGLGENVERTEXARRAYSOESPROC) glewGetProcAddress ("glGenVertexArraysOES");
    s_deviceConfig.m_glIsVertexArrayOES = (PFNGLISVERTEXARRAYOESPROC) glewGetProcAddress ("glIsVertexArrayOES");
  }

  // GL_OES_viewport_array
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OES_viewport_array])
  {
    s_deviceConfig.m_glViewportArrayvOES = (PFNGLVIEWPORTARRAYVOESPROC) glewGetProcAddress ("glViewportArrayvOES");
    s_deviceConfig.m_glViewportIndexedfOES = (PFNGLVIEWPORTINDEXEDFOESPROC) glewGetProcAddress ("glViewportIndexedfOES");
    s_deviceConfig.m_glViewportIndexedfvOES = (PFNGLVIEWPORTINDEXEDFVOESPROC) glewGetProcAddress ("glViewportIndexedfvOES");
    s_deviceConfig.m_glScissorArrayvOES = (PFNGLSCISSORARRAYVOESPROC) glewGetProcAddress ("glScissorArrayvOES");
    s_deviceConfig.m_glScissorIndexedOES = (PFNGLSCISSORINDEXEDOESPROC) glewGetProcAddress ("glScissorIndexedOES");
    s_deviceConfig.m_glScissorIndexedvOES = (PFNGLSCISSORINDEXEDVOESPROC) glewGetProcAddress ("glScissorIndexedvOES");
    s_deviceConfig.m_glDepthRangeArrayfvOES = (PFNGLDEPTHRANGEARRAYFVOESPROC) glewGetProcAddress ("glDepthRangeArrayfvOES");
    s_deviceConfig.m_glDepthRangeIndexedfOES = (PFNGLDEPTHRANGEINDEXEDFOESPROC) glewGetProcAddress ("glDepthRangeIndexedfOES");
    s_deviceConfig.m_glGetFloati_vOES = (PFNGLGETFLOATI_VOESPROC) glewGetProcAddress ("glGetFloati_vOES");
    s_deviceConfig.m_glEnableiOES = (PFNGLENABLEIOESPROC) glewGetProcAddress ("glEnableiOES");
    s_deviceConfig.m_glDisableiOES = (PFNGLDISABLEIOESPROC) glewGetProcAddress ("glDisableiOES");
    s_deviceConfig.m_glIsEnablediOES = (PFNGLISENABLEDIOESPROC) glewGetProcAddress ("glIsEnablediOES");
  }

  // GL_OVR_multiview
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OVR_multiview])
  {
    s_deviceConfig.m_glFramebufferTextureMultiviewOVR = (PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC) glewGetProcAddress ("glFramebufferTextureMultiviewOVR");
    s_deviceConfig.m_glNamedFramebufferTextureMultiviewOVR = (PFNGLNAMEDFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC) glewGetProcAddress ("glNamedFramebufferTextureMultiviewOVR");
  }

  // GL_OVR_multiview_multisampled_render_to_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_OVR_multiview_multisampled_render_to_texture])
  {
    s_deviceConfig.m_glFramebufferTextureMultisampleMultiviewOVR = (PFNGLFRAMEBUFFERTEXTUREMULTISAMPLEMULTIVIEWOVRPROC) glewGetProcAddress ("glFramebufferTextureMultisampleMultiviewOVR");
  }

  // GL_PGI_misc_hints
  if (s_deviceConfig.m_featureSupported [GLEW_GL_PGI_misc_hints])
  {
    s_deviceConfig.m_glHintPGI = (PFNGLHINTPGIPROC) glewGetProcAddress ("glHintPGI");
  }

  // GL_QCOM_alpha_test
  if (s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_alpha_test])
  {
    s_deviceConfig.m_glAlphaFuncQCOM = (PFNGLALPHAFUNCQCOMPROC) glewGetProcAddress ("glAlphaFuncQCOM");
  }

  // GL_QCOM_driver_control
  if (s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_driver_control])
  {
    s_deviceConfig.m_glGetDriverControlsQCOM = (PFNGLGETDRIVERCONTROLSQCOMPROC) glewGetProcAddress ("glGetDriverControlsQCOM");
    s_deviceConfig.m_glGetDriverControlStringQCOM = (PFNGLGETDRIVERCONTROLSTRINGQCOMPROC) glewGetProcAddress ("glGetDriverControlStringQCOM");
    s_deviceConfig.m_glEnableDriverControlQCOM = (PFNGLENABLEDRIVERCONTROLQCOMPROC) glewGetProcAddress ("glEnableDriverControlQCOM");
    s_deviceConfig.m_glDisableDriverControlQCOM = (PFNGLDISABLEDRIVERCONTROLQCOMPROC) glewGetProcAddress ("glDisableDriverControlQCOM");
  }

  // GL_QCOM_extended_get
  if (s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_extended_get])
  {
    s_deviceConfig.m_glExtGetTexturesQCOM = (PFNGLEXTGETTEXTURESQCOMPROC) glewGetProcAddress ("glExtGetTexturesQCOM");
    s_deviceConfig.m_glExtGetBuffersQCOM = (PFNGLEXTGETBUFFERSQCOMPROC) glewGetProcAddress ("glExtGetBuffersQCOM");
    s_deviceConfig.m_glExtGetRenderbuffersQCOM = (PFNGLEXTGETRENDERBUFFERSQCOMPROC) glewGetProcAddress ("glExtGetRenderbuffersQCOM");
    s_deviceConfig.m_glExtGetFramebuffersQCOM = (PFNGLEXTGETFRAMEBUFFERSQCOMPROC) glewGetProcAddress ("glExtGetFramebuffersQCOM");
    s_deviceConfig.m_glExtGetTexLevelParameterivQCOM = (PFNGLEXTGETTEXLEVELPARAMETERIVQCOMPROC) glewGetProcAddress ("glExtGetTexLevelParameterivQCOM");
    s_deviceConfig.m_glExtTexObjectStateOverrideiQCOM = (PFNGLEXTTEXOBJECTSTATEOVERRIDEIQCOMPROC) glewGetProcAddress ("glExtTexObjectStateOverrideiQCOM");
    s_deviceConfig.m_glExtGetTexSubImageQCOM = (PFNGLEXTGETTEXSUBIMAGEQCOMPROC) glewGetProcAddress ("glExtGetTexSubImageQCOM");
    s_deviceConfig.m_glExtGetBufferPointervQCOM = (PFNGLEXTGETBUFFERPOINTERVQCOMPROC) glewGetProcAddress ("glExtGetBufferPointervQCOM");
  }

  // GL_QCOM_extended_get2
  if (s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_extended_get2])
  {
    s_deviceConfig.m_glExtGetShadersQCOM = (PFNGLEXTGETSHADERSQCOMPROC) glewGetProcAddress ("glExtGetShadersQCOM");
    s_deviceConfig.m_glExtGetProgramsQCOM = (PFNGLEXTGETPROGRAMSQCOMPROC) glewGetProcAddress ("glExtGetProgramsQCOM");
    s_deviceConfig.m_glExtIsProgramBinaryQCOM = (PFNGLEXTISPROGRAMBINARYQCOMPROC) glewGetProcAddress ("glExtIsProgramBinaryQCOM");
    s_deviceConfig.m_glExtGetProgramBinarySourceQCOM = (PFNGLEXTGETPROGRAMBINARYSOURCEQCOMPROC) glewGetProcAddress ("glExtGetProgramBinarySourceQCOM");
  }

  // GL_QCOM_framebuffer_foveated
  if (s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_framebuffer_foveated])
  {
    s_deviceConfig.m_glFramebufferFoveationConfigQCOM = (PFNGLFRAMEBUFFERFOVEATIONCONFIGQCOMPROC) glewGetProcAddress ("glFramebufferFoveationConfigQCOM");
    s_deviceConfig.m_glFramebufferFoveationParametersQCOM = (PFNGLFRAMEBUFFERFOVEATIONPARAMETERSQCOMPROC) glewGetProcAddress ("glFramebufferFoveationParametersQCOM");
  }

  // GL_QCOM_motion_estimation
  if (s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_motion_estimation])
  {
    s_deviceConfig.m_glTexEstimateMotionQCOM = (PFNGLTEXESTIMATEMOTIONQCOMPROC) glewGetProcAddress ("glTexEstimateMotionQCOM");
    s_deviceConfig.m_glTexEstimateMotionRegionsQCOM = (PFNGLTEXESTIMATEMOTIONREGIONSQCOMPROC) glewGetProcAddress ("glTexEstimateMotionRegionsQCOM");
  }

  // GL_QCOM_frame_extrapolation
  if (s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_frame_extrapolation])
  {
    s_deviceConfig.m_glExtrapolateTex2DQCOM = (PFNGLEXTRAPOLATETEX2DQCOMPROC) glewGetProcAddress ("glExtrapolateTex2DQCOM");
  }

  // GL_QCOM_texture_foveated
  if (s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_texture_foveated])
  {
    s_deviceConfig.m_glTextureFoveationParametersQCOM = (PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC) glewGetProcAddress ("glTextureFoveationParametersQCOM");
  }

  // GL_QCOM_shader_framebuffer_fetch_noncoherent
  if (s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_shader_framebuffer_fetch_noncoherent])
  {
    s_deviceConfig.m_glFramebufferFetchBarrierQCOM = (PFNGLFRAMEBUFFERFETCHBARRIERQCOMPROC) glewGetProcAddress ("glFramebufferFetchBarrierQCOM");
  }

  // GL_QCOM_shading_rate
  if (s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_shading_rate])
  {
    s_deviceConfig.m_glShadingRateQCOM = (PFNGLSHADINGRATEQCOMPROC) glewGetProcAddress ("glShadingRateQCOM");
  }

  // GL_QCOM_tiled_rendering
  if (s_deviceConfig.m_featureSupported [GLEW_GL_QCOM_tiled_rendering])
  {
    s_deviceConfig.m_glStartTilingQCOM = (PFNGLSTARTTILINGQCOMPROC) glewGetProcAddress ("glStartTilingQCOM");
    s_deviceConfig.m_glEndTilingQCOM = (PFNGLENDTILINGQCOMPROC) glewGetProcAddress ("glEndTilingQCOM");
  }

  // GL_SGIS_detail_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_detail_texture])
  {
    s_deviceConfig.m_glDetailTexFuncSGIS = (PFNGLDETAILTEXFUNCSGISPROC) glewGetProcAddress ("glDetailTexFuncSGIS");
    s_deviceConfig.m_glGetDetailTexFuncSGIS = (PFNGLGETDETAILTEXFUNCSGISPROC) glewGetProcAddress ("glGetDetailTexFuncSGIS");
  }

  // GL_SGIS_fog_function
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_fog_function])
  {
    s_deviceConfig.m_glFogFuncSGIS = (PFNGLFOGFUNCSGISPROC) glewGetProcAddress ("glFogFuncSGIS");
    s_deviceConfig.m_glGetFogFuncSGIS = (PFNGLGETFOGFUNCSGISPROC) glewGetProcAddress ("glGetFogFuncSGIS");
  }

  // GL_SGIS_multisample
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_multisample])
  {
    s_deviceConfig.m_glSampleMaskSGIS = (PFNGLSAMPLEMASKSGISPROC) glewGetProcAddress ("glSampleMaskSGIS");
    s_deviceConfig.m_glSamplePatternSGIS = (PFNGLSAMPLEPATTERNSGISPROC) glewGetProcAddress ("glSamplePatternSGIS");
  }

  // GL_SGIS_pixel_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_pixel_texture])
  {
    s_deviceConfig.m_glPixelTexGenParameteriSGIS = (PFNGLPIXELTEXGENPARAMETERISGISPROC) glewGetProcAddress ("glPixelTexGenParameteriSGIS");
    s_deviceConfig.m_glPixelTexGenParameterivSGIS = (PFNGLPIXELTEXGENPARAMETERIVSGISPROC) glewGetProcAddress ("glPixelTexGenParameterivSGIS");
    s_deviceConfig.m_glPixelTexGenParameterfSGIS = (PFNGLPIXELTEXGENPARAMETERFSGISPROC) glewGetProcAddress ("glPixelTexGenParameterfSGIS");
    s_deviceConfig.m_glPixelTexGenParameterfvSGIS = (PFNGLPIXELTEXGENPARAMETERFVSGISPROC) glewGetProcAddress ("glPixelTexGenParameterfvSGIS");
    s_deviceConfig.m_glGetPixelTexGenParameterivSGIS = (PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC) glewGetProcAddress ("glGetPixelTexGenParameterivSGIS");
    s_deviceConfig.m_glGetPixelTexGenParameterfvSGIS = (PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC) glewGetProcAddress ("glGetPixelTexGenParameterfvSGIS");
  }

  // GL_SGIS_point_parameters
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_point_parameters])
  {
    s_deviceConfig.m_glPointParameterfSGIS = (PFNGLPOINTPARAMETERFSGISPROC) glewGetProcAddress ("glPointParameterfSGIS");
    s_deviceConfig.m_glPointParameterfvSGIS = (PFNGLPOINTPARAMETERFVSGISPROC) glewGetProcAddress ("glPointParameterfvSGIS");
  }

  // GL_SGIS_sharpen_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_sharpen_texture])
  {
    s_deviceConfig.m_glSharpenTexFuncSGIS = (PFNGLSHARPENTEXFUNCSGISPROC) glewGetProcAddress ("glSharpenTexFuncSGIS");
    s_deviceConfig.m_glGetSharpenTexFuncSGIS = (PFNGLGETSHARPENTEXFUNCSGISPROC) glewGetProcAddress ("glGetSharpenTexFuncSGIS");
  }

  // GL_SGIS_texture4D
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_texture4D])
  {
    s_deviceConfig.m_glTexImage4DSGIS = (PFNGLTEXIMAGE4DSGISPROC) glewGetProcAddress ("glTexImage4DSGIS");
    s_deviceConfig.m_glTexSubImage4DSGIS = (PFNGLTEXSUBIMAGE4DSGISPROC) glewGetProcAddress ("glTexSubImage4DSGIS");
  }

  // GL_SGIS_texture_color_mask
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_texture_color_mask])
  {
    s_deviceConfig.m_glTextureColorMaskSGIS = (PFNGLTEXTURECOLORMASKSGISPROC) glewGetProcAddress ("glTextureColorMaskSGIS");
  }

  // GL_SGIS_texture_filter4
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIS_texture_filter4])
  {
    s_deviceConfig.m_glGetTexFilterFuncSGIS = (PFNGLGETTEXFILTERFUNCSGISPROC) glewGetProcAddress ("glGetTexFilterFuncSGIS");
    s_deviceConfig.m_glTexFilterFuncSGIS = (PFNGLTEXFILTERFUNCSGISPROC) glewGetProcAddress ("glTexFilterFuncSGIS");
  }

  // GL_SGIX_async
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_async])
  {
    s_deviceConfig.m_glAsyncMarkerSGIX = (PFNGLASYNCMARKERSGIXPROC) glewGetProcAddress ("glAsyncMarkerSGIX");
    s_deviceConfig.m_glFinishAsyncSGIX = (PFNGLFINISHASYNCSGIXPROC) glewGetProcAddress ("glFinishAsyncSGIX");
    s_deviceConfig.m_glPollAsyncSGIX = (PFNGLPOLLASYNCSGIXPROC) glewGetProcAddress ("glPollAsyncSGIX");
    s_deviceConfig.m_glGenAsyncMarkersSGIX = (PFNGLGENASYNCMARKERSSGIXPROC) glewGetProcAddress ("glGenAsyncMarkersSGIX");
    s_deviceConfig.m_glDeleteAsyncMarkersSGIX = (PFNGLDELETEASYNCMARKERSSGIXPROC) glewGetProcAddress ("glDeleteAsyncMarkersSGIX");
    s_deviceConfig.m_glIsAsyncMarkerSGIX = (PFNGLISASYNCMARKERSGIXPROC) glewGetProcAddress ("glIsAsyncMarkerSGIX");
  }

  // GL_SGIX_flush_raster
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_flush_raster])
  {
    s_deviceConfig.m_glFlushRasterSGIX = (PFNGLFLUSHRASTERSGIXPROC) glewGetProcAddress ("glFlushRasterSGIX");
  }

  // GL_SGIX_fragment_lighting
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_fragment_lighting])
  {
    s_deviceConfig.m_glFragmentColorMaterialSGIX = (PFNGLFRAGMENTCOLORMATERIALSGIXPROC) glewGetProcAddress ("glFragmentColorMaterialSGIX");
    s_deviceConfig.m_glFragmentLightfSGIX = (PFNGLFRAGMENTLIGHTFSGIXPROC) glewGetProcAddress ("glFragmentLightfSGIX");
    s_deviceConfig.m_glFragmentLightfvSGIX = (PFNGLFRAGMENTLIGHTFVSGIXPROC) glewGetProcAddress ("glFragmentLightfvSGIX");
    s_deviceConfig.m_glFragmentLightiSGIX = (PFNGLFRAGMENTLIGHTISGIXPROC) glewGetProcAddress ("glFragmentLightiSGIX");
    s_deviceConfig.m_glFragmentLightivSGIX = (PFNGLFRAGMENTLIGHTIVSGIXPROC) glewGetProcAddress ("glFragmentLightivSGIX");
    s_deviceConfig.m_glFragmentLightModelfSGIX = (PFNGLFRAGMENTLIGHTMODELFSGIXPROC) glewGetProcAddress ("glFragmentLightModelfSGIX");
    s_deviceConfig.m_glFragmentLightModelfvSGIX = (PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) glewGetProcAddress ("glFragmentLightModelfvSGIX");
    s_deviceConfig.m_glFragmentLightModeliSGIX = (PFNGLFRAGMENTLIGHTMODELISGIXPROC) glewGetProcAddress ("glFragmentLightModeliSGIX");
    s_deviceConfig.m_glFragmentLightModelivSGIX = (PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) glewGetProcAddress ("glFragmentLightModelivSGIX");
    s_deviceConfig.m_glFragmentMaterialfSGIX = (PFNGLFRAGMENTMATERIALFSGIXPROC) glewGetProcAddress ("glFragmentMaterialfSGIX");
    s_deviceConfig.m_glFragmentMaterialfvSGIX = (PFNGLFRAGMENTMATERIALFVSGIXPROC) glewGetProcAddress ("glFragmentMaterialfvSGIX");
    s_deviceConfig.m_glFragmentMaterialiSGIX = (PFNGLFRAGMENTMATERIALISGIXPROC) glewGetProcAddress ("glFragmentMaterialiSGIX");
    s_deviceConfig.m_glFragmentMaterialivSGIX = (PFNGLFRAGMENTMATERIALIVSGIXPROC) glewGetProcAddress ("glFragmentMaterialivSGIX");
    s_deviceConfig.m_glGetFragmentLightfvSGIX = (PFNGLGETFRAGMENTLIGHTFVSGIXPROC) glewGetProcAddress ("glGetFragmentLightfvSGIX");
    s_deviceConfig.m_glGetFragmentLightivSGIX = (PFNGLGETFRAGMENTLIGHTIVSGIXPROC) glewGetProcAddress ("glGetFragmentLightivSGIX");
    s_deviceConfig.m_glGetFragmentMaterialfvSGIX = (PFNGLGETFRAGMENTMATERIALFVSGIXPROC) glewGetProcAddress ("glGetFragmentMaterialfvSGIX");
    s_deviceConfig.m_glGetFragmentMaterialivSGIX = (PFNGLGETFRAGMENTMATERIALIVSGIXPROC) glewGetProcAddress ("glGetFragmentMaterialivSGIX");
    s_deviceConfig.m_glLightEnviSGIX = (PFNGLLIGHTENVISGIXPROC) glewGetProcAddress ("glLightEnviSGIX");
  }

  // GL_SGIX_framezoom
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_framezoom])
  {
    s_deviceConfig.m_glFrameZoomSGIX = (PFNGLFRAMEZOOMSGIXPROC) glewGetProcAddress ("glFrameZoomSGIX");
  }

  // GL_SGIX_igloo_interface
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_igloo_interface])
  {
    s_deviceConfig.m_glIglooInterfaceSGIX = (PFNGLIGLOOINTERFACESGIXPROC) glewGetProcAddress ("glIglooInterfaceSGIX");
  }

  // GL_SGIX_instruments
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_instruments])
  {
    s_deviceConfig.m_glGetInstrumentsSGIX = (PFNGLGETINSTRUMENTSSGIXPROC) glewGetProcAddress ("glGetInstrumentsSGIX");
    s_deviceConfig.m_glInstrumentsBufferSGIX = (PFNGLINSTRUMENTSBUFFERSGIXPROC) glewGetProcAddress ("glInstrumentsBufferSGIX");
    s_deviceConfig.m_glPollInstrumentsSGIX = (PFNGLPOLLINSTRUMENTSSGIXPROC) glewGetProcAddress ("glPollInstrumentsSGIX");
    s_deviceConfig.m_glReadInstrumentsSGIX = (PFNGLREADINSTRUMENTSSGIXPROC) glewGetProcAddress ("glReadInstrumentsSGIX");
    s_deviceConfig.m_glStartInstrumentsSGIX = (PFNGLSTARTINSTRUMENTSSGIXPROC) glewGetProcAddress ("glStartInstrumentsSGIX");
    s_deviceConfig.m_glStopInstrumentsSGIX = (PFNGLSTOPINSTRUMENTSSGIXPROC) glewGetProcAddress ("glStopInstrumentsSGIX");
  }

  // GL_SGIX_list_priority
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_list_priority])
  {
    s_deviceConfig.m_glGetListParameterfvSGIX = (PFNGLGETLISTPARAMETERFVSGIXPROC) glewGetProcAddress ("glGetListParameterfvSGIX");
    s_deviceConfig.m_glGetListParameterivSGIX = (PFNGLGETLISTPARAMETERIVSGIXPROC) glewGetProcAddress ("glGetListParameterivSGIX");
    s_deviceConfig.m_glListParameterfSGIX = (PFNGLLISTPARAMETERFSGIXPROC) glewGetProcAddress ("glListParameterfSGIX");
    s_deviceConfig.m_glListParameterfvSGIX = (PFNGLLISTPARAMETERFVSGIXPROC) glewGetProcAddress ("glListParameterfvSGIX");
    s_deviceConfig.m_glListParameteriSGIX = (PFNGLLISTPARAMETERISGIXPROC) glewGetProcAddress ("glListParameteriSGIX");
    s_deviceConfig.m_glListParameterivSGIX = (PFNGLLISTPARAMETERIVSGIXPROC) glewGetProcAddress ("glListParameterivSGIX");
  }

  // GL_SGIX_pixel_texture
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_pixel_texture])
  {
    s_deviceConfig.m_glPixelTexGenSGIX = (PFNGLPIXELTEXGENSGIXPROC) glewGetProcAddress ("glPixelTexGenSGIX");
  }

  // GL_SGIX_polynomial_ffd
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_polynomial_ffd])
  {
    s_deviceConfig.m_glDeformationMap3dSGIX = (PFNGLDEFORMATIONMAP3DSGIXPROC) glewGetProcAddress ("glDeformationMap3dSGIX");
    s_deviceConfig.m_glDeformationMap3fSGIX = (PFNGLDEFORMATIONMAP3FSGIXPROC) glewGetProcAddress ("glDeformationMap3fSGIX");
    s_deviceConfig.m_glDeformSGIX = (PFNGLDEFORMSGIXPROC) glewGetProcAddress ("glDeformSGIX");
    s_deviceConfig.m_glLoadIdentityDeformationMapSGIX = (PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC) glewGetProcAddress ("glLoadIdentityDeformationMapSGIX");
  }

  // GL_SGIX_reference_plane
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_reference_plane])
  {
    s_deviceConfig.m_glReferencePlaneSGIX = (PFNGLREFERENCEPLANESGIXPROC) glewGetProcAddress ("glReferencePlaneSGIX");
  }

  // GL_SGIX_sprite
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_sprite])
  {
    s_deviceConfig.m_glSpriteParameterfSGIX = (PFNGLSPRITEPARAMETERFSGIXPROC) glewGetProcAddress ("glSpriteParameterfSGIX");
    s_deviceConfig.m_glSpriteParameterfvSGIX = (PFNGLSPRITEPARAMETERFVSGIXPROC) glewGetProcAddress ("glSpriteParameterfvSGIX");
    s_deviceConfig.m_glSpriteParameteriSGIX = (PFNGLSPRITEPARAMETERISGIXPROC) glewGetProcAddress ("glSpriteParameteriSGIX");
    s_deviceConfig.m_glSpriteParameterivSGIX = (PFNGLSPRITEPARAMETERIVSGIXPROC) glewGetProcAddress ("glSpriteParameterivSGIX");
  }

  // GL_SGIX_tag_sample_buffer
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGIX_tag_sample_buffer])
  {
    s_deviceConfig.m_glTagSampleBufferSGIX = (PFNGLTAGSAMPLEBUFFERSGIXPROC) glewGetProcAddress ("glTagSampleBufferSGIX");
  }

  // GL_SGI_color_table
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SGI_color_table])
  {
    s_deviceConfig.m_glColorTableSGI = (PFNGLCOLORTABLESGIPROC) glewGetProcAddress ("glColorTableSGI");
    s_deviceConfig.m_glColorTableParameterfvSGI = (PFNGLCOLORTABLEPARAMETERFVSGIPROC) glewGetProcAddress ("glColorTableParameterfvSGI");
    s_deviceConfig.m_glColorTableParameterivSGI = (PFNGLCOLORTABLEPARAMETERIVSGIPROC) glewGetProcAddress ("glColorTableParameterivSGI");
    s_deviceConfig.m_glCopyColorTableSGI = (PFNGLCOPYCOLORTABLESGIPROC) glewGetProcAddress ("glCopyColorTableSGI");
    s_deviceConfig.m_glGetColorTableSGI = (PFNGLGETCOLORTABLESGIPROC) glewGetProcAddress ("glGetColorTableSGI");
    s_deviceConfig.m_glGetColorTableParameterfvSGI = (PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) glewGetProcAddress ("glGetColorTableParameterfvSGI");
    s_deviceConfig.m_glGetColorTableParameterivSGI = (PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) glewGetProcAddress ("glGetColorTableParameterivSGI");
  }

  // GL_SUNX_constant_data
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SUNX_constant_data])
  {
    s_deviceConfig.m_glFinishTextureSUNX = (PFNGLFINISHTEXTURESUNXPROC) glewGetProcAddress ("glFinishTextureSUNX");
  }

  // GL_SUN_global_alpha
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SUN_global_alpha])
  {
    s_deviceConfig.m_glGlobalAlphaFactorbSUN = (PFNGLGLOBALALPHAFACTORBSUNPROC) glewGetProcAddress ("glGlobalAlphaFactorbSUN");
    s_deviceConfig.m_glGlobalAlphaFactorsSUN = (PFNGLGLOBALALPHAFACTORSSUNPROC) glewGetProcAddress ("glGlobalAlphaFactorsSUN");
    s_deviceConfig.m_glGlobalAlphaFactoriSUN = (PFNGLGLOBALALPHAFACTORISUNPROC) glewGetProcAddress ("glGlobalAlphaFactoriSUN");
    s_deviceConfig.m_glGlobalAlphaFactorfSUN = (PFNGLGLOBALALPHAFACTORFSUNPROC) glewGetProcAddress ("glGlobalAlphaFactorfSUN");
    s_deviceConfig.m_glGlobalAlphaFactordSUN = (PFNGLGLOBALALPHAFACTORDSUNPROC) glewGetProcAddress ("glGlobalAlphaFactordSUN");
    s_deviceConfig.m_glGlobalAlphaFactorubSUN = (PFNGLGLOBALALPHAFACTORUBSUNPROC) glewGetProcAddress ("glGlobalAlphaFactorubSUN");
    s_deviceConfig.m_glGlobalAlphaFactorusSUN = (PFNGLGLOBALALPHAFACTORUSSUNPROC) glewGetProcAddress ("glGlobalAlphaFactorusSUN");
    s_deviceConfig.m_glGlobalAlphaFactoruiSUN = (PFNGLGLOBALALPHAFACTORUISUNPROC) glewGetProcAddress ("glGlobalAlphaFactoruiSUN");
  }

  // GL_SUN_mesh_array
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SUN_mesh_array])
  {
    s_deviceConfig.m_glDrawMeshArraysSUN = (PFNGLDRAWMESHARRAYSSUNPROC) glewGetProcAddress ("glDrawMeshArraysSUN");
  }

  // GL_SUN_triangle_list
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SUN_triangle_list])
  {
    s_deviceConfig.m_glReplacementCodeuiSUN = (PFNGLREPLACEMENTCODEUISUNPROC) glewGetProcAddress ("glReplacementCodeuiSUN");
    s_deviceConfig.m_glReplacementCodeusSUN = (PFNGLREPLACEMENTCODEUSSUNPROC) glewGetProcAddress ("glReplacementCodeusSUN");
    s_deviceConfig.m_glReplacementCodeubSUN = (PFNGLREPLACEMENTCODEUBSUNPROC) glewGetProcAddress ("glReplacementCodeubSUN");
    s_deviceConfig.m_glReplacementCodeuivSUN = (PFNGLREPLACEMENTCODEUIVSUNPROC) glewGetProcAddress ("glReplacementCodeuivSUN");
    s_deviceConfig.m_glReplacementCodeusvSUN = (PFNGLREPLACEMENTCODEUSVSUNPROC) glewGetProcAddress ("glReplacementCodeusvSUN");
    s_deviceConfig.m_glReplacementCodeubvSUN = (PFNGLREPLACEMENTCODEUBVSUNPROC) glewGetProcAddress ("glReplacementCodeubvSUN");
    s_deviceConfig.m_glReplacementCodePointerSUN = (PFNGLREPLACEMENTCODEPOINTERSUNPROC) glewGetProcAddress ("glReplacementCodePointerSUN");
  }

  // GL_SUN_vertex
  if (s_deviceConfig.m_featureSupported [GLEW_GL_SUN_vertex])
  {
    s_deviceConfig.m_glColor4ubVertex2fSUN = (PFNGLCOLOR4UBVERTEX2FSUNPROC) glewGetProcAddress ("glColor4ubVertex2fSUN");
    s_deviceConfig.m_glColor4ubVertex2fvSUN = (PFNGLCOLOR4UBVERTEX2FVSUNPROC) glewGetProcAddress ("glColor4ubVertex2fvSUN");
    s_deviceConfig.m_glColor4ubVertex3fSUN = (PFNGLCOLOR4UBVERTEX3FSUNPROC) glewGetProcAddress ("glColor4ubVertex3fSUN");
    s_deviceConfig.m_glColor4ubVertex3fvSUN = (PFNGLCOLOR4UBVERTEX3FVSUNPROC) glewGetProcAddress ("glColor4ubVertex3fvSUN");
    s_deviceConfig.m_glColor3fVertex3fSUN = (PFNGLCOLOR3FVERTEX3FSUNPROC) glewGetProcAddress ("glColor3fVertex3fSUN");
    s_deviceConfig.m_glColor3fVertex3fvSUN = (PFNGLCOLOR3FVERTEX3FVSUNPROC) glewGetProcAddress ("glColor3fVertex3fvSUN");
    s_deviceConfig.m_glNormal3fVertex3fSUN = (PFNGLNORMAL3FVERTEX3FSUNPROC) glewGetProcAddress ("glNormal3fVertex3fSUN");
    s_deviceConfig.m_glNormal3fVertex3fvSUN = (PFNGLNORMAL3FVERTEX3FVSUNPROC) glewGetProcAddress ("glNormal3fVertex3fvSUN");
    s_deviceConfig.m_glColor4fNormal3fVertex3fSUN = (PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) glewGetProcAddress ("glColor4fNormal3fVertex3fSUN");
    s_deviceConfig.m_glColor4fNormal3fVertex3fvSUN = (PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) glewGetProcAddress ("glColor4fNormal3fVertex3fvSUN");
    s_deviceConfig.m_glTexCoord2fVertex3fSUN = (PFNGLTEXCOORD2FVERTEX3FSUNPROC) glewGetProcAddress ("glTexCoord2fVertex3fSUN");
    s_deviceConfig.m_glTexCoord2fVertex3fvSUN = (PFNGLTEXCOORD2FVERTEX3FVSUNPROC) glewGetProcAddress ("glTexCoord2fVertex3fvSUN");
    s_deviceConfig.m_glTexCoord4fVertex4fSUN = (PFNGLTEXCOORD4FVERTEX4FSUNPROC) glewGetProcAddress ("glTexCoord4fVertex4fSUN");
    s_deviceConfig.m_glTexCoord4fVertex4fvSUN = (PFNGLTEXCOORD4FVERTEX4FVSUNPROC) glewGetProcAddress ("glTexCoord4fVertex4fvSUN");
    s_deviceConfig.m_glTexCoord2fColor4ubVertex3fSUN = (PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) glewGetProcAddress ("glTexCoord2fColor4ubVertex3fSUN");
    s_deviceConfig.m_glTexCoord2fColor4ubVertex3fvSUN = (PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) glewGetProcAddress ("glTexCoord2fColor4ubVertex3fvSUN");
    s_deviceConfig.m_glTexCoord2fColor3fVertex3fSUN = (PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) glewGetProcAddress ("glTexCoord2fColor3fVertex3fSUN");
    s_deviceConfig.m_glTexCoord2fColor3fVertex3fvSUN = (PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) glewGetProcAddress ("glTexCoord2fColor3fVertex3fvSUN");
    s_deviceConfig.m_glTexCoord2fNormal3fVertex3fSUN = (PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) glewGetProcAddress ("glTexCoord2fNormal3fVertex3fSUN");
    s_deviceConfig.m_glTexCoord2fNormal3fVertex3fvSUN = (PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) glewGetProcAddress ("glTexCoord2fNormal3fVertex3fvSUN");
    s_deviceConfig.m_glTexCoord2fColor4fNormal3fVertex3fSUN = (PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) glewGetProcAddress ("glTexCoord2fColor4fNormal3fVertex3fSUN");
    s_deviceConfig.m_glTexCoord2fColor4fNormal3fVertex3fvSUN = (PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) glewGetProcAddress ("glTexCoord2fColor4fNormal3fVertex3fvSUN");
    s_deviceConfig.m_glTexCoord4fColor4fNormal3fVertex4fSUN = (PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) glewGetProcAddress ("glTexCoord4fColor4fNormal3fVertex4fSUN");
    s_deviceConfig.m_glTexCoord4fColor4fNormal3fVertex4fvSUN = (PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) glewGetProcAddress ("glTexCoord4fColor4fNormal3fVertex4fvSUN");
    s_deviceConfig.m_glReplacementCodeuiVertex3fSUN = (PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) glewGetProcAddress ("glReplacementCodeuiVertex3fSUN");
    s_deviceConfig.m_glReplacementCodeuiVertex3fvSUN = (PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) glewGetProcAddress ("glReplacementCodeuiVertex3fvSUN");
    s_deviceConfig.m_glReplacementCodeuiColor4ubVertex3fSUN = (PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) glewGetProcAddress ("glReplacementCodeuiColor4ubVertex3fSUN");
    s_deviceConfig.m_glReplacementCodeuiColor4ubVertex3fvSUN = (PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) glewGetProcAddress ("glReplacementCodeuiColor4ubVertex3fvSUN");
    s_deviceConfig.m_glReplacementCodeuiColor3fVertex3fSUN = (PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) glewGetProcAddress ("glReplacementCodeuiColor3fVertex3fSUN");
    s_deviceConfig.m_glReplacementCodeuiColor3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) glewGetProcAddress ("glReplacementCodeuiColor3fVertex3fvSUN");
    s_deviceConfig.m_glReplacementCodeuiNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) glewGetProcAddress ("glReplacementCodeuiNormal3fVertex3fSUN");
    s_deviceConfig.m_glReplacementCodeuiNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) glewGetProcAddress ("glReplacementCodeuiNormal3fVertex3fvSUN");
    s_deviceConfig.m_glReplacementCodeuiColor4fNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) glewGetProcAddress ("glReplacementCodeuiColor4fNormal3fVertex3fSUN");
    s_deviceConfig.m_glReplacementCodeuiColor4fNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) glewGetProcAddress ("glReplacementCodeuiColor4fNormal3fVertex3fvSUN");
    s_deviceConfig.m_glReplacementCodeuiTexCoord2fVertex3fSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) glewGetProcAddress ("glReplacementCodeuiTexCoord2fVertex3fSUN");
    s_deviceConfig.m_glReplacementCodeuiTexCoord2fVertex3fvSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) glewGetProcAddress ("glReplacementCodeuiTexCoord2fVertex3fvSUN");
    s_deviceConfig.m_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) glewGetProcAddress ("glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN");
    s_deviceConfig.m_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) glewGetProcAddress ("glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN");
    s_deviceConfig.m_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) glewGetProcAddress ("glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN");
    s_deviceConfig.m_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = (PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) glewGetProcAddress ("glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN");
  }

  s_initialised = true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void glew::gl::Deinitialise ()
{
  s_initialised = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
